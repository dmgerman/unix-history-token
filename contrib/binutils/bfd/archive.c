begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for archive files (libraries).    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000    Free Software Foundation, Inc.    Written by Cygnus Support.  Mostly Gumby Henkel-Wallace's fault.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* @setfilename archive-info SECTION 	Archives  DESCRIPTION 	An archive (or library) is just another BFD.  It has a symbol 	table, although there's not much a user program will do with it.  	The big difference between an archive BFD and an ordinary BFD 	is that the archive doesn't have sections.  Instead it has a 	chain of BFDs that are considered its contents.  These BFDs can 	be manipulated like any other.  The BFDs contained in an 	archive opened for reading will all be opened for reading.  You 	may put either input or output BFDs into an archive opened for 	output; they will be handled correctly when the archive is closed.  	Use<<bfd_openr_next_archived_file>> to step through 	the contents of an archive opened for input.  You don't 	have to read the entire archive if you don't want 	to!  Read it until you find what you want.  	Archive contents of output BFDs are chained through the<<next>> pointer in a BFD.  The first one is findable through 	the<<archive_head>> slot of the archive.  Set it with<<bfd_set_archive_head>> (q.v.).  A given BFD may be in only one 	open output archive at a time.  	As expected, the BFD archive code is more general than the 	archive code of any given environment.  BFD archives may 	contain files of different formats (e.g., a.out and coff) and 	even different architectures.  You may even place archives 	recursively into archives!  	This can cause unexpected confusion, since some archive 	formats are more expressive than others.  For instance, Intel 	COFF archives can preserve long filenames; SunOS a.out archives 	cannot.  If you move a file from the first to the second 	format and back again, the filename may be truncated. 	Likewise, different a.out environments have different 	conventions as to how they truncate filenames, whether they 	preserve directory names in filenames, etc.  When 	interoperating with native tools, be sure your files are 	homogeneous.  	Beware: most of these formats do not react well to the 	presence of spaces in filenames.  We do the best we can, but 	can't always handle this case due to restrictions in the format of 	archives.  Many Unix utilities are braindead in regards to 	spaces and such in filenames anyway, so this shouldn't be much 	of a restriction.  	Archives are supported in BFD in<<archive.c>>.  */
end_comment

begin_comment
comment|/* Assumes:    o - all archive elements start on an even boundary, newline padded;    o - all arch headers are char *;    o - all arch headers are the same size (across architectures). */
end_comment

begin_comment
comment|/* Some formats provide a way to cram a long filename into the short    (16 chars) space provided by a BSD archive.  The trick is: make a    special "file" in the front of the archive, sort of like the SYMDEF    entry.  If the filename is too long to fit, put it in the extended    name table, and use its index as the filename.  To prevent    confusion prepend the index with a space.  This means you can't    have filenames that start with a space, but then again, many Unix    utilities can't handle that anyway.     This scheme unfortunately requires that you stand on your head in    order to write an archive since you need to put a magic file at the    front, and need to touch every entry to do so.  C'est la vie.     We support two variants of this idea:    The SVR4 format (extended name table is named "//"),    and an extended pseudo-BSD variant (extended name table is named    "ARFILENAMES/").  The origin of the latter format is uncertain.     BSD 4.4 uses a third scheme:  It writes a long filename    directly after the header.  This allows 'ar q' to work.    We currently can read BSD 4.4 archives, but not write them. */
end_comment

begin_comment
comment|/* Summary of archive member names:   Symbol table (must be first):  "__.SYMDEF       " - Symbol table, Berkeley style, produced by ranlib.  "/               " - Symbol table, system 5 style.   Long name table (must be before regular file members):  "//              " - Long name table, System 5 R4 style.  "ARFILENAMES/    " - Long name table, non-standard extended BSD (not BSD 4.4).   Regular file members with short names:  "filename.o/     " - Regular file, System 5 style (embedded spaces ok).  "filename.o      " - Regular file, Berkeley style (no embedded spaces).   Regular files with long names (or embedded spaces, for BSD variants):  "/18             " - SVR4 style, name at offset 18 in name table.  "#1/23           " - Long name (or embedded paces) 23 characters long, 		      BSD 4.4 style, full name follows header. 		      Implemented for reading, not writing.  " 18             " - Long name 18 characters long, extended pseudo-BSD.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"aout/ranlib.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GNU960
end_ifdef

begin_define
define|#
directive|define
name|BFD_GNU960_ARMAG
parameter_list|(
name|abfd
parameter_list|)
value|(BFD_COFF_FILE_P((abfd)) ? ARMAG : ARMAGB)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define offsetof for those systems which lack it */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((unsigned long)&((TYPE *)0)->MEMBER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We keep a cache of archive filepointers to archive elements to    speed up searching the archive by filepos.  We only add an entry to    the cache when we actually read one.  We also don't sort the cache;    it's generally short enough to search linearly.    Note that the pointers here point to the front of the ar_hdr, not    to the front of the contents!  */
end_comment

begin_struct
struct|struct
name|ar_cache
block|{
name|file_ptr
name|ptr
decl_stmt|;
name|bfd
modifier|*
name|arelt
decl_stmt|;
name|struct
name|ar_cache
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ar_padchar
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->ar_pad_char)
end_define

begin_define
define|#
directive|define
name|ar_maxnamelen
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->ar_max_namelen)
end_define

begin_define
define|#
directive|define
name|arch_eltdata
parameter_list|(
name|bfd
parameter_list|)
value|((struct areltdata *) ((bfd)->arelt_data))
end_define

begin_define
define|#
directive|define
name|arch_hdr
parameter_list|(
name|bfd
parameter_list|)
value|((struct ar_hdr *)arch_eltdata(bfd)->arch_header)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_extended_arelt_filename
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|arch
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|do_slurp_bsd_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|do_slurp_coff_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|normalize
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|areltdata
modifier|*
name|bfd_ar_hdr_from_filesystem
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
name|member
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|boolean
name|_bfd_generic_mkarchive
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|archive_head
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_next_mapent  SYNOPSIS 	symindex bfd_get_next_mapent(bfd *abfd, symindex previous, carsym **sym);  DESCRIPTION 	Step through archive @var{abfd}'s symbol table (if it 	has one).  Successively update @var{sym} with the next symbol's 	information, returning that symbol's (internal) index into the 	symbol table.  	Supply<<BFD_NO_MORE_SYMBOLS>> as the @var{previous} entry to get 	the first one; returns<<BFD_NO_MORE_SYMBOLS>> when you've already 	got the last one.  	A<<carsym>> is a canonical archive symbol.  The only 	user-visible element is its name, a null-terminated string. */
end_comment

begin_function
name|symindex
name|bfd_get_next_mapent
parameter_list|(
name|abfd
parameter_list|,
name|prev
parameter_list|,
name|entry
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|symindex
name|prev
decl_stmt|;
name|carsym
modifier|*
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|BFD_NO_MORE_SYMBOLS
return|;
block|}
if|if
condition|(
name|prev
operator|==
name|BFD_NO_MORE_SYMBOLS
condition|)
name|prev
operator|=
literal|0
expr_stmt|;
else|else
operator|++
name|prev
expr_stmt|;
if|if
condition|(
name|prev
operator|>=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
condition|)
return|return
name|BFD_NO_MORE_SYMBOLS
return|;
operator|*
name|entry
operator|=
operator|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|+
name|prev
operator|)
expr_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* To be called by backends only */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_create_empty_archive_element_shell
parameter_list|(
name|obfd
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
return|return
name|_bfd_new_bfd_contained_in
argument_list|(
name|obfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_archive_head  SYNOPSIS 	boolean bfd_set_archive_head(bfd *output, bfd *new_head);  DESCRIPTION 	Set the head of the chain of 	BFDs contained in the archive @var{output} to @var{new_head}. */
end_comment

begin_function
name|boolean
name|bfd_set_archive_head
parameter_list|(
name|output_archive
parameter_list|,
name|new_head
parameter_list|)
name|bfd
modifier|*
name|output_archive
decl_stmt|;
name|bfd
modifier|*
name|new_head
decl_stmt|;
block|{
name|output_archive
operator|->
name|archive_head
operator|=
name|new_head
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bfd
modifier|*
name|_bfd_look_for_bfd_in_cache
parameter_list|(
name|arch_bfd
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|arch_bfd
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|struct
name|ar_cache
modifier|*
name|current
decl_stmt|;
for|for
control|(
name|current
operator|=
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
if|if
condition|(
name|current
operator|->
name|ptr
operator|==
name|filepos
condition|)
return|return
name|current
operator|->
name|arelt
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Kind of stupid to call cons for each one, but we don't do too many */
end_comment

begin_function
name|boolean
name|_bfd_add_bfd_to_archive_cache
parameter_list|(
name|arch_bfd
parameter_list|,
name|filepos
parameter_list|,
name|new_elt
parameter_list|)
name|bfd
modifier|*
name|arch_bfd
decl_stmt|,
decl|*
name|new_elt
decl_stmt|;
end_function

begin_decl_stmt
name|file_ptr
name|filepos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ar_cache
modifier|*
name|new_cache
init|=
operator|(
operator|(
expr|struct
name|ar_cache
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|arch_bfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_cache
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|new_cache
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|new_cache
operator|->
name|ptr
operator|=
name|filepos
expr_stmt|;
name|new_cache
operator|->
name|arelt
operator|=
name|new_elt
expr_stmt|;
name|new_cache
operator|->
name|next
operator|=
operator|(
expr|struct
name|ar_cache
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
operator|==
name|NULL
condition|)
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
operator|=
name|new_cache
expr_stmt|;
else|else
block|{
name|struct
name|ar_cache
modifier|*
name|current
init|=
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
decl_stmt|;
while|while
condition|(
name|current
operator|->
name|next
operator|!=
name|NULL
condition|)
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|current
operator|->
name|next
operator|=
name|new_cache
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The name begins with space.  Hence the rest of the name is an index into    the string table.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_extended_arelt_filename
parameter_list|(
name|arch
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|long
name|index
init|=
literal|0
decl_stmt|;
comment|/* Should extract string so that I can guarantee not to overflow into      the next region, but I'm too lazy.  */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Skip first char, which is '/' in SVR4 or ' ' in some other variants.  */
name|index
operator|=
name|strtol
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|extended_names
operator|+
name|index
return|;
block|}
end_function

begin_comment
comment|/* This functions reads an arch header and returns an areltdata pointer, or    NULL on error.     Presumes the file pointer is already in the right place (ie pointing    to the ar_hdr in the file).   Moves the file pointer; on success it    should be pointing to the front of the file contents; on failure it    could have been moved arbitrarily. */
end_comment

begin_function
name|PTR
name|_bfd_generic_read_ar_hdr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|_bfd_generic_read_ar_hdr_mag
argument_list|(
name|abfd
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Alpha ECOFF uses an optional different ARFMAG value, so we have a    variant of _bfd_generic_read_ar_hdr which accepts a magic string.  */
end_comment

begin_function
name|PTR
name|_bfd_generic_read_ar_hdr_mag
parameter_list|(
name|abfd
parameter_list|,
name|mag
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|mag
decl_stmt|;
block|{
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|char
modifier|*
name|hdrp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
decl_stmt|;
name|unsigned
name|int
name|parsed_size
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|ared
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|namelen
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|allocsize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|allocptr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|hdrp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|hdr
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|mag
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|hdr
operator|.
name|ar_fmag
argument_list|,
name|mag
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|parsed_size
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Extract the filename from the archive - there are two ways to      specify an extended name table, either the first char of the      name is a space, or it's a slash.  */
if|if
condition|(
operator|(
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
operator|(
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|' '
operator|&&
name|memchr
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
literal|'/'
argument_list|,
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|&&
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|get_extended_arelt_filename
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* BSD4.4-style long filename.      Only implemented for reading, so far!  */
elseif|else
if|if
condition|(
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|hdr
operator|.
name|ar_name
index|[
literal|1
index|]
operator|==
literal|'1'
operator|&&
name|hdr
operator|.
name|ar_name
index|[
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|hdr
operator|.
name|ar_name
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
comment|/* BSD-4.4 extended name */
name|namelen
operator|=
name|atoi
argument_list|(
operator|&
name|hdr
operator|.
name|ar_name
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|allocsize
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
name|parsed_size
operator|-=
name|namelen
expr_stmt|;
name|allocptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|allocsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|filename
operator|=
operator|(
name|allocptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|,
name|namelen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namelen
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|filename
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* We judge the end of the name by looking for '/' or ' '. 	 Note:  The SYSV format (terminated by '/') allows embedded 	 spaces, so only look for ' ' if we don't find '/'.  */
name|char
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|memchr
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
literal|'\0'
argument_list|,
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|e
operator|=
name|memchr
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
literal|'/'
argument_list|,
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|e
operator|=
name|memchr
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
literal|' '
argument_list|,
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|namelen
operator|=
name|e
operator|-
name|hdr
operator|.
name|ar_name
expr_stmt|;
else|else
block|{
comment|/* If we didn't find a termination character, then the name 	     must be the entire field.  */
name|namelen
operator|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|allocsize
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allocptr
condition|)
block|{
name|allocptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|allocsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|ared
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|allocptr
expr_stmt|;
name|ared
operator|->
name|arch_header
operator|=
name|allocptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ared
operator|->
name|arch_header
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ared
operator|->
name|parsed_size
operator|=
name|parsed_size
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|ared
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
else|else
block|{
name|ared
operator|->
name|filename
operator|=
name|allocptr
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|namelen
condition|)
name|memcpy
argument_list|(
name|ared
operator|->
name|filename
argument_list|,
name|hdr
operator|.
name|ar_name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|ared
operator|->
name|filename
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|PTR
operator|)
name|ared
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is an internal function; it's mainly used when indexing    through the archive symbol table, but also used to get the next    element, since it handles the bookkeeping so nicely for us.  */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_get_elt_at_filepos
parameter_list|(
name|archive
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|new_areldata
decl_stmt|;
name|bfd
modifier|*
name|n_nfd
decl_stmt|;
name|n_nfd
operator|=
name|_bfd_look_for_bfd_in_cache
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_nfd
condition|)
return|return
name|n_nfd
return|;
if|if
condition|(
literal|0
operator|>
name|bfd_seek
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|new_areldata
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|_bfd_read_ar_hdr
argument_list|(
name|archive
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|n_nfd
operator|=
name|_bfd_create_empty_archive_element_shell
argument_list|(
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_nfd
operator|==
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|new_areldata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n_nfd
operator|->
name|origin
operator|=
name|bfd_tell
argument_list|(
name|archive
argument_list|)
expr_stmt|;
name|n_nfd
operator|->
name|arelt_data
operator|=
operator|(
name|PTR
operator|)
name|new_areldata
expr_stmt|;
name|n_nfd
operator|->
name|filename
operator|=
name|new_areldata
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|_bfd_add_bfd_to_archive_cache
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|,
name|n_nfd
argument_list|)
condition|)
return|return
name|n_nfd
return|;
comment|/* Huh?  */
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|n_nfd
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|new_areldata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the BFD which is referenced by the symbol in ABFD indexed by    INDEX.  INDEX should have been returned by bfd_get_next_mapent.  */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_generic_get_elt_at_index
parameter_list|(
name|abfd
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|symindex
name|index
decl_stmt|;
block|{
name|carsym
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|+
name|index
expr_stmt|;
return|return
name|_bfd_get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
name|entry
operator|->
name|file_offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_openr_next_archived_file  SYNOPSIS 	bfd *bfd_openr_next_archived_file(bfd *archive, bfd *previous);  DESCRIPTION 	Provided a BFD, @var{archive}, containing an archive and NULL, open 	an input BFD on the first contained element and returns that. 	Subsequent calls should pass 	the archive and the previous return value to return a created 	BFD to the next contained element. NULL is returned when there 	are no more. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|bfd
modifier|*
name|last_file
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|bfd_get_format
argument_list|(
name|archive
argument_list|)
operator|!=
name|bfd_archive
operator|)
operator|||
operator|(
name|archive
operator|->
name|direction
operator|==
name|write_direction
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|BFD_SEND
argument_list|(
name|archive
argument_list|,
name|openr_next_archived_file
argument_list|,
operator|(
name|archive
operator|,
name|last_file
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd
modifier|*
name|bfd_generic_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|bfd
modifier|*
name|last_file
decl_stmt|;
block|{
name|file_ptr
name|filestart
decl_stmt|;
if|if
condition|(
operator|!
name|last_file
condition|)
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|size
init|=
name|arelt_size
argument_list|(
name|last_file
argument_list|)
decl_stmt|;
comment|/* Pad to an even boundary... 	 Note that last_file->origin can be odd in the case of 	 BSD-4.4-style element with a long odd size.  */
name|filestart
operator|=
name|last_file
operator|->
name|origin
operator|+
name|size
expr_stmt|;
name|filestart
operator|+=
name|filestart
operator|%
literal|2
expr_stmt|;
block|}
return|return
name|_bfd_get_elt_at_filepos
argument_list|(
name|archive
argument_list|,
name|filestart
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|bfd_target
modifier|*
name|bfd_generic_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|artdata
modifier|*
name|tdata_hold
decl_stmt|;
name|char
name|armag
index|[
name|SARMAG
operator|+
literal|1
index|]
decl_stmt|;
name|tdata_hold
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|armag
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SARMAG
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|GNU960
if|if
condition|(
name|strncmp
argument_list|(
name|armag
argument_list|,
name|BFD_GNU960_ARMAG
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
else|#
directive|else
if|if
condition|(
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAGB
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* We are setting bfd_ardata(abfd) here, but since bfd_ardata      involves a cast, we can't do it as the left operand of assignment.  */
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|SARMAG
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|archive_head
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_slurp_armap
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|tdata_hold
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_slurp_extended_name_table
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|tdata_hold
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|first
decl_stmt|;
comment|/* This archive has a map, so we may presume that the contents 	 are object files.  Make sure that if the first file in the 	 archive can be recognized as an object file, it is for this 	 target.  If not, assume that this is the wrong format.  If 	 the first file is not an object file, somebody is doing 	 something weird, and we permit it so that ar -t will work.  	 This is done because any normal format will recognize any 	 normal archive, regardless of the format of the object files. 	 We do accept an empty archive.  */
name|first
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fail
decl_stmt|;
name|first
operator|->
name|target_defaulted
operator|=
name|false
expr_stmt|;
name|fail
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|first
argument_list|,
name|bfd_object
argument_list|)
operator|&&
name|first
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
operator|(
name|void
operator|)
name|bfd_close
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|tdata_hold
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* We ought to close first here, but we can't, because we              have no way to remove it from the archive cache.  FIXME.  */
block|}
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Some constants for a 32 bit BSD archive structure.  We do not    support 64 bit archives presently; so far as I know, none actually    exist.  Supporting them would require changing these constants, and    changing some bfd_h_get_32 to bfd_h_get_64.  */
end_comment

begin_comment
comment|/* The size of an external symdef structure.  */
end_comment

begin_define
define|#
directive|define
name|BSD_SYMDEF_SIZE
value|8
end_define

begin_comment
comment|/* The offset from the start of a symdef structure to the file offset.  */
end_comment

begin_define
define|#
directive|define
name|BSD_SYMDEF_OFFSET_SIZE
value|4
end_define

begin_comment
comment|/* The size of the symdef count.  */
end_comment

begin_define
define|#
directive|define
name|BSD_SYMDEF_COUNT_SIZE
value|4
end_define

begin_comment
comment|/* The size of the string count.  */
end_comment

begin_define
define|#
directive|define
name|BSD_STRING_COUNT_SIZE
value|4
end_define

begin_comment
comment|/* Returns false on error, true otherwise */
end_comment

begin_function
specifier|static
name|boolean
name|do_slurp_bsd_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|unsigned
name|int
name|counter
decl_stmt|;
name|bfd_byte
modifier|*
name|raw_armap
decl_stmt|,
modifier|*
name|rbase
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|unsigned
name|int
name|parsed_size
decl_stmt|;
name|carsym
modifier|*
name|set
decl_stmt|;
name|mapdata
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|_bfd_read_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|parsed_size
operator|=
name|mapdata
operator|->
name|parsed_size
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
comment|/* Don't need it any more.  */
name|raw_armap
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
literal|1
argument_list|,
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|parsed_size
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
name|byebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ardata
operator|->
name|symdef_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|raw_armap
argument_list|)
operator|/
name|BSD_SYMDEF_SIZE
expr_stmt|;
if|if
condition|(
name|ardata
operator|->
name|symdef_count
operator|*
name|BSD_SYMDEF_SIZE
operator|>
name|parsed_size
operator|-
name|BSD_SYMDEF_COUNT_SIZE
condition|)
block|{
comment|/* Probably we're using the wrong byte ordering.  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
goto|goto
name|byebye
goto|;
block|}
name|ardata
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
name|rbase
operator|=
name|raw_armap
operator|+
name|BSD_SYMDEF_COUNT_SIZE
expr_stmt|;
name|stringbase
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|rbase
operator|+
name|ardata
operator|->
name|symdef_count
operator|*
name|BSD_SYMDEF_SIZE
operator|+
name|BSD_STRING_COUNT_SIZE
operator|)
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|ardata
operator|->
name|symdef_count
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ardata
operator|->
name|symdefs
condition|)
return|return
name|false
return|;
for|for
control|(
name|counter
operator|=
literal|0
operator|,
name|set
operator|=
name|ardata
operator|->
name|symdefs
init|;
name|counter
operator|<
name|ardata
operator|->
name|symdef_count
condition|;
name|counter
operator|++
operator|,
name|set
operator|++
operator|,
name|rbase
operator|+=
name|BSD_SYMDEF_SIZE
control|)
block|{
name|set
operator|->
name|name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|rbase
argument_list|)
operator|+
name|stringbase
expr_stmt|;
name|set
operator|->
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|rbase
operator|+
name|BSD_SYMDEF_OFFSET_SIZE
argument_list|)
expr_stmt|;
block|}
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary if you have to.  */
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
comment|/* FIXME, we should provide some way to free raw_ardata when      we are done using the strings from it.  For now, it seems      to be allocated on an objalloc anyway...  */
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns false on error, true otherwise.  */
end_comment

begin_function
specifier|static
name|boolean
name|do_slurp_coff_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|int
modifier|*
name|raw_armap
decl_stmt|,
modifier|*
name|rawptr
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|unsigned
name|int
name|stringsize
decl_stmt|;
name|unsigned
name|int
name|parsed_size
decl_stmt|;
name|carsym
modifier|*
name|carsyms
decl_stmt|;
name|unsigned
name|int
name|nsymz
decl_stmt|;
comment|/* Number of symbols in armap.  */
name|bfd_vma
argument_list|(
argument|*swap
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
name|int_buf
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|carsym_size
decl_stmt|,
name|ptrsize
decl_stmt|,
name|i
decl_stmt|;
name|mapdata
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|_bfd_read_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|parsed_size
operator|=
name|mapdata
operator|->
name|parsed_size
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
comment|/* Don't need it any more.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|int_buf
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* It seems that all numeric information in a coff archive is always      in big endian format, nomatter the host or target.  */
name|swap
operator|=
name|bfd_getb32
expr_stmt|;
name|nsymz
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|PTR
operator|)
name|int_buf
argument_list|)
expr_stmt|;
name|stringsize
operator|=
name|parsed_size
operator|-
operator|(
literal|4
operator|*
name|nsymz
operator|)
operator|-
literal|4
expr_stmt|;
if|#
directive|if
literal|1
comment|/* ... except that some archive formats are broken, and it may be our      fault - the i960 little endian coff sometimes has big and sometimes      little, because our tools changed.  Here's a horrible hack to clean      up the crap.  */
if|if
condition|(
name|stringsize
operator|>
literal|0xfffff
operator|&&
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_arch_i960
operator|&&
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_coff_flavour
condition|)
block|{
comment|/* This looks dangerous, let's do it the other way around.  */
name|nsymz
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|PTR
operator|)
name|int_buf
argument_list|)
expr_stmt|;
name|stringsize
operator|=
name|parsed_size
operator|-
operator|(
literal|4
operator|*
name|nsymz
operator|)
operator|-
literal|4
expr_stmt|;
name|swap
operator|=
name|bfd_getl32
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* The coff armap must be read sequentially.  So we construct a      bsd-style one in core all at once, for simplicity.  */
name|carsym_size
operator|=
operator|(
name|nsymz
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
operator|)
expr_stmt|;
name|ptrsize
operator|=
operator|(
literal|4
operator|*
name|nsymz
operator|)
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|carsym_size
operator|+
name|stringsize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ardata
operator|->
name|symdefs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|carsyms
operator|=
name|ardata
operator|->
name|symdefs
expr_stmt|;
name|stringbase
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ardata
operator|->
name|symdefs
operator|)
operator|+
name|carsym_size
expr_stmt|;
comment|/* Allocate and read in the raw offsets.  */
name|raw_armap
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|ptrsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
name|NULL
condition|)
goto|goto
name|release_symdefs
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
literal|1
argument_list|,
name|ptrsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|ptrsize
operator|||
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|stringbase
argument_list|,
literal|1
argument_list|,
name|stringsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|stringsize
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
goto|goto
name|release_raw_armap
goto|;
block|}
comment|/* OK, build the carsyms.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsymz
condition|;
name|i
operator|++
control|)
block|{
name|rawptr
operator|=
name|raw_armap
operator|+
name|i
expr_stmt|;
name|carsyms
operator|->
name|file_offset
operator|=
name|swap
argument_list|(
operator|(
name|PTR
operator|)
name|rawptr
argument_list|)
expr_stmt|;
name|carsyms
operator|->
name|name
operator|=
name|stringbase
expr_stmt|;
name|stringbase
operator|+=
name|strlen
argument_list|(
name|stringbase
argument_list|)
operator|+
literal|1
expr_stmt|;
name|carsyms
operator|++
expr_stmt|;
block|}
operator|*
name|stringbase
operator|=
literal|0
expr_stmt|;
name|ardata
operator|->
name|symdef_count
operator|=
name|nsymz
expr_stmt|;
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary if you have to.  */
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
comment|/* Check for a second archive header (as used by PE).  */
block|{
name|struct
name|areltdata
modifier|*
name|tmp
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|ardata
operator|->
name|first_file_filepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|_bfd_read_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tmp
operator|->
name|arch_header
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|tmp
operator|->
name|arch_header
index|[
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|tmp
operator|->
name|parsed_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
name|release_raw_armap
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
name|release_symdefs
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|ardata
argument_list|)
operator|->
name|symdefs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* This routine can handle either coff-style or bsd-style armaps.    Returns false on error, true otherwise */
end_comment

begin_function
name|boolean
name|bfd_slurp_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|int
name|i
init|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|i
operator|!=
literal|16
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"__.SYMDEF       "
argument_list|,
literal|16
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"__.SYMDEF/      "
argument_list|,
literal|16
argument_list|)
condition|)
comment|/* old Linux archives */
return|return
name|do_slurp_bsd_armap
argument_list|(
name|abfd
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/               "
argument_list|,
literal|16
argument_list|)
condition|)
return|return
name|do_slurp_coff_armap
argument_list|(
name|abfd
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/SYM64/         "
argument_list|,
literal|16
argument_list|)
condition|)
block|{
comment|/* Irix 6 archive--must be recognized by code in elf64-mips.c.  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns false on error, true otherwise */
end_comment

begin_comment
comment|/* flavor 2 of a bsd armap, similar to bfd_slurp_bsd_armap except the    header is in a slightly different order and the map name is '/'.    This flavour is used by hp300hpux.  */
end_comment

begin_define
define|#
directive|define
name|HPUX_SYMDEF_COUNT_SIZE
value|2
end_define

begin_function
name|boolean
name|bfd_slurp_bsd_armap_f2
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|unsigned
name|int
name|counter
decl_stmt|;
name|bfd_byte
modifier|*
name|raw_armap
decl_stmt|,
modifier|*
name|rbase
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|unsigned
name|int
name|stringsize
decl_stmt|;
name|carsym
modifier|*
name|set
decl_stmt|;
name|int
name|i
init|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|i
operator|!=
literal|16
condition|)
return|return
name|false
return|;
comment|/* The archive has at least 16 bytes in it.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|-
literal|16L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"__.SYMDEF       "
argument_list|,
literal|16
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"__.SYMDEF/      "
argument_list|,
literal|16
argument_list|)
condition|)
comment|/* old Linux archives */
return|return
name|do_slurp_bsd_armap
argument_list|(
name|abfd
argument_list|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/               "
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
name|mapdata
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|_bfd_read_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|raw_armap
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|mapdata
operator|->
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
name|NULL
condition|)
block|{
name|byebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
literal|1
argument_list|,
name|mapdata
operator|->
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|mapdata
operator|->
name|parsed_size
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
name|byebyebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
goto|goto
name|byebye
goto|;
block|}
name|ardata
operator|->
name|symdef_count
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ardata
operator|->
name|symdef_count
operator|*
name|BSD_SYMDEF_SIZE
operator|>
name|mapdata
operator|->
name|parsed_size
operator|-
name|HPUX_SYMDEF_COUNT_SIZE
condition|)
block|{
comment|/* Probably we're using the wrong byte ordering.  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
goto|goto
name|byebyebye
goto|;
block|}
name|ardata
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
name|stringsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|raw_armap
operator|+
name|HPUX_SYMDEF_COUNT_SIZE
argument_list|)
expr_stmt|;
comment|/* Skip sym count and string sz.  */
name|stringbase
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|raw_armap
operator|+
name|HPUX_SYMDEF_COUNT_SIZE
operator|+
name|BSD_STRING_COUNT_SIZE
operator|)
expr_stmt|;
name|rbase
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|stringbase
operator|+
name|stringsize
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|ardata
operator|->
name|symdef_count
operator|*
name|BSD_SYMDEF_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ardata
operator|->
name|symdefs
condition|)
return|return
name|false
return|;
for|for
control|(
name|counter
operator|=
literal|0
operator|,
name|set
operator|=
name|ardata
operator|->
name|symdefs
init|;
name|counter
operator|<
name|ardata
operator|->
name|symdef_count
condition|;
name|counter
operator|++
operator|,
name|set
operator|++
operator|,
name|rbase
operator|+=
name|BSD_SYMDEF_SIZE
control|)
block|{
name|set
operator|->
name|name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|rbase
argument_list|)
operator|+
name|stringbase
expr_stmt|;
name|set
operator|->
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|rbase
operator|+
name|BSD_SYMDEF_OFFSET_SIZE
argument_list|)
expr_stmt|;
block|}
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary if you have to.  */
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
comment|/* FIXME, we should provide some way to free raw_ardata when      we are done using the strings from it.  For now, it seems      to be allocated on an objalloc anyway...  */
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Extended name table.    Normally archives support only 14-character filenames.    Intel has extended the format: longer names are stored in a special   element (the first in the archive, or second if there is an armap);   the name in the ar_hdr is replaced by<space><index into filename   element>.  Index is the P.R. of an int (decimal).  Data General have   extended the format by using the prefix // for the special element.  */
end_comment

begin_comment
comment|/* Returns false on error, true otherwise.  */
end_comment

begin_function
name|boolean
name|_bfd_slurp_extended_name_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|namedata
decl_stmt|;
comment|/* FIXME:  Formatting sucks here, and in case of failure of BFD_READ,      we probably don't want to return true.  */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"ARFILENAMES/    "
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"//              "
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
name|namedata
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|_bfd_read_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|namedata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|namedata
operator|->
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|==
name|NULL
condition|)
block|{
name|byebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|namedata
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
argument_list|,
literal|1
argument_list|,
name|namedata
operator|->
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namedata
operator|->
name|parsed_size
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
goto|goto
name|byebye
goto|;
block|}
comment|/* Since the archive is supposed to be printable if it contains 	 text, the entries in the list are newline-padded, not null 	 padded. In SVR4-style archives, the names also have a 	 trailing '/'.  DOS/NT created archive often have \ in them 	 We'll fix all problems here..  */
block|{
name|char
modifier|*
name|temp
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
decl_stmt|;
name|char
modifier|*
name|limit
init|=
name|temp
operator|+
name|namedata
operator|->
name|parsed_size
decl_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|limit
condition|;
operator|++
name|temp
control|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\012'
condition|)
name|temp
index|[
name|temp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|?
operator|-
literal|1
else|:
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\\'
condition|)
operator|*
name|temp
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
comment|/* Pad to an even boundary if you have to.  */
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|+=
operator|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
comment|/* FIXME, we can't release namedata here because it was allocated 	 below extended_names on the objalloc...  */
if|#
directive|if
literal|0
block|bfd_release (abfd, namedata);
endif|#
directive|endif
block|}
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* Return a copy of the stuff in the filename between any :]> and a    semicolon.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|normalize
parameter_list|(
name|abfd
parameter_list|,
name|file
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|CONST
name|char
modifier|*
name|first
decl_stmt|;
name|CONST
name|char
modifier|*
name|last
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|first
operator|=
name|file
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|-
literal|1
expr_stmt|;
name|last
operator|=
name|first
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|first
operator|!=
name|file
condition|)
block|{
if|if
condition|(
operator|*
name|first
operator|==
literal|';'
condition|)
name|last
operator|=
name|first
expr_stmt|;
if|if
condition|(
operator|*
name|first
operator|==
literal|':'
operator|||
operator|*
name|first
operator|==
literal|']'
operator|||
operator|*
name|first
operator|==
literal|'>'
condition|)
block|{
name|first
operator|++
expr_stmt|;
break|break;
block|}
name|first
operator|--
expr_stmt|;
block|}
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|first
argument_list|,
name|last
operator|-
name|first
argument_list|)
expr_stmt|;
name|copy
index|[
name|last
operator|-
name|first
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|normalize
parameter_list|(
name|abfd
parameter_list|,
name|file
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
block|{
comment|/* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
name|char
modifier|*
name|bslash
init|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
operator|(
name|bslash
operator|!=
name|NULL
operator|&&
name|bslash
operator|>
name|filename
operator|)
condition|)
name|filename
operator|=
name|bslash
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|&&
name|file
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|file
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|filename
operator|=
name|file
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|filename
operator|++
expr_stmt|;
else|else
name|filename
operator|=
name|file
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build a BFD style extended name table.  */
end_comment

begin_function
name|boolean
name|_bfd_archive_bsd_construct_extended_name_table
parameter_list|(
name|abfd
parameter_list|,
name|tabloc
parameter_list|,
name|tablen
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|tabloc
decl_stmt|;
name|bfd_size_type
modifier|*
name|tablen
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
block|{
operator|*
name|name
operator|=
literal|"ARFILENAMES/"
expr_stmt|;
return|return
name|_bfd_construct_extended_name_table
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|,
name|tabloc
argument_list|,
name|tablen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an SVR4 style extended name table.  */
end_comment

begin_function
name|boolean
name|_bfd_archive_coff_construct_extended_name_table
parameter_list|(
name|abfd
parameter_list|,
name|tabloc
parameter_list|,
name|tablen
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|tabloc
decl_stmt|;
name|bfd_size_type
modifier|*
name|tablen
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
block|{
operator|*
name|name
operator|=
literal|"//"
expr_stmt|;
return|return
name|_bfd_construct_extended_name_table
argument_list|(
name|abfd
argument_list|,
name|true
argument_list|,
name|tabloc
argument_list|,
name|tablen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Follows archive_head and produces an extended name table if    necessary.  Returns (in tabloc) a pointer to an extended name    table, and in tablen the length of the table.  If it makes an entry    it clobbers the filename so that the element may be written without    further massage.  Returns true if it ran successfully, false if    something went wrong.  A successful return may still involve a    zero-length tablen!  */
end_comment

begin_function
name|boolean
name|_bfd_construct_extended_name_table
parameter_list|(
name|abfd
parameter_list|,
name|trailing_slash
parameter_list|,
name|tabloc
parameter_list|,
name|tablen
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|trailing_slash
decl_stmt|;
name|char
modifier|*
modifier|*
name|tabloc
decl_stmt|;
name|bfd_size_type
modifier|*
name|tablen
decl_stmt|;
block|{
name|unsigned
name|int
name|maxname
init|=
name|abfd
operator|->
name|xvec
operator|->
name|ar_max_namelen
decl_stmt|;
name|unsigned
name|int
name|total_namelen
init|=
literal|0
decl_stmt|;
name|bfd
modifier|*
name|current
decl_stmt|;
name|char
modifier|*
name|strptr
decl_stmt|;
operator|*
name|tablen
operator|=
literal|0
expr_stmt|;
comment|/* Figure out how long the table should be.  */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|normal
decl_stmt|;
name|unsigned
name|int
name|thislen
decl_stmt|;
name|normal
operator|=
name|normalize
argument_list|(
name|current
argument_list|,
name|current
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|normal
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|thislen
operator|=
name|strlen
argument_list|(
name|normal
argument_list|)
expr_stmt|;
if|if
condition|(
name|thislen
operator|>
name|maxname
operator|&&
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|BFD_TRADITIONAL_FORMAT
operator|)
operator|!=
literal|0
condition|)
name|thislen
operator|=
name|maxname
expr_stmt|;
if|if
condition|(
name|thislen
operator|>
name|maxname
condition|)
block|{
comment|/* Add one to leave room for \n.  */
name|total_namelen
operator|+=
name|thislen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|trailing_slash
condition|)
block|{
comment|/* Leave room for trailing slash.  */
operator|++
name|total_namelen
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
name|arch_hdr
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|normal
argument_list|,
name|hdr
operator|->
name|ar_name
argument_list|,
name|thislen
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|thislen
operator|<
sizeof|sizeof
name|hdr
operator|->
name|ar_name
operator|&&
name|hdr
operator|->
name|ar_name
index|[
name|thislen
index|]
operator|!=
name|ar_padchar
argument_list|(
name|current
argument_list|)
operator|)
condition|)
block|{
comment|/* Must have been using extended format even though it 	         didn't need to.  Fix it to use normal format.  */
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|normal
argument_list|,
name|thislen
argument_list|)
expr_stmt|;
if|if
condition|(
name|thislen
operator|<
name|maxname
operator|||
operator|(
name|thislen
operator|==
name|maxname
operator|&&
name|thislen
operator|<
sizeof|sizeof
name|hdr
operator|->
name|ar_name
operator|)
condition|)
name|hdr
operator|->
name|ar_name
index|[
name|thislen
index|]
operator|=
name|ar_padchar
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|total_namelen
operator|==
literal|0
condition|)
return|return
name|true
return|;
operator|*
name|tabloc
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|total_namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tabloc
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|*
name|tablen
operator|=
name|total_namelen
expr_stmt|;
name|strptr
operator|=
operator|*
name|tabloc
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|normal
decl_stmt|;
name|unsigned
name|int
name|thislen
decl_stmt|;
name|normal
operator|=
name|normalize
argument_list|(
name|current
argument_list|,
name|current
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|normal
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|thislen
operator|=
name|strlen
argument_list|(
name|normal
argument_list|)
expr_stmt|;
if|if
condition|(
name|thislen
operator|>
name|maxname
condition|)
block|{
comment|/* Works for now; may need to be re-engineered if we 	     encounter an oddball archive format and want to 	     generalise this hack.  */
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
name|arch_hdr
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|strptr
argument_list|,
name|normal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trailing_slash
condition|)
name|strptr
index|[
name|thislen
index|]
operator|=
literal|'\012'
expr_stmt|;
else|else
block|{
name|strptr
index|[
name|thislen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strptr
index|[
name|thislen
operator|+
literal|1
index|]
operator|=
literal|'\012'
expr_stmt|;
block|}
name|hdr
operator|->
name|ar_name
index|[
literal|0
index|]
operator|=
name|ar_padchar
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* We know there will always be enough room (one of the few 	     cases where you may safely use sprintf).  */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_name
operator|)
operator|+
literal|1
argument_list|,
literal|"%-d"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|strptr
operator|-
operator|*
name|tabloc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Kinda Kludgy.  We should just use the returned value of 	     sprintf but not all implementations get this right.  */
block|{
name|char
modifier|*
name|temp
init|=
name|hdr
operator|->
name|ar_name
operator|+
literal|2
decl_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|hdr
operator|->
name|ar_name
operator|+
name|maxname
condition|;
name|temp
operator|++
control|)
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\0'
condition|)
operator|*
name|temp
operator|=
literal|' '
expr_stmt|;
block|}
name|strptr
operator|+=
name|thislen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|trailing_slash
condition|)
operator|++
name|strptr
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** A couple of functions for creating ar_hdrs */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX_LARGE_AR_IDS
end_ifdef

begin_comment
comment|/* Function to encode large UID/GID values according to HP.  */
end_comment

begin_function
specifier|static
name|void
name|hpux_uid_gid_encode
parameter_list|(
name|str
parameter_list|,
name|id
parameter_list|)
name|char
name|str
index|[
literal|6
index|]
decl_stmt|;
name|long
name|int
name|id
decl_stmt|;
block|{
name|int
name|cnt
decl_stmt|;
name|str
index|[
literal|5
index|]
operator|=
literal|'@'
operator|+
operator|(
name|id
operator|&
literal|3
operator|)
expr_stmt|;
name|id
operator|>>=
literal|2
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|4
init|;
name|cnt
operator|>=
literal|0
condition|;
operator|++
name|cnt
operator|,
name|id
operator|>>=
literal|6
control|)
name|str
index|[
name|cnt
index|]
operator|=
literal|' '
operator|+
operator|(
name|id
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HPUX_LARGE_AR_IDS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETUID
end_ifndef

begin_define
define|#
directive|define
name|getuid
parameter_list|()
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETGID
end_ifndef

begin_define
define|#
directive|define
name|getgid
parameter_list|()
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Takes a filename, returns an arelt_data for it, or NULL if it can't    make one.  The filename must refer to a filename in the filesystem.    The filename field of the ar_hdr will NOT be initialized.  If member    is set, and it's an in-memory bfd, we fake it.  */
end_comment

begin_function
specifier|static
name|struct
name|areltdata
modifier|*
name|bfd_ar_hdr_from_filesystem
parameter_list|(
name|abfd
parameter_list|,
name|filename
parameter_list|,
name|member
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|bfd
modifier|*
name|member
decl_stmt|;
block|{
name|struct
name|stat
name|status
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|ared
decl_stmt|;
name|struct
name|ar_hdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp1
decl_stmt|;
if|if
condition|(
name|member
operator|&&
operator|(
name|member
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Assume we just "made" the member, and fake it.  */
name|struct
name|bfd_in_memory
modifier|*
name|bim
init|=
operator|(
expr|struct
name|bfd_in_memory
operator|*
operator|)
name|member
operator|->
name|iostream
decl_stmt|;
name|time
argument_list|(
operator|&
name|status
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|status
operator|.
name|st_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|status
operator|.
name|st_gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|status
operator|.
name|st_mode
operator|=
literal|0644
expr_stmt|;
name|status
operator|.
name|st_size
operator|=
name|bim
operator|->
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ared
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ared
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|hdr
operator|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ared
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|)
expr_stmt|;
comment|/* ar headers are space padded, not null padded!  */
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|hdr
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|hdr
operator|->
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Goddamned sprintf doesn't permit MAXIMUM field lengths.  */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_date
operator|)
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|status
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUX_LARGE_AR_IDS
comment|/* HP has a very "special" way to handle UID/GID's with numeric values> 99999.  */
if|if
condition|(
name|status
operator|.
name|st_uid
operator|>
literal|99999
condition|)
name|hpux_uid_gid_encode
argument_list|(
name|hdr
operator|->
name|ar_gid
argument_list|,
operator|(
name|long
operator|)
name|status
operator|.
name|st_uid
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_uid
operator|)
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|status
operator|.
name|st_uid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUX_LARGE_AR_IDS
comment|/* HP has a very "special" way to handle UID/GID's with numeric values> 99999.  */
if|if
condition|(
name|status
operator|.
name|st_gid
operator|>
literal|99999
condition|)
name|hpux_uid_gid_encode
argument_list|(
name|hdr
operator|->
name|ar_uid
argument_list|,
operator|(
name|long
operator|)
name|status
operator|.
name|st_gid
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_gid
operator|)
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|status
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_mode
operator|)
argument_list|,
literal|"%-8o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|status
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_size
operator|)
argument_list|,
literal|"%-10ld"
argument_list|,
operator|(
name|long
operator|)
name|status
operator|.
name|st_size
argument_list|)
expr_stmt|;
comment|/* Correct for a lossage in sprintf whereby it null-terminates.  I cannot      understand how these C losers could design such a ramshackle bunch of      IO operations.  */
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
name|temp1
operator|=
name|temp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|-
literal|2
expr_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|temp1
condition|;
name|temp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\0'
condition|)
operator|*
name|temp
operator|=
literal|' '
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|hdr
operator|->
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ared
operator|->
name|parsed_size
operator|=
name|status
operator|.
name|st_size
expr_stmt|;
name|ared
operator|->
name|arch_header
operator|=
operator|(
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
return|return
name|ared
return|;
block|}
end_function

begin_comment
comment|/* This is magic required by the "ar" program.  Since it's    undocumented, it's undocumented.  You may think that it would take    a strong stomach to write this, and it does, but it takes even a    stronger stomach to try to code around such a thing!  */
end_comment

begin_decl_stmt
name|struct
name|ar_hdr
modifier|*
name|bfd_special_undocumented_glue
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|ar_hdr
modifier|*
name|bfd_special_undocumented_glue
parameter_list|(
name|abfd
parameter_list|,
name|filename
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|ar_elt
init|=
name|bfd_ar_hdr_from_filesystem
argument_list|(
name|abfd
argument_list|,
name|filename
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ar_elt
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|ar_elt
operator|->
name|arch_header
return|;
block|}
end_function

begin_comment
comment|/* Analogous to stat call.  */
end_comment

begin_function
name|int
name|bfd_generic_stat_arch_elt
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|aloser
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|hdr
operator|=
name|arch_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
define|#
directive|define
name|foo
parameter_list|(
name|arelt
parameter_list|,
name|stelt
parameter_list|,
name|size
parameter_list|)
define|\
value|buf->stelt = strtol (hdr->arelt,&aloser, size);	\   if (aloser == hdr->arelt)	      			\     return -1;
comment|/* Some platforms support special notations for large IDs.  */
ifdef|#
directive|ifdef
name|HPUX_LARGE_AR_IDS
define|#
directive|define
name|foo2
parameter_list|(
name|arelt
parameter_list|,
name|stelt
parameter_list|,
name|size
parameter_list|)
define|\
value|if (hdr->arelt[5] == ' ')						\     {									\       foo (arelt, stelt, size);						\     }									\   else									\     {									\       int cnt;								\       for (buf->stelt = cnt = 0; cnt< 5; ++cnt)			\ 	{								\ 	  if (hdr->arelt[cnt]< ' ' || hdr->arelt[cnt]> ' ' + 0x3f)	\ 	    return -1;							\ 	  buf->stelt<<= 6;						\ 	  buf->stelt += hdr->arelt[cnt] - ' ';				\ 	}								\       if (hdr->arelt[5]< '@' || hdr->arelt[5]> '@' + 3)		\ 	return -1;							\       buf->stelt<<= 2;							\       buf->stelt += hdr->arelt[5] - '@';				\     }
else|#
directive|else
define|#
directive|define
name|foo2
parameter_list|(
name|arelt
parameter_list|,
name|stelt
parameter_list|,
name|size
parameter_list|)
value|foo (arelt, stelt, size)
endif|#
directive|endif
name|foo
argument_list|(
name|ar_date
argument_list|,
name|st_mtime
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo2
argument_list|(
name|ar_uid
argument_list|,
name|st_uid
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo2
argument_list|(
name|ar_gid
argument_list|,
name|st_gid
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_mode
argument_list|,
name|st_mode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|buf
operator|->
name|st_size
operator|=
name|arch_eltdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|parsed_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bfd_dont_truncate_arname
parameter_list|(
name|abfd
parameter_list|,
name|pathname
parameter_list|,
name|arhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|arhdr
decl_stmt|;
block|{
comment|/* FIXME: This interacts unpleasantly with ar's quick-append option.      Fortunately ic960 users will never use that option.  Fixing this      is very hard; fortunately I know how to do it and will do so once      intel's release is out the door.  */
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|arhdr
decl_stmt|;
name|size_t
name|length
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|size_t
name|maxlen
init|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|BFD_TRADITIONAL_FORMAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_bsd_truncate_arname
argument_list|(
name|abfd
argument_list|,
name|pathname
argument_list|,
name|arhdr
argument_list|)
expr_stmt|;
return|return;
block|}
name|filename
operator|=
name|normalize
argument_list|(
name|abfd
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME */
name|abort
argument_list|()
expr_stmt|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|maxlen
condition|)
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Add the padding character if there is room for it.  */
if|if
condition|(
name|length
operator|<
name|maxlen
operator|||
operator|(
name|length
operator|==
name|maxlen
operator|&&
name|length
operator|<
sizeof|sizeof
name|hdr
operator|->
name|ar_name
operator|)
condition|)
operator|(
name|hdr
operator|->
name|ar_name
operator|)
index|[
name|length
index|]
operator|=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_bsd_truncate_arname
parameter_list|(
name|abfd
parameter_list|,
name|pathname
parameter_list|,
name|arhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|arhdr
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|arhdr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|CONST
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|int
name|maxlen
init|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
block|{
comment|/* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
name|char
modifier|*
name|bslash
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
operator|(
name|bslash
operator|!=
name|NULL
operator|&&
name|bslash
operator|>
name|filename
operator|)
condition|)
name|filename
operator|=
name|bslash
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|&&
name|pathname
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|pathname
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|filename
operator|=
name|pathname
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|pathname
expr_stmt|;
else|else
operator|++
name|filename
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|maxlen
condition|)
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* pathname: meet procrustes */
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|length
operator|=
name|maxlen
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
name|maxlen
condition|)
operator|(
name|hdr
operator|->
name|ar_name
operator|)
index|[
name|length
index|]
operator|=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store name into ar header.  Truncates the name to fit.    1> strip pathname to be just the basename.    2> if it's short enuf to fit, stuff it in.    3> If it doesn't end with .o, truncate it to fit    4> truncate it before the .o, append .o, stuff THAT in.  */
end_comment

begin_comment
comment|/* This is what gnu ar does.  It's better but incompatible with the    bsd ar.  */
end_comment

begin_function
name|void
name|bfd_gnu_truncate_arname
parameter_list|(
name|abfd
parameter_list|,
name|pathname
parameter_list|,
name|arhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|arhdr
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|arhdr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|CONST
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|int
name|maxlen
init|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
block|{
comment|/* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
name|char
modifier|*
name|bslash
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
operator|(
name|bslash
operator|!=
name|NULL
operator|&&
name|bslash
operator|>
name|filename
operator|)
condition|)
name|filename
operator|=
name|bslash
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|&&
name|pathname
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|pathname
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|filename
operator|=
name|pathname
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|pathname
expr_stmt|;
else|else
operator|++
name|filename
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|maxlen
condition|)
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* pathname: meet procrustes */
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filename
index|[
name|length
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|filename
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|)
condition|)
block|{
name|hdr
operator|->
name|ar_name
index|[
name|maxlen
operator|-
literal|2
index|]
operator|=
literal|'.'
expr_stmt|;
name|hdr
operator|->
name|ar_name
index|[
name|maxlen
operator|-
literal|1
index|]
operator|=
literal|'o'
expr_stmt|;
block|}
name|length
operator|=
name|maxlen
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
literal|16
condition|)
operator|(
name|hdr
operator|->
name|ar_name
operator|)
index|[
name|length
index|]
operator|=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The BFD is open for write and has its format set to bfd_archive.  */
end_comment

begin_function
name|boolean
name|_bfd_write_archive_contents
parameter_list|(
name|arch
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
block|{
name|bfd
modifier|*
name|current
decl_stmt|;
name|char
modifier|*
name|etable
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|elength
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ename
init|=
name|NULL
decl_stmt|;
name|boolean
name|makemap
init|=
name|bfd_has_map
argument_list|(
name|arch
argument_list|)
decl_stmt|;
name|boolean
name|hasobjects
init|=
name|false
decl_stmt|;
comment|/* If no .o's, don't bother to make a map.  */
name|bfd_size_type
name|wrote
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|tries
decl_stmt|;
comment|/* Verify the viability of all entries; if any of them live in the      filesystem (as opposed to living in an archive open for input)      then construct a fresh ar_hdr for them.  */
for|for
control|(
name|current
operator|=
name|arch
operator|->
name|archive_head
init|;
name|current
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
comment|/* This check is checking the bfds for the objects we're reading 	 from (which are usually either an object file or archive on 	 disk), not the archive entries we're writing to.  We don't 	 actually create bfds for the archive members, we just copy 	 them byte-wise when we write out the archive.  */
if|if
condition|(
name|bfd_write_p
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|current
operator|->
name|arelt_data
condition|)
block|{
name|current
operator|->
name|arelt_data
operator|=
operator|(
name|PTR
operator|)
name|bfd_ar_hdr_from_filesystem
argument_list|(
name|arch
argument_list|,
name|current
operator|->
name|filename
argument_list|,
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|->
name|arelt_data
condition|)
return|return
name|false
return|;
comment|/* Put in the file name.  */
name|BFD_SEND
argument_list|(
name|arch
argument_list|,
name|_bfd_truncate_arname
argument_list|,
operator|(
name|arch
operator|,
name|current
operator|->
name|filename
operator|,
operator|(
name|char
operator|*
operator|)
name|arch_hdr
argument_list|(
name|current
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|makemap
operator|&&
operator|!
name|hasobjects
condition|)
block|{
comment|/* Don't bother if we won't make a map!  */
if|if
condition|(
operator|(
name|bfd_check_format
argument_list|(
name|current
argument_list|,
name|bfd_object
argument_list|)
operator|)
if|#
directive|if
literal|0
comment|/* FIXME -- these are not set correctly */
condition|&& ((bfd_get_file_flags (current)& HAS_SYMS))
endif|#
directive|endif
condition|)
name|hasobjects
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|arch
argument_list|,
name|_bfd_construct_extended_name_table
argument_list|,
operator|(
name|arch
operator|,
operator|&
name|etable
operator|,
operator|&
name|elength
operator|,
operator|&
name|ename
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|arch
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
ifdef|#
directive|ifdef
name|GNU960
name|wrote
operator|=
name|bfd_write
argument_list|(
name|BFD_GNU960_ARMAG
argument_list|(
name|arch
argument_list|)
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|arch
argument_list|)
expr_stmt|;
else|#
directive|else
name|wrote
operator|=
name|bfd_write
argument_list|(
name|ARMAG
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|arch
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wrote
operator|!=
name|SARMAG
condition|)
return|return
name|false
return|;
if|if
condition|(
name|makemap
operator|&&
name|hasobjects
condition|)
block|{
if|if
condition|(
name|_bfd_compute_and_write_armap
argument_list|(
name|arch
argument_list|,
name|elength
argument_list|)
operator|!=
name|true
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|elength
operator|!=
literal|0
condition|)
block|{
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
name|ename
argument_list|)
expr_stmt|;
comment|/* Round size up to even number in archive header.  */
name|sprintf
argument_list|(
operator|&
operator|(
name|hdr
operator|.
name|ar_size
index|[
literal|0
index|]
operator|)
argument_list|,
literal|"%-10d"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|elength
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|hdr
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|)
operator|||
name|bfd_write
argument_list|(
name|etable
argument_list|,
literal|1
argument_list|,
name|elength
argument_list|,
name|arch
argument_list|)
operator|!=
name|elength
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|elength
operator|%
literal|2
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
block|}
for|for
control|(
name|current
operator|=
name|arch
operator|->
name|archive_head
init|;
name|current
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|char
name|buffer
index|[
name|DEFAULT_BUFFERSIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|remaining
init|=
name|arelt_size
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
name|arch_hdr
argument_list|(
name|current
argument_list|)
decl_stmt|;
comment|/* Write ar header.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|current
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
while|while
condition|(
name|remaining
condition|)
block|{
name|unsigned
name|int
name|amt
init|=
name|DEFAULT_BUFFERSIZE
decl_stmt|;
if|if
condition|(
name|amt
operator|>
name|remaining
condition|)
name|amt
operator|=
name|remaining
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|buffer
argument_list|,
name|amt
argument_list|,
literal|1
argument_list|,
name|current
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|amt
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
name|remaining
operator|-=
name|amt
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|%
literal|2
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|makemap
operator|&&
name|hasobjects
condition|)
block|{
comment|/* Verify the timestamp in the archive file.  If it would not be 	 accepted by the linker, rewrite it until it would be.  If 	 anything odd happens, break out and just return.  (The 	 Berkeley linker checks the timestamp and refuses to read the 	 table-of-contents if it is>60 seconds less than the file's 	 modified-time.  That painful hack requires this painful hack.  */
name|tries
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|bfd_update_armap_timestamp
argument_list|(
name|arch
argument_list|)
condition|)
break|break;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: writing archive was slow: rewriting timestamp\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|tries
operator|<
literal|6
condition|)
do|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note that the namidx for the first symbol is 0.  */
end_comment

begin_function
name|boolean
name|_bfd_compute_and_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
block|{
name|char
modifier|*
name|first_name
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|current
decl_stmt|;
name|file_ptr
name|elt_no
init|=
literal|0
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
init|=
name|NULL
decl_stmt|;
name|int
name|orl_max
init|=
literal|1024
decl_stmt|;
comment|/* fine initial default */
name|int
name|orl_count
init|=
literal|0
decl_stmt|;
name|int
name|stridx
init|=
literal|0
decl_stmt|;
comment|/* string index */
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|NULL
decl_stmt|;
name|long
name|syms_max
init|=
literal|0
decl_stmt|;
name|boolean
name|ret
decl_stmt|;
comment|/* Dunno if this is the best place for this info...  */
if|if
condition|(
name|elength
operator|!=
literal|0
condition|)
name|elength
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
name|elength
operator|+=
name|elength
operator|%
literal|2
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|orl
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|orl_max
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|orl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* We put the symbol names on the arch objalloc, and then discard      them when done.  */
name|first_name
operator|=
name|bfd_alloc
argument_list|(
name|arch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_name
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Drop all the files called __.SYMDEF, we're going to make our own.  */
while|while
condition|(
name|arch
operator|->
name|archive_head
operator|&&
name|strcmp
argument_list|(
name|arch
operator|->
name|archive_head
operator|->
name|filename
argument_list|,
literal|"__.SYMDEF"
argument_list|)
operator|==
literal|0
condition|)
name|arch
operator|->
name|archive_head
operator|=
name|arch
operator|->
name|archive_head
operator|->
name|next
expr_stmt|;
comment|/* Map over each element.  */
for|for
control|(
name|current
operator|=
name|arch
operator|->
name|archive_head
init|;
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
operator|,
name|elt_no
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bfd_check_format
argument_list|(
name|current
argument_list|,
name|bfd_object
argument_list|)
operator|==
name|true
operator|)
operator|&&
operator|(
operator|(
name|bfd_get_file_flags
argument_list|(
name|current
argument_list|)
operator|&
name|HAS_SYMS
operator|)
operator|)
condition|)
block|{
name|long
name|storage
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|long
name|src_count
decl_stmt|;
name|storage
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|storage
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|storage
operator|>
name|syms_max
condition|)
block|{
if|if
condition|(
name|syms_max
operator|>
literal|0
condition|)
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
name|syms_max
operator|=
name|storage
expr_stmt|;
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|syms_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|current
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Now map over all the symbols, picking out the ones we                  want.  */
for|for
control|(
name|src_count
operator|=
literal|0
init|;
name|src_count
operator|<
name|symcount
condition|;
name|src_count
operator|++
control|)
block|{
name|flagword
name|flags
init|=
operator|(
name|syms
index|[
name|src_count
index|]
operator|)
operator|->
name|flags
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|syms
index|[
name|src_count
index|]
operator|->
name|section
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|||
name|flags
operator|&
name|BSF_WEAK
operator|||
name|flags
operator|&
name|BSF_INDIRECT
operator|||
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
operator|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|size_t
name|namelen
decl_stmt|;
name|struct
name|orl
modifier|*
name|new_map
decl_stmt|;
comment|/* This symbol will go into the archive header.  */
if|if
condition|(
name|orl_count
operator|==
name|orl_max
condition|)
block|{
name|orl_max
operator|*=
literal|2
expr_stmt|;
name|new_map
operator|=
operator|(
operator|(
expr|struct
name|orl
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|map
argument_list|,
name|orl_max
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|orl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_map
operator|==
operator|(
expr|struct
name|orl
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|map
operator|=
name|new_map
expr_stmt|;
block|}
name|namelen
operator|=
name|strlen
argument_list|(
name|syms
index|[
name|src_count
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|map
index|[
name|orl_count
index|]
operator|.
name|name
operator|=
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|arch
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|map
index|[
name|orl_count
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
operator|*
operator|(
name|map
index|[
name|orl_count
index|]
operator|.
name|name
operator|)
operator|=
name|bfd_alloc
argument_list|(
name|arch
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|map
index|[
name|orl_count
index|]
operator|.
name|name
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
operator|*
operator|(
name|map
index|[
name|orl_count
index|]
operator|.
name|name
operator|)
argument_list|,
name|syms
index|[
name|src_count
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|map
index|[
name|orl_count
index|]
operator|)
operator|.
name|pos
operator|=
operator|(
name|file_ptr
operator|)
name|current
expr_stmt|;
operator|(
name|map
index|[
name|orl_count
index|]
operator|)
operator|.
name|namidx
operator|=
name|stridx
expr_stmt|;
name|stridx
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
operator|++
name|orl_count
expr_stmt|;
block|}
block|}
block|}
comment|/* Now ask the BFD to free up any cached information, so we 	     don't fill all of memory with symbol tables.  */
if|if
condition|(
operator|!
name|bfd_free_cached_info
argument_list|(
name|current
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* OK, now we have collected all the data, let's write them out.  */
name|ret
operator|=
name|BFD_SEND
argument_list|(
name|arch
argument_list|,
name|write_armap
argument_list|,
operator|(
name|arch
operator|,
name|elength
operator|,
name|map
operator|,
name|orl_count
operator|,
name|stridx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms_max
operator|>
literal|0
condition|)
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_name
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|arch
argument_list|,
name|first_name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
name|error_return
label|:
if|if
condition|(
name|syms_max
operator|>
literal|0
condition|)
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_name
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|arch
argument_list|,
name|first_name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|boolean
name|bsd_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|int
name|padit
init|=
name|stridx
operator|&
literal|1
decl_stmt|;
name|unsigned
name|int
name|ranlibsize
init|=
name|orl_count
operator|*
name|BSD_SYMDEF_SIZE
decl_stmt|;
name|unsigned
name|int
name|stringsize
init|=
name|stridx
operator|+
name|padit
decl_stmt|;
comment|/* Include 8 bytes to store ranlibsize and stringsize in output.  */
name|unsigned
name|int
name|mapsize
init|=
name|ranlibsize
operator|+
name|stringsize
operator|+
literal|8
decl_stmt|;
name|file_ptr
name|firstreal
decl_stmt|;
name|bfd
modifier|*
name|current
init|=
name|arch
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
name|last_elt
init|=
name|current
decl_stmt|;
comment|/* last element arch seen */
name|bfd_byte
name|temp
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|firstreal
operator|=
name|mapsize
operator|+
name|elength
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|SARMAG
expr_stmt|;
name|stat
argument_list|(
name|arch
operator|->
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
name|RANLIBMAG
argument_list|)
expr_stmt|;
comment|/* Remember the timestamp, to keep it holy.  But fudge it a little.  */
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
operator|=
name|statbuf
operator|.
name|st_mtime
operator|+
name|ARMAP_TIME_OFFSET
expr_stmt|;
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_datepos
operator|=
operator|(
name|SARMAG
operator|+
name|offsetof
argument_list|(
expr|struct
name|ar_hdr
argument_list|,
name|ar_date
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_uid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_gid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|mapsize
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|hdr
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ranlibsize
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|orl_count
condition|;
name|count
operator|++
control|)
block|{
name|bfd_byte
name|buf
index|[
name|BSD_SYMDEF_SIZE
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|pos
operator|)
operator|!=
name|last_elt
condition|)
block|{
do|do
block|{
name|firstreal
operator|+=
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
name|firstreal
operator|+=
name|firstreal
operator|%
literal|2
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|pos
condition|)
do|;
block|}
comment|/* if new archive element */
name|last_elt
operator|=
name|current
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
name|map
index|[
name|count
index|]
operator|.
name|namidx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
name|firstreal
argument_list|,
name|buf
operator|+
name|BSD_SYMDEF_OFFSET_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
name|BSD_SYMDEF_SIZE
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
name|BSD_SYMDEF_SIZE
condition|)
return|return
name|false
return|;
block|}
comment|/* Now write the strings themselves.  */
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
name|stringsize
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|orl_count
condition|;
name|count
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|*
name|map
index|[
name|count
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|*
name|map
index|[
name|count
index|]
operator|.
name|name
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|arch
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
comment|/* The spec sez this should be a newline.  But in order to be      bug-compatible for sun's ar we use a null.  */
if|if
condition|(
name|padit
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
literal|""
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* At the end of archive file handling, update the timestamp in the    file, so the linker will accept it.     Return true if the timestamp was OK, or an unusual problem happened.    Return false if we updated the timestamp.  */
end_comment

begin_function
name|boolean
name|_bfd_archive_bsd_update_armap_timestamp
parameter_list|(
name|arch
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
block|{
name|struct
name|stat
name|archstat
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Flush writes, get last-write timestamp from file, and compare it      to the timestamp IN the file.  */
name|bfd_flush
argument_list|(
name|arch
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_stat
argument_list|(
name|arch
argument_list|,
operator|&
name|archstat
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|_
argument_list|(
literal|"Reading archive file mod timestamp"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Can't read mod time for some reason.  */
return|return
name|true
return|;
block|}
if|if
condition|(
name|archstat
operator|.
name|st_mtime
operator|<=
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
condition|)
comment|/* OK by the linker's rules.  */
return|return
name|true
return|;
comment|/* Update the timestamp.  */
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
operator|=
name|archstat
operator|.
name|st_mtime
operator|+
name|ARMAP_TIME_OFFSET
expr_stmt|;
comment|/* Prepare an ASCII version suitable for writing.  */
name|memset
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hdr
operator|.
name|ar_date
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|hdr
operator|.
name|ar_date
operator|)
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Write it into the file.  */
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_datepos
operator|=
operator|(
name|SARMAG
operator|+
name|offsetof
argument_list|(
expr|struct
name|ar_hdr
argument_list|,
name|ar_date
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|arch
argument_list|,
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_datepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|)
operator|)
condition|)
block|{
comment|/* FIXME: bfd can't call perror.  */
name|perror
argument_list|(
name|_
argument_list|(
literal|"Writing updated armap timestamp"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some error while writing.  */
return|return
name|true
return|;
block|}
comment|/* We updated the timestamp successfully.  */
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A coff armap looks like :    lARMAG    struct ar_hdr with name = '/'    number of symbols    offset of file for symbol 0    offset of file for symbol 1     offset of file for symbol n-1    symbol name 0    symbol name 1     symbol name n-1 */
end_comment

begin_function
name|boolean
name|coff_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|symbol_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|symbol_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
comment|/* The size of the ranlib is the number of exported symbols in the      archive * the number of bytes in a int, + an int for the count.  */
name|unsigned
name|int
name|ranlibsize
init|=
operator|(
name|symbol_count
operator|*
literal|4
operator|)
operator|+
literal|4
decl_stmt|;
name|unsigned
name|int
name|stringsize
init|=
name|stridx
decl_stmt|;
name|unsigned
name|int
name|mapsize
init|=
name|stringsize
operator|+
name|ranlibsize
decl_stmt|;
name|file_ptr
name|archive_member_file_ptr
decl_stmt|;
name|bfd
modifier|*
name|current
init|=
name|arch
operator|->
name|archive_head
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|padit
init|=
name|mapsize
operator|&
literal|1
decl_stmt|;
if|if
condition|(
name|padit
condition|)
name|mapsize
operator|++
expr_stmt|;
comment|/* Work out where the first object file will go in the archive.  */
name|archive_member_file_ptr
operator|=
operator|(
name|mapsize
operator|+
name|elength
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|SARMAG
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|mapsize
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This, at least, is what Intel coff sets the values to.  */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_uid
operator|)
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_gid
operator|)
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_mode
operator|)
argument_list|,
literal|"%-7o"
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|hdr
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
comment|/* Write the ar header for this item and the number of symbols.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_write_bigendian_4byte_int
argument_list|(
name|arch
argument_list|,
name|symbol_count
argument_list|)
expr_stmt|;
comment|/* Two passes, first write the file offsets for each symbol -      remembering that each offset is on a two byte boundary.  */
comment|/* Write out the file offset for the file associated with each      symbol, and remember to keep the offsets padded out.  */
name|current
operator|=
name|arch
operator|->
name|archive_head
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
name|count
operator|<
name|symbol_count
condition|)
block|{
comment|/* For each symbol which is used defined in this object, write 	 out the object file's address in the archive.  */
while|while
condition|(
name|count
operator|<
name|symbol_count
operator|&&
operator|(
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|pos
operator|)
operator|==
name|current
condition|)
block|{
name|bfd_write_bigendian_4byte_int
argument_list|(
name|arch
argument_list|,
name|archive_member_file_ptr
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Add size of this archive entry.  */
name|archive_member_file_ptr
operator|+=
operator|(
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|)
expr_stmt|;
comment|/* Remember aboout the even alignment.  */
name|archive_member_file_ptr
operator|+=
name|archive_member_file_ptr
operator|%
literal|2
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
comment|/* Now write the strings themselves.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|symbol_count
condition|;
name|count
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|*
name|map
index|[
name|count
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|*
name|map
index|[
name|count
index|]
operator|.
name|name
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|arch
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
comment|/* The spec sez this should be a newline.  But in order to be      bug-compatible for arc960 we use a null.  */
if|if
condition|(
name|padit
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
literal|""
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

