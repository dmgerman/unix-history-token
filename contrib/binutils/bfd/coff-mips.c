begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for MIPS Extended-Coff files.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2007    Free Software Foundation, Inc.    Original version by Per Bothner.    Full support added by Ian Lance Taylor, ian@cygnus.com.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/mips.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Prototypes for static functions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mips_ecoff_bad_format_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|filehdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_ecoff_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_ecoff_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_adjust_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_adjust_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|arelent
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_generic_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_refhi_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_reflo_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_gprel_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_relocate_hi
name|PARAMS
argument_list|(
operator|(
expr|struct
name|internal_reloc
operator|*
name|refhi
operator|,
expr|struct
name|internal_reloc
operator|*
name|reflo
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd_byte
operator|*
name|contents
operator|,
name|bfd_vma
name|relocation
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mips_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|mips_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* ECOFF has COFF sections, but the debugging information is stored in    a completely different format.  ECOFF targets use some of the    swapping routines from coffswap.h, and some of the generic COFF    routines in coffgen.c, but, unlike the real COFF targets, do not    use coffcode.h itself.     Get the generic COFF swapping routines, except for the reloc,    symbol, and lineno ones.  Give them ECOFF names.  */
end_comment

begin_define
define|#
directive|define
name|MIPSECOFF
end_define

begin_define
define|#
directive|define
name|NO_COFF_RELOCS
end_define

begin_define
define|#
directive|define
name|NO_COFF_SYMBOLS
end_define

begin_define
define|#
directive|define
name|NO_COFF_LINENOS
end_define

begin_define
define|#
directive|define
name|coff_swap_filehdr_in
value|mips_ecoff_swap_filehdr_in
end_define

begin_define
define|#
directive|define
name|coff_swap_filehdr_out
value|mips_ecoff_swap_filehdr_out
end_define

begin_define
define|#
directive|define
name|coff_swap_aouthdr_in
value|mips_ecoff_swap_aouthdr_in
end_define

begin_define
define|#
directive|define
name|coff_swap_aouthdr_out
value|mips_ecoff_swap_aouthdr_out
end_define

begin_define
define|#
directive|define
name|coff_swap_scnhdr_in
value|mips_ecoff_swap_scnhdr_in
end_define

begin_define
define|#
directive|define
name|coff_swap_scnhdr_out
value|mips_ecoff_swap_scnhdr_out
end_define

begin_include
include|#
directive|include
file|"coffswap.h"
end_include

begin_comment
comment|/* Get the ECOFF swapping routines.  */
end_comment

begin_define
define|#
directive|define
name|ECOFF_32
end_define

begin_include
include|#
directive|include
file|"ecoffswap.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* How to process the various relocs types.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|mips_howto_table
index|[]
init|=
block|{
comment|/* Reloc type 0 is ignored.  The reloc reading code ensures that      this is a reference to the .abs section, which will cause      bfd_perform_relocation to do nothing.  */
name|HOWTO
argument_list|(
name|MIPS_R_IGNORE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"IGNORE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit reference to a symbol, normally from a data section.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFHALF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips_generic_reloc
argument_list|,
comment|/* special_function */
literal|"REFHALF"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit reference to a symbol, normally from a data section.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFWORD
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips_generic_reloc
argument_list|,
comment|/* special_function */
literal|"REFWORD"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 26 bit absolute jump address.  */
name|HOWTO
argument_list|(
name|MIPS_R_JMPADDR
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper four 				   bits must match the PC.  */
name|mips_generic_reloc
argument_list|,
comment|/* special_function */
literal|"JMPADDR"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x3ffffff
argument_list|,
comment|/* src_mask */
literal|0x3ffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high 16 bits of a symbol value.  Handled by the function      mips_refhi_reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFHI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips_refhi_reloc
argument_list|,
comment|/* special_function */
literal|"REFHI"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The low 16 bits of a symbol value.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|mips_reflo_reloc
argument_list|,
comment|/* special_function */
literal|"REFLO"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A reference to an offset from the gp register.  Handled by the      function mips_gprel_reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_GPREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_gprel_reloc
argument_list|,
comment|/* special_function */
literal|"GPREL"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A reference to a literal using an offset from the gp register.      Handled by the function mips_gprel_reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_gprel_reloc
argument_list|,
comment|/* special_function */
literal|"LITERAL"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|8
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|9
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|10
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|11
argument_list|)
block|,
comment|/* FIXME: This relocation is used (internally only) to represent branches      when assembling.  It should never appear in output files, and      be removed.  (It used to be used for embedded-PIC support.)  */
name|HOWTO
argument_list|(
name|MIPS_R_PCREL16
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_generic_reloc
argument_list|,
comment|/* special_function */
literal|"PCREL16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIPS_HOWTO_COUNT
define|\
value|(sizeof mips_howto_table / sizeof mips_howto_table[0])
end_define

begin_escape
end_escape

begin_comment
comment|/* See whether the magic number matches.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_ecoff_bad_format_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_magic
condition|)
block|{
case|case
name|MIPS_MAGIC_1
case|:
comment|/* I don't know what endianness this implies.  */
return|return
name|TRUE
return|;
case|case
name|MIPS_MAGIC_BIG
case|:
case|case
name|MIPS_MAGIC_BIG2
case|:
case|case
name|MIPS_MAGIC_BIG3
case|:
return|return
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
return|;
case|case
name|MIPS_MAGIC_LITTLE
case|:
case|case
name|MIPS_MAGIC_LITTLE2
case|:
case|case
name|MIPS_MAGIC_LITTLE3
case|:
return|return
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reloc handling.  MIPS ECOFF relocs are packed into 8 bytes in    external form.  They use a bit which indicates whether the symbol    is external.  */
end_comment

begin_comment
comment|/* Swap a reloc in.  */
end_comment

begin_function
specifier|static
name|void
name|mips_ecoff_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|ext_ptr
parameter_list|,
name|intern
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext_ptr
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
block|{
specifier|const
name|RELOC
modifier|*
name|ext
init|=
operator|(
name|RELOC
operator|*
operator|)
name|ext_ptr
decl_stmt|;
name|intern
operator|->
name|r_vaddr
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|intern
operator|->
name|r_symndx
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|<<
name|RELOC_BITS0_SYMNDX_SH_LEFT_BIG
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|<<
name|RELOC_BITS1_SYMNDX_SH_LEFT_BIG
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|<<
name|RELOC_BITS2_SYMNDX_SH_LEFT_BIG
operator|)
operator|)
expr_stmt|;
name|intern
operator|->
name|r_type
operator|=
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_TYPE_BIG
operator|)
operator|>>
name|RELOC_BITS3_TYPE_SH_BIG
operator|)
expr_stmt|;
name|intern
operator|->
name|r_extern
operator|=
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_EXTERN_BIG
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|intern
operator|->
name|r_symndx
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|<<
name|RELOC_BITS0_SYMNDX_SH_LEFT_LITTLE
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|<<
name|RELOC_BITS1_SYMNDX_SH_LEFT_LITTLE
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|<<
name|RELOC_BITS2_SYMNDX_SH_LEFT_LITTLE
operator|)
operator|)
expr_stmt|;
name|intern
operator|->
name|r_type
operator|=
operator|(
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_BITS3_TYPE_SH_LITTLE
operator|)
operator||
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_TYPEHI_LITTLE
operator|)
operator|<<
name|RELOC_BITS3_TYPEHI_SH_LITTLE
operator|)
operator|)
expr_stmt|;
name|intern
operator|->
name|r_extern
operator|=
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_EXTERN_LITTLE
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Swap a reloc out.  */
end_comment

begin_function
specifier|static
name|void
name|mips_ecoff_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|intern
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
name|PTR
name|dst
decl_stmt|;
block|{
name|RELOC
modifier|*
name|ext
init|=
operator|(
name|RELOC
operator|*
operator|)
name|dst
decl_stmt|;
name|long
name|r_symndx
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|intern
operator|->
name|r_extern
operator|||
operator|(
name|intern
operator|->
name|r_symndx
operator|>=
literal|0
operator|&&
name|intern
operator|->
name|r_symndx
operator|<=
literal|12
operator|)
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|intern
operator|->
name|r_symndx
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|intern
operator|->
name|r_vaddr
argument_list|,
name|ext
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS0_SYMNDX_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS1_SYMNDX_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS2_SYMNDX_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|r_type
operator|<<
name|RELOC_BITS3_TYPE_SH_BIG
operator|)
operator|&
name|RELOC_BITS3_TYPE_BIG
operator|)
operator||
operator|(
name|intern
operator|->
name|r_extern
condition|?
name|RELOC_BITS3_EXTERN_BIG
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS0_SYMNDX_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS1_SYMNDX_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS2_SYMNDX_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|r_type
operator|<<
name|RELOC_BITS3_TYPE_SH_LITTLE
operator|)
operator|&
name|RELOC_BITS3_TYPE_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|r_type
operator|>>
name|RELOC_BITS3_TYPEHI_SH_LITTLE
operator|&
name|RELOC_BITS3_TYPEHI_LITTLE
operator|)
operator|)
operator||
operator|(
name|intern
operator|->
name|r_extern
condition|?
name|RELOC_BITS3_EXTERN_LITTLE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish canonicalizing a reloc.  Part of this is generic to all    ECOFF targets, and that part is in ecoff.c.  The rest is done in    this backend routine.  It must fill in the howto field.  */
end_comment

begin_function
specifier|static
name|void
name|mips_adjust_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|intern
parameter_list|,
name|rptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
name|arelent
modifier|*
name|rptr
decl_stmt|;
block|{
if|if
condition|(
name|intern
operator|->
name|r_type
operator|>
name|MIPS_R_PCREL16
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|intern
operator|->
name|r_extern
operator|&&
operator|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_GPREL
operator|||
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_LITERAL
operator|)
condition|)
name|rptr
operator|->
name|addend
operator|+=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
expr_stmt|;
comment|/* If the type is MIPS_R_IGNORE, make sure this is a reference to      the absolute section so that the reloc is ignored.  */
if|if
condition|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_IGNORE
condition|)
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|rptr
operator|->
name|howto
operator|=
operator|&
name|mips_howto_table
index|[
name|intern
operator|->
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make any adjustments needed to a reloc before writing it out.  None    are needed for MIPS.  */
end_comment

begin_function
specifier|static
name|void
name|mips_adjust_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|rel
parameter_list|,
name|intern
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|arelent
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|intern
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* ECOFF relocs are either against external symbols, or against    sections.  If we are producing relocatable output, and the reloc    is against an external symbol, and nothing has given us any    additional addend, the resulting reloc will also be against the    same symbol.  In such a case, we don't want to change anything    about the way the reloc is handled, since it will all be done at    final link time.  Rather than put special case code into    bfd_perform_relocation, all the reloc types use this howto    function.  It just short circuits the reloc if producing    relocatable output against an external symbol.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_generic_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* Do a REFHI relocation.  This has to be done in combination with a    REFLO reloc, because there is a carry from the REFLO to the REFHI.    Here we just save the information we need; we do the actual    relocation when we see the REFLO.  MIPS ECOFF requires that the    REFLO immediately follow the REFHI.  As a GNU extension, we permit    an arbitrary number of HI relocs to be associated with a single LO    reloc.  This extension permits gcc to output the HI and LO relocs    itself.  */
end_comment

begin_struct
struct|struct
name|mips_hi
block|{
name|struct
name|mips_hi
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: This should not be a static variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_hi
modifier|*
name|mips_refhi_list
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_refhi_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|mips_hi
modifier|*
name|n
decl_stmt|;
comment|/* If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
name|ret
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Save the information, and let REFLO do the actual relocation.  */
name|n
operator|=
operator|(
expr|struct
name|mips_hi
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|->
name|addr
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|n
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|mips_refhi_list
expr_stmt|;
name|mips_refhi_list
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do a REFLO relocation.  This is a straightforward 16 bit inplace    relocation; this function exists in order to do the REFHI    relocation described above.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_reflo_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|mips_refhi_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mips_hi
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|mips_refhi_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|vallo
decl_stmt|;
name|struct
name|mips_hi
modifier|*
name|next
decl_stmt|;
comment|/* Do the REFHI relocation.  Note that we actually don't 	     need to know anything about the REFLO itself, except 	     where to find the low 16 bits of the addend needed by the 	     REFHI.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|vallo
operator|=
operator|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|vallo
expr_stmt|;
name|val
operator|+=
name|l
operator|->
name|addend
expr_stmt|;
comment|/* The low order 16 bits are always treated as a signed 	     value.  Therefore, a negative value in the low order bits 	     requires an adjustment in the high order bits.  We need 	     to make this adjustment in two ways: once for the bits we 	     took from the data, and once for the bits we are putting 	     back in to the data.  */
if|if
condition|(
operator|(
name|vallo
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
literal|0x10000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
name|mips_refhi_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now do the REFLO reloc in the usual way.  */
return|return
name|mips_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do a GPREL relocation.  This is a 16 bit value which must become    the offset from the gp register.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_gprel_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_boolean
name|relocatable
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ECOFF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|relocatable
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|relocatable
operator|=
name|FALSE
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|relocatable
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* We have to figure out the gp value, so that we can adjust the      symbol value correctly.  We look up the symbol _gp in the output      BFD.  If we can't find it, we're stuck.  We cache it in the ECOFF      target data.  We don't need to adjust the symbol value for an      external symbol if we are producing relocatable output.  */
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
operator|&&
operator|(
operator|!
name|relocatable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|relocatable
condition|)
block|{
comment|/* Make up a value.  */
name|gp
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|0x4000
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|sym
operator|=
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
name|i
operator|=
name|count
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gp
operator|=
name|bfd_asymbol_value
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|count
condition|)
block|{
comment|/* Only get the error once.  */
name|gp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"GP relative relocation when _gp not defined"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Set val to the offset into the section or symbol.  */
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|+
name|reloc_entry
operator|->
name|addend
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x8000
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocatable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocatable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|0xffff
operator|)
operator||
operator|(
name|val
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
comment|/* Make sure it fit in 16 bits.  */
if|if
condition|(
operator|(
name|long
operator|)
name|val
operator|>=
literal|0x8000
operator|||
operator|(
name|long
operator|)
name|val
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Get the howto structure for a generic reloc type.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|mips_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|int
name|mips_type
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_16
case|:
name|mips_type
operator|=
name|MIPS_R_REFHALF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
name|mips_type
operator|=
name|MIPS_R_REFWORD
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_JMP
case|:
name|mips_type
operator|=
name|MIPS_R_JMPADDR
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|mips_type
operator|=
name|MIPS_R_REFHI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|mips_type
operator|=
name|MIPS_R_REFLO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_GPREL16
case|:
name|mips_type
operator|=
name|MIPS_R_GPREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_LITERAL
case|:
name|mips_type
operator|=
name|MIPS_R_LITERAL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
name|mips_type
operator|=
name|MIPS_R_PCREL16
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|&
name|mips_howto_table
index|[
name|mips_type
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|mips_bfd_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mips_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mips_howto_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mips_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|mips_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|mips_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A helper routine for mips_relocate_section which handles the REFHI    relocations.  The REFHI relocation must be followed by a REFLO    relocation, and the addend used is formed from the addends of both    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|mips_relocate_hi
parameter_list|(
name|refhi
parameter_list|,
name|reflo
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocation
parameter_list|)
name|struct
name|internal_reloc
modifier|*
name|refhi
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|reflo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|vallo
decl_stmt|;
if|if
condition|(
name|refhi
operator|==
name|NULL
condition|)
return|return;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|refhi
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
name|reflo
operator|==
name|NULL
condition|)
name|vallo
operator|=
literal|0
expr_stmt|;
else|else
name|vallo
operator|=
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|reflo
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|vallo
expr_stmt|;
name|val
operator|+=
name|relocation
expr_stmt|;
comment|/* The low order 16 bits are always treated as a signed value.      Therefore, a negative value in the low order bits requires an      adjustment in the high order bits.  We need to make this      adjustment in two ways: once for the bits we took from the data,      and once for the bits we are putting back in to the data.  */
if|if
condition|(
operator|(
name|vallo
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
literal|0x10000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|contents
operator|+
name|refhi
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relocate a section while linking a MIPS ECOFF file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|external_relocs
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|PTR
name|external_relocs
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|symndx_to_section
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|bfd_boolean
name|gp_undefined
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel_end
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_boolean
name|got_lo
decl_stmt|;
name|struct
name|internal_reloc
name|lo_int_rel
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_bfd
operator|->
name|xvec
operator|->
name|byteorder
operator|==
name|output_bfd
operator|->
name|xvec
operator|->
name|byteorder
argument_list|)
expr_stmt|;
comment|/* We keep a table mapping the symndx found in an internal reloc to      the appropriate section.  This is faster than looking up the      section by name each time.  */
name|symndx_to_section
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symndx_to_section
expr_stmt|;
if|if
condition|(
name|symndx_to_section
operator|==
operator|(
name|asection
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|amt
operator|=
name|NUM_RELOC_SECTIONS
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|symndx_to_section
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symndx_to_section
condition|)
return|return
name|FALSE
return|;
name|symndx_to_section
index|[
name|RELOC_SECTION_NONE
index|]
operator|=
name|NULL
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_TEXT
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_RDATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".rdata"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_DATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_SDATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".sdata"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_SBSS
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".sbss"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_BSS
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_INIT
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".init"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_LIT8
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".lit8"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_LIT4
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".lit4"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_XDATA
index|]
operator|=
name|NULL
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_PDATA
index|]
operator|=
name|NULL
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_FINI
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".fini"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_LITA
index|]
operator|=
name|NULL
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_ABS
index|]
operator|=
name|NULL
expr_stmt|;
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symndx_to_section
operator|=
name|symndx_to_section
expr_stmt|;
block|}
name|sym_hashes
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|sym_hashes
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
name|gp_undefined
operator|=
name|TRUE
expr_stmt|;
else|else
name|gp_undefined
operator|=
name|FALSE
expr_stmt|;
name|got_lo
operator|=
name|FALSE
expr_stmt|;
name|ext_rel
operator|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|external_relocs
expr_stmt|;
name|ext_rel_end
operator|=
name|ext_rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ext_rel
operator|<
name|ext_rel_end
condition|;
name|ext_rel
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|int_rel
decl_stmt|;
name|bfd_boolean
name|use_lo
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|got_lo
condition|)
name|mips_ecoff_swap_reloc_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|ext_rel
argument_list|,
operator|&
name|int_rel
argument_list|)
expr_stmt|;
else|else
block|{
name|int_rel
operator|=
name|lo_int_rel
expr_stmt|;
name|got_lo
operator|=
name|FALSE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|int_rel
operator|.
name|r_type
operator|<
sizeof|sizeof
name|mips_howto_table
operator|/
sizeof|sizeof
name|mips_howto_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* The REFHI reloc requires special handling.  It must be followed 	 by a REFLO reloc, and the addend is formed from both relocs.  */
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_REFHI
condition|)
block|{
name|struct
name|external_reloc
modifier|*
name|lo_ext_rel
decl_stmt|;
comment|/* As a GNU extension, permit an arbitrary number of REFHI              relocs before the REFLO reloc.  This permits gcc to emit 	     the HI and LO relocs itself.  */
for|for
control|(
name|lo_ext_rel
operator|=
name|ext_rel
operator|+
literal|1
init|;
name|lo_ext_rel
operator|<
name|ext_rel_end
condition|;
name|lo_ext_rel
operator|++
control|)
block|{
name|mips_ecoff_swap_reloc_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|lo_ext_rel
argument_list|,
operator|&
name|lo_int_rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo_int_rel
operator|.
name|r_type
operator|!=
name|int_rel
operator|.
name|r_type
condition|)
break|break;
block|}
if|if
condition|(
name|lo_ext_rel
operator|<
name|ext_rel_end
operator|&&
name|lo_int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_REFLO
operator|&&
name|int_rel
operator|.
name|r_extern
operator|==
name|lo_int_rel
operator|.
name|r_extern
operator|&&
name|int_rel
operator|.
name|r_symndx
operator|==
name|lo_int_rel
operator|.
name|r_symndx
condition|)
block|{
name|use_lo
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|lo_ext_rel
operator|==
name|ext_rel
operator|+
literal|1
condition|)
name|got_lo
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|howto
operator|=
operator|&
name|mips_howto_table
index|[
name|int_rel
operator|.
name|r_type
index|]
expr_stmt|;
if|if
condition|(
name|int_rel
operator|.
name|r_extern
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|int_rel
operator|.
name|r_symndx
index|]
expr_stmt|;
comment|/* If h is NULL, that means that there is a reloc against an 	     external symbol which we thought was just a debugging 	     symbol.  This should not happen.  */
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|int_rel
operator|.
name|r_symndx
operator|<
literal|0
operator|||
name|int_rel
operator|.
name|r_symndx
operator|>=
name|NUM_RELOC_SECTIONS
condition|)
name|s
operator|=
name|NULL
expr_stmt|;
else|else
name|s
operator|=
name|symndx_to_section
index|[
name|int_rel
operator|.
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* The GPREL reloc uses an addend: the difference in the GP 	 values.  */
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_GPREL
operator|&&
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_LITERAL
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gp_undefined
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"GP relative relocation used when GP not defined"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Only give the error once per link.  */
name|gp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
name|gp_undefined
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|int_rel
operator|.
name|r_extern
condition|)
block|{
comment|/* This is a relocation against a section.  The current 		 addend in the instruction is the difference between 		 INPUT_SECTION->vma and the GP value of INPUT_BFD.  We 		 must change this to be the difference between the 		 final definition (which will end up in RELOCATION) 		 and the GP value of OUTPUT_BFD (which is in GP).  */
name|addend
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gp
operator|-
name|gp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This is a relocation against a defined symbol.  The 		 current addend in the instruction is simply the 		 desired offset into the symbol (normally zero).  We 		 are going to change this into a relocation against a 		 defined symbol, so we want the instruction to hold 		 the difference between the final definition of the 		 symbol (which will end up in RELOCATION) and the GP 		 value of OUTPUT_BFD (which is in GP).  */
name|addend
operator|=
operator|-
name|gp
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a relocation against an undefined or common 		 symbol.  The current addend in the instruction is 		 simply the desired offset into the symbol (normally 		 zero).  We are generating relocatable output, and we 		 aren't going to define this symbol, so we just leave 		 the instruction alone.  */
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* We are generating relocatable output, and must convert 	     the existing reloc.  */
if|if
condition|(
name|int_rel
operator|.
name|r_extern
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* This symbol is defined in the output.  Convert 		     the reloc from being against the symbol to being 		     against the section.  */
comment|/* Clear the r_extern bit.  */
name|int_rel
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
comment|/* Compute a new r_symndx value.  */
name|s
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|int_rel
operator|.
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_BSS
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_DATA
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_FINI
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_INIT
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT4
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_RDATA
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SBSS
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_TEXT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int_rel
operator|.
name|r_symndx
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add the section VMA and the symbol value.  */
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* For a PC relative relocation, the object file 		     currently holds just the addend.  We must adjust 		     by the address to get the right value.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|relocation
operator|-=
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Change the symndx value to the right one for the 		     output BFD.  */
name|int_rel
operator|.
name|r_symndx
operator|=
name|h
operator|->
name|indx
expr_stmt|;
if|if
condition|(
name|int_rel
operator|.
name|r_symndx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This symbol is not being written out.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|int_rel
operator|.
name|r_symndx
operator|=
literal|0
expr_stmt|;
block|}
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a relocation against a section.  Adjust the 		 value by the amount the section moved.  */
name|relocation
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|-
name|s
operator|->
name|vma
operator|)
expr_stmt|;
block|}
name|relocation
operator|+=
name|addend
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
comment|/* Adjust a PC relative relocation by removing the reference 	     to the original address in the section and including the 	     reference to the new address.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|-
name|input_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Adjust the contents.  */
if|if
condition|(
name|relocation
operator|==
literal|0
condition|)
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
else|else
block|{
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_REFHI
condition|)
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|relocation
argument_list|,
operator|(
name|contents
operator|+
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|mips_relocate_hi
argument_list|(
operator|&
name|int_rel
argument_list|,
name|use_lo
condition|?
operator|&
name|lo_int_rel
else|:
name|NULL
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
block|}
comment|/* Adjust the reloc address.  */
name|int_rel
operator|.
name|r_vaddr
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|-
name|input_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Save the changed reloc information.  */
name|mips_ecoff_swap_reloc_out
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|int_rel
argument_list|,
operator|(
name|PTR
operator|)
name|ext_rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We are producing a final executable.  */
if|if
condition|(
name|int_rel
operator|.
name|r_extern
condition|)
block|{
comment|/* This is a reloc against a symbol.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|hsec
decl_stmt|;
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hsec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a reloc against a section.  */
name|relocation
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|-
name|s
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* A PC relative reloc is already correct in the object 		 file.  Make it look like a pcrel_offset relocation by 		 adding in the start address.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|relocation
operator|+=
name|int_rel
operator|.
name|r_vaddr
expr_stmt|;
block|}
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_REFHI
condition|)
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
operator|(
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
else|else
block|{
name|mips_relocate_hi
argument_list|(
operator|&
name|int_rel
argument_list|,
name|use_lo
condition|?
operator|&
name|lo_int_rel
else|:
name|NULL
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
block|}
comment|/* MIPS_R_JMPADDR requires peculiar overflow detection.  The 	 instruction provides a 28 bit address (the two lower bits are 	 implicit zeroes) which is combined with the upper four bits 	 of the instruction address.  */
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
operator|&&
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_JMPADDR
operator|&&
operator|(
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|+
operator|(
name|int_rel
operator|.
name|r_extern
condition|?
literal|0
else|:
name|s
operator|->
name|vma
operator|)
operator|)
operator|&
literal|0xf0000000
operator|)
operator|!=
operator|(
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
operator|(
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
operator|)
operator|&
literal|0xf0000000
operator|)
operator|)
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|int_rel
operator|.
name|r_extern
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
else|else
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the ECOFF backend structure.  The backend field of the    target vector points to this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ecoff_backend_data
name|mips_ecoff_backend_data
init|=
block|{
comment|/* COFF backend structure.  */
block|{
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* aux_in */
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* sym_in */
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* lineno_in */
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/*aux_out*/
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* sym_out */
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* lineno_out */
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* reloc_out */
name|mips_ecoff_swap_filehdr_out
block|,
name|mips_ecoff_swap_aouthdr_out
block|,
name|mips_ecoff_swap_scnhdr_out
block|,
name|FILHSZ
block|,
name|AOUTSZ
block|,
name|SCNHSZ
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FILNMLEN
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|4
block|,
name|FALSE
block|,
literal|2
block|,
name|mips_ecoff_swap_filehdr_in
block|,
name|mips_ecoff_swap_aouthdr_in
block|,
name|mips_ecoff_swap_scnhdr_in
block|,
name|NULL
block|,
name|mips_ecoff_bad_format_hook
block|,
name|_bfd_ecoff_set_arch_mach_hook
block|,
name|_bfd_ecoff_mkobject_hook
block|,
name|_bfd_ecoff_styp_to_sec_flags
block|,
name|_bfd_ecoff_set_alignment_hook
block|,
name|_bfd_ecoff_slurp_symbol_table
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Supported architecture.  */
name|bfd_arch_mips
block|,
comment|/* Initial portion of armap string.  */
literal|"__________"
block|,
comment|/* The page boundary used to align sections in a demand-paged      executable file.  E.g., 0x1000.  */
literal|0x1000
block|,
comment|/* TRUE if the .rdata section is part of the text segment, as on the      Alpha.  FALSE if .rdata is part of the data segment, as on the      MIPS.  */
name|FALSE
block|,
comment|/* Bitsize of constructor entries.  */
literal|32
block|,
comment|/* Reloc to use for constructor entries.  */
operator|&
name|mips_howto_table
index|[
name|MIPS_R_REFWORD
index|]
block|,
block|{
comment|/* Symbol table magic number.  */
name|magicSym
block|,
comment|/* Alignment of debugging information.  E.g., 4.  */
literal|4
block|,
comment|/* Sizes of external symbolic information.  */
sizeof|sizeof
argument_list|(
expr|struct
name|hdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opt_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|rfd_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ext_ext
argument_list|)
block|,
comment|/* Functions to swap in external symbolic data.  */
name|ecoff_swap_hdr_in
block|,
name|ecoff_swap_dnr_in
block|,
name|ecoff_swap_pdr_in
block|,
name|ecoff_swap_sym_in
block|,
name|ecoff_swap_opt_in
block|,
name|ecoff_swap_fdr_in
block|,
name|ecoff_swap_rfd_in
block|,
name|ecoff_swap_ext_in
block|,
name|_bfd_ecoff_swap_tir_in
block|,
name|_bfd_ecoff_swap_rndx_in
block|,
comment|/* Functions to swap out external symbolic data.  */
name|ecoff_swap_hdr_out
block|,
name|ecoff_swap_dnr_out
block|,
name|ecoff_swap_pdr_out
block|,
name|ecoff_swap_sym_out
block|,
name|ecoff_swap_opt_out
block|,
name|ecoff_swap_fdr_out
block|,
name|ecoff_swap_rfd_out
block|,
name|ecoff_swap_ext_out
block|,
name|_bfd_ecoff_swap_tir_out
block|,
name|_bfd_ecoff_swap_rndx_out
block|,
comment|/* Function to read in symbolic data.  */
name|_bfd_ecoff_slurp_symbolic_info
block|}
block|,
comment|/* External reloc size.  */
name|RELSZ
block|,
comment|/* Reloc swapping functions.  */
name|mips_ecoff_swap_reloc_in
block|,
name|mips_ecoff_swap_reloc_out
block|,
comment|/* Backend reloc tweaking.  */
name|mips_adjust_reloc_in
block|,
name|mips_adjust_reloc_out
block|,
comment|/* Relocate section contents while linking.  */
name|mips_relocate_section
block|,
comment|/* Do final adjustments to filehdr and aouthdr.  */
name|NULL
block|,
comment|/* Read an element from an archive at a given file position.  */
name|_bfd_get_elt_at_filepos
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Looking up a reloc type is MIPS specific.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_reloc_type_lookup
value|mips_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_reloc_name_lookup
value|mips_bfd_reloc_name_lookup
end_define

begin_comment
comment|/* Getting relocated section contents is generic.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_comment
comment|/* Handling file windows is generic.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_comment
comment|/* Relaxing sections is MIPS specific.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_comment
comment|/* GC of sections is not done.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_comment
comment|/* Merging of sections is not done.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_merge_sections
value|bfd_generic_merge_sections
end_define

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_is_group_section
value|bfd_generic_is_group_section
end_define

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_discard_group
value|bfd_generic_discard_group
end_define

begin_define
define|#
directive|define
name|_bfd_ecoff_section_already_linked
define|\
value|_bfd_generic_section_already_linked
end_define

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|ecoff_big_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|ecoff_little_vec
init|=
block|{
literal|"ecoff-littlemips"
block|,
comment|/* name */
name|bfd_target_ecoff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_ecoff_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|&
name|ecoff_big_vec
block|,
operator|(
name|PTR
operator|)
operator|&
name|mips_ecoff_backend_data
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|ecoff_big_vec
init|=
block|{
literal|"ecoff-bigmips"
block|,
comment|/* name */
name|bfd_target_ecoff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_ecoff_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|&
name|ecoff_little_vec
block|,
operator|(
name|PTR
operator|)
operator|&
name|mips_ecoff_backend_data
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|ecoff_biglittle_vec
init|=
block|{
literal|"ecoff-biglittlemips"
block|,
comment|/* name */
name|bfd_target_ecoff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_ecoff_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
operator|&
name|mips_ecoff_backend_data
block|}
decl_stmt|;
end_decl_stmt

end_unit

