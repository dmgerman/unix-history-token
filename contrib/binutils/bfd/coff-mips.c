begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for MIPS Extended-Coff files.    Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999    Free Software Foundation, Inc.    Original version by Per Bothner.    Full support added by Ian Lance Taylor, ian@cygnus.com.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/mips.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Prototypes for static functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|mips_ecoff_bad_format_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|filehdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_ecoff_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_ecoff_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_adjust_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_adjust_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|arelent
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_generic_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_refhi_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_reflo_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_gprel_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_relhi_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_rello_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_switch_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_relocate_hi
name|PARAMS
argument_list|(
operator|(
expr|struct
name|internal_reloc
operator|*
name|refhi
operator|,
expr|struct
name|internal_reloc
operator|*
name|reflo
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd_byte
operator|*
name|contents
operator|,
name|size_t
name|adjust
operator|,
name|bfd_vma
name|relocation
operator|,
name|boolean
name|pcrel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_read_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_relax_pcrel16
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|mips_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* ECOFF has COFF sections, but the debugging information is stored in    a completely different format.  ECOFF targets use some of the    swapping routines from coffswap.h, and some of the generic COFF    routines in coffgen.c, but, unlike the real COFF targets, do not    use coffcode.h itself.     Get the generic COFF swapping routines, except for the reloc,    symbol, and lineno ones.  Give them ECOFF names.  */
end_comment

begin_define
define|#
directive|define
name|MIPSECOFF
end_define

begin_define
define|#
directive|define
name|NO_COFF_RELOCS
end_define

begin_define
define|#
directive|define
name|NO_COFF_SYMBOLS
end_define

begin_define
define|#
directive|define
name|NO_COFF_LINENOS
end_define

begin_define
define|#
directive|define
name|coff_swap_filehdr_in
value|mips_ecoff_swap_filehdr_in
end_define

begin_define
define|#
directive|define
name|coff_swap_filehdr_out
value|mips_ecoff_swap_filehdr_out
end_define

begin_define
define|#
directive|define
name|coff_swap_aouthdr_in
value|mips_ecoff_swap_aouthdr_in
end_define

begin_define
define|#
directive|define
name|coff_swap_aouthdr_out
value|mips_ecoff_swap_aouthdr_out
end_define

begin_define
define|#
directive|define
name|coff_swap_scnhdr_in
value|mips_ecoff_swap_scnhdr_in
end_define

begin_define
define|#
directive|define
name|coff_swap_scnhdr_out
value|mips_ecoff_swap_scnhdr_out
end_define

begin_include
include|#
directive|include
file|"coffswap.h"
end_include

begin_comment
comment|/* Get the ECOFF swapping routines.  */
end_comment

begin_define
define|#
directive|define
name|ECOFF_32
end_define

begin_include
include|#
directive|include
file|"ecoffswap.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* How to process the various relocs types.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|mips_howto_table
index|[]
init|=
block|{
comment|/* Reloc type 0 is ignored.  The reloc reading code ensures that      this is a reference to the .abs section, which will cause      bfd_perform_relocation to do nothing.  */
name|HOWTO
argument_list|(
name|MIPS_R_IGNORE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"IGNORE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit reference to a symbol, normally from a data section.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFHALF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips_generic_reloc
argument_list|,
comment|/* special_function */
literal|"REFHALF"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit reference to a symbol, normally from a data section.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFWORD
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips_generic_reloc
argument_list|,
comment|/* special_function */
literal|"REFWORD"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 26 bit absolute jump address.  */
name|HOWTO
argument_list|(
name|MIPS_R_JMPADDR
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper four 				   bits must match the PC.  */
name|mips_generic_reloc
argument_list|,
comment|/* special_function */
literal|"JMPADDR"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3ffffff
argument_list|,
comment|/* src_mask */
literal|0x3ffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high 16 bits of a symbol value.  Handled by the function      mips_refhi_reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFHI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips_refhi_reloc
argument_list|,
comment|/* special_function */
literal|"REFHI"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The low 16 bits of a symbol value.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|mips_reflo_reloc
argument_list|,
comment|/* special_function */
literal|"REFLO"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A reference to an offset from the gp register.  Handled by the      function mips_gprel_reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_GPREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_gprel_reloc
argument_list|,
comment|/* special_function */
literal|"GPREL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A reference to a literal using an offset from the gp register.      Handled by the function mips_gprel_reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_gprel_reloc
argument_list|,
comment|/* special_function */
literal|"LITERAL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|8
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|9
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|10
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|11
argument_list|)
block|,
comment|/* This reloc is a Cygnus extension used when generating position      independent code for embedded systems.  It represents a 16 bit PC      relative reloc rightshifted twice as used in the MIPS branch      instructions.  */
name|HOWTO
argument_list|(
name|MIPS_R_PCREL16
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_generic_reloc
argument_list|,
comment|/* special_function */
literal|"PCREL16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This reloc is a Cygnus extension used when generating position      independent code for embedded systems.  It represents the high 16      bits of a PC relative reloc.  The next reloc must be      MIPS_R_RELLO, and the addend is formed from the addends of the      two instructions, just as in MIPS_R_REFHI and MIPS_R_REFLO.  The      final value is actually PC relative to the location of the      MIPS_R_RELLO reloc, not the MIPS_R_RELHI reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_RELHI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips_relhi_reloc
argument_list|,
comment|/* special_function */
literal|"RELHI"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This reloc is a Cygnus extension used when generating position      independent code for embedded systems.  It represents the low 16      bits of a PC relative reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_RELLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|mips_rello_reloc
argument_list|,
comment|/* special_function */
literal|"RELLO"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|15
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|16
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|17
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|18
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|19
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|20
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|21
argument_list|)
block|,
comment|/* This reloc is a Cygnus extension used when generating position      independent code for embedded systems.  It represents an entry in      a switch table, which is the difference between two symbols in      the .text section.  The symndx is actually the offset from the      reloc address to the subtrahend.  See include/coff/mips.h for      more details.  */
name|HOWTO
argument_list|(
argument|MIPS_R_SWITCH
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
argument|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
argument|mips_switch_reloc
argument_list|,
comment|/* special_function */
literal|"SWITCH"
argument_list|,
comment|/* name */
argument|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
argument|true
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIPS_HOWTO_COUNT
define|\
value|(sizeof mips_howto_table / sizeof mips_howto_table[0])
end_define

begin_comment
comment|/* When the linker is doing relaxing, it may change a external PCREL16    reloc.  This typically represents an instruction like        bal foo    We change it to        .set  noreorder        bal   $L1        lui   $at,%hi(foo - $L1)      $L1:        addiu $at,%lo(foo - $L1)        addu  $at,$at,$31        jalr  $at    PCREL16_EXPANSION_ADJUSTMENT is the number of bytes this changes the    instruction by.  */
end_comment

begin_define
define|#
directive|define
name|PCREL16_EXPANSION_ADJUSTMENT
value|(4 * 4)
end_define

begin_escape
end_escape

begin_comment
comment|/* See whether the magic number matches.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_ecoff_bad_format_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_magic
condition|)
block|{
case|case
name|MIPS_MAGIC_1
case|:
comment|/* I don't know what endianness this implies.  */
return|return
name|true
return|;
case|case
name|MIPS_MAGIC_BIG
case|:
case|case
name|MIPS_MAGIC_BIG2
case|:
case|case
name|MIPS_MAGIC_BIG3
case|:
return|return
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
return|;
case|case
name|MIPS_MAGIC_LITTLE
case|:
case|case
name|MIPS_MAGIC_LITTLE2
case|:
case|case
name|MIPS_MAGIC_LITTLE3
case|:
return|return
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reloc handling.  MIPS ECOFF relocs are packed into 8 bytes in    external form.  They use a bit which indicates whether the symbol    is external.  */
end_comment

begin_comment
comment|/* Swap a reloc in.  */
end_comment

begin_function
specifier|static
name|void
name|mips_ecoff_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|ext_ptr
parameter_list|,
name|intern
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext_ptr
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
block|{
specifier|const
name|RELOC
modifier|*
name|ext
init|=
operator|(
name|RELOC
operator|*
operator|)
name|ext_ptr
decl_stmt|;
name|intern
operator|->
name|r_vaddr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|intern
operator|->
name|r_symndx
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|<<
name|RELOC_BITS0_SYMNDX_SH_LEFT_BIG
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|<<
name|RELOC_BITS1_SYMNDX_SH_LEFT_BIG
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|<<
name|RELOC_BITS2_SYMNDX_SH_LEFT_BIG
operator|)
operator|)
expr_stmt|;
name|intern
operator|->
name|r_type
operator|=
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_TYPE_BIG
operator|)
operator|>>
name|RELOC_BITS3_TYPE_SH_BIG
operator|)
expr_stmt|;
name|intern
operator|->
name|r_extern
operator|=
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_EXTERN_BIG
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|intern
operator|->
name|r_symndx
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|<<
name|RELOC_BITS0_SYMNDX_SH_LEFT_LITTLE
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|<<
name|RELOC_BITS1_SYMNDX_SH_LEFT_LITTLE
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|<<
name|RELOC_BITS2_SYMNDX_SH_LEFT_LITTLE
operator|)
operator|)
expr_stmt|;
name|intern
operator|->
name|r_type
operator|=
operator|(
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_BITS3_TYPE_SH_LITTLE
operator|)
operator||
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_TYPEHI_LITTLE
operator|)
operator|<<
name|RELOC_BITS3_TYPEHI_SH_LITTLE
operator|)
operator|)
expr_stmt|;
name|intern
operator|->
name|r_extern
operator|=
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_EXTERN_LITTLE
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
comment|/* If this is a MIPS_R_SWITCH reloc, or an internal MIPS_R_RELHI or      MIPS_R_RELLO reloc, r_symndx is actually the offset from the      reloc address to the base of the difference (see      include/coff/mips.h for more details).  We copy symndx into the      r_offset field so as not to confuse ecoff_slurp_reloc_table in      ecoff.c.  In adjust_reloc_in we then copy r_offset into the reloc      addend.  */
if|if
condition|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_SWITCH
operator|||
operator|(
operator|!
name|intern
operator|->
name|r_extern
operator|&&
operator|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_RELLO
operator|||
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_RELHI
operator|)
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|intern
operator|->
name|r_extern
argument_list|)
expr_stmt|;
name|intern
operator|->
name|r_offset
operator|=
name|intern
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|intern
operator|->
name|r_offset
operator|&
literal|0x800000
condition|)
name|intern
operator|->
name|r_offset
operator|-=
literal|0x1000000
expr_stmt|;
name|intern
operator|->
name|r_symndx
operator|=
name|RELOC_SECTION_TEXT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Swap a reloc out.  */
end_comment

begin_function
specifier|static
name|void
name|mips_ecoff_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|intern
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
name|PTR
name|dst
decl_stmt|;
block|{
name|RELOC
modifier|*
name|ext
init|=
operator|(
name|RELOC
operator|*
operator|)
name|dst
decl_stmt|;
name|long
name|r_symndx
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|intern
operator|->
name|r_extern
operator|||
operator|(
name|intern
operator|->
name|r_symndx
operator|>=
literal|0
operator|&&
name|intern
operator|->
name|r_symndx
operator|<=
literal|12
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a MIPS_R_SWITCH reloc, or an internal MIPS_R_RELLO or      MIPS_R_RELHI reloc, we actually want to write the contents of      r_offset out as the symbol index.  This undoes the change made by      mips_ecoff_swap_reloc_in.  */
if|if
condition|(
name|intern
operator|->
name|r_type
operator|!=
name|MIPS_R_SWITCH
operator|&&
operator|(
name|intern
operator|->
name|r_extern
operator|||
operator|(
name|intern
operator|->
name|r_type
operator|!=
name|MIPS_R_RELHI
operator|&&
name|intern
operator|->
name|r_type
operator|!=
name|MIPS_R_RELLO
operator|)
operator|)
condition|)
name|r_symndx
operator|=
name|intern
operator|->
name|r_symndx
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|intern
operator|->
name|r_symndx
operator|==
name|RELOC_SECTION_TEXT
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|intern
operator|->
name|r_offset
operator|&
literal|0xffffff
expr_stmt|;
block|}
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|intern
operator|->
name|r_vaddr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS0_SYMNDX_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS1_SYMNDX_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS2_SYMNDX_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|r_type
operator|<<
name|RELOC_BITS3_TYPE_SH_BIG
operator|)
operator|&
name|RELOC_BITS3_TYPE_BIG
operator|)
operator||
operator|(
name|intern
operator|->
name|r_extern
condition|?
name|RELOC_BITS3_EXTERN_BIG
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS0_SYMNDX_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS1_SYMNDX_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|=
name|r_symndx
operator|>>
name|RELOC_BITS2_SYMNDX_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|r_type
operator|<<
name|RELOC_BITS3_TYPE_SH_LITTLE
operator|)
operator|&
name|RELOC_BITS3_TYPE_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|r_type
operator|>>
name|RELOC_BITS3_TYPEHI_SH_LITTLE
operator|&
name|RELOC_BITS3_TYPEHI_LITTLE
operator|)
operator|)
operator||
operator|(
name|intern
operator|->
name|r_extern
condition|?
name|RELOC_BITS3_EXTERN_LITTLE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish canonicalizing a reloc.  Part of this is generic to all    ECOFF targets, and that part is in ecoff.c.  The rest is done in    this backend routine.  It must fill in the howto field.  */
end_comment

begin_function
specifier|static
name|void
name|mips_adjust_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|intern
parameter_list|,
name|rptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
name|arelent
modifier|*
name|rptr
decl_stmt|;
block|{
if|if
condition|(
name|intern
operator|->
name|r_type
operator|>
name|MIPS_R_SWITCH
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|intern
operator|->
name|r_extern
operator|&&
operator|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_GPREL
operator|||
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_LITERAL
operator|)
condition|)
name|rptr
operator|->
name|addend
operator|+=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
expr_stmt|;
comment|/* If the type is MIPS_R_IGNORE, make sure this is a reference to      the absolute section so that the reloc is ignored.  */
if|if
condition|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_IGNORE
condition|)
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
comment|/* If this is a MIPS_R_SWITCH reloc, or an internal MIPS_R_RELHI or      MIPS_R_RELLO reloc, we want the addend field of the BFD relocto      hold the value which was originally in the symndx field of the      internal MIPS ECOFF reloc.  This value was copied into      intern->r_offset by mips_swap_reloc_in, and here we copy it into      the addend field.  */
if|if
condition|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_SWITCH
operator|||
operator|(
operator|!
name|intern
operator|->
name|r_extern
operator|&&
operator|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_RELHI
operator|||
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_RELLO
operator|)
operator|)
condition|)
name|rptr
operator|->
name|addend
operator|=
name|intern
operator|->
name|r_offset
expr_stmt|;
name|rptr
operator|->
name|howto
operator|=
operator|&
name|mips_howto_table
index|[
name|intern
operator|->
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make any adjustments needed to a reloc before writing it out.  None    are needed for MIPS.  */
end_comment

begin_function
specifier|static
name|void
name|mips_adjust_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|rel
parameter_list|,
name|intern
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|arelent
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
block|{
comment|/* For a MIPS_R_SWITCH reloc, or an internal MIPS_R_RELHI or      MIPS_R_RELLO reloc, we must copy rel->addend into      intern->r_offset.  This will then be written out as the symbol      index by mips_ecoff_swap_reloc_out.  This operation parallels the      action of mips_adjust_reloc_in.  */
if|if
condition|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_SWITCH
operator|||
operator|(
operator|!
name|intern
operator|->
name|r_extern
operator|&&
operator|(
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_RELHI
operator|||
name|intern
operator|->
name|r_type
operator|==
name|MIPS_R_RELLO
operator|)
operator|)
condition|)
name|intern
operator|->
name|r_offset
operator|=
name|rel
operator|->
name|addend
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ECOFF relocs are either against external symbols, or against    sections.  If we are producing relocateable output, and the reloc    is against an external symbol, and nothing has given us any    additional addend, the resulting reloc will also be against the    same symbol.  In such a case, we don't want to change anything    about the way the reloc is handled, since it will all be done at    final link time.  Rather than put special case code into    bfd_perform_relocation, all the reloc types use this howto    function.  It just short circuits the reloc if producing    relocateable output against an external symbol.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_generic_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* Do a REFHI relocation.  This has to be done in combination with a    REFLO reloc, because there is a carry from the REFLO to the REFHI.    Here we just save the information we need; we do the actual    relocation when we see the REFLO.  MIPS ECOFF requires that the    REFLO immediately follow the REFHI.  As a GNU extension, we permit    an arbitrary number of HI relocs to be associated with a single LO    reloc.  This extension permits gcc to output the HI and LO relocs    itself.  */
end_comment

begin_struct
struct|struct
name|mips_hi
block|{
name|struct
name|mips_hi
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: This should not be a static variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_hi
modifier|*
name|mips_refhi_list
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_refhi_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|mips_hi
modifier|*
name|n
decl_stmt|;
comment|/* If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
name|ret
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Save the information, and let REFLO do the actual relocation.  */
name|n
operator|=
operator|(
expr|struct
name|mips_hi
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|->
name|addr
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|n
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|mips_refhi_list
expr_stmt|;
name|mips_refhi_list
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do a REFLO relocation.  This is a straightforward 16 bit inplace    relocation; this function exists in order to do the REFHI    relocation described above.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_reflo_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|mips_refhi_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mips_hi
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|mips_refhi_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|vallo
decl_stmt|;
name|struct
name|mips_hi
modifier|*
name|next
decl_stmt|;
comment|/* Do the REFHI relocation.  Note that we actually don't 	     need to know anything about the REFLO itself, except 	     where to find the low 16 bits of the addend needed by the 	     REFHI.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|vallo
operator|=
operator|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|vallo
expr_stmt|;
name|val
operator|+=
name|l
operator|->
name|addend
expr_stmt|;
comment|/* The low order 16 bits are always treated as a signed 	     value.  Therefore, a negative value in the low order bits 	     requires an adjustment in the high order bits.  We need 	     to make this adjustment in two ways: once for the bits we 	     took from the data, and once for the bits we are putting 	     back in to the data.  */
if|if
condition|(
operator|(
name|vallo
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
literal|0x10000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
name|mips_refhi_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now do the REFLO reloc in the usual way.  */
return|return
name|mips_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do a GPREL relocation.  This is a 16 bit value which must become    the offset from the gp register.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_gprel_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ECOFF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|relocateable
operator|=
name|true
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|relocateable
operator|==
name|false
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* We have to figure out the gp value, so that we can adjust the      symbol value correctly.  We look up the symbol _gp in the output      BFD.  If we can't find it, we're stuck.  We cache it in the ECOFF      target data.  We don't need to adjust the symbol value for an      external symbol if we are producing relocateable output.  */
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
operator|&&
operator|(
name|relocateable
operator|==
name|false
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|relocateable
operator|!=
name|false
condition|)
block|{
comment|/* Make up a value.  */
name|gp
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|0x4000
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|sym
operator|=
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
name|i
operator|=
name|count
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
specifier|register
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gp
operator|=
name|bfd_asymbol_value
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|count
condition|)
block|{
comment|/* Only get the error once.  */
name|gp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"GP relative relocation when _gp not defined"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Set val to the offset into the section or symbol.  */
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|+
name|reloc_entry
operator|->
name|addend
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x8000
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocateable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
name|relocateable
operator|==
name|false
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
name|val
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocateable
operator|!=
name|false
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
comment|/* Make sure it fit in 16 bits.  */
if|if
condition|(
name|val
operator|>=
literal|0x8000
operator|&&
name|val
operator|<
literal|0xffff8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Do a RELHI relocation.  We do this in conjunction with a RELLO    reloc, just as REFHI and REFLO are done together.  RELHI and RELLO    are Cygnus extensions used when generating position independent    code for embedded systems.  */
end_comment

begin_comment
comment|/* FIXME: This should not be a static variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_hi
modifier|*
name|mips_relhi_list
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_relhi_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|mips_hi
modifier|*
name|n
decl_stmt|;
comment|/* If this is a reloc against a section symbol, then it is correct      in the object file.  The only time we want to change this case is      when we are relaxing, and that is handled entirely by      mips_relocate_section and never calls this function.  */
if|if
condition|(
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* This is an external symbol.  If we're relocating, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
name|ret
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Save the information, and let RELLO do the actual relocation.  */
name|n
operator|=
operator|(
expr|struct
name|mips_hi
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|->
name|addr
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|n
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|mips_relhi_list
expr_stmt|;
name|mips_relhi_list
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do a RELLO relocation.  This is a straightforward 16 bit PC    relative relocation; this function exists in order to do the RELHI    relocation described above.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_rello_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|mips_relhi_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mips_hi
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|mips_relhi_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|vallo
decl_stmt|;
name|struct
name|mips_hi
modifier|*
name|next
decl_stmt|;
comment|/* Do the RELHI relocation.  Note that we actually don't 	     need to know anything about the RELLO itself, except 	     where to find the low 16 bits of the addend needed by the 	     RELHI.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|vallo
operator|=
operator|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|vallo
expr_stmt|;
name|val
operator|+=
name|l
operator|->
name|addend
expr_stmt|;
comment|/* If the symbol is defined, make val PC relative.  If the 	     symbol is not defined we don't want to do this, because 	     we don't want the value in the object file to incorporate 	     the address of the reloc.  */
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
name|val
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|reloc_entry
operator|->
name|address
operator|)
expr_stmt|;
comment|/* The low order 16 bits are always treated as a signed 	     value.  Therefore, a negative value in the low order bits 	     requires an adjustment in the high order bits.  We need 	     to make this adjustment in two ways: once for the bits we 	     took from the data, and once for the bits we are putting 	     back in to the data.  */
if|if
condition|(
operator|(
name|vallo
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
literal|0x10000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
name|mips_relhi_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If this is a reloc against a section symbol, then it is correct      in the object file.  The only time we want to change this case is      when we are relaxing, and that is handled entirely by      mips_relocate_section and never calls this function.  */
if|if
condition|(
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* bfd_perform_relocation does not handle pcrel_offset relocations      correctly when generating a relocateable file, so handle them      directly here.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Now do the RELLO reloc in the usual way.  */
return|return
name|mips_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is the special function for the MIPS_R_SWITCH reloc.  This    special reloc is normally correct in the object file, and only    requires special handling when relaxing.  We don't want    bfd_perform_relocation to tamper with it at all.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_switch_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Get the howto structure for a generic reloc type.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|mips_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|int
name|mips_type
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_16
case|:
name|mips_type
operator|=
name|MIPS_R_REFHALF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
name|mips_type
operator|=
name|MIPS_R_REFWORD
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_JMP
case|:
name|mips_type
operator|=
name|MIPS_R_JMPADDR
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|mips_type
operator|=
name|MIPS_R_REFHI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|mips_type
operator|=
name|MIPS_R_REFLO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_GPREL
case|:
name|mips_type
operator|=
name|MIPS_R_GPREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_LITERAL
case|:
name|mips_type
operator|=
name|MIPS_R_LITERAL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
name|mips_type
operator|=
name|MIPS_R_PCREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PCREL_HI16_S
case|:
name|mips_type
operator|=
name|MIPS_R_RELHI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PCREL_LO16
case|:
name|mips_type
operator|=
name|MIPS_R_RELLO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_GPREL32
case|:
name|mips_type
operator|=
name|MIPS_R_SWITCH
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|&
name|mips_howto_table
index|[
name|mips_type
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A helper routine for mips_relocate_section which handles the REFHI    and RELHI relocations.  The REFHI relocation must be followed by a    REFLO relocation (and RELHI by a RELLO), and the addend used is    formed from the addends of both instructions.  */
end_comment

begin_function
specifier|static
name|void
name|mips_relocate_hi
parameter_list|(
name|refhi
parameter_list|,
name|reflo
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|adjust
parameter_list|,
name|relocation
parameter_list|,
name|pcrel
parameter_list|)
name|struct
name|internal_reloc
modifier|*
name|refhi
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|reflo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|size_t
name|adjust
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|boolean
name|pcrel
decl_stmt|;
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|vallo
decl_stmt|;
if|if
condition|(
name|refhi
operator|==
name|NULL
condition|)
return|return;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|adjust
operator|+
name|refhi
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
name|reflo
operator|==
name|NULL
condition|)
name|vallo
operator|=
literal|0
expr_stmt|;
else|else
name|vallo
operator|=
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|adjust
operator|+
name|reflo
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|vallo
expr_stmt|;
name|val
operator|+=
name|relocation
expr_stmt|;
comment|/* The low order 16 bits are always treated as a signed value.      Therefore, a negative value in the low order bits requires an      adjustment in the high order bits.  We need to make this      adjustment in two ways: once for the bits we took from the data,      and once for the bits we are putting back in to the data.  */
if|if
condition|(
operator|(
name|vallo
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
if|if
condition|(
name|pcrel
condition|)
name|val
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
operator|(
name|reflo
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|+
name|adjust
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
literal|0x10000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|contents
operator|+
name|adjust
operator|+
name|refhi
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relocate a section while linking a MIPS ECOFF file.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|external_relocs
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|PTR
name|external_relocs
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|symndx_to_section
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|boolean
name|gp_undefined
decl_stmt|;
name|size_t
name|adjust
decl_stmt|;
name|long
modifier|*
name|offsets
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel_end
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|boolean
name|got_lo
decl_stmt|;
name|struct
name|internal_reloc
name|lo_int_rel
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_bfd
operator|->
name|xvec
operator|->
name|byteorder
operator|==
name|output_bfd
operator|->
name|xvec
operator|->
name|byteorder
argument_list|)
expr_stmt|;
comment|/* We keep a table mapping the symndx found in an internal reloc to      the appropriate section.  This is faster than looking up the      section by name each time.  */
name|symndx_to_section
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symndx_to_section
expr_stmt|;
if|if
condition|(
name|symndx_to_section
operator|==
operator|(
name|asection
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|symndx_to_section
operator|=
operator|(
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|NUM_RELOC_SECTIONS
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|symndx_to_section
condition|)
return|return
name|false
return|;
name|symndx_to_section
index|[
name|RELOC_SECTION_NONE
index|]
operator|=
name|NULL
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_TEXT
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_RDATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".rdata"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_DATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_SDATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".sdata"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_SBSS
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".sbss"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_BSS
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_INIT
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".init"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_LIT8
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".lit8"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_LIT4
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".lit4"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_XDATA
index|]
operator|=
name|NULL
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_PDATA
index|]
operator|=
name|NULL
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_FINI
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".fini"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_LITA
index|]
operator|=
name|NULL
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_ABS
index|]
operator|=
name|NULL
expr_stmt|;
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symndx_to_section
operator|=
name|symndx_to_section
expr_stmt|;
block|}
name|sym_hashes
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|sym_hashes
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
name|gp_undefined
operator|=
name|true
expr_stmt|;
else|else
name|gp_undefined
operator|=
name|false
expr_stmt|;
name|got_lo
operator|=
name|false
expr_stmt|;
name|adjust
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ecoff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
operator|==
name|NULL
condition|)
name|offsets
operator|=
name|NULL
expr_stmt|;
else|else
name|offsets
operator|=
name|ecoff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
operator|->
name|offsets
expr_stmt|;
name|ext_rel
operator|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|external_relocs
expr_stmt|;
name|ext_rel_end
operator|=
name|ext_rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ext_rel
operator|<
name|ext_rel_end
condition|;
name|ext_rel
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|int_rel
decl_stmt|;
name|boolean
name|use_lo
init|=
name|false
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|got_lo
condition|)
name|mips_ecoff_swap_reloc_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|ext_rel
argument_list|,
operator|&
name|int_rel
argument_list|)
expr_stmt|;
else|else
block|{
name|int_rel
operator|=
name|lo_int_rel
expr_stmt|;
name|got_lo
operator|=
name|false
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|int_rel
operator|.
name|r_type
operator|<
sizeof|sizeof
name|mips_howto_table
operator|/
sizeof|sizeof
name|mips_howto_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* The REFHI and RELHI relocs requires special handling.  they 	 must be followed by a REFLO or RELLO reloc, respectively, and 	 the addend is formed from both relocs.  */
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_REFHI
operator|||
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_RELHI
condition|)
block|{
name|struct
name|external_reloc
modifier|*
name|lo_ext_rel
decl_stmt|;
comment|/* As a GNU extension, permit an arbitrary number of REFHI              or RELHI relocs before the REFLO or RELLO reloc.  This              permits gcc to emit the HI and LO relocs itself.  */
for|for
control|(
name|lo_ext_rel
operator|=
name|ext_rel
operator|+
literal|1
init|;
name|lo_ext_rel
operator|<
name|ext_rel_end
condition|;
name|lo_ext_rel
operator|++
control|)
block|{
name|mips_ecoff_swap_reloc_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|lo_ext_rel
argument_list|,
operator|&
name|lo_int_rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo_int_rel
operator|.
name|r_type
operator|!=
name|int_rel
operator|.
name|r_type
condition|)
break|break;
block|}
if|if
condition|(
name|lo_ext_rel
operator|<
name|ext_rel_end
operator|&&
operator|(
name|lo_int_rel
operator|.
name|r_type
operator|==
operator|(
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_REFHI
condition|?
name|MIPS_R_REFLO
else|:
name|MIPS_R_RELLO
operator|)
operator|)
operator|&&
name|int_rel
operator|.
name|r_extern
operator|==
name|lo_int_rel
operator|.
name|r_extern
operator|&&
name|int_rel
operator|.
name|r_symndx
operator|==
name|lo_int_rel
operator|.
name|r_symndx
condition|)
block|{
name|use_lo
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|lo_ext_rel
operator|==
name|ext_rel
operator|+
literal|1
condition|)
name|got_lo
operator|=
name|true
expr_stmt|;
block|}
block|}
name|howto
operator|=
operator|&
name|mips_howto_table
index|[
name|int_rel
operator|.
name|r_type
index|]
expr_stmt|;
comment|/* The SWITCH reloc must be handled specially.  This reloc is 	 marks the location of a difference between two portions of an 	 object file.  The symbol index does not reference a symbol, 	 but is actually the offset from the reloc to the subtrahend 	 of the difference.  This reloc is correct in the object file, 	 and needs no further adjustment, unless we are relaxing.  If 	 we are relaxing, we may have to add in an offset.  Since no 	 symbols are involved in this reloc, we handle it completely 	 here.  */
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_SWITCH
condition|)
block|{
if|if
condition|(
name|offsets
operator|!=
name|NULL
operator|&&
name|offsets
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|offsets
index|[
name|i
index|]
argument_list|,
operator|(
name|contents
operator|+
name|adjust
operator|+
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|==
name|bfd_reloc_ok
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|int_rel
operator|.
name|r_extern
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|int_rel
operator|.
name|r_symndx
index|]
expr_stmt|;
comment|/* If h is NULL, that means that there is a reloc against an 	     external symbol which we thought was just a debugging 	     symbol.  This should not happen.  */
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|int_rel
operator|.
name|r_symndx
operator|<
literal|0
operator|||
name|int_rel
operator|.
name|r_symndx
operator|>=
name|NUM_RELOC_SECTIONS
condition|)
name|s
operator|=
name|NULL
expr_stmt|;
else|else
name|s
operator|=
name|symndx_to_section
index|[
name|int_rel
operator|.
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* The GPREL reloc uses an addend: the difference in the GP 	 values.  */
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_GPREL
operator|&&
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_LITERAL
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gp_undefined
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"GP relative relocation when GP not defined"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Only give the error once per link.  */
name|gp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
name|gp_undefined
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|int_rel
operator|.
name|r_extern
condition|)
block|{
comment|/* This is a relocation against a section.  The current 		 addend in the instruction is the difference between 		 INPUT_SECTION->vma and the GP value of INPUT_BFD.  We 		 must change this to be the difference between the 		 final definition (which will end up in RELOCATION) 		 and the GP value of OUTPUT_BFD (which is in GP).  */
name|addend
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gp
operator|-
name|gp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This is a relocation against a defined symbol.  The 		 current addend in the instruction is simply the 		 desired offset into the symbol (normally zero).  We 		 are going to change this into a relocation against a 		 defined symbol, so we want the instruction to hold 		 the difference between the final definition of the 		 symbol (which will end up in RELOCATION) and the GP 		 value of OUTPUT_BFD (which is in GP).  */
name|addend
operator|=
operator|-
name|gp
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a relocation against an undefined or common 		 symbol.  The current addend in the instruction is 		 simply the desired offset into the symbol (normally 		 zero).  We are generating relocateable output, and we 		 aren't going to define this symbol, so we just leave 		 the instruction alone.  */
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If we are relaxing, mips_relax_section may have set 	 offsets[i] to some value.  A value of 1 means we must expand 	 a PC relative branch into a multi-instruction of sequence, 	 and any other value is an addend.  */
if|if
condition|(
name|offsets
operator|!=
name|NULL
operator|&&
name|offsets
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|relocateable
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_PCREL16
operator|||
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_RELHI
operator|||
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_RELLO
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsets
index|[
name|i
index|]
operator|!=
literal|1
condition|)
name|addend
operator|+=
name|offsets
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
name|bfd_byte
modifier|*
name|here
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|int_rel
operator|.
name|r_extern
operator|&&
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_PCREL16
argument_list|)
expr_stmt|;
comment|/* Move the rest of the instructions up.  */
name|here
operator|=
operator|(
name|contents
operator|+
name|adjust
operator|+
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
expr_stmt|;
name|memmove
argument_list|(
name|here
operator|+
name|PCREL16_EXPANSION_ADJUSTMENT
argument_list|,
name|here
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|input_section
operator|->
name|_raw_size
operator|-
operator|(
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate the new instructions.  */
if|if
condition|(
operator|!
name|mips_relax_pcrel16
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|h
argument_list|,
name|here
argument_list|,
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
operator|(
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
operator|+
name|adjust
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We must adjust everything else up a notch.  */
name|adjust
operator|+=
name|PCREL16_EXPANSION_ADJUSTMENT
expr_stmt|;
comment|/* mips_relax_pcrel16 handles all the details of this 		 relocation.  */
continue|continue;
block|}
block|}
comment|/* If we are relaxing, and this is a reloc against the .text 	 segment, we may need to adjust it if some branches have been 	 expanded.  The reloc types which are likely to occur in the 	 .text section are handled efficiently by mips_relax_section, 	 and thus do not need to be handled here.  */
if|if
condition|(
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|debug_info
operator|.
name|adjust
operator|!=
name|NULL
operator|&&
operator|!
name|int_rel
operator|.
name|r_extern
operator|&&
name|int_rel
operator|.
name|r_symndx
operator|==
name|RELOC_SECTION_TEXT
operator|&&
operator|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
literal|".text"
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_PCREL16
operator|&&
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_SWITCH
operator|&&
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_RELHI
operator|&&
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_RELLO
operator|)
operator|)
condition|)
block|{
name|bfd_vma
name|adr
decl_stmt|;
name|struct
name|ecoff_value_adjust
modifier|*
name|a
decl_stmt|;
comment|/* We need to get the addend so that we know whether we need 	     to adjust the address.  */
name|BFD_ASSERT
argument_list|(
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_REFWORD
argument_list|)
expr_stmt|;
name|adr
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|contents
operator|+
name|adjust
operator|+
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|debug_info
operator|.
name|adjust
init|;
name|a
operator|!=
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
if|if
condition|(
name|adr
operator|>=
name|a
operator|->
name|start
operator|&&
name|adr
operator|<
name|a
operator|->
name|end
condition|)
name|addend
operator|+=
name|a
operator|->
name|adjust
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* We are generating relocateable output, and must convert 	     the existing reloc.  */
if|if
condition|(
name|int_rel
operator|.
name|r_extern
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* This symbol is defined in the output.  Convert 		     the reloc from being against the symbol to being 		     against the section.  */
comment|/* Clear the r_extern bit.  */
name|int_rel
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
comment|/* Compute a new r_symndx value.  */
name|s
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|int_rel
operator|.
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_BSS
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_DATA
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_FINI
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_INIT
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT4
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_RDATA
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SBSS
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_TEXT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int_rel
operator|.
name|r_symndx
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add the section VMA and the symbol value.  */
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* For a PC relative relocation, the object file 		     currently holds just the addend.  We must adjust 		     by the address to get the right value.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|relocation
operator|-=
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
expr_stmt|;
comment|/* If we are converting a RELHI or RELLO reloc 			 from being against an external symbol to 			 being against a section, we must put a 			 special value into the r_offset field.  This 			 value is the old addend.  The r_offset for 			 both the RELHI and RELLO relocs are the same, 			 and we set both when we see RELHI.  */
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_RELHI
condition|)
block|{
name|long
name|addhi
decl_stmt|,
name|addlo
decl_stmt|;
name|addhi
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|contents
operator|+
name|adjust
operator|+
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
name|addhi
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|addhi
operator|&
literal|0x8000
condition|)
name|addhi
operator|-=
literal|0x10000
expr_stmt|;
name|addhi
operator|<<=
literal|16
expr_stmt|;
if|if
condition|(
operator|!
name|use_lo
condition|)
name|addlo
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|addlo
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|contents
operator|+
name|adjust
operator|+
name|lo_int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
name|addlo
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|addlo
operator|&
literal|0x8000
condition|)
name|addlo
operator|-=
literal|0x10000
expr_stmt|;
name|lo_int_rel
operator|.
name|r_offset
operator|=
name|addhi
operator|+
name|addlo
expr_stmt|;
block|}
name|int_rel
operator|.
name|r_offset
operator|=
name|addhi
operator|+
name|addlo
expr_stmt|;
block|}
block|}
name|h
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Change the symndx value to the right one for the 		     output BFD.  */
name|int_rel
operator|.
name|r_symndx
operator|=
name|h
operator|->
name|indx
expr_stmt|;
if|if
condition|(
name|int_rel
operator|.
name|r_symndx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This symbol is not being written out.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|int_rel
operator|.
name|r_symndx
operator|=
literal|0
expr_stmt|;
block|}
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a relocation against a section.  Adjust the 		 value by the amount the section moved.  */
name|relocation
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|-
name|s
operator|->
name|vma
operator|)
expr_stmt|;
block|}
name|relocation
operator|+=
name|addend
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
comment|/* Adjust a PC relative relocation by removing the reference 	     to the original address in the section and including the 	     reference to the new address.  However, external RELHI 	     and RELLO relocs are PC relative, but don't include any 	     reference to the address.  The addend is merely an 	     addend.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
operator|&&
operator|(
operator|!
name|int_rel
operator|.
name|r_extern
operator|||
operator|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_RELHI
operator|&&
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_RELLO
operator|)
operator|)
condition|)
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|-
name|input_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Adjust the contents.  */
if|if
condition|(
name|relocation
operator|==
literal|0
condition|)
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
else|else
block|{
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_REFHI
operator|&&
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_RELHI
condition|)
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|relocation
argument_list|,
operator|(
name|contents
operator|+
name|adjust
operator|+
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|mips_relocate_hi
argument_list|(
operator|&
name|int_rel
argument_list|,
name|use_lo
condition|?
operator|&
name|lo_int_rel
else|:
name|NULL
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|adjust
argument_list|,
name|relocation
argument_list|,
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_RELHI
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
block|}
comment|/* Adjust the reloc address.  */
name|int_rel
operator|.
name|r_vaddr
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|-
name|input_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Save the changed reloc information.  */
name|mips_ecoff_swap_reloc_out
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|int_rel
argument_list|,
operator|(
name|PTR
operator|)
name|ext_rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We are producing a final executable.  */
if|if
condition|(
name|int_rel
operator|.
name|r_extern
condition|)
block|{
comment|/* This is a reloc against a symbol.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|hsec
decl_stmt|;
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hsec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|true
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a reloc against a section.  */
name|relocation
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|-
name|s
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* A PC relative reloc is already correct in the object 		 file.  Make it look like a pcrel_offset relocation by 		 adding in the start address.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_RELHI
operator|||
operator|!
name|use_lo
condition|)
name|relocation
operator|+=
name|int_rel
operator|.
name|r_vaddr
operator|+
name|adjust
expr_stmt|;
else|else
name|relocation
operator|+=
name|lo_int_rel
operator|.
name|r_vaddr
operator|+
name|adjust
expr_stmt|;
block|}
block|}
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_REFHI
operator|&&
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_RELHI
condition|)
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
operator|(
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|+
name|adjust
operator|)
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
else|else
block|{
name|mips_relocate_hi
argument_list|(
operator|&
name|int_rel
argument_list|,
name|use_lo
condition|?
operator|&
name|lo_int_rel
else|:
name|NULL
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|adjust
argument_list|,
name|relocation
argument_list|,
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_RELHI
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
block|}
comment|/* MIPS_R_JMPADDR requires peculiar overflow detection.  The 	 instruction provides a 28 bit address (the two lower bits are 	 implicit zeroes) which is combined with the upper four bits 	 of the instruction address.  */
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
operator|&&
name|int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_JMPADDR
operator|&&
operator|(
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|+
operator|(
name|int_rel
operator|.
name|r_extern
condition|?
literal|0
else|:
name|s
operator|->
name|vma
operator|)
operator|)
operator|&
literal|0xf0000000
operator|)
operator|!=
operator|(
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
operator|(
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
operator|+
name|adjust
operator|)
operator|&
literal|0xf0000000
operator|)
operator|)
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|int_rel
operator|.
name|r_extern
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|int_rel
operator|.
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in the relocs for a section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_read_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|ecoff_section_tdata
modifier|*
name|section_tdata
decl_stmt|;
name|section_tdata
operator|=
name|ecoff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_tdata
operator|==
operator|(
expr|struct
name|ecoff_section_tdata
operator|*
operator|)
name|NULL
condition|)
block|{
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_section_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|section_tdata
operator|=
name|ecoff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|section_tdata
operator|->
name|external_relocs
operator|=
name|NULL
expr_stmt|;
name|section_tdata
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
name|section_tdata
operator|->
name|offsets
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|section_tdata
operator|->
name|external_relocs
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|external_relocs_size
decl_stmt|;
name|external_relocs_size
operator|=
operator|(
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_reloc_size
operator|*
name|sec
operator|->
name|reloc_count
operator|)
expr_stmt|;
name|section_tdata
operator|->
name|external_relocs
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|external_relocs_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_tdata
operator|->
name|external_relocs
operator|==
name|NULL
operator|&&
name|external_relocs_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|section_tdata
operator|->
name|external_relocs
argument_list|,
literal|1
argument_list|,
name|external_relocs_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|external_relocs_size
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Relax a section when linking a MIPS ECOFF file.  This is used for    embedded PIC code, which always uses PC relative branches which    only have an 18 bit range on MIPS.  If a branch is not in range, we    generate a long instruction sequence to compensate.  Each time we    find a branch to expand, we have to check all the others again to    make sure they are still in range.  This is slow, but it only has    to be done when -relax is passed to the linker.     This routine figures out which branches need to expand; the actual    expansion is done in mips_relocate_section when the section    contents are relocated.  The information is stored in the offsets    field of the ecoff_section_tdata structure.  An offset of 1 means    that the branch must be expanded into a multi-instruction PC    relative branch (such an offset will only occur for a PC relative    branch to an external symbol).  Any other offset must be a multiple    of four, and is the amount to change the branch by (such an offset    will only occur for a PC relative branch within the same section).     We do not modify the section relocs or contents themselves so that    if memory usage becomes an issue we can discard them and read them    again.  The only information we must save in memory between this    routine and the mips_relocate_section routine is the table of    offsets.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
name|struct
name|ecoff_section_tdata
modifier|*
name|section_tdata
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|long
modifier|*
name|offsets
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel_end
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Assume we are not going to need another pass.  */
operator|*
name|again
operator|=
name|false
expr_stmt|;
comment|/* If we are not generating an ECOFF file, this is much too      confusing to deal with.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|!=
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If there are no relocs, there is nothing to do.  */
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* We are only interested in PC relative relocs, and why would there      ever be one from anything but the .text section?  */
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".text"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
comment|/* Read in the relocs, if we haven't already got them.  */
name|section_tdata
operator|=
name|ecoff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_tdata
operator|==
operator|(
expr|struct
name|ecoff_section_tdata
operator|*
operator|)
name|NULL
operator|||
name|section_tdata
operator|->
name|external_relocs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|mips_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|section_tdata
operator|=
name|ecoff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
block|{
comment|/* We must initialize _cooked_size only the first time we are 	 called.  */
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
block|}
name|contents
operator|=
name|section_tdata
operator|->
name|contents
expr_stmt|;
name|offsets
operator|=
name|section_tdata
operator|->
name|offsets
expr_stmt|;
comment|/* Look for any external PC relative relocs.  Internal PC relative      relocs are already correct in the object file, so they certainly      can not overflow.  */
name|ext_rel
operator|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|section_tdata
operator|->
name|external_relocs
expr_stmt|;
name|ext_rel_end
operator|=
name|ext_rel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ext_rel
operator|<
name|ext_rel_end
condition|;
name|ext_rel
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|int_rel
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|hsec
decl_stmt|;
name|bfd_signed_vma
name|relocation
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|adj_ext_rel
decl_stmt|;
name|unsigned
name|int
name|adj_i
decl_stmt|;
name|unsigned
name|long
name|ext_count
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
modifier|*
name|adj_h_ptr
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
modifier|*
name|adj_h_ptr_end
decl_stmt|;
name|struct
name|ecoff_value_adjust
modifier|*
name|adjust
decl_stmt|;
comment|/* If we have already expanded this reloc, we certainly don't 	 need to do it again.  */
if|if
condition|(
name|offsets
operator|!=
operator|(
name|long
operator|*
operator|)
name|NULL
operator|&&
name|offsets
index|[
name|i
index|]
operator|==
literal|1
condition|)
continue|continue;
comment|/* Quickly check that this reloc is external PCREL16.  */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ext_rel
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_EXTERN_BIG
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
operator|(
name|ext_rel
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_TYPE_BIG
operator|)
operator|>>
name|RELOC_BITS3_TYPE_SH_BIG
operator|)
operator|!=
name|MIPS_R_PCREL16
operator|)
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ext_rel
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_EXTERN_LITTLE
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
operator|(
name|ext_rel
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_BITS3_TYPE_SH_LITTLE
operator|)
operator|!=
name|MIPS_R_PCREL16
operator|)
condition|)
continue|continue;
block|}
name|mips_ecoff_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|ext_rel
argument_list|,
operator|&
name|int_rel
argument_list|)
expr_stmt|;
name|h
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_hashes
index|[
name|int_rel
operator|.
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* Just ignore undefined symbols.  These will presumably 	     generate an error later in the link.  */
continue|continue;
block|}
comment|/* Get the value of the symbol.  */
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hsec
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Subtract out the current address.  */
name|relocation
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
operator|(
name|int_rel
operator|.
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|)
operator|)
expr_stmt|;
comment|/* The addend is stored in the object file.  In the normal case 	 of ``bal symbol'', the addend will be -4.  It will only be 	 different in the case of ``bal symbol+constant''.  To avoid 	 always reading in the section contents, we don't check the 	 addend in the object file (we could easily check the contents 	 if we happen to have already read them in, but I fear that 	 this could be confusing).  This means we will screw up if 	 there is a branch to a symbol that is in range, but added to 	 a constant which puts it out of range; in such a case the 	 link will fail with a reloc overflow error.  Since the 	 compiler will never generate such code, it should be easy 	 enough to work around it by changing the assembly code in the 	 source file.  */
name|relocation
operator|-=
literal|4
expr_stmt|;
comment|/* Now RELOCATION is the number we want to put in the object 	 file.  See whether it fits.  */
if|if
condition|(
name|relocation
operator|>=
operator|-
literal|0x20000
operator|&&
name|relocation
operator|<
literal|0x20000
condition|)
continue|continue;
comment|/* Now that we know this reloc needs work, which will rarely 	 happen, go ahead and grab the section contents.  */
if|if
condition|(
name|contents
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|keep_memory
condition|)
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
else|else
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|info
operator|->
name|keep_memory
condition|)
name|section_tdata
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
block|}
comment|/* We only support changing the bal instruction.  It would be 	 possible to handle other PC relative branches, but some of 	 them (the conditional branches) would require a different 	 length instruction sequence which would complicate both this 	 routine and mips_relax_pcrel16.  It could be written if 	 somebody felt it were important.  Ignoring this reloc will 	 presumably cause a reloc overflow error later on.  */
if|if
condition|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|int_rel
operator|.
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
operator|!=
literal|0x0411ffff
condition|)
comment|/* bgezal $0,. == bal . */
continue|continue;
comment|/* Bother.  We need to expand this reloc, and we will need to 	 make another relaxation pass since this change may put other 	 relocs out of range.  We need to examine the local branches 	 and we need to allocate memory to hold the offsets we must 	 add to them.  We also need to adjust the values of all 	 symbols in the object file following this location.  */
name|sec
operator|->
name|_cooked_size
operator|+=
name|PCREL16_EXPANSION_ADJUSTMENT
expr_stmt|;
operator|*
name|again
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|offsets
operator|==
operator|(
name|long
operator|*
operator|)
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|size
operator|=
name|sec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|offsets
operator|=
operator|(
name|long
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsets
operator|==
operator|(
name|long
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|memset
argument_list|(
name|offsets
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|section_tdata
operator|->
name|offsets
operator|=
name|offsets
expr_stmt|;
block|}
name|offsets
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Now look for all PC relative references that cross this reloc 	 and adjust their offsets.  */
name|adj_ext_rel
operator|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|section_tdata
operator|->
name|external_relocs
expr_stmt|;
for|for
control|(
name|adj_i
operator|=
literal|0
init|;
name|adj_ext_rel
operator|<
name|ext_rel_end
condition|;
name|adj_ext_rel
operator|++
operator|,
name|adj_i
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|adj_int_rel
decl_stmt|;
name|bfd_vma
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|int
name|change
decl_stmt|;
name|mips_ecoff_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|adj_ext_rel
argument_list|,
operator|&
name|adj_int_rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj_int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_PCREL16
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
comment|/* We only care about local references.  External ones 		 will be relocated correctly anyhow.  */
if|if
condition|(
name|adj_int_rel
operator|.
name|r_extern
condition|)
continue|continue;
comment|/* We are only interested in a PC relative reloc within 		 this section.  FIXME: Cross section PC relative 		 relocs may not be handled correctly; does anybody 		 care?  */
if|if
condition|(
name|adj_int_rel
operator|.
name|r_symndx
operator|!=
name|RELOC_SECTION_TEXT
condition|)
continue|continue;
name|start
operator|=
name|adj_int_rel
operator|.
name|r_vaddr
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|adj_int_rel
operator|.
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
expr_stmt|;
name|stop
operator|=
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|stop
operator|&
literal|0x20000
operator|)
operator|!=
literal|0
condition|)
name|stop
operator|-=
literal|0x40000
expr_stmt|;
name|stop
operator|+=
name|adj_int_rel
operator|.
name|r_vaddr
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adj_int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_RELHI
condition|)
block|{
name|struct
name|internal_reloc
name|rello
decl_stmt|;
name|long
name|addhi
decl_stmt|,
name|addlo
decl_stmt|;
comment|/* The next reloc must be MIPS_R_RELLO, and we handle 		 them together.  */
name|BFD_ASSERT
argument_list|(
name|adj_ext_rel
operator|+
literal|1
operator|<
name|ext_rel_end
argument_list|)
expr_stmt|;
name|mips_ecoff_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|adj_ext_rel
operator|+
literal|1
argument_list|)
argument_list|,
operator|&
name|rello
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rello
operator|.
name|r_type
operator|==
name|MIPS_R_RELLO
argument_list|)
expr_stmt|;
name|addhi
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|adj_int_rel
operator|.
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
expr_stmt|;
name|addhi
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|addhi
operator|&
literal|0x8000
condition|)
name|addhi
operator|-=
literal|0x10000
expr_stmt|;
name|addhi
operator|<<=
literal|16
expr_stmt|;
name|addlo
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|rello
operator|.
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
expr_stmt|;
name|addlo
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|addlo
operator|&
literal|0x8000
condition|)
name|addlo
operator|-=
literal|0x10000
expr_stmt|;
if|if
condition|(
name|adj_int_rel
operator|.
name|r_extern
condition|)
block|{
comment|/* The value we want here is 		       sym - RELLOaddr + addend 		     which we can express as 		       sym - (RELLOaddr - addend) 		     Therefore if we are expanding the area between 		     RELLOaddr and RELLOaddr - addend we must adjust 		     the addend.  This is admittedly ambiguous, since 		     we might mean (sym + addend) - RELLOaddr, but in 		     practice we don't, and there is no way to handle 		     that case correctly since at this point we have 		     no idea whether any reloc is being expanded 		     between sym and sym + addend.  */
name|start
operator|=
name|rello
operator|.
name|r_vaddr
operator|-
operator|(
name|addhi
operator|+
name|addlo
operator|)
expr_stmt|;
name|stop
operator|=
name|rello
operator|.
name|r_vaddr
expr_stmt|;
block|}
else|else
block|{
comment|/* An internal RELHI/RELLO pair represents the 		     difference between two addresses, $LC0 - foo. 		     The symndx value is actually the difference 		     between the reloc address and $LC0.  This lets us 		     compute $LC0, and, by considering the addend, 		     foo.  If the reloc we are expanding falls between 		     those two relocs, we must adjust the addend.  At 		     this point, the symndx value is actually in the 		     r_offset field, where it was put by 		     mips_ecoff_swap_reloc_in.  */
name|start
operator|=
name|rello
operator|.
name|r_vaddr
operator|-
name|adj_int_rel
operator|.
name|r_offset
expr_stmt|;
name|stop
operator|=
name|start
operator|+
name|addhi
operator|+
name|addlo
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|adj_int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_SWITCH
condition|)
block|{
comment|/* A MIPS_R_SWITCH reloc represents a word of the form 		   .word $L3-$LS12 		 The value in the object file is correct, assuming the 		 original value of $L3.  The symndx value is actually 		 the difference between the reloc address and $LS12. 		 This lets us compute the original value of $LS12 as 		   vaddr - symndx 		 and the original value of $L3 as 		   vaddr - symndx + addend 		 where addend is the value from the object file.  At 		 this point, the symndx value is actually found in the 		 r_offset field, since it was moved by 		 mips_ecoff_swap_reloc_in.  */
name|start
operator|=
name|adj_int_rel
operator|.
name|r_vaddr
operator|-
name|adj_int_rel
operator|.
name|r_offset
expr_stmt|;
name|stop
operator|=
name|start
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|contents
operator|+
name|adj_int_rel
operator|.
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* If the range expressed by this reloc, which is the 	     distance between START and STOP crosses the reloc we are 	     expanding, we must adjust the offset.  The sign of the 	     adjustment depends upon the direction in which the range 	     crosses the reloc being expanded.  */
if|if
condition|(
name|start
operator|<=
name|int_rel
operator|.
name|r_vaddr
operator|&&
name|stop
operator|>
name|int_rel
operator|.
name|r_vaddr
condition|)
name|change
operator|=
name|PCREL16_EXPANSION_ADJUSTMENT
expr_stmt|;
elseif|else
if|if
condition|(
name|start
operator|>
name|int_rel
operator|.
name|r_vaddr
operator|&&
name|stop
operator|<=
name|int_rel
operator|.
name|r_vaddr
condition|)
name|change
operator|=
operator|-
name|PCREL16_EXPANSION_ADJUSTMENT
expr_stmt|;
else|else
name|change
operator|=
literal|0
expr_stmt|;
name|offsets
index|[
name|adj_i
index|]
operator|+=
name|change
expr_stmt|;
if|if
condition|(
name|adj_int_rel
operator|.
name|r_type
operator|==
name|MIPS_R_RELHI
condition|)
block|{
name|adj_ext_rel
operator|++
expr_stmt|;
name|adj_i
operator|++
expr_stmt|;
name|offsets
index|[
name|adj_i
index|]
operator|+=
name|change
expr_stmt|;
block|}
block|}
comment|/* Find all symbols in this section defined by this object file 	 and adjust their values.  Note that we decide whether to 	 adjust the value based on the value stored in the ECOFF EXTR 	 structure, because the value stored in the hash table may 	 have been changed by an earlier expanded reloc and thus may 	 no longer correctly indicate whether the symbol is before or 	 after the expanded reloc.  */
name|ext_count
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|iextMax
expr_stmt|;
name|adj_h_ptr
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_hashes
expr_stmt|;
name|adj_h_ptr_end
operator|=
name|adj_h_ptr
operator|+
name|ext_count
expr_stmt|;
for|for
control|(
init|;
name|adj_h_ptr
operator|<
name|adj_h_ptr_end
condition|;
name|adj_h_ptr
operator|++
control|)
block|{
name|struct
name|ecoff_link_hash_entry
modifier|*
name|adj_h
decl_stmt|;
name|adj_h
operator|=
operator|*
name|adj_h_ptr
expr_stmt|;
if|if
condition|(
name|adj_h
operator|!=
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|adj_h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|adj_h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|adj_h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|adj_h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|>
name|int_rel
operator|.
name|r_vaddr
condition|)
name|adj_h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+=
name|PCREL16_EXPANSION_ADJUSTMENT
expr_stmt|;
block|}
comment|/* Add an entry to the symbol value adjust list.  This is used 	 by bfd_ecoff_debug_accumulate to adjust the values of 	 internal symbols and FDR's.  */
name|adjust
operator|=
operator|(
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_value_adjust
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|adjust
operator|==
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|adjust
operator|->
name|start
operator|=
name|int_rel
operator|.
name|r_vaddr
expr_stmt|;
name|adjust
operator|->
name|end
operator|=
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|adjust
operator|->
name|adjust
operator|=
name|PCREL16_EXPANSION_ADJUSTMENT
expr_stmt|;
name|adjust
operator|->
name|next
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|adjust
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|adjust
operator|=
name|adjust
expr_stmt|;
block|}
if|if
condition|(
name|contents
operator|!=
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
operator|&&
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|contents
operator|!=
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
operator|&&
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* This routine is called from mips_relocate_section when a PC    relative reloc must be expanded into the five instruction sequence.    It handles all the details of the expansion, including resolving    the reloc.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_relax_pcrel16
parameter_list|(
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|h
parameter_list|,
name|location
parameter_list|,
name|address
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_byte
modifier|*
name|location
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
comment|/* 0x0411ffff is bgezal $0,. == bal .  */
name|BFD_ASSERT
argument_list|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
operator|==
literal|0x0411ffff
argument_list|)
expr_stmt|;
comment|/* We need to compute the distance between the symbol and the      current address plus eight.  */
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|relocation
operator|-=
name|address
operator|+
literal|8
expr_stmt|;
comment|/* If the lower half is negative, increment the upper 16 half.  */
if|if
condition|(
operator|(
name|relocation
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|relocation
operator|+=
literal|0x10000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
literal|0x04110001
argument_list|,
name|location
argument_list|)
expr_stmt|;
comment|/* bal .+8 */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
literal|0x3c010000
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
argument_list|,
comment|/* lui $at,XX */
name|location
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
literal|0x24210000
operator||
operator|(
name|relocation
operator|&
literal|0xffff
operator|)
argument_list|,
comment|/* addiu $at,$at,XX */
name|location
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
literal|0x003f0821
argument_list|,
name|location
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* addu $at,$at,$ra */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
literal|0x0020f809
argument_list|,
name|location
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* jalr $at */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Given a .sdata section and a .rel.sdata in-memory section, store    relocation information into the .rel.sdata section which can be    used at runtime to relocate the section.  This is called by the    linker when the --embedded-relocs switch is used.  This is called    after the add_symbols entry point has been called for all the    objects, and before the final_link entry point is called.  This    function presumes that the object was compiled using    -membedded-pic.  */
end_comment

begin_function
name|boolean
name|bfd_mips_ecoff_create_embedded_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|datasec
parameter_list|,
name|relsec
parameter_list|,
name|errmsg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|datasec
decl_stmt|;
name|asection
modifier|*
name|relsec
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|struct
name|ecoff_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|ecoff_section_tdata
modifier|*
name|section_tdata
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel_end
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|relocateable
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|datasec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|sym_hashes
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_hashes
expr_stmt|;
if|if
condition|(
operator|!
name|mips_read_relocs
argument_list|(
name|abfd
argument_list|,
name|datasec
argument_list|)
condition|)
return|return
name|false
return|;
name|relsec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|datasec
operator|->
name|reloc_count
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsec
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|p
operator|=
name|relsec
operator|->
name|contents
expr_stmt|;
name|section_tdata
operator|=
name|ecoff_section_data
argument_list|(
name|abfd
argument_list|,
name|datasec
argument_list|)
expr_stmt|;
name|ext_rel
operator|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|section_tdata
operator|->
name|external_relocs
expr_stmt|;
name|ext_rel_end
operator|=
name|ext_rel
operator|+
name|datasec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|ext_rel
operator|<
name|ext_rel_end
condition|;
name|ext_rel
operator|++
operator|,
name|p
operator|+=
literal|4
control|)
block|{
name|struct
name|internal_reloc
name|int_rel
decl_stmt|;
name|boolean
name|text_relative
decl_stmt|;
name|mips_ecoff_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|ext_rel
argument_list|,
operator|&
name|int_rel
argument_list|)
expr_stmt|;
comment|/* We are going to write a four byte word into the runtime reloc 	 section.  The word will be the address in the data section 	 which must be relocated.  This must be on a word boundary, 	 which means the lower two bits must be zero.  We use the 	 least significant bit to indicate how the value in the data 	 section must be relocated.  A 0 means that the value is 	 relative to the text section, while a 1 indicates that the 	 value is relative to the data section.  Given that we are 	 assuming the code was compiled using -membedded-pic, there 	 should not be any other possibilities.  */
comment|/* We can only relocate REFWORD relocs at run time.  */
if|if
condition|(
name|int_rel
operator|.
name|r_type
operator|!=
name|MIPS_R_REFWORD
condition|)
block|{
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"unsupported reloc type"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|int_rel
operator|.
name|r_extern
condition|)
block|{
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|int_rel
operator|.
name|r_symndx
index|]
expr_stmt|;
comment|/* If h is NULL, that means that there is a reloc against an 	     external symbol which we thought was just a debugging 	     symbol.  This should not happen.  */
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|text_relative
operator|=
name|true
expr_stmt|;
else|else
name|text_relative
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|int_rel
operator|.
name|r_symndx
condition|)
block|{
case|case
name|RELOC_SECTION_TEXT
case|:
name|text_relative
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_SDATA
case|:
case|case
name|RELOC_SECTION_SBSS
case|:
case|case
name|RELOC_SECTION_LIT8
case|:
name|text_relative
operator|=
name|false
expr_stmt|;
break|break;
default|default:
comment|/* No other sections should appear in -membedded-pic                  code.  */
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"reloc against unsupported section"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|(
name|int_rel
operator|.
name|r_offset
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"reloc not properly aligned"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|int_rel
operator|.
name|r_vaddr
operator|-
name|datasec
operator|->
name|vma
operator|+
name|datasec
operator|->
name|output_offset
operator|+
operator|(
name|text_relative
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the ECOFF backend structure.  The backend field of the    target vector points to this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ecoff_backend_data
name|mips_ecoff_backend_data
init|=
block|{
comment|/* COFF backend structure.  */
block|{
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* aux_in */
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* sym_in */
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* lineno_in */
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/*aux_out*/
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* sym_out */
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* lineno_out */
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* reloc_out */
name|mips_ecoff_swap_filehdr_out
block|,
name|mips_ecoff_swap_aouthdr_out
block|,
name|mips_ecoff_swap_scnhdr_out
block|,
name|FILHSZ
block|,
name|AOUTSZ
block|,
name|SCNHSZ
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FILNMLEN
block|,
name|true
block|,
name|false
block|,
literal|4
block|,
name|mips_ecoff_swap_filehdr_in
block|,
name|mips_ecoff_swap_aouthdr_in
block|,
name|mips_ecoff_swap_scnhdr_in
block|,
name|NULL
block|,
name|mips_ecoff_bad_format_hook
block|,
name|_bfd_ecoff_set_arch_mach_hook
block|,
name|_bfd_ecoff_mkobject_hook
block|,
name|_bfd_ecoff_styp_to_sec_flags
block|,
name|_bfd_ecoff_set_alignment_hook
block|,
name|_bfd_ecoff_slurp_symbol_table
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Supported architecture.  */
name|bfd_arch_mips
block|,
comment|/* Initial portion of armap string.  */
literal|"__________"
block|,
comment|/* The page boundary used to align sections in a demand-paged      executable file.  E.g., 0x1000.  */
literal|0x1000
block|,
comment|/* True if the .rdata section is part of the text segment, as on the      Alpha.  False if .rdata is part of the data segment, as on the      MIPS.  */
name|false
block|,
comment|/* Bitsize of constructor entries.  */
literal|32
block|,
comment|/* Reloc to use for constructor entries.  */
operator|&
name|mips_howto_table
index|[
name|MIPS_R_REFWORD
index|]
block|,
block|{
comment|/* Symbol table magic number.  */
name|magicSym
block|,
comment|/* Alignment of debugging information.  E.g., 4.  */
literal|4
block|,
comment|/* Sizes of external symbolic information.  */
sizeof|sizeof
argument_list|(
expr|struct
name|hdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opt_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|rfd_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ext_ext
argument_list|)
block|,
comment|/* Functions to swap in external symbolic data.  */
name|ecoff_swap_hdr_in
block|,
name|ecoff_swap_dnr_in
block|,
name|ecoff_swap_pdr_in
block|,
name|ecoff_swap_sym_in
block|,
name|ecoff_swap_opt_in
block|,
name|ecoff_swap_fdr_in
block|,
name|ecoff_swap_rfd_in
block|,
name|ecoff_swap_ext_in
block|,
name|_bfd_ecoff_swap_tir_in
block|,
name|_bfd_ecoff_swap_rndx_in
block|,
comment|/* Functions to swap out external symbolic data.  */
name|ecoff_swap_hdr_out
block|,
name|ecoff_swap_dnr_out
block|,
name|ecoff_swap_pdr_out
block|,
name|ecoff_swap_sym_out
block|,
name|ecoff_swap_opt_out
block|,
name|ecoff_swap_fdr_out
block|,
name|ecoff_swap_rfd_out
block|,
name|ecoff_swap_ext_out
block|,
name|_bfd_ecoff_swap_tir_out
block|,
name|_bfd_ecoff_swap_rndx_out
block|,
comment|/* Function to read in symbolic data.  */
name|_bfd_ecoff_slurp_symbolic_info
block|}
block|,
comment|/* External reloc size.  */
name|RELSZ
block|,
comment|/* Reloc swapping functions.  */
name|mips_ecoff_swap_reloc_in
block|,
name|mips_ecoff_swap_reloc_out
block|,
comment|/* Backend reloc tweaking.  */
name|mips_adjust_reloc_in
block|,
name|mips_adjust_reloc_out
block|,
comment|/* Relocate section contents while linking.  */
name|mips_relocate_section
block|,
comment|/* Do final adjustments to filehdr and aouthdr.  */
name|NULL
block|,
comment|/* Read an element from an archive at a given file position.  */
name|_bfd_get_elt_at_filepos
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Looking up a reloc type is MIPS specific.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_reloc_type_lookup
value|mips_bfd_reloc_type_lookup
end_define

begin_comment
comment|/* Getting relocated section contents is generic.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_comment
comment|/* Handling file windows is generic.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_comment
comment|/* Relaxing sections is MIPS specific.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_relax_section
value|mips_relax_section
end_define

begin_comment
comment|/* GC of sections is not done.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|ecoff_big_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|ecoff_little_vec
init|=
block|{
literal|"ecoff-littlemips"
block|,
comment|/* name */
name|bfd_target_ecoff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_ecoff_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|&
name|ecoff_big_vec
block|,
operator|(
name|PTR
operator|)
operator|&
name|mips_ecoff_backend_data
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|ecoff_big_vec
init|=
block|{
literal|"ecoff-bigmips"
block|,
comment|/* name */
name|bfd_target_ecoff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_ecoff_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|&
name|ecoff_little_vec
block|,
operator|(
name|PTR
operator|)
operator|&
name|mips_ecoff_backend_data
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|ecoff_biglittle_vec
init|=
block|{
literal|"ecoff-biglittlemips"
block|,
comment|/* name */
name|bfd_target_ecoff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_ecoff_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
operator|&
name|mips_ecoff_backend_data
block|}
decl_stmt|;
end_decl_stmt

end_unit

