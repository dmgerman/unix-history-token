begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for OSF/1 core files.    Copyright 1993, 1994, 1995, 1998, 1999, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file can only be compiled on systems which use OSF/1 style    core files.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_comment
comment|/* forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|make_bfd_asection
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|flagword
operator|,
name|bfd_size_type
operator|,
name|bfd_vma
operator|,
name|file_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|osf_core_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|osf_core_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|osf_core_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|osf_core_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_abort
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are stored in the bfd's tdata */
end_comment

begin_struct
struct|struct
name|osf_core_struct
block|{
name|int
name|sig
decl_stmt|;
name|char
name|cmd
index|[
name|MAXCOMLEN
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|core_hdr
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->tdata.osf_core_data)
end_define

begin_define
define|#
directive|define
name|core_signal
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->sig)
end_define

begin_define
define|#
directive|define
name|core_command
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->cmd)
end_define

begin_function
specifier|static
name|asection
modifier|*
name|make_bfd_asection
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|,
name|_raw_size
parameter_list|,
name|vma
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|_raw_size
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|asection
modifier|*
name|asect
decl_stmt|;
name|asect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|asect
condition|)
return|return
name|NULL
return|;
name|asect
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|asect
operator|->
name|_raw_size
operator|=
name|_raw_size
expr_stmt|;
name|asect
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
name|asect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|asect
operator|->
name|alignment_power
operator|=
literal|8
expr_stmt|;
return|return
name|asect
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|osf_core_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|;
name|struct
name|core_filehdr
name|core_header
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
name|core_header
expr_stmt|;
name|val
operator|=
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|core_header
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|core_header
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|core_header
operator|.
name|magic
argument_list|,
literal|"Core"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|osf_core_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|osf_core_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|core_hdr
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
name|strncpy
argument_list|(
name|core_command
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|core_header
operator|.
name|name
argument_list|,
name|MAXCOMLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|core_signal
argument_list|(
name|abfd
argument_list|)
operator|=
name|core_header
operator|.
name|signo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|core_header
operator|.
name|nscns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|core_scnhdr
name|core_scnhdr
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
name|core_scnhdr
expr_stmt|;
name|val
operator|=
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|core_scnhdr
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|core_scnhdr
condition|)
break|break;
comment|/* Skip empty sections.  */
if|if
condition|(
name|core_scnhdr
operator|.
name|size
operator|==
literal|0
operator|||
name|core_scnhdr
operator|.
name|scnptr
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|core_scnhdr
operator|.
name|scntype
condition|)
block|{
case|case
name|SCNRGN
case|:
name|secname
operator|=
literal|".data"
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|SCNSTACK
case|:
name|secname
operator|=
literal|".stack"
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|SCNREGS
case|:
name|secname
operator|=
literal|".reg"
expr_stmt|;
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Unhandled OSF/1 core file section type %d\n"
argument_list|)
argument_list|,
name|core_scnhdr
operator|.
name|scntype
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
name|secname
argument_list|,
name|flags
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|core_scnhdr
operator|.
name|size
argument_list|,
operator|(
name|bfd_vma
operator|)
name|core_scnhdr
operator|.
name|vaddr
argument_list|,
operator|(
name|file_ptr
operator|)
name|core_scnhdr
operator|.
name|scnptr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* OK, we believe you.  You're a core file (sure, sure).  */
return|return
name|abfd
operator|->
name|xvec
return|;
name|fail
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|core_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|bfd_section_list_clear
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|osf_core_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_command
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|osf_core_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_signal
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|osf_core_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|TRUE
return|;
comment|/* FIXME, We have no way of telling at this point */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If somebody calls any byte-swapping routines, shoot them.  */
end_comment

begin_function
specifier|static
name|void
name|swap_abort
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
comment|/* This way doesn't require any declaration for ANSI to fuck up */
block|}
end_function

begin_define
define|#
directive|define
name|NO_GET
value|((bfd_vma (*) (const void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_PUT
value|((void (*) (bfd_vma, void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_GETS
value|((bfd_signed_vma (*) (const void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_GET64
value|((bfd_uint64_t (*) (const void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_PUT64
value|((void (*) (bfd_uint64_t, void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_GETS64
value|((bfd_int64_t (*) (const void *)) swap_abort)
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|osf_core_vec
init|=
block|{
literal|"osf-core"
block|,
name|bfd_target_unknown_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* target byte order */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* symbol prefix */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|NO_GET64
block|,
name|NO_GETS64
block|,
name|NO_PUT64
block|,
comment|/* 64 bit data */
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* 32 bit data */
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* 16 bit data */
name|NO_GET64
block|,
name|NO_GETS64
block|,
name|NO_PUT64
block|,
comment|/* 64 bit hdrs */
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* 32 bit hdrs */
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* 16 bit hdrs */
block|{
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
comment|/* unknown format */
name|_bfd_dummy_target
block|,
comment|/* object file */
name|_bfd_dummy_target
block|,
comment|/* archive */
name|osf_core_core_file_p
comment|/* a core file */
block|}
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|}
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|osf_core
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_nosymbols
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_norelocs
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_nolink
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
literal|0
comment|/* backend_data */
block|}
decl_stmt|;
end_decl_stmt

end_unit

