begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SPU specific support for 32-bit ELF     Copyright 2006, 2007 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/spu.h"
end_include

begin_include
include|#
directive|include
file|"elf32-spu.h"
end_include

begin_comment
comment|/* We use RELA style relocs.  Don't define USE_REL.  */
end_comment

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|spu_elf_rel9
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Values of type 'enum elf_spu_reloc_type' are used to index this    array, so it must be declared in the order of that type.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_SPU_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_NONE"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR10
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|14
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00ffc000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR16
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|7
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x007fff80
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR16_HI
argument_list|,
literal|16
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|7
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR16_HI"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x007fff80
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR16_LO
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|7
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR16_LO"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x007fff80
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR18
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|18
argument_list|,
name|FALSE
argument_list|,
literal|7
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR18"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x01ffff80
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_REL16
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|7
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_REL16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x007fff80
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR7
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|7
argument_list|,
name|FALSE
argument_list|,
literal|14
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR7"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x001fc000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_REL9
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|spu_elf_rel9
argument_list|,
literal|"SPU_REL9"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0180007f
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_REL9I
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|spu_elf_rel9
argument_list|,
literal|"SPU_REL9I"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000c07f
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR10I
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|14
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR10I"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00ffc000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR16I
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|7
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR16I"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x007fff80
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_REL32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_REL32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_ADDR16X
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|7
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_ADDR16X"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x007fff80
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_PPU32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_PPU32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPU_PPU64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"SPU_PPU64"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
specifier|const
name|spu_elf_special_sections
index|[]
init|=
block|{
block|{
literal|".toe"
block|,
literal|4
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|enum
name|elf_spu_reloc_type
name|spu_elf_bfd_to_reloc_type
parameter_list|(
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
name|R_SPU_NONE
return|;
case|case
name|BFD_RELOC_SPU_IMM10W
case|:
return|return
name|R_SPU_ADDR10
return|;
case|case
name|BFD_RELOC_SPU_IMM16W
case|:
return|return
name|R_SPU_ADDR16
return|;
case|case
name|BFD_RELOC_SPU_LO16
case|:
return|return
name|R_SPU_ADDR16_LO
return|;
case|case
name|BFD_RELOC_SPU_HI16
case|:
return|return
name|R_SPU_ADDR16_HI
return|;
case|case
name|BFD_RELOC_SPU_IMM18
case|:
return|return
name|R_SPU_ADDR18
return|;
case|case
name|BFD_RELOC_SPU_PCREL16
case|:
return|return
name|R_SPU_REL16
return|;
case|case
name|BFD_RELOC_SPU_IMM7
case|:
return|return
name|R_SPU_ADDR7
return|;
case|case
name|BFD_RELOC_SPU_IMM8
case|:
return|return
name|R_SPU_NONE
return|;
case|case
name|BFD_RELOC_SPU_PCREL9a
case|:
return|return
name|R_SPU_REL9
return|;
case|case
name|BFD_RELOC_SPU_PCREL9b
case|:
return|return
name|R_SPU_REL9I
return|;
case|case
name|BFD_RELOC_SPU_IMM10
case|:
return|return
name|R_SPU_ADDR10I
return|;
case|case
name|BFD_RELOC_SPU_IMM16
case|:
return|return
name|R_SPU_ADDR16I
return|;
case|case
name|BFD_RELOC_32
case|:
return|return
name|R_SPU_ADDR32
return|;
case|case
name|BFD_RELOC_32_PCREL
case|:
return|return
name|R_SPU_REL32
return|;
case|case
name|BFD_RELOC_SPU_PPU32
case|:
return|return
name|R_SPU_PPU32
return|;
case|case
name|BFD_RELOC_SPU_PPU64
case|:
return|return
name|R_SPU_PPU64
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|spu_elf_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|enum
name|elf_spu_reloc_type
name|r_type
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_spu_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
name|R_SPU_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|spu_elf_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|enum
name|elf_spu_reloc_type
name|r_type
init|=
name|spu_elf_bfd_to_reloc_type
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPU_NONE
condition|)
return|return
name|NULL
return|;
return|return
name|elf_howto_table
operator|+
name|r_type
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|spu_elf_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|elf_howto_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|elf_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|elf_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Apply R_SPU_REL9 and R_SPU_REL9I relocs.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|spu_elf_rel9
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_size_type
name|octets
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|long
name|insn
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|octets
operator|=
name|reloc_entry
operator|->
name|address
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Get symbol value.  */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|val
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|section
operator|->
name|output_section
condition|)
name|val
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|val
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Make it pc-relative.  */
name|val
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|val
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|+
literal|256
operator|>=
literal|512
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
comment|/* Move two high bits of value to REL9I and REL9 position.      The mask will take care of selecting the right field.  */
name|val
operator|=
operator|(
name|val
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x180
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x180
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|insn
operator|&=
operator|~
name|reloc_entry
operator|->
name|howto
operator|->
name|dst_mask
expr_stmt|;
name|insn
operator||=
name|val
operator|&
name|reloc_entry
operator|->
name|howto
operator|->
name|dst_mask
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|spu_elf_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sec
operator|->
name|used_by_bfd
condition|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
block|}
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Specially mark defined symbols named _EAR_* with BSF_KEEP so that    strip --strip-unneeded will not remove them.  */
end_comment

begin_function
specifier|static
name|void
name|spu_elf_backend_symbol_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|section
operator|!=
name|bfd_abs_section_ptr
operator|&&
name|strncmp
argument_list|(
name|sym
operator|->
name|name
argument_list|,
literal|"_EAR_"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|flags
operator||=
name|BSF_KEEP
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SPU ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|spu_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* The stub hash table.  */
name|struct
name|bfd_hash_table
name|stub_hash_table
decl_stmt|;
comment|/* Shortcuts to overlay sections.  */
name|asection
modifier|*
name|stub
decl_stmt|;
name|asection
modifier|*
name|ovtab
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|ovly_load
decl_stmt|;
comment|/* An array of two output sections per overlay region, chosen such that      the first section vma is the overlay buffer vma (ie. the section has      the lowest vma in the group that occupy the region), and the second      section vma+size specifies the end of the region.  We keep pointers      to sections like this because section vmas may change when laying      them out.  */
name|asection
modifier|*
modifier|*
name|ovl_region
decl_stmt|;
comment|/* Number of overlay buffers.  */
name|unsigned
name|int
name|num_buf
decl_stmt|;
comment|/* Total number of overlays.  */
name|unsigned
name|int
name|num_overlays
decl_stmt|;
comment|/* Set if we should emit symbols for stubs.  */
name|unsigned
name|int
name|emit_stub_syms
range|:
literal|1
decl_stmt|;
comment|/* Set if we want stubs on calls out of overlay regions to      non-overlay regions.  */
name|unsigned
name|int
name|non_overlay_stubs
range|:
literal|1
decl_stmt|;
comment|/* Set on error.  */
name|unsigned
name|int
name|stub_overflow
range|:
literal|1
decl_stmt|;
comment|/* Set if stack size analysis should be done.  */
name|unsigned
name|int
name|stack_analysis
range|:
literal|1
decl_stmt|;
comment|/* Set if __stack_* syms will be emitted.  */
name|unsigned
name|int
name|emit_stack_syms
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|spu_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct spu_link_hash_table *) ((p)->hash))
end_define

begin_struct
struct|struct
name|spu_stub_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Destination of this stub.  */
name|asection
modifier|*
name|target_section
decl_stmt|;
name|bfd_vma
name|target_off
decl_stmt|;
comment|/* Offset of entry in stub section.  */
name|bfd_vma
name|off
decl_stmt|;
comment|/* Offset from this stub to stub that loads the overlay index.  */
name|bfd_vma
name|delta
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Create an entry in a spu stub hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stub_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spu_stub_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|spu_stub_hash_entry
modifier|*
name|sh
init|=
operator|(
expr|struct
name|spu_stub_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
name|sh
operator|->
name|target_section
operator|=
name|NULL
expr_stmt|;
name|sh
operator|->
name|target_off
operator|=
literal|0
expr_stmt|;
name|sh
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|sh
operator|->
name|delta
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create a spu ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|spu_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|htab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|htab
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Init the stub hash table too.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spu_stub_hash_entry
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
operator|&
name|htab
operator|->
name|stub
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|htab
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|spu_link_hash_table
argument_list|,
name|stub
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|htab
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Free the derived linker hash table.  */
end_comment

begin_function
specifier|static
name|void
name|spu_elf_link_hash_table_free
parameter_list|(
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|ret
init|=
operator|(
expr|struct
name|spu_link_hash_table
operator|*
operator|)
name|hash
decl_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ret
operator|->
name|stub_hash_table
argument_list|)
expr_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the symbol for the given R_SYMNDX in IBFD and set *HP and *SYMP    to (hash, NULL) for global symbols, and (NULL, sym) for locals.  Set    *SYMSECP to the symbol's section.  *LOCSYMSP caches local syms.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|get_sym_h
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hp
parameter_list|,
name|Elf_Internal_Sym
modifier|*
modifier|*
name|symp
parameter_list|,
name|asection
modifier|*
modifier|*
name|symsecp
parameter_list|,
name|Elf_Internal_Sym
modifier|*
modifier|*
name|locsymsp
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
init|=
name|elf_sym_hashes
argument_list|(
name|ibfd
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
operator|*
name|hp
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|symp
operator|!=
name|NULL
condition|)
operator|*
name|symp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symsecp
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|symsec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|symsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
operator|*
name|symsecp
operator|=
name|symsec
expr_stmt|;
block|}
block|}
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|locsyms
init|=
operator|*
name|locsymsp
decl_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
block|{
name|locsyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
block|{
name|size_t
name|symcount
init|=
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
comment|/* If we are reading symbols into the contents, then 		 read the global syms too.  This is done to cache 		 syms for later stack analysis.  */
if|if
condition|(
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|locsymsp
operator|==
operator|&
name|symtab_hdr
operator|->
name|contents
condition|)
name|symcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
name|symtab_hdr
operator|->
name|sh_entsize
expr_stmt|;
name|locsyms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symcount
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|locsymsp
operator|=
name|locsyms
expr_stmt|;
block|}
name|sym
operator|=
name|locsyms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
operator|*
name|hp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symp
operator|!=
name|NULL
condition|)
operator|*
name|symp
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|symsecp
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|symsec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|)
operator|||
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
name|symsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|ibfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|symsecp
operator|=
name|symsec
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Build a name for an entry in the stub hash table.  We can't use a    local symbol name because ld -r might generate duplicate local symbols.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|spu_stub_name
parameter_list|(
specifier|const
name|asection
modifier|*
name|sym_sec
parameter_list|,
specifier|const
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
if|if
condition|(
name|h
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|stub_name
return|;
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%s+%x"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|stub_name
return|;
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%x:%x+%x"
argument_list|,
name|sym_sec
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stub_name
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'+'
operator|&&
name|stub_name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'0'
operator|&&
name|stub_name
index|[
name|len
index|]
operator|==
literal|0
condition|)
name|stub_name
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|stub_name
return|;
block|}
end_function

begin_comment
comment|/* Create the note section if not already present.  This is done early so    that the linker maps the sections to the right place in the output.  */
end_comment

begin_function
name|bfd_boolean
name|spu_elf_create_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|int
name|stack_analysis
parameter_list|,
name|int
name|emit_stack_syms
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* Stash some options away where we can get at them later.  */
name|htab
operator|->
name|stack_analysis
operator|=
name|stack_analysis
expr_stmt|;
name|htab
operator|->
name|emit_stack_syms
operator|=
name|emit_stack_syms
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
name|SPU_PTNOTE_SPUNAME
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|ibfd
operator|==
name|NULL
condition|)
block|{
comment|/* Make SPU_PTNOTE_SPUNAME section.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
expr_stmt|;
name|flags
operator|=
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
expr_stmt|;
name|s
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|ibfd
argument_list|,
name|SPU_PTNOTE_SPUNAME
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|ibfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|name_len
operator|=
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|size
operator|=
literal|12
operator|+
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|SPU_PLUGIN_NAME
argument_list|)
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
expr_stmt|;
name|size
operator|+=
operator|(
name|name_len
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|ibfd
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|data
operator|=
name|bfd_zalloc
argument_list|(
name|ibfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|bfd_put_32
argument_list|(
name|ibfd
argument_list|,
sizeof|sizeof
argument_list|(
name|SPU_PLUGIN_NAME
argument_list|)
argument_list|,
name|data
operator|+
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|ibfd
argument_list|,
name|name_len
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|ibfd
argument_list|,
literal|1
argument_list|,
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
literal|12
argument_list|,
name|SPU_PLUGIN_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|SPU_PLUGIN_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
literal|12
operator|+
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|SPU_PLUGIN_NAME
argument_list|)
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|data
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* qsort predicate to sort sections by vma.  */
end_comment

begin_function
specifier|static
name|int
name|sort_sections
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|asection
modifier|*
specifier|const
modifier|*
name|s1
init|=
name|a
decl_stmt|;
specifier|const
name|asection
modifier|*
specifier|const
modifier|*
name|s2
init|=
name|b
decl_stmt|;
name|bfd_signed_vma
name|delta
init|=
operator|(
operator|*
name|s1
operator|)
operator|->
name|vma
operator|-
operator|(
operator|*
name|s2
operator|)
operator|->
name|vma
decl_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
return|return
name|delta
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
return|return
operator|(
operator|*
name|s1
operator|)
operator|->
name|index
operator|-
operator|(
operator|*
name|s2
operator|)
operator|->
name|index
return|;
block|}
end_function

begin_comment
comment|/* Identify overlays in the output bfd, and number them.  */
end_comment

begin_function
name|bfd_boolean
name|spu_elf_find_overlays
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|asection
modifier|*
modifier|*
name|alloc_sec
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|ovl_index
decl_stmt|,
name|num_buf
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_vma
name|ovl_end
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|->
name|section_count
operator|<
literal|2
condition|)
return|return
name|FALSE
return|;
name|alloc_sec
operator|=
name|bfd_malloc
argument_list|(
name|output_bfd
operator|->
name|section_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|alloc_sec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_sec
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Pick out all the alloced sections.  */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|!=
name|SEC_THREAD_LOCAL
operator|&&
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
name|alloc_sec
index|[
name|n
operator|++
index|]
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|alloc_sec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Sort them by vma.  */
name|qsort
argument_list|(
name|alloc_sec
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|alloc_sec
argument_list|)
argument_list|,
name|sort_sections
argument_list|)
expr_stmt|;
comment|/* Look for overlapping vmas.  Any with overlap must be overlays.      Count them.  Also count the number of overlay regions and for      each region save a section from that region with the lowest vma      and another section with the highest end vma.  */
name|ovl_end
operator|=
name|alloc_sec
index|[
literal|0
index|]
operator|->
name|vma
operator|+
name|alloc_sec
index|[
literal|0
index|]
operator|->
name|size
expr_stmt|;
for|for
control|(
name|ovl_index
operator|=
literal|0
operator|,
name|num_buf
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|alloc_sec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|vma
operator|<
name|ovl_end
condition|)
block|{
name|asection
modifier|*
name|s0
init|=
name|alloc_sec
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|spu_elf_section_data
argument_list|(
name|s0
argument_list|)
operator|->
name|ovl_index
operator|==
literal|0
condition|)
block|{
name|spu_elf_section_data
argument_list|(
name|s0
argument_list|)
operator|->
name|ovl_index
operator|=
operator|++
name|ovl_index
expr_stmt|;
name|alloc_sec
index|[
name|num_buf
operator|*
literal|2
index|]
operator|=
name|s0
expr_stmt|;
name|alloc_sec
index|[
name|num_buf
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|s0
expr_stmt|;
name|num_buf
operator|++
expr_stmt|;
block|}
name|spu_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|ovl_index
operator|=
operator|++
name|ovl_index
expr_stmt|;
if|if
condition|(
name|ovl_end
operator|<
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|size
condition|)
block|{
name|ovl_end
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|size
expr_stmt|;
name|alloc_sec
index|[
name|num_buf
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|s
expr_stmt|;
block|}
block|}
else|else
name|ovl_end
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|size
expr_stmt|;
block|}
name|htab
operator|->
name|num_overlays
operator|=
name|ovl_index
expr_stmt|;
name|htab
operator|->
name|num_buf
operator|=
name|num_buf
expr_stmt|;
if|if
condition|(
name|ovl_index
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|alloc_sec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|alloc_sec
operator|=
name|bfd_realloc
argument_list|(
name|alloc_sec
argument_list|,
name|num_buf
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|alloc_sec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_sec
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|ovl_region
operator|=
name|alloc_sec
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* One of these per stub.  */
end_comment

begin_define
define|#
directive|define
name|SIZEOF_STUB1
value|8
end_define

begin_define
define|#
directive|define
name|ILA_79
value|0x4200004f
end_define

begin_comment
comment|/* ila $79,function_address */
end_comment

begin_define
define|#
directive|define
name|BR
value|0x32000000
end_define

begin_comment
comment|/* br stub2 */
end_comment

begin_comment
comment|/* One of these per overlay.  */
end_comment

begin_define
define|#
directive|define
name|SIZEOF_STUB2
value|8
end_define

begin_define
define|#
directive|define
name|ILA_78
value|0x4200004e
end_define

begin_comment
comment|/* ila $78,overlay_number */
end_comment

begin_comment
comment|/* br __ovly_load */
end_comment

begin_define
define|#
directive|define
name|NOP
value|0x40200000
end_define

begin_comment
comment|/* Return true for all relative and absolute branch instructions.    bra   00110000 0..    brasl 00110001 0..    br    00110010 0..    brsl  00110011 0..    brz   00100000 0..    brnz  00100001 0..    brhz  00100010 0..    brhnz 00100011 0..  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_branch
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|insn
parameter_list|)
block|{
return|return
operator|(
name|insn
index|[
literal|0
index|]
operator|&
literal|0xec
operator|)
operator|==
literal|0x20
operator|&&
operator|(
name|insn
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true for branch hint instructions.    hbra  0001000..    hbrr  0001001..  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_hint
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|insn
parameter_list|)
block|{
return|return
operator|(
name|insn
index|[
literal|0
index|]
operator|&
literal|0xfc
operator|)
operator|==
literal|0x10
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if this reloc symbol should possibly go via an overlay stub.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|needs_ovl_stub
parameter_list|(
specifier|const
name|char
modifier|*
name|sym_name
parameter_list|,
name|asection
modifier|*
name|sym_sec
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|struct
name|spu_link_hash_table
modifier|*
name|htab
parameter_list|,
name|bfd_boolean
name|is_branch
parameter_list|)
block|{
if|if
condition|(
name|htab
operator|->
name|num_overlays
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|spu_elf_section_data
argument_list|(
name|sym_sec
operator|->
name|output_section
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* setjmp always goes via an overlay stub, because then the return      and hence the longjmp goes via __ovly_return.  That magically      makes setjmp/longjmp between overlays work.  */
if|if
condition|(
name|strncmp
argument_list|(
name|sym_name
argument_list|,
literal|"setjmp"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|sym_name
index|[
literal|6
index|]
operator|==
literal|'\0'
operator|||
name|sym_name
index|[
literal|6
index|]
operator|==
literal|'@'
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* Usually, symbols in non-overlay sections don't need stubs.  */
if|if
condition|(
name|spu_elf_section_data
argument_list|(
name|sym_sec
operator|->
name|output_section
argument_list|)
operator|->
name|ovl_index
operator|==
literal|0
operator|&&
operator|!
name|htab
operator|->
name|non_overlay_stubs
condition|)
return|return
name|FALSE
return|;
comment|/* A reference from some other section to a symbol in an overlay      section needs a stub.  */
if|if
condition|(
name|spu_elf_section_data
argument_list|(
name|sym_sec
operator|->
name|output_section
argument_list|)
operator|->
name|ovl_index
operator|!=
name|spu_elf_section_data
argument_list|(
name|input_section
operator|->
name|output_section
argument_list|)
operator|->
name|ovl_index
condition|)
return|return
name|TRUE
return|;
comment|/* If this insn isn't a branch then we are possibly taking the      address of a function and passing it out somehow.  */
return|return
operator|!
name|is_branch
return|;
block|}
end_function

begin_struct
struct|struct
name|stubarr
block|{
name|struct
name|bfd_hash_table
modifier|*
name|stub_hash_table
decl_stmt|;
name|struct
name|spu_stub_hash_entry
modifier|*
modifier|*
name|sh
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|err
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Called via elf_link_hash_traverse to allocate stubs for any _SPUEAR_    symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_spuear_stubs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
comment|/* Symbols starting with _SPUEAR_ need a stub because they may be      invoked by the PPU.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|def_regular
operator|&&
name|strncmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_SPUEAR_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|stubarr
modifier|*
name|stubs
init|=
name|inf
decl_stmt|;
specifier|static
name|Elf_Internal_Rela
name|zero_rel
decl_stmt|;
name|char
modifier|*
name|stub_name
init|=
name|spu_stub_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|h
argument_list|,
operator|&
name|zero_rel
argument_list|)
decl_stmt|;
name|struct
name|spu_stub_hash_entry
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
block|{
name|stubs
operator|->
name|err
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sh
operator|=
operator|(
expr|struct
name|spu_stub_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
name|stubs
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If this entry isn't new, we already have a stub.  */
if|if
condition|(
name|sh
operator|->
name|target_section
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|sh
operator|->
name|target_section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sh
operator|->
name|target_off
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|stubs
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called via bfd_hash_traverse to set up pointers to all symbols    in the stub hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|populate_stubs
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|bh
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|stubarr
modifier|*
name|stubs
init|=
name|inf
decl_stmt|;
name|stubs
operator|->
name|sh
index|[
operator|--
name|stubs
operator|->
name|count
index|]
operator|=
operator|(
expr|struct
name|spu_stub_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* qsort predicate to sort stubs by overlay number.  */
end_comment

begin_function
specifier|static
name|int
name|sort_stubs
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|spu_stub_hash_entry
modifier|*
specifier|const
modifier|*
name|sa
init|=
name|a
decl_stmt|;
specifier|const
name|struct
name|spu_stub_hash_entry
modifier|*
specifier|const
modifier|*
name|sb
init|=
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bfd_signed_vma
name|d
decl_stmt|;
name|i
operator|=
name|spu_elf_section_data
argument_list|(
operator|(
operator|*
name|sa
operator|)
operator|->
name|target_section
operator|->
name|output_section
argument_list|)
operator|->
name|ovl_index
expr_stmt|;
name|i
operator|-=
name|spu_elf_section_data
argument_list|(
operator|(
operator|*
name|sb
operator|)
operator|->
name|target_section
operator|->
name|output_section
argument_list|)
operator|->
name|ovl_index
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
name|d
operator|=
operator|(
operator|(
operator|*
name|sa
operator|)
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|+
operator|(
operator|*
name|sa
operator|)
operator|->
name|target_section
operator|->
name|output_offset
operator|+
operator|(
operator|*
name|sa
operator|)
operator|->
name|target_off
operator|-
operator|(
operator|*
name|sb
operator|)
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|-
operator|(
operator|*
name|sb
operator|)
operator|->
name|target_section
operator|->
name|output_offset
operator|-
operator|(
operator|*
name|sb
operator|)
operator|->
name|target_off
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
return|return
name|d
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
comment|/* Two functions at the same address.  Aliases perhaps.  */
name|i
operator|=
name|strcmp
argument_list|(
operator|(
operator|*
name|sb
operator|)
operator|->
name|root
operator|.
name|string
argument_list|,
operator|(
operator|*
name|sa
operator|)
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|i
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Allocate space for overlay call and return stubs.  */
end_comment

begin_function
name|bfd_boolean
name|spu_elf_size_stubs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|int
name|non_overlay_stubs
parameter_list|,
name|int
name|stack_analysis
parameter_list|,
name|asection
modifier|*
modifier|*
name|stub
parameter_list|,
name|asection
modifier|*
modifier|*
name|ovtab
parameter_list|,
name|asection
modifier|*
modifier|*
name|toe
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|struct
name|stubarr
name|stubs
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|group
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|htab
operator|->
name|non_overlay_stubs
operator|=
name|non_overlay_stubs
expr_stmt|;
name|stubs
operator|.
name|stub_hash_table
operator|=
operator|&
name|htab
operator|->
name|stub_hash_table
expr_stmt|;
name|stubs
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|stubs
operator|.
name|err
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_spu_vec
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|psyms
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|!=
operator|&
name|bfd_elf32_spu_vec
condition|)
continue|continue;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
comment|/* Arrange to read and keep global syms for later stack analysis.  */
name|psyms
operator|=
operator|&
name|local_syms
expr_stmt|;
if|if
condition|(
name|stack_analysis
condition|)
name|psyms
operator|=
operator|&
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
comment|/* Walk over each section attached to the input bfd.  */
for|for
control|(
name|section
operator|=
name|ibfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|,
modifier|*
name|irelaend
decl_stmt|,
modifier|*
name|irela
decl_stmt|;
comment|/* If there aren't any relocs, then there's nothing more to do.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this section is a link-once section that will be 	     discarded, then don't create any stubs.  */
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|section
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|output_bfd
condition|)
continue|continue;
comment|/* Get the relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_local
goto|;
comment|/* Now examine each relocation.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
control|)
block|{
name|enum
name|elf_spu_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|int
name|r_indx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|char
modifier|*
name|stub_name
decl_stmt|;
name|struct
name|spu_stub_hash_entry
modifier|*
name|sh
decl_stmt|;
name|unsigned
name|int
name|sym_type
decl_stmt|;
enum|enum
name|_insn_type
block|{
name|non_branch
block|,
name|branch
block|,
name|call
block|}
name|insn_type
enum|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>=
name|R_SPU_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
comment|/* Determine the reloc target section.  */
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|psyms
argument_list|,
name|r_indx
argument_list|,
name|ibfd
argument_list|)
condition|)
goto|goto
name|error_ret_free_internal
goto|;
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|output_bfd
condition|)
continue|continue;
comment|/* Ensure no stubs for user supplied overlay manager syms.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"__ovly_load"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"__ovly_return"
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|insn_type
operator|=
name|non_branch
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPU_REL16
operator|||
name|r_type
operator|==
name|R_SPU_ADDR16
condition|)
block|{
name|unsigned
name|char
name|insn
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|ibfd
argument_list|,
name|section
argument_list|,
name|insn
argument_list|,
name|irela
operator|->
name|r_offset
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|error_ret_free_internal
goto|;
if|if
condition|(
name|is_branch
argument_list|(
name|insn
argument_list|)
operator|||
name|is_hint
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insn_type
operator|=
name|branch
expr_stmt|;
if|if
condition|(
operator|(
name|insn
index|[
literal|0
index|]
operator|&
literal|0xfd
operator|)
operator|==
literal|0x31
condition|)
name|insn_type
operator|=
name|call
expr_stmt|;
block|}
block|}
comment|/* We are only interested in function symbols.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|sym_type
operator|=
name|h
operator|->
name|type
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
else|else
block|{
name|sym_type
operator|=
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_sym_name
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|,
name|symtab_hdr
argument_list|,
name|sym
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym_type
operator|!=
name|STT_FUNC
condition|)
block|{
comment|/* It's common for people to write assembly and forget 		     to give function symbols the right type.  Handle 		     calls to such symbols, but warn so that (hopefully) 		     people will fix their code.  We need the symbol 		     type to be correct to distinguish function pointer 		     initialisation from other pointer initialisation.  */
if|if
condition|(
name|insn_type
operator|==
name|call
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"warning: call to non-function"
literal|" symbol %s defined in %B"
argument_list|)
argument_list|,
name|sym_sec
operator|->
name|owner
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
else|else
continue|continue;
block|}
if|if
condition|(
operator|!
name|needs_ovl_stub
argument_list|(
name|sym_name
argument_list|,
name|sym_sec
argument_list|,
name|section
argument_list|,
name|htab
argument_list|,
name|insn_type
operator|!=
name|non_branch
argument_list|)
condition|)
continue|continue;
name|stub_name
operator|=
name|spu_stub_name
argument_list|(
name|sym_sec
argument_list|,
name|h
argument_list|,
name|irela
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_internal
goto|;
name|sh
operator|=
operator|(
expr|struct
name|spu_stub_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
name|error_ret_free_internal
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|error_ret_free_local
label|:
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
operator|)
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If this entry isn't new, we already have a stub.  */
if|if
condition|(
name|sh
operator|->
name|target_section
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sh
operator|->
name|target_section
operator|=
name|sym_sec
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|sh
operator|->
name|target_off
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|sh
operator|->
name|target_off
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|sh
operator|->
name|target_off
operator|+=
name|irela
operator|->
name|r_addend
expr_stmt|;
name|stubs
operator|.
name|count
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* We're done with the internal relocs, free them.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
block|}
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_spuear_stubs
argument_list|,
operator|&
name|stubs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stubs
operator|.
name|err
condition|)
return|return
name|FALSE
return|;
operator|*
name|stub
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stubs
operator|.
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator|)
expr_stmt|;
name|htab
operator|->
name|stub
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|ibfd
argument_list|,
literal|".stub"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|stub
operator|=
name|htab
operator|->
name|stub
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|stub
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|ibfd
argument_list|,
name|htab
operator|->
name|stub
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator|)
expr_stmt|;
name|htab
operator|->
name|ovtab
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|ibfd
argument_list|,
literal|".ovtab"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|ovtab
operator|=
name|htab
operator|->
name|ovtab
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|ovtab
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|ibfd
argument_list|,
name|htab
operator|->
name|stub
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|toe
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|ibfd
argument_list|,
literal|".toe"
argument_list|,
name|SEC_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|toe
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|ibfd
argument_list|,
operator|*
name|toe
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|(
operator|*
name|toe
operator|)
operator|->
name|size
operator|=
literal|16
expr_stmt|;
comment|/* Retrieve all the stubs and sort.  */
name|stubs
operator|.
name|sh
operator|=
name|bfd_malloc
argument_list|(
name|stubs
operator|.
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stubs
operator|.
name|sh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stubs
operator|.
name|sh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|i
operator|=
name|stubs
operator|.
name|count
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|populate_stubs
argument_list|,
operator|&
name|stubs
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|stubs
operator|.
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|stubs
operator|.
name|count
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|stubs
operator|.
name|sh
argument_list|,
name|stubs
operator|.
name|count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stubs
operator|.
name|sh
argument_list|)
argument_list|,
name|sort_stubs
argument_list|)
expr_stmt|;
comment|/* Now that the stubs are sorted, place them in the stub section.      Stubs are grouped per overlay      .	    ila $79,func1      .	    br 1f      .	    ila $79,func2      .	    br 1f      .      .      .	    ila $79,funcn      .	    nop      .	1:      .	    ila $78,ovl_index      .	    br __ovly_load  */
name|group
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stubs
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spu_elf_section_data
argument_list|(
name|stubs
operator|.
name|sh
index|[
name|group
index|]
operator|->
name|target_section
operator|->
name|output_section
argument_list|)
operator|->
name|ovl_index
operator|!=
name|spu_elf_section_data
argument_list|(
name|stubs
operator|.
name|sh
index|[
name|i
index|]
operator|->
name|target_section
operator|->
name|output_section
argument_list|)
operator|->
name|ovl_index
condition|)
block|{
name|htab
operator|->
name|stub
operator|->
name|size
operator|+=
name|SIZEOF_STUB2
expr_stmt|;
for|for
control|(
init|;
name|group
operator|!=
name|i
condition|;
name|group
operator|++
control|)
name|stubs
operator|.
name|sh
index|[
name|group
index|]
operator|->
name|delta
operator|=
name|stubs
operator|.
name|sh
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|off
operator|-
name|stubs
operator|.
name|sh
index|[
name|group
index|]
operator|->
name|off
expr_stmt|;
block|}
if|if
condition|(
name|group
operator|==
name|i
operator|||
operator|(
operator|(
name|stubs
operator|.
name|sh
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|stubs
operator|.
name|sh
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stubs
operator|.
name|sh
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|target_off
operator|)
operator|!=
operator|(
name|stubs
operator|.
name|sh
index|[
name|i
index|]
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|stubs
operator|.
name|sh
index|[
name|i
index|]
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stubs
operator|.
name|sh
index|[
name|i
index|]
operator|->
name|target_off
operator|)
operator|)
condition|)
block|{
name|stubs
operator|.
name|sh
index|[
name|i
index|]
operator|->
name|off
operator|=
name|htab
operator|->
name|stub
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|stub
operator|->
name|size
operator|+=
name|SIZEOF_STUB1
expr_stmt|;
block|}
else|else
name|stubs
operator|.
name|sh
index|[
name|i
index|]
operator|->
name|off
operator|=
name|stubs
operator|.
name|sh
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|off
expr_stmt|;
block|}
if|if
condition|(
name|group
operator|!=
name|i
condition|)
name|htab
operator|->
name|stub
operator|->
name|size
operator|+=
name|SIZEOF_STUB2
expr_stmt|;
for|for
control|(
init|;
name|group
operator|!=
name|i
condition|;
name|group
operator|++
control|)
name|stubs
operator|.
name|sh
index|[
name|group
index|]
operator|->
name|delta
operator|=
name|stubs
operator|.
name|sh
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|off
operator|-
name|stubs
operator|.
name|sh
index|[
name|group
index|]
operator|->
name|off
expr_stmt|;
comment|/* htab->ovtab consists of two arrays.     .	struct {     .	  u32 vma;     .	  u32 size;     .	  u32 file_off;     .	  u32 buf;     .	} _ovly_table[];     .     .	struct {     .	  u32 mapped;     .	} _ovly_buf_table[];  */
name|htab
operator|->
name|ovtab
operator|->
name|alignment_power
operator|=
literal|4
expr_stmt|;
name|htab
operator|->
name|ovtab
operator|->
name|size
operator|=
name|htab
operator|->
name|num_overlays
operator|*
literal|16
operator|+
name|htab
operator|->
name|num_buf
operator|*
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Functions to handle embedded spu_ovl.o object.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ovl_mgr_open
parameter_list|(
name|struct
name|bfd
modifier|*
name|nbfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|stream
return|;
block|}
end_function

begin_function
specifier|static
name|file_ptr
name|ovl_mgr_pread
parameter_list|(
name|struct
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|file_ptr
name|nbytes
parameter_list|,
name|file_ptr
name|offset
parameter_list|)
block|{
name|struct
name|_ovl_stream
modifier|*
name|os
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|size_t
name|max
decl_stmt|;
name|os
operator|=
operator|(
expr|struct
name|_ovl_stream
operator|*
operator|)
name|stream
expr_stmt|;
name|max
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|os
operator|->
name|end
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|os
operator|->
name|start
expr_stmt|;
if|if
condition|(
operator|(
name|ufile_ptr
operator|)
name|offset
operator|>=
name|max
condition|)
return|return
literal|0
return|;
name|count
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|max
operator|-
name|offset
condition|)
name|count
operator|=
name|max
operator|-
name|offset
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|os
operator|->
name|start
operator|+
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|spu_elf_open_builtin_lib
parameter_list|(
name|bfd
modifier|*
modifier|*
name|ovl_bfd
parameter_list|,
specifier|const
name|struct
name|_ovl_stream
modifier|*
name|stream
parameter_list|)
block|{
operator|*
name|ovl_bfd
operator|=
name|bfd_openr_iovec
argument_list|(
literal|"builtin ovl_mgr"
argument_list|,
literal|"elf32-spu"
argument_list|,
name|ovl_mgr_open
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stream
argument_list|,
name|ovl_mgr_pread
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|*
name|ovl_bfd
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Fill in the ila and br for a stub.  On the last stub for a group,    write the stub that sets the overlay number too.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|write_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|bh
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|spu_stub_hash_entry
modifier|*
name|ent
init|=
operator|(
expr|struct
name|spu_stub_hash_entry
operator|*
operator|)
name|bh
decl_stmt|;
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|inf
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|htab
operator|->
name|stub
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|ent
operator|->
name|target_section
decl_stmt|;
name|unsigned
name|int
name|ovl
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
name|ent
operator|->
name|target_off
operator|+
name|s
operator|->
name|output_offset
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|bfd_put_32
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|ILA_79
operator|+
operator|(
operator|(
name|val
operator|<<
literal|7
operator|)
operator|&
literal|0x01ffff80
operator|)
argument_list|,
name|sec
operator|->
name|contents
operator|+
name|ent
operator|->
name|off
argument_list|)
expr_stmt|;
name|val
operator|=
name|ent
operator|->
name|delta
operator|+
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|BR
operator|+
operator|(
operator|(
name|val
operator|<<
literal|5
operator|)
operator|&
literal|0x007fff80
operator|)
argument_list|,
name|sec
operator|->
name|contents
operator|+
name|ent
operator|->
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* If this is the last stub of this group, write stub2.  */
if|if
condition|(
name|ent
operator|->
name|delta
operator|==
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|NOP
argument_list|,
name|sec
operator|->
name|contents
operator|+
name|ent
operator|->
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|ovl
operator|=
name|spu_elf_section_data
argument_list|(
name|s
operator|->
name|output_section
argument_list|)
operator|->
name|ovl_index
expr_stmt|;
name|bfd_put_32
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|ILA_78
operator|+
operator|(
operator|(
name|ovl
operator|<<
literal|7
operator|)
operator|&
literal|0x01ffff80
operator|)
argument_list|,
name|sec
operator|->
name|contents
operator|+
name|ent
operator|->
name|off
operator|+
literal|8
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|htab
operator|->
name|ovly_load
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|ovly_load
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|ovly_load
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|off
operator|+
literal|12
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|+
literal|0x20000
operator|>=
literal|0x40000
condition|)
name|htab
operator|->
name|stub_overflow
operator|=
name|TRUE
expr_stmt|;
name|bfd_put_32
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|BR
operator|+
operator|(
operator|(
name|val
operator|<<
literal|5
operator|)
operator|&
literal|0x007fff80
operator|)
argument_list|,
name|sec
operator|->
name|contents
operator|+
name|ent
operator|->
name|off
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|emit_stub_syms
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|len1
operator|=
sizeof|sizeof
argument_list|(
literal|"00000000.ovl_call."
argument_list|)
operator|-
literal|1
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|ent
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_malloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
literal|"00000000.ovl_call."
argument_list|,
name|len1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
operator|+
name|len1
argument_list|,
name|ent
operator|->
name|root
operator|.
name|string
argument_list|,
name|len2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|ent
operator|->
name|off
expr_stmt|;
name|h
operator|->
name|size
operator|=
operator|(
name|ent
operator|->
name|delta
operator|==
literal|0
condition|?
name|SIZEOF_STUB1
operator|+
name|SIZEOF_STUB2
else|:
name|SIZEOF_STUB1
operator|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
name|h
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Define an STT_OBJECT symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|define_ovtab_symbol
parameter_list|(
name|struct
name|spu_link_hash_table
modifier|*
name|htab
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|||
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|ovtab
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
name|h
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B is not allowed to define %s"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Fill in all stubs and the overlay tables.  */
end_comment

begin_function
name|bfd_boolean
name|spu_elf_build_stubs
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|int
name|emit_syms
parameter_list|,
name|asection
modifier|*
name|toe
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|htab
operator|->
name|emit_stub_syms
operator|=
name|emit_syms
expr_stmt|;
name|htab
operator|->
name|stub
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|stub
operator|->
name|owner
argument_list|,
name|htab
operator|->
name|stub
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|stub
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
literal|"__ovly_load"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|htab
operator|->
name|ovly_load
operator|=
name|h
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|def_regular
argument_list|)
expr_stmt|;
name|s
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|spu_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|ovl_index
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s in overlay section"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Write out all the stubs.  */
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|write_one_stub
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|stub_overflow
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"overlay stub relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|htab
operator|->
name|ovtab
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|ovtab
operator|->
name|owner
argument_list|,
name|htab
operator|->
name|ovtab
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|ovtab
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Write out _ovly_table.  */
name|p
operator|=
name|htab
operator|->
name|ovtab
operator|->
name|contents
expr_stmt|;
name|obfd
operator|=
name|htab
operator|->
name|ovtab
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|ovl_index
init|=
name|spu_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|ovl_index
decl_stmt|;
if|if
condition|(
name|ovl_index
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|mid
decl_stmt|;
name|unsigned
name|long
name|off
init|=
operator|(
name|ovl_index
operator|-
literal|1
operator|)
operator|*
literal|16
decl_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|ovtab
operator|->
name|owner
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|p
operator|+
name|off
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|ovtab
operator|->
name|owner
argument_list|,
operator|(
name|s
operator|->
name|size
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
argument_list|,
name|p
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* file_off written later in spu_elf_modify_program_headers.  */
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|htab
operator|->
name|num_buf
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|ovl_region
index|[
literal|2
operator|*
name|mid
operator|+
literal|1
index|]
operator|->
name|vma
operator|+
name|htab
operator|->
name|ovl_region
index|[
literal|2
operator|*
name|mid
operator|+
literal|1
index|]
operator|->
name|size
operator|<=
name|s
operator|->
name|vma
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|htab
operator|->
name|ovl_region
index|[
literal|2
operator|*
name|mid
index|]
operator|->
name|vma
operator|>
name|s
operator|->
name|vma
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|ovtab
operator|->
name|owner
argument_list|,
name|mid
operator|+
literal|1
argument_list|,
name|p
operator|+
name|off
operator|+
literal|12
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|lo
operator|<
name|hi
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write out _ovly_buf_table.  */
name|p
operator|=
name|htab
operator|->
name|ovtab
operator|->
name|contents
operator|+
name|htab
operator|->
name|num_overlays
operator|*
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|htab
operator|->
name|num_buf
condition|;
name|i
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|ovtab
operator|->
name|owner
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|h
operator|=
name|define_ovtab_symbol
argument_list|(
name|htab
argument_list|,
literal|"_ovly_table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|size
operator|=
name|htab
operator|->
name|num_overlays
operator|*
literal|16
expr_stmt|;
name|h
operator|=
name|define_ovtab_symbol
argument_list|(
name|htab
argument_list|,
literal|"_ovly_table_end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|htab
operator|->
name|num_overlays
operator|*
literal|16
expr_stmt|;
name|h
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|define_ovtab_symbol
argument_list|(
name|htab
argument_list|,
literal|"_ovly_buf_table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|htab
operator|->
name|num_overlays
operator|*
literal|16
expr_stmt|;
name|h
operator|->
name|size
operator|=
name|htab
operator|->
name|num_buf
operator|*
literal|4
expr_stmt|;
name|h
operator|=
name|define_ovtab_symbol
argument_list|(
name|htab
argument_list|,
literal|"_ovly_buf_table_end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|htab
operator|->
name|num_overlays
operator|*
literal|16
operator|+
name|htab
operator|->
name|num_buf
operator|*
literal|4
expr_stmt|;
name|h
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|define_ovtab_symbol
argument_list|(
name|htab
argument_list|,
literal|"_EAR_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|toe
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|size
operator|=
literal|16
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* OFFSET in SEC (presumably) is the beginning of a function prologue.    Search for stack adjusting insns, and return the sp delta.  */
end_comment

begin_function
specifier|static
name|int
name|find_function_stack_adjust
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|int
name|unrecog
decl_stmt|;
name|int
name|reg
index|[
literal|128
index|]
decl_stmt|;
name|memset
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unrecog
operator|=
literal|0
init|;
name|offset
operator|+
literal|4
operator|<=
name|sec
operator|->
name|size
operator|&&
name|unrecog
operator|<
literal|32
condition|;
name|offset
operator|+=
literal|4
control|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|rt
decl_stmt|,
name|ra
decl_stmt|;
name|int
name|imm
decl_stmt|;
comment|/* Assume no relocs on stack adjusing insns.  */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
condition|)
break|break;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0x24
comment|/* stqd */
condition|)
continue|continue;
name|rt
operator|=
name|buf
index|[
literal|3
index|]
operator|&
literal|0x7f
expr_stmt|;
name|ra
operator|=
operator|(
operator|(
name|buf
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|buf
index|[
literal|3
index|]
operator|>>
literal|7
operator|)
expr_stmt|;
comment|/* Partly decoded immediate field.  */
name|imm
operator|=
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|9
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|1
operator|)
operator||
operator|(
name|buf
index|[
literal|3
index|]
operator|>>
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0x1c
comment|/* ai */
condition|)
block|{
name|imm
operator|>>=
literal|7
expr_stmt|;
name|imm
operator|=
operator|(
name|imm
operator|^
literal|0x200
operator|)
operator|-
literal|0x200
expr_stmt|;
name|reg
index|[
name|rt
index|]
operator|=
name|reg
index|[
name|ra
index|]
operator|+
name|imm
expr_stmt|;
if|if
condition|(
name|rt
operator|==
literal|1
comment|/* sp */
condition|)
block|{
if|if
condition|(
name|imm
operator|>
literal|0
condition|)
break|break;
return|return
name|reg
index|[
name|rt
index|]
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0x18
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0xe0
operator|)
operator|==
literal|0
comment|/* a */
condition|)
block|{
name|int
name|rb
init|=
operator|(
operator|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0x1f
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|buf
index|[
literal|2
index|]
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
operator|)
decl_stmt|;
name|reg
index|[
name|rt
index|]
operator|=
name|reg
index|[
name|ra
index|]
operator|+
name|reg
index|[
name|rb
index|]
expr_stmt|;
if|if
condition|(
name|rt
operator|==
literal|1
condition|)
return|return
name|reg
index|[
name|rt
index|]
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0xfc
operator|)
operator|==
literal|0x40
comment|/* il, ilh, ilhu, ila */
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|>=
literal|0x42
comment|/* ila */
condition|)
name|imm
operator||=
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|<<
literal|17
expr_stmt|;
else|else
block|{
name|imm
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0x40
comment|/* il */
condition|)
block|{
if|if
condition|(
operator|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
goto|goto
name|unknown_insn
goto|;
name|imm
operator|=
operator|(
name|imm
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
comment|/* ilhu */
condition|)
name|imm
operator|<<=
literal|16
expr_stmt|;
block|}
name|reg
index|[
name|rt
index|]
operator|=
name|imm
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0x60
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|!=
literal|0
comment|/* iohl */
condition|)
block|{
name|reg
index|[
name|rt
index|]
operator||=
name|imm
operator|&
literal|0xffff
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0x04
comment|/* ori */
condition|)
block|{
name|imm
operator|>>=
literal|7
expr_stmt|;
name|imm
operator|=
operator|(
name|imm
operator|^
literal|0x200
operator|)
operator|-
literal|0x200
expr_stmt|;
name|reg
index|[
name|rt
index|]
operator|=
name|reg
index|[
name|ra
index|]
operator||
name|imm
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0x33
operator|&&
name|imm
operator|==
literal|1
comment|/* brsl .+4 */
operator|)
operator|||
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0x08
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0xe0
operator|)
operator|==
literal|0
comment|/* sf */
operator|)
condition|)
block|{
comment|/* Used in pic reg load.  Say rt is trashed.  */
name|reg
index|[
name|rt
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|is_branch
argument_list|(
name|buf
argument_list|)
condition|)
comment|/* If we hit a branch then we must be out of the prologue.  */
break|break;
name|unknown_insn
label|:
operator|++
name|unrecog
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* qsort predicate to sort symbols by section and value.  */
end_comment

begin_decl_stmt
specifier|static
name|Elf_Internal_Sym
modifier|*
name|sort_syms_syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
modifier|*
name|sort_syms_psecs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sort_syms
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|Elf_Internal_Sym
modifier|*
specifier|const
modifier|*
name|s1
init|=
name|a
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
specifier|const
modifier|*
name|s2
init|=
name|b
decl_stmt|;
name|asection
modifier|*
name|sec1
decl_stmt|,
modifier|*
name|sec2
decl_stmt|;
name|bfd_signed_vma
name|delta
decl_stmt|;
name|sec1
operator|=
name|sort_syms_psecs
index|[
operator|*
name|s1
operator|-
name|sort_syms_syms
index|]
expr_stmt|;
name|sec2
operator|=
name|sort_syms_psecs
index|[
operator|*
name|s2
operator|-
name|sort_syms_syms
index|]
expr_stmt|;
if|if
condition|(
name|sec1
operator|!=
name|sec2
condition|)
return|return
name|sec1
operator|->
name|index
operator|-
name|sec2
operator|->
name|index
return|;
name|delta
operator|=
operator|(
operator|*
name|s1
operator|)
operator|->
name|st_value
operator|-
operator|(
operator|*
name|s2
operator|)
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
return|return
name|delta
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
name|delta
operator|=
operator|(
operator|*
name|s2
operator|)
operator|->
name|st_size
operator|-
operator|(
operator|*
name|s1
operator|)
operator|->
name|st_size
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
return|return
name|delta
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
return|return
operator|*
name|s1
operator|<
operator|*
name|s2
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_struct
struct|struct
name|call_info
block|{
name|struct
name|function_info
modifier|*
name|fun
decl_stmt|;
name|struct
name|call_info
modifier|*
name|next
decl_stmt|;
name|int
name|is_tail
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|function_info
block|{
comment|/* List of functions called.  Also branches to hot/cold part of      function.  */
name|struct
name|call_info
modifier|*
name|call_list
decl_stmt|;
comment|/* For hot/cold part of function, point to owner.  */
name|struct
name|function_info
modifier|*
name|start
decl_stmt|;
comment|/* Symbol at start of function.  */
union|union
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|}
name|u
union|;
comment|/* Function section.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Address range of (this part of) function.  */
name|bfd_vma
name|lo
decl_stmt|,
name|hi
decl_stmt|;
comment|/* Stack usage.  */
name|int
name|stack
decl_stmt|;
comment|/* Set if global symbol.  */
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
comment|/* Set if known to be start of function (as distinct from a hunk      in hot/cold section.  */
name|unsigned
name|int
name|is_func
range|:
literal|1
decl_stmt|;
comment|/* Flags used during call tree traversal.  */
name|unsigned
name|int
name|visit1
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|non_root
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|visit2
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|marking
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|visit3
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|spu_elf_stack_info
block|{
name|int
name|num_fun
decl_stmt|;
name|int
name|max_fun
decl_stmt|;
comment|/* Variable size array describing functions, one per contiguous      address range belonging to a function.  */
name|struct
name|function_info
name|fun
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate a struct spu_elf_stack_info with MAX_FUN struct function_info    entries for section SEC.  */
end_comment

begin_function
specifier|static
name|struct
name|spu_elf_stack_info
modifier|*
name|alloc_stack_info
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|int
name|max_fun
parameter_list|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
init|=
name|spu_elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|spu_elf_stack_info
argument_list|)
expr_stmt|;
name|amt
operator|+=
operator|(
name|max_fun
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|function_info
argument_list|)
expr_stmt|;
name|sec_data
operator|->
name|stack_info
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_data
operator|->
name|stack_info
operator|!=
name|NULL
condition|)
name|sec_data
operator|->
name|stack_info
operator|->
name|max_fun
operator|=
name|max_fun
expr_stmt|;
return|return
name|sec_data
operator|->
name|stack_info
return|;
block|}
end_function

begin_comment
comment|/* Add a new struct function_info describing a (part of a) function    starting at SYM_H.  Keep the array sorted by address.  */
end_comment

begin_function
specifier|static
name|struct
name|function_info
modifier|*
name|maybe_insert_function
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|sym_h
parameter_list|,
name|bfd_boolean
name|global
parameter_list|,
name|bfd_boolean
name|is_func
parameter_list|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
init|=
name|spu_elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|struct
name|spu_elf_stack_info
modifier|*
name|sinfo
init|=
name|sec_data
operator|->
name|stack_info
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|sinfo
operator|==
name|NULL
condition|)
block|{
name|sinfo
operator|=
name|alloc_stack_info
argument_list|(
name|sec
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|sinfo
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|global
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
init|=
name|sym_h
decl_stmt|;
name|off
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|size
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
block|}
else|else
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|sym_h
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|size
operator|=
name|h
operator|->
name|size
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|sinfo
operator|->
name|num_fun
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|lo
operator|<=
name|off
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
comment|/* Don't add another entry for an alias, but do update some 	 info.  */
if|if
condition|(
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|lo
operator|==
name|off
condition|)
block|{
comment|/* Prefer globals over local syms.  */
if|if
condition|(
name|global
operator|&&
operator|!
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|global
condition|)
block|{
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|global
operator|=
name|TRUE
expr_stmt|;
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|u
operator|.
name|h
operator|=
name|sym_h
expr_stmt|;
block|}
if|if
condition|(
name|is_func
condition|)
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|is_func
operator|=
name|TRUE
expr_stmt|;
return|return
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
return|;
block|}
comment|/* Ignore a zero-size symbol inside an existing function.  */
elseif|else
if|if
condition|(
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|hi
operator|>
name|off
operator|&&
name|size
operator|==
literal|0
condition|)
return|return
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
return|;
block|}
if|if
condition|(
operator|++
name|i
operator|<
name|sinfo
operator|->
name|num_fun
condition|)
name|memmove
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
argument_list|,
operator|(
name|sinfo
operator|->
name|num_fun
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>=
name|sinfo
operator|->
name|max_fun
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|spu_elf_stack_info
argument_list|)
decl_stmt|;
name|bfd_size_type
name|old
init|=
name|amt
decl_stmt|;
name|old
operator|+=
operator|(
name|sinfo
operator|->
name|max_fun
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|function_info
argument_list|)
expr_stmt|;
name|sinfo
operator|->
name|max_fun
operator|+=
literal|20
operator|+
operator|(
name|sinfo
operator|->
name|max_fun
operator|>>
literal|1
operator|)
expr_stmt|;
name|amt
operator|+=
operator|(
name|sinfo
operator|->
name|max_fun
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|function_info
argument_list|)
expr_stmt|;
name|sinfo
operator|=
name|bfd_realloc
argument_list|(
name|sinfo
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sinfo
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sinfo
operator|+
name|old
argument_list|,
literal|0
argument_list|,
name|amt
operator|-
name|old
argument_list|)
expr_stmt|;
name|sec_data
operator|->
name|stack_info
operator|=
name|sinfo
expr_stmt|;
block|}
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|is_func
operator|=
name|is_func
expr_stmt|;
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|global
operator|=
name|global
expr_stmt|;
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|sec
operator|=
name|sec
expr_stmt|;
if|if
condition|(
name|global
condition|)
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|u
operator|.
name|h
operator|=
name|sym_h
expr_stmt|;
else|else
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|sym_h
expr_stmt|;
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|lo
operator|=
name|off
expr_stmt|;
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|hi
operator|=
name|off
operator|+
name|size
expr_stmt|;
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|stack
operator|=
operator|-
name|find_function_stack_adjust
argument_list|(
name|sec
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|sinfo
operator|->
name|num_fun
operator|+=
literal|1
expr_stmt|;
return|return
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the name of FUN.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|func_name
parameter_list|(
name|struct
name|function_info
modifier|*
name|fun
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
while|while
condition|(
name|fun
operator|->
name|start
operator|!=
name|NULL
condition|)
name|fun
operator|=
name|fun
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|fun
operator|->
name|global
condition|)
return|return
name|fun
operator|->
name|u
operator|.
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
return|;
name|sec
operator|=
name|fun
operator|->
name|sec
expr_stmt|;
if|if
condition|(
name|fun
operator|->
name|u
operator|.
name|sym
operator|->
name|st_name
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_malloc
argument_list|(
name|len
operator|+
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
literal|"(null)"
return|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s+%lx"
argument_list|,
name|sec
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fun
operator|->
name|u
operator|.
name|sym
operator|->
name|st_value
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
name|ibfd
operator|=
name|sec
operator|->
name|owner
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
return|return
name|bfd_elf_sym_name
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|fun
operator|->
name|u
operator|.
name|sym
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the instruction at OFF in SEC.  Return true iff the instruction    is a nop, lnop, or stop 0 (all zero insn).  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_nop
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|off
parameter_list|)
block|{
name|unsigned
name|char
name|insn
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|off
operator|+
literal|4
operator|>
name|sec
operator|->
name|size
operator|||
operator|!
name|bfd_get_section_contents
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|insn
argument_list|,
name|off
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|insn
index|[
literal|0
index|]
operator|&
literal|0xbf
operator|)
operator|==
literal|0
operator|&&
operator|(
name|insn
index|[
literal|1
index|]
operator|&
literal|0xe0
operator|)
operator|==
literal|0x20
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|insn
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|insn
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|insn
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|insn
index|[
literal|3
index|]
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Extend the range of FUN to cover nop padding up to LIMIT.    Return TRUE iff some instruction other than a NOP was found.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|insns_at_end
parameter_list|(
name|struct
name|function_info
modifier|*
name|fun
parameter_list|,
name|bfd_vma
name|limit
parameter_list|)
block|{
name|bfd_vma
name|off
init|=
operator|(
name|fun
operator|->
name|hi
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
decl_stmt|;
while|while
condition|(
name|off
operator|<
name|limit
operator|&&
name|is_nop
argument_list|(
name|fun
operator|->
name|sec
argument_list|,
name|off
argument_list|)
condition|)
name|off
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|limit
condition|)
block|{
name|fun
operator|->
name|hi
operator|=
name|off
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|fun
operator|->
name|hi
operator|=
name|limit
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Check and fix overlapping function ranges.  Return TRUE iff there    are gaps in the current info we have about functions in SEC.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|check_function_ranges
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
init|=
name|spu_elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|struct
name|spu_elf_stack_info
modifier|*
name|sinfo
init|=
name|sec_data
operator|->
name|stack_info
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bfd_boolean
name|gaps
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|sinfo
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sinfo
operator|->
name|num_fun
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sinfo
operator|->
name|fun
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|hi
operator|>
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|lo
condition|)
block|{
comment|/* Fix overlapping symbols.  */
specifier|const
name|char
modifier|*
name|f1
init|=
name|func_name
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|f2
init|=
name|func_name
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|einfo
argument_list|(
name|_
argument_list|(
literal|"warning: %s overlaps %s\n"
argument_list|)
argument_list|,
name|f1
argument_list|,
name|f2
argument_list|)
expr_stmt|;
name|sinfo
operator|->
name|fun
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|hi
operator|=
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|lo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insns_at_end
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|lo
argument_list|)
condition|)
name|gaps
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sinfo
operator|->
name|num_fun
operator|==
literal|0
condition|)
name|gaps
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sinfo
operator|->
name|fun
index|[
literal|0
index|]
operator|.
name|lo
operator|!=
literal|0
condition|)
name|gaps
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sinfo
operator|->
name|fun
index|[
name|sinfo
operator|->
name|num_fun
operator|-
literal|1
index|]
operator|.
name|hi
operator|>
name|sec
operator|->
name|size
condition|)
block|{
specifier|const
name|char
modifier|*
name|f1
init|=
name|func_name
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|sinfo
operator|->
name|num_fun
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|einfo
argument_list|(
name|_
argument_list|(
literal|"warning: %s exceeds section size\n"
argument_list|)
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|sinfo
operator|->
name|fun
index|[
name|sinfo
operator|->
name|num_fun
operator|-
literal|1
index|]
operator|.
name|hi
operator|=
name|sec
operator|->
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insns_at_end
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|sinfo
operator|->
name|num_fun
operator|-
literal|1
index|]
argument_list|,
name|sec
operator|->
name|size
argument_list|)
condition|)
name|gaps
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|gaps
return|;
block|}
end_function

begin_comment
comment|/* Search current function info for a function that contains address    OFFSET in section SEC.  */
end_comment

begin_function
specifier|static
name|struct
name|function_info
modifier|*
name|find_function
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
init|=
name|spu_elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|struct
name|spu_elf_stack_info
modifier|*
name|sinfo
init|=
name|sec_data
operator|->
name|stack_info
decl_stmt|;
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|mid
decl_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|sinfo
operator|->
name|num_fun
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|sinfo
operator|->
name|fun
index|[
name|mid
index|]
operator|.
name|lo
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>=
name|sinfo
operator|->
name|fun
index|[
name|mid
index|]
operator|.
name|hi
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
return|return
operator|&
name|sinfo
operator|->
name|fun
index|[
name|mid
index|]
return|;
block|}
name|info
operator|->
name|callbacks
operator|->
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%A:0x%v not found in function table\n"
argument_list|)
argument_list|,
name|sec
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Add CALLEE to CALLER call list if not already present.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|insert_callee
parameter_list|(
name|struct
name|function_info
modifier|*
name|caller
parameter_list|,
name|struct
name|call_info
modifier|*
name|callee
parameter_list|)
block|{
name|struct
name|call_info
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|caller
operator|->
name|call_list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|fun
operator|==
name|callee
operator|->
name|fun
condition|)
block|{
comment|/* Tail calls use less stack than normal calls.  Retain entry 	   for normal call over one for tail call.  */
if|if
condition|(
name|p
operator|->
name|is_tail
operator|>
name|callee
operator|->
name|is_tail
condition|)
name|p
operator|->
name|is_tail
operator|=
name|callee
operator|->
name|is_tail
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|callee
operator|->
name|next
operator|=
name|caller
operator|->
name|call_list
expr_stmt|;
name|caller
operator|->
name|call_list
operator|=
name|callee
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Rummage through the relocs for SEC, looking for function calls.    If CALL_TREE is true, fill in call graph.  If CALL_TREE is false,    mark destination symbols on calls as being functions.  Also    look at branches, which may be tail calls or go to hot/cold    section part of same function.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mark_functions_via_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|int
name|call_tree
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|,
modifier|*
name|irelaend
decl_stmt|,
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|syms
decl_stmt|;
name|void
modifier|*
name|psyms
decl_stmt|;
specifier|static
name|bfd_boolean
name|warned
decl_stmt|;
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|psyms
operator|=
operator|&
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|syms
operator|=
operator|*
operator|(
name|Elf_Internal_Sym
operator|*
operator|*
operator|)
name|psyms
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
control|)
block|{
name|enum
name|elf_spu_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|int
name|r_indx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|unsigned
name|char
name|insn
index|[
literal|4
index|]
decl_stmt|;
name|bfd_boolean
name|is_call
decl_stmt|;
name|struct
name|function_info
modifier|*
name|caller
decl_stmt|;
name|struct
name|call_info
modifier|*
name|callee
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_SPU_REL16
operator|&&
name|r_type
operator|!=
name|R_SPU_ADDR16
condition|)
continue|continue;
name|r_indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|psyms
argument_list|,
name|r_indx
argument_list|,
name|sec
operator|->
name|owner
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|sec
operator|->
name|output_section
operator|->
name|owner
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|insn
argument_list|,
name|irela
operator|->
name|r_offset
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|is_branch
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sym_sec
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator|)
operator|)
operator|!=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|call_tree
condition|)
name|warned
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|call_tree
operator|||
operator|!
name|warned
condition|)
name|info
operator|->
name|callbacks
operator|->
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%v): call to non-code section"
literal|" %B(%A), stack analysis incomplete\n"
argument_list|)
argument_list|,
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|irela
operator|->
name|r_offset
argument_list|,
name|sym_sec
operator|->
name|owner
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|is_call
operator|=
operator|(
name|insn
index|[
literal|0
index|]
operator|&
literal|0xfd
operator|)
operator|==
literal|0x31
expr_stmt|;
if|if
condition|(
name|h
condition|)
name|val
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|val
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|val
operator|+=
name|irela
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
operator|!
name|call_tree
condition|)
block|{
name|struct
name|function_info
modifier|*
name|fun
decl_stmt|;
if|if
condition|(
name|irela
operator|->
name|r_addend
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|fake
init|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fake
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fake
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|fake
operator|->
name|st_value
operator|=
name|val
expr_stmt|;
name|fake
operator|->
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
name|sym
operator|=
name|fake
expr_stmt|;
block|}
if|if
condition|(
name|sym
condition|)
name|fun
operator|=
name|maybe_insert_function
argument_list|(
name|sym_sec
argument_list|,
name|sym
argument_list|,
name|FALSE
argument_list|,
name|is_call
argument_list|)
expr_stmt|;
else|else
name|fun
operator|=
name|maybe_insert_function
argument_list|(
name|sym_sec
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|,
name|is_call
argument_list|)
expr_stmt|;
if|if
condition|(
name|fun
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|irela
operator|->
name|r_addend
operator|!=
literal|0
operator|&&
name|fun
operator|->
name|u
operator|.
name|sym
operator|!=
name|sym
condition|)
name|free
argument_list|(
name|sym
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|caller
operator|=
name|find_function
argument_list|(
name|sec
argument_list|,
name|irela
operator|->
name|r_offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|caller
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|callee
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
expr|*
name|callee
argument_list|)
expr_stmt|;
if|if
condition|(
name|callee
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|callee
operator|->
name|fun
operator|=
name|find_function
argument_list|(
name|sym_sec
argument_list|,
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|callee
operator|->
name|fun
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|callee
operator|->
name|is_tail
operator|=
operator|!
name|is_call
expr_stmt|;
if|if
condition|(
operator|!
name|insert_callee
argument_list|(
name|caller
argument_list|,
name|callee
argument_list|)
condition|)
name|free
argument_list|(
name|callee
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_call
operator|&&
operator|!
name|callee
operator|->
name|fun
operator|->
name|is_func
operator|&&
name|callee
operator|->
name|fun
operator|->
name|stack
operator|==
literal|0
condition|)
block|{
comment|/* This is either a tail call or a branch from one part of 	     the function to another, ie. hot/cold section.  If the 	     destination has been called by some other function then 	     it is a separate function.  We also assume that functions 	     are not split across input files.  */
if|if
condition|(
name|callee
operator|->
name|fun
operator|->
name|start
operator|!=
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|!=
name|sym_sec
operator|->
name|owner
condition|)
block|{
name|callee
operator|->
name|fun
operator|->
name|start
operator|=
name|NULL
expr_stmt|;
name|callee
operator|->
name|fun
operator|->
name|is_func
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|callee
operator|->
name|fun
operator|->
name|start
operator|=
name|caller
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Handle something like .init or .fini, which has a piece of a function.    These sections are pasted together to form a single function.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|pasted_function
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|l
decl_stmt|;
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
decl_stmt|;
name|struct
name|spu_elf_stack_info
modifier|*
name|sinfo
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|fake
decl_stmt|;
name|struct
name|function_info
modifier|*
name|fun
decl_stmt|,
modifier|*
name|fun_start
decl_stmt|;
name|fake
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fake
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fake
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|fake
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|fake
operator|->
name|st_size
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|fake
operator|->
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|fun
operator|=
name|maybe_insert_function
argument_list|(
name|sec
argument_list|,
name|fake
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fun
condition|)
return|return
name|FALSE
return|;
comment|/* Find a function immediately preceding this section.  */
name|fun_start
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|l
operator|=
name|sec
operator|->
name|output_section
operator|->
name|map_head
operator|.
name|link_order
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|==
name|sec
condition|)
block|{
if|if
condition|(
name|fun_start
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fun_start
operator|->
name|start
condition|)
name|fun_start
operator|=
name|fun_start
operator|->
name|start
expr_stmt|;
name|fun
operator|->
name|start
operator|=
name|fun_start
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|l
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
operator|(
name|sec_data
operator|=
name|spu_elf_section_data
argument_list|(
name|l
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|sinfo
operator|=
name|sec_data
operator|->
name|stack_info
operator|)
operator|!=
name|NULL
operator|&&
name|sinfo
operator|->
name|num_fun
operator|!=
literal|0
condition|)
name|fun_start
operator|=
operator|&
name|sinfo
operator|->
name|fun
index|[
name|sinfo
operator|->
name|num_fun
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|info
operator|->
name|callbacks
operator|->
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%A link_order not found\n"
argument_list|)
argument_list|,
name|sec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* We're only interested in code sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|interesting_section
parameter_list|(
name|asection
modifier|*
name|s
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
name|struct
name|spu_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
return|return
operator|(
name|s
operator|!=
name|htab
operator|->
name|stub
operator|&&
name|s
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|output_section
operator|->
name|owner
operator|==
name|obfd
operator|&&
operator|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator|)
operator|)
operator|&&
name|s
operator|->
name|size
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Map address ranges in code sections to functions.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|discover_functions
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|int
name|bfd_idx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
modifier|*
modifier|*
name|psym_arr
decl_stmt|;
name|asection
modifier|*
modifier|*
modifier|*
name|sec_arr
decl_stmt|;
name|bfd_boolean
name|gaps
init|=
name|FALSE
decl_stmt|;
name|bfd_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
name|bfd_idx
operator|++
expr_stmt|;
name|psym_arr
operator|=
name|bfd_zmalloc
argument_list|(
name|bfd_idx
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|psym_arr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym_arr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec_arr
operator|=
name|bfd_zmalloc
argument_list|(
name|bfd_idx
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sec_arr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_arr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_idx
operator|=
literal|0
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
operator|,
name|bfd_idx
operator|++
control|)
block|{
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_spu_vec
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|size_t
name|symcount
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|syms
decl_stmt|,
modifier|*
name|sy
decl_stmt|,
modifier|*
modifier|*
name|psyms
decl_stmt|,
modifier|*
modifier|*
name|psy
decl_stmt|;
name|asection
modifier|*
modifier|*
name|psecs
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|!=
operator|&
name|bfd_elf32_spu_vec
condition|)
continue|continue;
comment|/* Read all the symbols.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|symcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
name|symtab_hdr
operator|->
name|sh_entsize
expr_stmt|;
if|if
condition|(
name|symcount
operator|==
literal|0
condition|)
continue|continue;
name|syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
block|{
name|syms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symcount
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|void
operator|*
operator|)
name|syms
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Select defined function symbols that are going to be output.  */
name|psyms
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|psyms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psyms
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|psym_arr
index|[
name|bfd_idx
index|]
operator|=
name|psyms
expr_stmt|;
name|psecs
operator|=
name|bfd_malloc
argument_list|(
name|symcount
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|psecs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psecs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec_arr
index|[
name|bfd_idx
index|]
operator|=
name|psecs
expr_stmt|;
for|for
control|(
name|psy
operator|=
name|psyms
operator|,
name|p
operator|=
name|psecs
operator|,
name|sy
operator|=
name|syms
init|;
name|sy
operator|<
name|syms
operator|+
name|symcount
condition|;
operator|++
name|p
operator|,
operator|++
name|sy
control|)
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sy
operator|->
name|st_info
argument_list|)
operator|==
name|STT_NOTYPE
operator|||
name|ELF_ST_TYPE
argument_list|(
name|sy
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
operator|*
name|p
operator|=
name|s
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|ibfd
argument_list|,
name|sy
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|interesting_section
argument_list|(
name|s
argument_list|,
name|output_bfd
argument_list|,
name|htab
argument_list|)
condition|)
operator|*
name|psy
operator|++
operator|=
name|sy
expr_stmt|;
block|}
name|symcount
operator|=
name|psy
operator|-
name|psyms
expr_stmt|;
operator|*
name|psy
operator|=
name|NULL
expr_stmt|;
comment|/* Sort them by section and offset within section.  */
name|sort_syms_syms
operator|=
name|syms
expr_stmt|;
name|sort_syms_psecs
operator|=
name|psecs
expr_stmt|;
name|qsort
argument_list|(
name|psyms
argument_list|,
name|symcount
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|psyms
argument_list|)
argument_list|,
name|sort_syms
argument_list|)
expr_stmt|;
comment|/* Now inspect the function symbols.  */
for|for
control|(
name|psy
operator|=
name|psyms
init|;
name|psy
operator|<
name|psyms
operator|+
name|symcount
condition|;
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|psecs
index|[
operator|*
name|psy
operator|-
name|syms
index|]
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
modifier|*
name|psy2
decl_stmt|;
for|for
control|(
name|psy2
operator|=
name|psy
init|;
operator|++
name|psy2
operator|<
name|psyms
operator|+
name|symcount
condition|;
control|)
if|if
condition|(
name|psecs
index|[
operator|*
name|psy2
operator|-
name|syms
index|]
operator|!=
name|s
condition|)
break|break;
if|if
condition|(
operator|!
name|alloc_stack_info
argument_list|(
name|s
argument_list|,
name|psy2
operator|-
name|psy
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|psy
operator|=
name|psy2
expr_stmt|;
block|}
comment|/* First install info about properly typed and sized functions. 	 In an ideal world this will cover all code sections, except 	 when partitioning functions into hot and cold sections, 	 and the horrible pasted together .init and .fini functions.  */
for|for
control|(
name|psy
operator|=
name|psyms
init|;
name|psy
operator|<
name|psyms
operator|+
name|symcount
condition|;
operator|++
name|psy
control|)
block|{
name|sy
operator|=
operator|*
name|psy
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sy
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|psecs
index|[
name|sy
operator|-
name|syms
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|maybe_insert_function
argument_list|(
name|s
argument_list|,
name|sy
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
operator|&&
operator|!
name|gaps
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|interesting_section
argument_list|(
name|sec
argument_list|,
name|output_bfd
argument_list|,
name|htab
argument_list|)
condition|)
name|gaps
operator||=
name|check_function_ranges
argument_list|(
name|sec
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gaps
condition|)
block|{
comment|/* See if we can discover more function symbols by looking at 	 relocations.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_idx
operator|=
literal|0
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
operator|,
name|bfd_idx
operator|++
control|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|psym_arr
index|[
name|bfd_idx
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|interesting_section
argument_list|(
name|sec
argument_list|,
name|output_bfd
argument_list|,
name|htab
argument_list|)
operator|&&
name|sec
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|mark_functions_via_relocs
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_idx
operator|=
literal|0
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
operator|,
name|bfd_idx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|syms
decl_stmt|,
modifier|*
name|sy
decl_stmt|,
modifier|*
modifier|*
name|psyms
decl_stmt|,
modifier|*
modifier|*
name|psy
decl_stmt|;
name|asection
modifier|*
modifier|*
name|psecs
decl_stmt|;
if|if
condition|(
operator|(
name|psyms
operator|=
name|psym_arr
index|[
name|bfd_idx
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|psecs
operator|=
name|sec_arr
index|[
name|bfd_idx
index|]
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|gaps
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
operator|&&
operator|!
name|gaps
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|interesting_section
argument_list|(
name|sec
argument_list|,
name|output_bfd
argument_list|,
name|htab
argument_list|)
condition|)
name|gaps
operator||=
name|check_function_ranges
argument_list|(
name|sec
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gaps
condition|)
continue|continue;
comment|/* Finally, install all globals.  */
for|for
control|(
name|psy
operator|=
name|psyms
init|;
operator|(
name|sy
operator|=
operator|*
name|psy
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|psy
control|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|psecs
index|[
name|sy
operator|-
name|syms
index|]
expr_stmt|;
comment|/* Global syms might be improperly typed functions.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sy
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sy
operator|->
name|st_info
argument_list|)
operator|==
name|STB_GLOBAL
condition|)
block|{
if|if
condition|(
operator|!
name|maybe_insert_function
argument_list|(
name|s
argument_list|,
name|sy
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Some of the symbols we've installed as marking the 	     beginning of functions may have a size of zero.  Extend 	     the range of such functions to the beginning of the 	     next symbol of interest.  */
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|interesting_section
argument_list|(
name|sec
argument_list|,
name|output_bfd
argument_list|,
name|htab
argument_list|)
condition|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
decl_stmt|;
name|struct
name|spu_elf_stack_info
modifier|*
name|sinfo
decl_stmt|;
name|sec_data
operator|=
name|spu_elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|sinfo
operator|=
name|sec_data
operator|->
name|stack_info
expr_stmt|;
if|if
condition|(
name|sinfo
operator|!=
name|NULL
condition|)
block|{
name|int
name|fun_idx
decl_stmt|;
name|bfd_vma
name|hi
init|=
name|sec
operator|->
name|size
decl_stmt|;
for|for
control|(
name|fun_idx
operator|=
name|sinfo
operator|->
name|num_fun
init|;
operator|--
name|fun_idx
operator|>=
literal|0
condition|;
control|)
block|{
name|sinfo
operator|->
name|fun
index|[
name|fun_idx
index|]
operator|.
name|hi
operator|=
name|hi
expr_stmt|;
name|hi
operator|=
name|sinfo
operator|->
name|fun
index|[
name|fun_idx
index|]
operator|.
name|lo
expr_stmt|;
block|}
block|}
comment|/* No symbols in this section.  Must be .init or .fini 		   or something similar.  */
elseif|else
if|if
condition|(
operator|!
name|pasted_function
argument_list|(
name|sec
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_idx
operator|=
literal|0
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
operator|,
name|bfd_idx
operator|++
control|)
block|{
if|if
condition|(
name|psym_arr
index|[
name|bfd_idx
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|free
argument_list|(
name|psym_arr
index|[
name|bfd_idx
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sec_arr
index|[
name|bfd_idx
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|psym_arr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sec_arr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Mark nodes in the call graph that are called by some other node.  */
end_comment

begin_function
specifier|static
name|void
name|mark_non_root
parameter_list|(
name|struct
name|function_info
modifier|*
name|fun
parameter_list|)
block|{
name|struct
name|call_info
modifier|*
name|call
decl_stmt|;
name|fun
operator|->
name|visit1
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|call
operator|=
name|fun
operator|->
name|call_list
init|;
name|call
condition|;
name|call
operator|=
name|call
operator|->
name|next
control|)
block|{
name|call
operator|->
name|fun
operator|->
name|non_root
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|call
operator|->
name|fun
operator|->
name|visit1
condition|)
name|mark_non_root
argument_list|(
name|call
operator|->
name|fun
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove cycles from the call graph.  */
end_comment

begin_function
specifier|static
name|void
name|call_graph_traverse
parameter_list|(
name|struct
name|function_info
modifier|*
name|fun
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|call_info
modifier|*
modifier|*
name|callp
decl_stmt|,
modifier|*
name|call
decl_stmt|;
name|fun
operator|->
name|visit2
operator|=
name|TRUE
expr_stmt|;
name|fun
operator|->
name|marking
operator|=
name|TRUE
expr_stmt|;
name|callp
operator|=
operator|&
name|fun
operator|->
name|call_list
expr_stmt|;
while|while
condition|(
operator|(
name|call
operator|=
operator|*
name|callp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|call
operator|->
name|fun
operator|->
name|visit2
condition|)
name|call_graph_traverse
argument_list|(
name|call
operator|->
name|fun
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|call
operator|->
name|fun
operator|->
name|marking
condition|)
block|{
specifier|const
name|char
modifier|*
name|f1
init|=
name|func_name
argument_list|(
name|fun
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|f2
init|=
name|func_name
argument_list|(
name|call
operator|->
name|fun
argument_list|)
decl_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|info
argument_list|(
name|_
argument_list|(
literal|"Stack analysis will ignore the call "
literal|"from %s to %s\n"
argument_list|)
argument_list|,
name|f1
argument_list|,
name|f2
argument_list|)
expr_stmt|;
operator|*
name|callp
operator|=
name|call
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
name|callp
operator|=
operator|&
name|call
operator|->
name|next
expr_stmt|;
block|}
name|fun
operator|->
name|marking
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Populate call_list for each function.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|build_call_tree
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_spu_vec
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|!=
operator|&
name|bfd_elf32_spu_vec
condition|)
continue|continue;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|interesting_section
argument_list|(
name|sec
argument_list|,
name|output_bfd
argument_list|,
name|htab
argument_list|)
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|mark_functions_via_relocs
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Transfer call info from hot/cold section part of function 	 to main entry.  */
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
decl_stmt|;
name|struct
name|spu_elf_stack_info
modifier|*
name|sinfo
decl_stmt|;
if|if
condition|(
operator|(
name|sec_data
operator|=
name|spu_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|sinfo
operator|=
name|sec_data
operator|->
name|stack_info
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sinfo
operator|->
name|num_fun
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|start
operator|!=
name|NULL
condition|)
block|{
name|struct
name|call_info
modifier|*
name|call
init|=
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|call_list
decl_stmt|;
while|while
condition|(
name|call
operator|!=
name|NULL
condition|)
block|{
name|struct
name|call_info
modifier|*
name|call_next
init|=
name|call
operator|->
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|insert_callee
argument_list|(
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|call
argument_list|)
condition|)
name|free
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|call
operator|=
name|call_next
expr_stmt|;
block|}
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|call_list
operator|=
name|NULL
expr_stmt|;
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|non_root
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Find the call graph root(s).  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_spu_vec
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|!=
operator|&
name|bfd_elf32_spu_vec
condition|)
continue|continue;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
decl_stmt|;
name|struct
name|spu_elf_stack_info
modifier|*
name|sinfo
decl_stmt|;
if|if
condition|(
operator|(
name|sec_data
operator|=
name|spu_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|sinfo
operator|=
name|sec_data
operator|->
name|stack_info
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sinfo
operator|->
name|num_fun
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|visit1
condition|)
name|mark_non_root
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Remove cycles from the call graph.  We start from the root node(s)      so that we break cycles in a reasonable place.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_spu_vec
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|!=
operator|&
name|bfd_elf32_spu_vec
condition|)
continue|continue;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
decl_stmt|;
name|struct
name|spu_elf_stack_info
modifier|*
name|sinfo
decl_stmt|;
if|if
condition|(
operator|(
name|sec_data
operator|=
name|spu_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|sinfo
operator|=
name|sec_data
operator|->
name|stack_info
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sinfo
operator|->
name|num_fun
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|non_root
condition|)
name|call_graph_traverse
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Descend the call graph for FUN, accumulating total stack required.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|sum_stack
parameter_list|(
name|struct
name|function_info
modifier|*
name|fun
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|int
name|emit_stack_syms
parameter_list|)
block|{
name|struct
name|call_info
modifier|*
name|call
decl_stmt|;
name|struct
name|function_info
modifier|*
name|max
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|max_stack
init|=
name|fun
operator|->
name|stack
decl_stmt|;
name|bfd_vma
name|stack
decl_stmt|;
specifier|const
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
name|fun
operator|->
name|visit3
condition|)
return|return
name|max_stack
return|;
for|for
control|(
name|call
operator|=
name|fun
operator|->
name|call_list
init|;
name|call
condition|;
name|call
operator|=
name|call
operator|->
name|next
control|)
block|{
name|stack
operator|=
name|sum_stack
argument_list|(
name|call
operator|->
name|fun
argument_list|,
name|info
argument_list|,
name|emit_stack_syms
argument_list|)
expr_stmt|;
comment|/* Include caller stack for normal calls, don't do so for 	 tail calls.  fun->stack here is local stack usage for 	 this function.  */
if|if
condition|(
operator|!
name|call
operator|->
name|is_tail
condition|)
name|stack
operator|+=
name|fun
operator|->
name|stack
expr_stmt|;
if|if
condition|(
name|max_stack
operator|<
name|stack
condition|)
block|{
name|max_stack
operator|=
name|stack
expr_stmt|;
name|max
operator|=
name|call
operator|->
name|fun
expr_stmt|;
block|}
block|}
name|f1
operator|=
name|func_name
argument_list|(
name|fun
argument_list|)
expr_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|minfo
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%v 0x%v\n"
argument_list|)
argument_list|,
name|f1
argument_list|,
name|fun
operator|->
name|stack
argument_list|,
name|max_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|fun
operator|->
name|call_list
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|minfo
argument_list|(
name|_
argument_list|(
literal|"  calls:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|call
operator|=
name|fun
operator|->
name|call_list
init|;
name|call
condition|;
name|call
operator|=
name|call
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|f2
init|=
name|func_name
argument_list|(
name|call
operator|->
name|fun
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|ann1
init|=
name|call
operator|->
name|fun
operator|==
name|max
condition|?
literal|"*"
else|:
literal|" "
decl_stmt|;
specifier|const
name|char
modifier|*
name|ann2
init|=
name|call
operator|->
name|is_tail
condition|?
literal|"t"
else|:
literal|" "
decl_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|minfo
argument_list|(
name|_
argument_list|(
literal|"   %s%s %s\n"
argument_list|)
argument_list|,
name|ann1
argument_list|,
name|ann2
argument_list|,
name|f2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now fun->stack holds cumulative stack.  */
name|fun
operator|->
name|stack
operator|=
name|max_stack
expr_stmt|;
name|fun
operator|->
name|visit3
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|emit_stack_syms
condition|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_malloc
argument_list|(
literal|18
operator|+
name|strlen
argument_list|(
name|f1
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fun
operator|->
name|global
operator|||
name|ELF_ST_BIND
argument_list|(
name|fun
operator|->
name|u
operator|.
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_GLOBAL
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__stack_%s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__stack_%x_%s"
argument_list|,
name|fun
operator|->
name|sec
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|max_stack
expr_stmt|;
name|h
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
name|max_stack
return|;
block|}
end_function

begin_comment
comment|/* Provide an estimate of total stack required.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|spu_elf_stack_analysis
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|int
name|emit_stack_syms
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd_vma
name|max_stack
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|discover_functions
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|build_call_tree
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|callbacks
operator|->
name|info
argument_list|(
name|_
argument_list|(
literal|"Stack size for call graph root nodes.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|minfo
argument_list|(
name|_
argument_list|(
literal|"\nStack size for functions.  "
literal|"Annotations: '*' max stack, 't' tail call\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_spu_vec
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|!=
operator|&
name|bfd_elf32_spu_vec
condition|)
continue|continue;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|_spu_elf_section_data
modifier|*
name|sec_data
decl_stmt|;
name|struct
name|spu_elf_stack_info
modifier|*
name|sinfo
decl_stmt|;
if|if
condition|(
operator|(
name|sec_data
operator|=
name|spu_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|sinfo
operator|=
name|sec_data
operator|->
name|stack_info
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sinfo
operator|->
name|num_fun
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
operator|.
name|non_root
condition|)
block|{
name|bfd_vma
name|stack
decl_stmt|;
specifier|const
name|char
modifier|*
name|f1
decl_stmt|;
name|stack
operator|=
name|sum_stack
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
argument_list|,
name|info
argument_list|,
name|emit_stack_syms
argument_list|)
expr_stmt|;
name|f1
operator|=
name|func_name
argument_list|(
operator|&
name|sinfo
operator|->
name|fun
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|info
argument_list|(
name|_
argument_list|(
literal|"  %s: 0x%v\n"
argument_list|)
argument_list|,
name|f1
argument_list|,
name|stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_stack
operator|<
name|stack
condition|)
name|max_stack
operator|=
name|stack
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|info
operator|->
name|callbacks
operator|->
name|info
argument_list|(
name|_
argument_list|(
literal|"Maximum stack required is 0x%v\n"
argument_list|)
argument_list|,
name|max_stack
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Perform a final link.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|spu_elf_final_link
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|stack_analysis
operator|&&
operator|!
name|spu_elf_stack_analysis
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|htab
operator|->
name|emit_stack_syms
argument_list|)
condition|)
name|info
operator|->
name|callbacks
operator|->
name|einfo
argument_list|(
literal|"%X%P: stack analysis error: %E\n"
argument_list|)
expr_stmt|;
return|return
name|bfd_elf_final_link
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called when not normally emitting relocs, ie. !info->relocatable    and !info->emitrelocations.  Returns a count of special relocs    that need to be emitted.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|spu_elf_count_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
init|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
decl_stmt|;
for|for
control|(
init|;
name|relocs
operator|<
name|relend
condition|;
name|relocs
operator|++
control|)
block|{
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|relocs
operator|->
name|r_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPU_PPU32
operator|||
name|r_type
operator|==
name|R_SPU_PPU64
condition|)
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Apply RELOCS to CONTENTS of INPUT_SECTION from INPUT_BFD.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|spu_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|struct
name|spu_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_boolean
name|ret
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|emit_these_relocs
init|=
name|FALSE
decl_stmt|;
name|htab
operator|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
operator|(
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
operator|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_boolean
name|warned
decl_stmt|;
name|bfd_boolean
name|branch
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPU_PPU32
operator|||
name|r_type
operator|==
name|R_SPU_PPU64
condition|)
block|{
name|emit_these_relocs
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
name|howto
operator|=
name|elf_howto_table
operator|+
name|r_type
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|warned
operator|=
name|FALSE
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_sym_name
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
if|if
condition|(
name|unresolved_reloc
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%s+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* If this symbol is in an overlay area, we may need to relocate 	 to the overlay stub.  */
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|branch
operator|=
operator|(
name|is_branch
argument_list|(
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
operator|||
name|is_hint
argument_list|(
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|needs_ovl_stub
argument_list|(
name|sym_name
argument_list|,
name|sec
argument_list|,
name|input_section
argument_list|,
name|htab
argument_list|,
name|branch
argument_list|)
condition|)
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|struct
name|spu_stub_hash_entry
modifier|*
name|sh
decl_stmt|;
name|stub_name
operator|=
name|spu_stub_name
argument_list|(
name|sec
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sh
operator|=
operator|(
expr|struct
name|spu_stub_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|!=
name|NULL
condition|)
block|{
name|relocation
operator|=
operator|(
name|htab
operator|->
name|stub
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|stub
operator|->
name|output_offset
operator|+
name|sh
operator|->
name|off
operator|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|sym_name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|&&
name|emit_these_relocs
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|!
name|info
operator|->
name|emitrelocations
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|wrel
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|wrel
operator|=
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPU_PPU32
operator|||
name|r_type
operator|==
name|R_SPU_PPU64
condition|)
operator|*
name|wrel
operator|++
operator|=
operator|*
name|rel
expr_stmt|;
block|}
name|input_section
operator|->
name|reloc_count
operator|=
name|wrel
operator|-
name|relocs
expr_stmt|;
comment|/* Backflips for _bfd_elf_link_output_relocs.  */
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rel_hdr
operator|->
name|sh_size
operator|=
name|input_section
operator|->
name|reloc_count
operator|*
name|rel_hdr
operator|->
name|sh_entsize
expr_stmt|;
name|ret
operator|=
literal|2
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Adjust _SPUEAR_ syms to point at their overlay stubs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|spu_elf_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|sym_name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|sym_sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|htab
operator|->
name|num_overlays
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|def_regular
operator|&&
name|strncmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_SPUEAR_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
name|Elf_Internal_Rela
name|zero_rel
decl_stmt|;
name|char
modifier|*
name|stub_name
init|=
name|spu_stub_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|h
argument_list|,
operator|&
name|zero_rel
argument_list|)
decl_stmt|;
name|struct
name|spu_stub_hash_entry
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sh
operator|=
operator|(
expr|struct
name|spu_stub_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|sym
operator|->
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|htab
operator|->
name|stub
operator|->
name|output_section
operator|->
name|owner
argument_list|,
name|htab
operator|->
name|stub
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
operator|(
name|htab
operator|->
name|stub
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|stub
operator|->
name|output_offset
operator|+
name|sh
operator|->
name|off
operator|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|spu_plugin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|spu_elf_plugin
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|spu_plugin
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set ELF header e_type for plugins.  */
end_comment

begin_function
specifier|static
name|void
name|spu_elf_post_process_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|spu_plugin
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_DYN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We may add an extra PT_LOAD segment for .toe.  We also need extra    segments for overlays.  */
end_comment

begin_function
specifier|static
name|int
name|spu_elf_additional_program_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|spu_link_hash_table
modifier|*
name|htab
init|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|int
name|extra
init|=
name|htab
operator|->
name|num_overlays
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|extra
condition|)
operator|++
name|extra
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".toe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
operator|++
name|extra
expr_stmt|;
return|return
name|extra
return|;
block|}
end_function

begin_comment
comment|/* Remove .toe section from other PT_LOAD segments and put it in    a segment of its own.  Put overlays in separate segments too.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|spu_elf_modify_segment_map
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|toe
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|toe
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".toe"
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
name|m
operator|->
name|count
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|s
operator|=
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|)
operator|==
name|toe
operator|||
name|spu_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|ovl_index
operator|!=
literal|0
condition|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m2
decl_stmt|;
name|bfd_vma
name|amt
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|m
operator|->
name|count
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|amt
operator|+=
operator|(
name|m
operator|->
name|count
operator|-
operator|(
name|i
operator|+
literal|2
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|m2
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m2
operator|->
name|count
operator|=
name|m
operator|->
name|count
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|m2
operator|->
name|sections
argument_list|,
name|m
operator|->
name|sections
operator|+
name|i
operator|+
literal|1
argument_list|,
name|m2
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|m2
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
name|m2
operator|->
name|next
operator|=
name|m
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|m2
expr_stmt|;
block|}
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|count
operator|=
name|i
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|m2
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m2
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
name|m2
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m2
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
name|m2
operator|->
name|next
operator|=
name|m
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|m2
expr_stmt|;
block|}
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Check that all loadable section VMAs lie in the range    LO .. HI inclusive.  */
end_comment

begin_function
name|asection
modifier|*
name|spu_elf_check_vma
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
name|lo
parameter_list|,
name|bfd_vma
name|hi
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|size
operator|!=
literal|0
operator|&&
operator|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|vma
operator|<
name|lo
operator|||
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|vma
operator|>
name|hi
operator|||
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|vma
operator|+
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|size
operator|-
literal|1
operator|>
name|hi
operator|)
condition|)
return|return
name|m
operator|->
name|sections
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Tweak the section type of .note.spu_name.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|spu_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|SPU_PTNOTE_SPUNAME
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_NOTE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Tweak phdrs before writing them out.  */
end_comment

begin_function
specifier|static
name|int
name|spu_elf_modify_program_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_obj_tdata
modifier|*
name|tdata
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|struct
name|spu_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|tdata
operator|->
name|phdr
expr_stmt|;
name|count
operator|=
name|tdata
operator|->
name|program_header_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
name|htab
operator|=
name|spu_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|num_overlays
operator|!=
literal|0
condition|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|o
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
condition|;
operator|++
name|i
operator|,
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|count
operator|!=
literal|0
operator|&&
operator|(
name|o
operator|=
name|spu_elf_section_data
argument_list|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
argument_list|)
operator|->
name|ovl_index
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Mark this as an overlay header.  */
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator||=
name|PF_OVERLAY
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|ovtab
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|ovtab
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|p
init|=
name|htab
operator|->
name|ovtab
operator|->
name|contents
decl_stmt|;
name|unsigned
name|int
name|off
init|=
operator|(
name|o
operator|-
literal|1
operator|)
operator|*
literal|16
operator|+
literal|8
decl_stmt|;
comment|/* Write file_off into _ovly_table.  */
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|ovtab
operator|->
name|owner
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
argument_list|,
name|p
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Round up p_filesz and p_memsz of PT_LOAD segments to multiples      of 16.  This should always be possible when using the standard      linker scripts, but don't create overlapping segments if      someone is playing games with linker scripts.  */
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|--
operator|!=
literal|0
condition|;
control|)
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|unsigned
name|adjust
decl_stmt|;
name|adjust
operator|=
operator|-
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
operator|&&
name|last
operator|!=
name|NULL
operator|&&
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|>
name|last
operator|->
name|p_offset
operator|-
name|adjust
condition|)
break|break;
name|adjust
operator|=
operator|-
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
operator|&&
name|last
operator|!=
name|NULL
operator|&&
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|!=
literal|0
operator|&&
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|>
name|last
operator|->
name|p_vaddr
operator|-
name|adjust
operator|&&
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|<=
name|last
operator|->
name|p_vaddr
condition|)
break|break;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|!=
literal|0
condition|)
name|last
operator|=
operator|&
name|phdr
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|--
operator|!=
literal|0
condition|;
control|)
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|unsigned
name|adjust
decl_stmt|;
name|adjust
operator|=
operator|-
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|&
literal|15
expr_stmt|;
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|+=
name|adjust
expr_stmt|;
name|adjust
operator|=
operator|-
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|&
literal|15
expr_stmt|;
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|+=
name|adjust
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_spu_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-spu"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_spu
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_SPU
end_define

begin_comment
comment|/* This matches the alignment need for DMA.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x80
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|spu_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_name_lookup
value|spu_elf_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|spu_elf_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_backend_count_relocs
value|spu_elf_count_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|spu_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|spu_elf_backend_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
value|spu_elf_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf32_new_section_hook
value|spu_elf_new_section_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|spu_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_free
value|spu_elf_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
value|spu_elf_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|spu_elf_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_program_headers
value|spu_elf_modify_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
value|spu_elf_post_process_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|spu_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|spu_elf_special_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_final_link
value|spu_elf_final_link
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

