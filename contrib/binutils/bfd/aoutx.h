begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD semi-generic back-end for a.out binaries.    Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* SECTION 	a.out backends   DESCRIPTION  	BFD supports a number of different flavours of a.out format, 	though the major differences are only the sizes of the 	structures on disk, and the shape of the relocation 	information.  	The support is split into a basic support file @file{aoutx.h} 	and other files which derive functions from the base. One 	derivation file is @file{aoutf1.h} (for a.out flavour 1), and 	adds to the basic a.out functions support for sun3, sun4, 386 	and 29k a.out files, to create a target jump vector for a 	specific target.  	This information is further split out into more specific files 	for each machine, including @file{sunos.c} for sun3 and sun4, 	@file{newsos3.c} for the Sony NEWS, and @file{demo64.c} for a 	demonstration of a 64 bit a.out format.  	The base file @file{aoutx.h} defines general mechanisms for 	reading and writing records to and from disk and various 	other methods which BFD requires. It is included by 	@file{aout32.c} and @file{aout64.c} to form the names<<aout_32_swap_exec_header_in>>,<<aout_64_swap_exec_header_in>>, etc.  	As an example, this is what goes on to make the back end for a 	sun4, from @file{aout32.c}:  |	#define ARCH_SIZE 32 |	#include "aoutx.h"  	Which exports names:  |	... |	aout_32_canonicalize_reloc |	aout_32_find_nearest_line |	aout_32_get_lineno |	aout_32_get_reloc_upper_bound |	...  	from @file{sunos.c}:  |	#define TARGET_NAME "a.out-sunos-big" |	#define VECNAME    sunos_big_vec |	#include "aoutf1.h"  	requires all the names from @file{aout32.c}, and produces the jump vector  |	sunos_big_vec  	The file @file{host-aout.c} is a special case.  It is for a large set 	of hosts that use ``more or less standard'' a.out files, and 	for which cross-debugging is not interesting.  It uses the 	standard 32-bit a.out support routines, but determines the 	file offsets and addresses of the text, data, and BSS 	sections, the machine architecture and machine type, and the 	entry point address, in a host-dependent manner.  Once these 	values have been determined, generic code is used to handle 	the  object file.  	When porting it to run on a new system, you must supply:  |        HOST_PAGE_SIZE |        HOST_SEGMENT_SIZE |        HOST_MACHINE_ARCH       (optional) |        HOST_MACHINE_MACHINE    (optional) |        HOST_TEXT_START_ADDR |        HOST_STACK_END_ADDR  	in the file @file{../include/sys/h-@var{XXX}.h} (for your host).  These 	values, plus the structures and macros defined in @file{a.out.h} on 	your host system, will produce a BFD target that will access 	ordinary a.out files on your host. To configure a new machine 	to use @file{host-aout.c}, specify:  |	TDEFAULTS = -DDEFAULT_VECTOR=host_aout_big_vec |	TDEPFILES= host-aout.o trad-core.o  	in the @file{config/@var{XXX}.mt} file, and modify @file{configure.in} 	to use the 	@file{@var{XXX}.mt} file (by setting "<<bfd_target=XXX>>") when your 	configuration is selected.  */
end_comment

begin_comment
comment|/* Some assumptions:    * Any BFD with D_PAGED set is ZMAGIC, and vice versa.      Doesn't matter what the setting of WP_TEXT is on output, but it'll      get set on input.    * Any BFD with D_PAGED clear and WP_TEXT set is NMAGIC.    * Any BFD with both flags clear is OMAGIC.    (Just want to make these explicit, so the conditions tested in this    file make sense if you're more familiar with a.out than with BFD.)  */
end_comment

begin_define
define|#
directive|define
name|KEEPIT
value|udata.i
end_define

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* For strchr and friends */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|<sysdep.h>
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_decl_stmt
specifier|static
name|boolean
name|aout_get_external_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|translate_from_native_sym_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|aout_symbol_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|translate_to_native_sym_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
expr|struct
name|external_nlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_o_magic
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_exec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_z_magic
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_exec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_n_magic
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_exec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SUBSECTION 	Relocations  DESCRIPTION 	The file @file{aoutx.h} provides for both the @emph{standard} 	and @emph{extended} forms of a.out relocation records.  	The standard records contain only an 	address, a symbol index, and a type field. The extended records 	(used on 29ks and sparcs) also have a full integer for an 	addend.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CTOR_TABLE_RELOC_HOWTO
end_ifndef

begin_define
define|#
directive|define
name|CTOR_TABLE_RELOC_IDX
value|2
end_define

begin_define
define|#
directive|define
name|CTOR_TABLE_RELOC_HOWTO
parameter_list|(
name|BFD
parameter_list|)
value|((obj_reloc_entry_size(BFD) == RELOC_EXT_SIZE \ 	     ? howto_table_ext : howto_table_std) \ 	    + CTOR_TABLE_RELOC_IDX)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_swap_std_reloc_in
end_ifndef

begin_define
define|#
directive|define
name|MY_swap_std_reloc_in
value|NAME(aout,swap_std_reloc_in)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_swap_std_reloc_out
end_ifndef

begin_define
define|#
directive|define
name|MY_swap_std_reloc_out
value|NAME(aout,swap_std_reloc_out)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_final_link_relocate
end_ifndef

begin_define
define|#
directive|define
name|MY_final_link_relocate
value|_bfd_final_link_relocate
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_relocate_contents
end_ifndef

begin_define
define|#
directive|define
name|MY_relocate_contents
value|_bfd_relocate_contents
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|howto_table_ext
value|NAME(aout,ext_howto_table)
end_define

begin_define
define|#
directive|define
name|howto_table_std
value|NAME(aout,std_howto_table)
end_define

begin_decl_stmt
name|reloc_howto_type
name|howto_table_ext
index|[]
init|=
block|{
comment|/* type           rs   size bsz  pcrel bitpos ovrf                  sf name          part_inpl readmask setmask pcdone */
name|HOWTO
argument_list|(
name|RELOC_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_DISP8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_DISP16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_DISP32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_WDISP30
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"WDISP30"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_WDISP22
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"WDISP22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_HI22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"HI22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_LO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"LO10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_SFA_BASE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"SFA_BASE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_SFA_OFF13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"SFA_OFF13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_BASE10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"BASE10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_BASE13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASE13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_BASE22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASE22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_PC10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"PC10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_PC22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"PC22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_JMP_TBL
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"JMP_TBL"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_SEGOFF16
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"SEGOFF16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"GLOB_DAT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"JMP_SLOT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"RELATIVE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert standard reloc records to "arelent" format (incl byte swap).  */
end_comment

begin_decl_stmt
name|reloc_howto_type
name|howto_table_std
index|[]
init|=
block|{
comment|/* type              rs size bsz  pcrel bitpos ovrf                     sf name     part_inpl readmask  setmask    pcdone */
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"8"
argument_list|,
name|true
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"64"
argument_list|,
name|true
argument_list|,
literal|0xdeaddead
argument_list|,
literal|0xdeaddead
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP8"
argument_list|,
name|true
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP64"
argument_list|,
name|true
argument_list|,
literal|0xfeedface
argument_list|,
literal|0xfeedface
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"GOT_REL"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|9
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASE16"
argument_list|,
name|false
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASE32"
argument_list|,
name|false
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
name|HOWTO
argument_list|(
literal|16
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"JMP_TABLE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
name|HOWTO
argument_list|(
literal|32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"RELATIVE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|}
block|,
name|HOWTO
argument_list|(
literal|40
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASEREL"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TABLE_SIZE
parameter_list|(
name|TABLE
parameter_list|)
value|(sizeof(TABLE)/sizeof(TABLE[0]))
end_define

begin_decl_stmt
name|reloc_howto_type
modifier|*
name|NAME
argument_list|(
name|aout
argument_list|,
name|reloc_type_lookup
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|EXT
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|case i: return&howto_table_ext[j]
define|#
directive|define
name|STD
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|case i: return&howto_table_std[j]
name|int
name|ext
init|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|==
name|RELOC_EXT_SIZE
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_CTOR
condition|)
switch|switch
condition|(
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|bits_per_address
condition|)
block|{
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|code
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ext
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
name|EXT
argument_list|(
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_HI22
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_LO10
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_32_PCREL_S2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_SPARC_WDISP22
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_SPARC13
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_SPARC_GOT10
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_SPARC_BASE13
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_SPARC_GOT13
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_SPARC_GOT22
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_SPARC_PC10
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_SPARC_PC22
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_SPARC_WPLT30
argument_list|,
literal|19
argument_list|)
expr_stmt|;
default|default:
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
block|}
else|else
comment|/* std relocs */
switch|switch
condition|(
name|code
condition|)
block|{
name|STD
argument_list|(
name|BFD_RELOC_16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_8_PCREL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_16_PCREL
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_32_PCREL
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_16_BASEREL
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_32_BASEREL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
default|default:
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
block|}
block|}
end_block

begin_comment
comment|/* SUBSECTION 	Internal entry points  DESCRIPTION 	@file{aoutx.h} exports several routines for accessing the 	contents of an a.out file, which are gathered and exported in 	turn by various format specific files (eg sunos.c).  */
end_comment

begin_comment
comment|/* FUNCTION 	 aout_@var{size}_swap_exec_header_in  SYNOPSIS 	void aout_@var{size}_swap_exec_header_in,            (bfd *abfd,             struct external_exec *raw_bytes,             struct internal_exec *execp);  DESCRIPTION 	Swap the information in an executable header @var{raw_bytes} taken 	from a raw byte stream memory image into the internal exec header 	structure @var{execp}. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME_swap_exec_header_in
end_ifndef

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|raw_bytes
argument_list|,
name|execp
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|external_exec
modifier|*
name|raw_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|external_exec
modifier|*
name|bytes
init|=
operator|(
expr|struct
name|external_exec
operator|*
operator|)
name|raw_bytes
decl_stmt|;
comment|/* The internal_exec structure has some fields that are unused in this      configuration (IE for i960), so ensure that all such uninitialized      fields are zero'd out.  There are places where two of these structs      are memcmp'd, and thus the contents do matter. */
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|execp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now fill in fields in the execp, from the bytes in the raw data.  */
name|execp
operator|->
name|a_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_text
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_syms
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_entry
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_trsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_drsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|NAME_swap_exec_header_in
value|NAME(aout,swap_exec_header_in)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FUNCTION 	aout_@var{size}_swap_exec_header_out  SYNOPSIS 	void aout_@var{size}_swap_exec_header_out 	  (bfd *abfd, 	   struct internal_exec *execp, 	   struct external_exec *raw_bytes);  DESCRIPTION 	Swap the information in an internal exec header structure 	@var{execp} into the buffer @var{raw_bytes} ready for writing to disk. */
end_comment

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|,
name|raw_bytes
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|external_exec
modifier|*
name|raw_bytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|external_exec
modifier|*
name|bytes
init|=
operator|(
expr|struct
name|external_exec
operator|*
operator|)
name|raw_bytes
decl_stmt|;
comment|/* Now fill in fields in the raw data, from the fields in the exec struct. */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_info
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_text
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_data
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_bss
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_syms
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_entry
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_trsize
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_drsize
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make all the section for an a.out file.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|make_sections
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
operator|&&
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
operator|&&
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
operator|&&
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".bss"
argument_list|)
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* FUNCTION 	aout_@var{size}_some_aout_object_p  SYNOPSIS 	const bfd_target *aout_@var{size}_some_aout_object_p 	 (bfd *abfd, 	  const bfd_target *(*callback_to_real_object_p)());  DESCRIPTION 	Some a.out variant thinks that the file open in @var{abfd} 	checking is an a.out file.  Do some more checking, and set up 	for access if it really is.  Call back to the calling 	environment's "finish up" function just before returning, to 	handle any last-minute setup. */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
modifier|*
name|NAME
argument_list|(
name|aout
argument_list|,
name|some_aout_object_p
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|,
name|callback_to_real_object_p
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|const
name|bfd_target
operator|*
operator|(
operator|*
name|callback_to_real_object_p
operator|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|aout_data_struct
modifier|*
name|rawptr
decl_stmt|,
modifier|*
name|oldrawptr
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|result
decl_stmt|;
name|rawptr
operator|=
operator|(
expr|struct
name|aout_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aout_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|oldrawptr
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
name|rawptr
expr_stmt|;
comment|/* Copy the contents of the old tdata struct.      In particular, we want the subformat, since for hpux it was set in      hp300hpux.c:swap_exec_header_in and will be used in      hp300hpux.c:callback.  */
if|if
condition|(
name|oldrawptr
operator|!=
name|NULL
condition|)
operator|*
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
operator|*
name|oldrawptr
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|.
name|hdr
operator|=
operator|&
name|rawptr
operator|->
name|e
expr_stmt|;
operator|*
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|.
name|hdr
operator|)
operator|=
operator|*
name|execp
expr_stmt|;
comment|/* Copy in the internal_exec struct */
name|execp
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|.
name|hdr
expr_stmt|;
comment|/* Set the file flags */
name|abfd
operator|->
name|flags
operator|=
name|BFD_NO_FLAGS
expr_stmt|;
if|if
condition|(
name|execp
operator|->
name|a_drsize
operator|||
name|execp
operator|->
name|a_trsize
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
comment|/* Setting of EXEC_P has been deferred to the bottom of this function */
if|if
condition|(
name|execp
operator|->
name|a_syms
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
expr_stmt|;
if|if
condition|(
name|N_DYNAMIC
argument_list|(
operator|*
name|execp
argument_list|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
if|if
condition|(
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|ZMAGIC
condition|)
block|{
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
operator||
name|WP_TEXT
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|z_magic
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|QMAGIC
condition|)
block|{
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
operator||
name|WP_TEXT
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|z_magic
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|subformat
operator|=
name|q_magic_format
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|NMAGIC
condition|)
block|{
name|abfd
operator|->
name|flags
operator||=
name|WP_TEXT
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|n_magic
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|OMAGIC
operator|||
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|BMAGIC
condition|)
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|o_magic
expr_stmt|;
else|else
block|{
comment|/* Should have been checked with N_BADMAG before this routine 	 was called.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|execp
operator|->
name|a_entry
expr_stmt|;
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|aout_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|execp
operator|->
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
expr_stmt|;
comment|/* The default relocation entry size is that of traditional V7 Unix.  */
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
comment|/* The default symbol entry size is that of traditional Unix. */
name|obj_symbol_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|EXTERNAL_NLIST_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
name|bfd_init_window
argument_list|(
operator|&
name|obj_aout_sym_window
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_init_window
argument_list|(
operator|&
name|obj_aout_string_window
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_aout_sym_hashes
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|make_sections
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|execp
operator|->
name|a_data
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|execp
operator|->
name|a_bss
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
operator|(
name|execp
operator|->
name|a_trsize
operator|!=
literal|0
condition|?
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_RELOC
operator|)
else|:
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
operator|(
name|execp
operator|->
name|a_drsize
operator|!=
literal|0
condition|?
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_RELOC
operator|)
else|:
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
ifdef|#
directive|ifdef
name|THIS_IS_ONLY_DOCUMENTATION
comment|/* The common code can't fill in these things because they depend      on either the start address of the text segment, the rounding      up of virtual addresses between segments, or the starting file      position of the text segment -- all of which varies among different      versions of a.out.  */
comment|/* Call back to the format-dependent code to fill in the rest of the      fields and do any further cleanup.  Things that should be filled      in by the callback:  */
name|struct
name|exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
operator|=
name|N_TXTSIZE
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_size
operator|=
name|N_TXTSIZE
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* data and bss are already filled in since they're so standard */
comment|/* The virtual memory addresses of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_TXTADDR
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_DATADDR
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_BSSADDR
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file offsets of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_TXTOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_DATOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file offsets of the relocation info */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_TRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_DRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file offsets of the string table and symbol table.  */
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_STROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_SYMOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* Determine the architecture and machine type of the object file.  */
switch|switch
condition|(
name|N_MACHTYPE
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
block|{
default|default:
name|abfd
operator|->
name|obj_arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
break|break;
block|}
name|adata
argument_list|(
name|abfd
argument_list|)
operator|->
name|page_size
operator|=
name|TARGET_PAGE_SIZE
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_size
operator|=
name|SEGMENT_SIZE
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
comment|/* The architecture is encoded in various ways in various a.out variants,      or is not encoded at all in some of them.  The relocation size depends      on the architecture and the a.out variant.  Finally, the return value      is the bfd_target vector in use.  If an error occurs, return zero and      set bfd_error to the appropriate error code.       Formats such as b.out, which have additional fields in the a.out      header, should cope with them in this callback as well.  */
endif|#
directive|endif
comment|/* DOCUMENTATION */
name|result
operator|=
call|(
modifier|*
name|callback_to_real_object_p
call|)
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Now that the segment addresses have been worked out, take a better      guess at whether the file is executable.  If the entry point      is within the text segment, assume it is.  (This makes files      executable even if their entry point address is 0, as long as      their text starts at zero.).       This test had to be changed to deal with systems where the text segment      runs at a different location than the default.  The problem is that the      entry address can appear to be outside the text segment, thus causing an      erroneous conclusion that the file isn't executable.       To fix this, we now accept any non-zero entry point as an indication of      executability.  This will work most of the time, since only the linker      sets the entry point, and that is likely to be non-zero for most systems. */
if|if
condition|(
name|execp
operator|->
name|a_entry
operator|!=
literal|0
operator|||
operator|(
name|execp
operator|->
name|a_entry
operator|>=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|&&
name|execp
operator|->
name|a_entry
operator|<
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
ifdef|#
directive|ifdef
name|STAT_FOR_EXEC
else|else
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
comment|/* The original heuristic doesn't work in some important cases.         The a.out file has no information about the text start         address.  For files (like kernels) linked to non-standard         addresses (ld -Ttext nnn) the entry point may not be between         the default text start (obj_textsec(abfd)->vma) and         (obj_textsec(abfd)->vma) + text size.  This is not just a mach         issue.  Many kernels are loaded at non standard addresses.  */
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|!=
name|NULL
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|fstat
argument_list|(
name|fileno
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|abfd
operator|->
name|iostream
operator|)
argument_list|)
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
literal|0111
operator|)
operator|!=
literal|0
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STAT_FOR_EXEC */
if|if
condition|(
name|result
condition|)
block|{
if|#
directive|if
literal|0
comment|/* These should be set correctly anyways.  */
block|abfd->sections = obj_textsec (abfd);       obj_textsec (abfd)->next = obj_datasec (abfd);       obj_datasec (abfd)->next = obj_bsssec (abfd);
endif|#
directive|endif
block|}
else|else
block|{
name|free
argument_list|(
name|rawptr
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
name|oldrawptr
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* FUNCTION 	aout_@var{size}_mkobject  SYNOPSIS 	boolean aout_@var{size}_mkobject, (bfd *abfd);  DESCRIPTION 	Initialize BFD @var{abfd} for use with a.out files. */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|mkobject
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|aout_data_struct
modifier|*
name|rawptr
decl_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
comment|/* Use an intermediate variable for clarity */
name|rawptr
operator|=
operator|(
expr|struct
name|aout_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aout_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
name|rawptr
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|&
operator|(
name|rawptr
operator|->
name|e
operator|)
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* FUNCTION 	aout_@var{size}_machine_type  SYNOPSIS 	enum machine_type  aout_@var{size}_machine_type 	 (enum bfd_architecture arch, 	  unsigned long machine));  DESCRIPTION 	Keep track of machine architecture and machine type for 	a.out's. Return the<<machine_type>> for a particular 	architecture and machine, or<<M_UNKNOWN>> if that exact architecture 	and machine can't be represented in a.out format.  	If the architecture is understood, machine type 0 (default) 	is always understood. */
end_comment

begin_decl_stmt
name|enum
name|machine_type
name|NAME
argument_list|(
name|aout
argument_list|,
name|machine_type
argument_list|)
argument_list|(
name|arch
argument_list|,
name|machine
argument_list|,
name|unknown
argument_list|)
decl|enum
name|bfd_architecture
name|arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
modifier|*
name|unknown
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|enum
name|machine_type
name|arch_flags
decl_stmt|;
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
operator|*
name|unknown
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
if|if
condition|(
name|machine
operator|==
literal|0
operator|||
name|machine
operator|==
name|bfd_mach_sparc
operator|||
name|machine
operator|==
name|bfd_mach_sparc_sparclite
operator|||
name|machine
operator|==
name|bfd_mach_sparc_v9
condition|)
name|arch_flags
operator|=
name|M_SPARC
expr_stmt|;
elseif|else
if|if
condition|(
name|machine
operator|==
name|bfd_mach_sparc_sparclet
condition|)
name|arch_flags
operator|=
name|M_SPARCLET
expr_stmt|;
break|break;
case|case
name|bfd_arch_m68k
case|:
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
literal|0
case|:
name|arch_flags
operator|=
name|M_68010
expr_stmt|;
break|break;
case|case
literal|68000
case|:
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
operator|*
name|unknown
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|68010
case|:
name|arch_flags
operator|=
name|M_68010
expr_stmt|;
break|break;
case|case
literal|68020
case|:
name|arch_flags
operator|=
name|M_68020
expr_stmt|;
break|break;
default|default:
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_i386
case|:
if|if
condition|(
name|machine
operator|==
literal|0
condition|)
name|arch_flags
operator|=
name|M_386
expr_stmt|;
break|break;
case|case
name|bfd_arch_a29k
case|:
if|if
condition|(
name|machine
operator|==
literal|0
condition|)
name|arch_flags
operator|=
name|M_29K
expr_stmt|;
break|break;
case|case
name|bfd_arch_arm
case|:
if|if
condition|(
name|machine
operator|==
literal|0
condition|)
name|arch_flags
operator|=
name|M_ARM
expr_stmt|;
break|break;
case|case
name|bfd_arch_mips
case|:
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2000
case|:
case|case
literal|3000
case|:
name|arch_flags
operator|=
name|M_MIPS1
expr_stmt|;
break|break;
case|case
literal|4000
case|:
comment|/* mips3 */
case|case
literal|4400
case|:
case|case
literal|8000
case|:
comment|/* mips4 */
comment|/* real mips2: */
case|case
literal|6000
case|:
name|arch_flags
operator|=
name|M_MIPS2
expr_stmt|;
break|break;
default|default:
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_ns32k
case|:
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
literal|0
case|:
name|arch_flags
operator|=
name|M_NS32532
expr_stmt|;
break|break;
case|case
literal|32032
case|:
name|arch_flags
operator|=
name|M_NS32032
expr_stmt|;
break|break;
case|case
literal|32532
case|:
name|arch_flags
operator|=
name|M_NS32532
expr_stmt|;
break|break;
default|default:
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_vax
case|:
operator|*
name|unknown
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|arch_flags
operator|!=
name|M_UNKNOWN
condition|)
operator|*
name|unknown
operator|=
name|false
expr_stmt|;
return|return
name|arch_flags
return|;
block|}
end_block

begin_comment
comment|/* FUNCTION 	aout_@var{size}_set_arch_mach  SYNOPSIS 	boolean aout_@var{size}_set_arch_mach, 	 (bfd *, 	  enum bfd_architecture arch, 	  unsigned long machine));  DESCRIPTION 	Set the architecture and the machine of the BFD @var{abfd} to the 	values @var{arch} and @var{machine}.  Verify that @var{abfd}'s format 	can support the architecture required. */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|set_arch_mach
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|machine
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|arch
operator|!=
name|bfd_arch_unknown
condition|)
block|{
name|boolean
name|unknown
decl_stmt|;
name|NAME
argument_list|(
name|aout
argument_list|,
name|machine_type
argument_list|)
argument_list|(
name|arch
argument_list|,
name|machine
argument_list|,
operator|&
name|unknown
argument_list|)
expr_stmt|;
if|if
condition|(
name|unknown
condition|)
return|return
name|false
return|;
block|}
comment|/* Determine the size of a relocation entry */
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
case|case
name|bfd_arch_a29k
case|:
case|case
name|bfd_arch_mips
case|:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_EXT_SIZE
expr_stmt|;
break|break;
default|default:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|*
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|set_sizes
operator|)
operator|(
name|abfd
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|adjust_o_magic
parameter_list|(
name|abfd
parameter_list|,
name|execp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
block|{
name|file_ptr
name|pos
init|=
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
decl_stmt|;
name|bfd_vma
name|vma
init|=
literal|0
decl_stmt|;
name|int
name|pad
init|=
literal|0
decl_stmt|;
comment|/* Text.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
else|else
name|vma
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|pos
operator|+=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|vma
operator|+=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
comment|/* Data.  */
if|if
condition|(
operator|!
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
block|{
if|#
directive|if
literal|0
comment|/* ?? Does alignment in the file image really matter? */
block|pad = align_power (vma, obj_datasec(abfd)->alignment_power) - vma;
endif|#
directive|endif
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|pad
expr_stmt|;
name|pos
operator|+=
name|pad
expr_stmt|;
name|vma
operator|+=
name|pad
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
block|}
else|else
name|vma
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
name|pos
operator|+=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|vma
operator|+=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
comment|/* BSS.  */
if|if
condition|(
operator|!
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
block|{
if|#
directive|if
literal|0
block|pad = align_power (vma, obj_bsssec(abfd)->alignment_power) - vma;
endif|#
directive|endif
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|pad
expr_stmt|;
name|pos
operator|+=
name|pad
expr_stmt|;
name|vma
operator|+=
name|pad
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
block|}
else|else
block|{
comment|/* The VMA of the .bss section is set by the the VMA of the          .data section plus the size of the .data section.  We may          need to add padding bytes to make this true.  */
name|pad
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|-
name|vma
expr_stmt|;
if|if
condition|(
name|pad
operator|>
literal|0
condition|)
block|{
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|pad
expr_stmt|;
name|pos
operator|+=
name|pad
expr_stmt|;
block|}
block|}
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
comment|/* Fix up the exec header.  */
name|execp
operator|->
name|a_text
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|N_SET_MAGIC
argument_list|(
operator|*
name|execp
argument_list|,
name|OMAGIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_z_magic
parameter_list|(
name|abfd
parameter_list|,
name|execp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
block|{
name|bfd_size_type
name|data_pad
decl_stmt|,
name|text_pad
decl_stmt|;
name|file_ptr
name|text_end
decl_stmt|;
name|CONST
name|struct
name|aout_backend_data
modifier|*
name|abdp
decl_stmt|;
name|int
name|ztih
decl_stmt|;
comment|/* Nonzero if text includes exec header.  */
name|abdp
operator|=
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Text.  */
name|ztih
operator|=
operator|(
name|abdp
operator|!=
name|NULL
operator|&&
operator|(
name|abdp
operator|->
name|text_includes_header
operator|||
name|obj_aout_subformat
argument_list|(
name|abfd
argument_list|)
operator|==
name|q_magic_format
operator|)
operator|)
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|ztih
condition|?
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
else|:
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|zmagic_disk_block_size
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
block|{
comment|/* ?? Do we really need to check for relocs here?  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|HAS_RELOC
operator|)
condition|?
literal|0
else|:
operator|(
name|ztih
condition|?
operator|(
name|abdp
operator|->
name|default_text_vma
operator|+
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|)
else|:
name|abdp
operator|->
name|default_text_vma
operator|)
operator|)
expr_stmt|;
name|text_pad
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* The .text section is being loaded at an unusual address.  We          may need to pad it such that the .data section starts at a page          boundary.  */
if|if
condition|(
name|ztih
condition|)
name|text_pad
operator|=
operator|(
operator|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|-
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|)
operator|&
operator|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|text_pad
operator|=
operator|(
operator|(
operator|-
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|)
operator|&
operator|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Find start of data.  */
if|if
condition|(
name|ztih
condition|)
block|{
name|text_end
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|text_pad
operator|+=
name|BFD_ALIGN
argument_list|(
name|text_end
argument_list|,
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
argument_list|)
operator|-
name|text_end
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that if page_size == zmagic_disk_block_size, then 	 filepos == page_size, and this case is the same as the ztih 	 case.  */
name|text_end
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|text_pad
operator|+=
name|BFD_ALIGN
argument_list|(
name|text_end
argument_list|,
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
argument_list|)
operator|-
name|text_end
expr_stmt|;
name|text_end
operator|+=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
expr_stmt|;
block|}
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|text_pad
expr_stmt|;
name|text_end
operator|+=
name|text_pad
expr_stmt|;
comment|/* Data.  */
if|if
condition|(
operator|!
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
block|{
name|bfd_vma
name|vma
decl_stmt|;
name|vma
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|BFD_ALIGN
argument_list|(
name|vma
argument_list|,
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abdp
operator|&&
name|abdp
operator|->
name|zmagic_mapped_contiguous
condition|)
block|{
name|text_pad
operator|=
operator|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|-
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|-
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|text_pad
expr_stmt|;
block|}
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|)
expr_stmt|;
comment|/* Fix up exec header while we're at it.  */
name|execp
operator|->
name|a_text
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|ztih
operator|&&
operator|(
operator|!
name|abdp
operator|||
operator|(
name|abdp
operator|&&
operator|!
name|abdp
operator|->
name|exec_header_not_counted
operator|)
operator|)
condition|)
name|execp
operator|->
name|a_text
operator|+=
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
expr_stmt|;
if|if
condition|(
name|obj_aout_subformat
argument_list|(
name|abfd
argument_list|)
operator|==
name|q_magic_format
condition|)
name|N_SET_MAGIC
argument_list|(
operator|*
name|execp
argument_list|,
name|QMAGIC
argument_list|)
expr_stmt|;
else|else
name|N_SET_MAGIC
argument_list|(
operator|*
name|execp
argument_list|,
name|ZMAGIC
argument_list|)
expr_stmt|;
comment|/* Spec says data section should be rounded up to page boundary.  */
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|align_power
argument_list|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|BFD_ALIGN
argument_list|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
argument_list|)
expr_stmt|;
name|data_pad
operator|=
name|execp
operator|->
name|a_data
operator|-
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
comment|/* BSS.  */
if|if
condition|(
operator|!
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
operator|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|+
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|)
expr_stmt|;
comment|/* If the BSS immediately follows the data section and extra space      in the page is left after the data section, fudge data      in the header so that the bss section looks smaller by that      amount.  We'll start the bss section there, and lie to the OS.      (Note that a linker script, as well as the above assignment,      could have explicitly set the BSS vma to immediately follow      the data section.)  */
if|if
condition|(
name|align_power
argument_list|(
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
argument_list|,
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
argument_list|)
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|+
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
condition|)
name|execp
operator|->
name|a_bss
operator|=
operator|(
name|data_pad
operator|>
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|)
condition|?
literal|0
else|:
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|-
name|data_pad
expr_stmt|;
else|else
name|execp
operator|->
name|a_bss
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_n_magic
parameter_list|(
name|abfd
parameter_list|,
name|execp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
block|{
name|file_ptr
name|pos
init|=
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
decl_stmt|;
name|bfd_vma
name|vma
init|=
literal|0
decl_stmt|;
name|int
name|pad
decl_stmt|;
comment|/* Text.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
else|else
name|vma
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|pos
operator|+=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|vma
operator|+=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
comment|/* Data.  */
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|BFD_ALIGN
argument_list|(
name|vma
argument_list|,
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
argument_list|)
expr_stmt|;
name|vma
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
comment|/* Since BSS follows data immediately, see if it needs alignment.  */
name|vma
operator|+=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|pad
operator|=
name|align_power
argument_list|(
name|vma
argument_list|,
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
argument_list|)
operator|-
name|vma
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|pad
expr_stmt|;
name|pos
operator|+=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
comment|/* BSS.  */
if|if
condition|(
operator|!
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
else|else
name|vma
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
comment|/* Fix up exec header.  */
name|execp
operator|->
name|a_text
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|N_SET_MAGIC
argument_list|(
operator|*
name|execp
argument_list|,
name|NMAGIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|adjust_sizes_and_vmas
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|text_size
argument_list|,
name|text_end
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
modifier|*
name|text_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|file_ptr
modifier|*
name|text_end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|make_sections
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|!=
name|undecided_magic
condition|)
return|return
name|true
return|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|align_power
argument_list|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
operator|*
name|text_size
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
comment|/* Rule (heuristic) for when to pad to a new page.  Note that there      are (at least) two ways demand-paged (ZMAGIC) files have been      handled.  Most Berkeley-based systems start the text segment at      (TARGET_PAGE_SIZE).  However, newer versions of SUNOS start the text      segment right after the exec header; the latter is counted in the      text segment size, and is paged in by the kernel with the rest of      the text. */
comment|/* This perhaps isn't the right way to do this, but made it simpler for me      to understand enough to implement it.  Better would probably be to go      right from BFD flags to alignment/positioning characteristics.  But the      old code was sloppy enough about handling the flags, and had enough      other magic, that it was a little hard for me to understand.  I think      I understand it better now, but I haven't time to do the cleanup this      minute.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
condition|)
comment|/* Whether or not WP_TEXT is set -- let D_PAGED override.  */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|z_magic
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
condition|)
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|n_magic
expr_stmt|;
else|else
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|o_magic
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_AOUT_DEBUG
comment|/* requires gcc2 */
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
name|fprintf
argument_list|(
argument|stderr
argument_list|,
literal|"%s text=<%x,%x,%x> data=<%x,%x,%x> bss=<%x,%x,%x>\n"
argument_list|,
argument|({ char *str; 	      switch (adata(abfd).magic) { 	      case n_magic: str =
literal|"NMAGIC"
argument|; break; 	      case o_magic: str =
literal|"OMAGIC"
argument|; break; 	      case z_magic: str =
literal|"ZMAGIC"
argument|; break; 	      default: abort (); 	      } 	      str; 	    })
argument_list|,
argument|obj_textsec(abfd)->vma
argument_list|,
argument|obj_textsec(abfd)->_raw_size
argument_list|,
argument|obj_textsec(abfd)->alignment_power
argument_list|,
argument|obj_datasec(abfd)->vma
argument_list|,
argument|obj_datasec(abfd)->_raw_size
argument_list|,
argument|obj_datasec(abfd)->alignment_power
argument_list|,
argument|obj_bsssec(abfd)->vma
argument_list|,
argument|obj_bsssec(abfd)->_raw_size
argument_list|,
argument|obj_bsssec(abfd)->alignment_power
argument_list|)
empty_stmt|;
endif|#
directive|endif
endif|#
directive|endif
switch|switch
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
condition|)
block|{
case|case
name|o_magic
case|:
name|adjust_o_magic
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|)
expr_stmt|;
break|break;
case|case
name|z_magic
case|:
name|adjust_z_magic
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|)
expr_stmt|;
break|break;
case|case
name|n_magic
case|:
name|adjust_n_magic
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BFD_AOUT_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       text=<%x,%x,%x> data=<%x,%x,%x> bss=<%x,%x>\n"
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
argument_list|,
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
argument_list|,
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* FUNCTION 	aout_@var{size}_new_section_hook  SYNOPSIS         boolean aout_@var{size}_new_section_hook, 	   (bfd *abfd, 	    asection *newsect));  DESCRIPTION 	Called by the BFD in response to a @code{bfd_make_section} 	request. */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|new_section_hook
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|newsect
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* align to double at least */
name|newsect
operator|->
name|alignment_power
operator|=
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|section_align_power
expr_stmt|;
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_object
condition|)
block|{
if|if
condition|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|=
name|newsect
expr_stmt|;
name|newsect
operator|->
name|target_index
operator|=
name|N_TEXT
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|".data"
argument_list|)
condition|)
block|{
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
name|newsect
expr_stmt|;
name|newsect
operator|->
name|target_index
operator|=
name|N_DATA
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
condition|)
block|{
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|=
name|newsect
expr_stmt|;
name|newsect
operator|->
name|target_index
operator|=
name|N_BSS
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* We allow more than three sections internally */
return|return
name|true
return|;
block|}
end_block

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|set_section_contents
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sec_ptr
name|section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|location
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|file_ptr
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|file_ptr
name|text_end
decl_stmt|;
name|bfd_size_type
name|text_size
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|adjust_sizes_and_vmas
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|text_size
argument_list|,
operator|&
name|text_end
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|section
operator|==
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|section
operator|!=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|&&
name|section
operator|!=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: can not represent section `%s' in a.out object file format"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_write
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read the external symbols from an a.out file.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_get_external_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_size_type
name|count
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|syms
decl_stmt|;
name|count
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
operator|/
name|EXTERNAL_NLIST_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
if|if
condition|(
name|bfd_get_file_window
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
argument_list|,
operator|&
name|obj_aout_sym_window
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|true
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|syms
operator|=
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|obj_aout_sym_window
argument_list|(
name|abfd
argument_list|)
operator|.
name|data
expr_stmt|;
else|#
directive|else
comment|/* We allocate using malloc to make the values easy to free 	 later on.  If we put them on the objalloc it might not be 	 possible to free them.  */
name|syms
operator|=
operator|(
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|count
operator|*
name|EXTERNAL_NLIST_SIZE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|NULL
operator|&&
name|count
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|syms
argument_list|,
literal|1
argument_list|,
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
argument_list|,
name|abfd
argument_list|)
operator|!=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
operator|)
condition|)
block|{
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
endif|#
directive|endif
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|syms
expr_stmt|;
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|string_chars
index|[
name|BYTES_IN_WORD
index|]
decl_stmt|;
name|bfd_size_type
name|stringsize
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
comment|/* Get the size of the strings.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|string_chars
argument_list|,
name|BYTES_IN_WORD
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|BYTES_IN_WORD
operator|)
condition|)
return|return
name|false
return|;
name|stringsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|string_chars
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
if|if
condition|(
name|bfd_get_file_window
argument_list|(
name|abfd
argument_list|,
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|stringsize
argument_list|,
operator|&
name|obj_aout_string_window
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|true
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|obj_aout_string_window
argument_list|(
name|abfd
argument_list|)
operator|.
name|data
expr_stmt|;
else|#
directive|else
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|stringsize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Skip space for the string count in the buffer for convenience 	 when using indexes.  */
if|if
condition|(
name|bfd_read
argument_list|(
name|strings
operator|+
name|BYTES_IN_WORD
argument_list|,
literal|1
argument_list|,
name|stringsize
operator|-
name|BYTES_IN_WORD
argument_list|,
name|abfd
argument_list|)
operator|!=
name|stringsize
operator|-
name|BYTES_IN_WORD
condition|)
block|{
name|free
argument_list|(
name|strings
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
endif|#
directive|endif
comment|/* Ensure that a zero index yields an empty string.  */
name|strings
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strings
index|[
name|stringsize
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
operator|=
name|strings
expr_stmt|;
name|obj_aout_external_string_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|stringsize
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Translate an a.out symbol into a BFD symbol.  The desc, other, type    and symbol->value fields of CACHE_PTR will be set from the a.out    nlist structure.  This function is responsible for setting    symbol->flags and symbol->section, and adjusting symbol->value.  */
end_comment

begin_function
specifier|static
name|boolean
name|translate_from_native_sym_flags
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|aout_symbol_type
modifier|*
name|cache_ptr
decl_stmt|;
block|{
name|flagword
name|visible
decl_stmt|;
if|if
condition|(
operator|(
name|cache_ptr
operator|->
name|type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
operator|||
name|cache_ptr
operator|->
name|type
operator|==
name|N_FN
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* This is a debugging symbol.  */
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
comment|/* Work out the symbol section.  */
switch|switch
condition|(
name|cache_ptr
operator|->
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_FN
case|:
name|sec
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|sec
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|sec
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|N_ABS
case|:
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
break|break;
block|}
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|sec
operator|->
name|vma
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Get the default visibility.  This does not apply to all types, so      we just hold it in a local variable to use if wanted.  */
if|if
condition|(
operator|(
name|cache_ptr
operator|->
name|type
operator|&
name|N_EXT
operator|)
operator|==
literal|0
condition|)
name|visible
operator|=
name|BSF_LOCAL
expr_stmt|;
else|else
name|visible
operator|=
name|BSF_GLOBAL
expr_stmt|;
switch|switch
condition|(
name|cache_ptr
operator|->
name|type
condition|)
block|{
default|default:
case|case
name|N_ABS
case|:
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|visible
expr_stmt|;
break|break;
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
if|if
condition|(
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* This is a common symbol.  */
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
block|}
else|else
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
break|break;
case|case
name|N_TEXT
case|:
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|visible
expr_stmt|;
break|break;
comment|/* N_SETV symbols used to represent set vectors placed in the 	 data section.  They are no longer generated.  Theoretically, 	 it was possible to extract the entries and combine them with 	 new ones, although I don't know if that was ever actually 	 done.  Unless that feature is restored, treat them as data 	 symbols.  */
case|case
name|N_SETV
case|:
case|case
name|N_SETV
operator||
name|N_EXT
case|:
case|case
name|N_DATA
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|visible
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|visible
expr_stmt|;
break|break;
case|case
name|N_SETA
case|:
case|case
name|N_SETA
operator||
name|N_EXT
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETT
operator||
name|N_EXT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETD
operator||
name|N_EXT
case|:
case|case
name|N_SETB
case|:
case|case
name|N_SETB
operator||
name|N_EXT
case|:
block|{
comment|/* This code is no longer needed.  It used to be used to make            the linker handle set symbols, but they are now handled in            the add_symbols routine instead.  */
if|#
directive|if
literal|0
block|asection *section; 	arelent_chain *reloc; 	asection *into_section;
comment|/* This is a set symbol.  The name of the symbol is the name 	   of the set (e.g., __CTOR_LIST__).  The value of the symbol 	   is the value to add to the set.  We create a section with 	   the same name as the symbol, and add a reloc to insert the 	   appropriate value into the section.  	   This action is actually obsolete; it used to make the 	   linker do the right thing, but the linker no longer uses 	   this function.  */
block|section = bfd_get_section_by_name (abfd, cache_ptr->symbol.name); 	if (section == NULL) 	  { 	    char *copy;  	    copy = bfd_alloc (abfd, strlen (cache_ptr->symbol.name) + 1); 	    if (copy == NULL) 	      return false;  	    strcpy (copy, cache_ptr->symbol.name); 	    section = bfd_make_section (abfd, copy); 	    if (section == NULL) 	      return false; 	  }  	reloc = (arelent_chain *) bfd_alloc (abfd, sizeof (arelent_chain)); 	if (reloc == NULL) 	  return false;
comment|/* Build a relocation entry for the constructor.  */
block|switch (cache_ptr->type& N_TYPE) 	  { 	  case N_SETA: 	    into_section = bfd_abs_section_ptr; 	    cache_ptr->type = N_ABS; 	    break; 	  case N_SETT: 	    into_section = obj_textsec (abfd); 	    cache_ptr->type = N_TEXT; 	    break; 	  case N_SETD: 	    into_section = obj_datasec (abfd); 	    cache_ptr->type = N_DATA; 	    break; 	  case N_SETB: 	    into_section = obj_bsssec (abfd); 	    cache_ptr->type = N_BSS; 	    break; 	  }
comment|/* Build a relocation pointing into the constructor section 	   pointing at the symbol in the set vector specified.  */
block|reloc->relent.addend = cache_ptr->symbol.value; 	cache_ptr->symbol.section = into_section; 	reloc->relent.sym_ptr_ptr = into_section->symbol_ptr_ptr;
comment|/* We modify the symbol to belong to a section depending upon 	   the name of the symbol, and add to the size of the section 	   to contain a pointer to the symbol. Build a reloc entry to 	   relocate to this symbol attached to this section.  */
block|section->flags = SEC_CONSTRUCTOR | SEC_RELOC;  	section->reloc_count++; 	section->alignment_power = 2;  	reloc->next = section->constructor_chain; 	section->constructor_chain = reloc; 	reloc->relent.address = section->_raw_size; 	section->_raw_size += BYTES_IN_WORD;  	reloc->relent.howto = CTOR_TABLE_RELOC_HOWTO(abfd);
endif|#
directive|endif
comment|/* 0 */
switch|switch
condition|(
name|cache_ptr
operator|->
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_SETA
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
break|break;
case|case
name|N_SETT
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SETD
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SETB
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
block|}
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_CONSTRUCTOR
expr_stmt|;
block|}
break|break;
case|case
name|N_WARNING
case|:
comment|/* This symbol is the text of a warning message.  The next 	 symbol is the symbol to associate the warning with.  If a 	 reference is made to that symbol, a warning is issued.  */
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
operator||
name|BSF_WARNING
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
break|break;
case|case
name|N_INDR
case|:
case|case
name|N_INDR
operator||
name|N_EXT
case|:
comment|/* An indirect symbol.  This consists of two symbols in a row. 	 The first symbol is the name of the indirection.  The second 	 symbol is the name of the target.  A reference to the first 	 symbol becomes a reference to the second.  */
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
operator||
name|BSF_INDIRECT
operator||
name|visible
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_ind_section_ptr
expr_stmt|;
break|break;
case|case
name|N_WEAKU
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|N_WEAKA
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|N_WEAKT
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|N_WEAKD
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|N_WEAKB
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the fields of SYM_POINTER according to CACHE_PTR.  */
end_comment

begin_function
specifier|static
name|boolean
name|translate_to_native_sym_flags
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|sym_pointer
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|cache_ptr
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|sym_pointer
decl_stmt|;
block|{
name|bfd_vma
name|value
init|=
name|cache_ptr
operator|->
name|value
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
comment|/* Mask out any existing type bits in case copying from one section      to another.  */
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|&=
operator|~
name|N_TYPE
expr_stmt|;
name|sec
operator|=
name|bfd_get_section
argument_list|(
name|cache_ptr
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
comment|/* This case occurs, e.g., for the *DEBUG* section of a COFF 	 file.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: can not represent section for symbol `%s' in a.out object file format"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|cache_ptr
operator|->
name|name
operator|!=
name|NULL
condition|?
name|cache_ptr
operator|->
name|name
else|:
literal|"*unknown*"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|off
operator|=
name|sec
operator|->
name|output_offset
expr_stmt|;
name|sec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_BSS
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_ind_section
argument_list|(
name|sec
argument_list|)
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
name|N_INDR
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: can not represent section `%s' in a.out object file format"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Turn the symbol from section relative to absolute again */
name|value
operator|+=
name|sec
operator|->
name|vma
operator|+
name|off
expr_stmt|;
if|if
condition|(
operator|(
name|cache_ptr
operator|->
name|flags
operator|&
name|BSF_WARNING
operator|)
operator|!=
literal|0
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
name|N_WARNING
expr_stmt|;
if|if
condition|(
operator|(
name|cache_ptr
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|aout_symbol_type
operator|*
operator|)
name|cache_ptr
operator|)
operator|->
name|type
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cache_ptr
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
condition|)
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_EXT
expr_stmt|;
if|if
condition|(
operator|(
name|cache_ptr
operator|->
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|type
init|=
operator|(
operator|(
name|aout_symbol_type
operator|*
operator|)
name|cache_ptr
operator|)
operator|->
name|type
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_ABS
case|:
name|type
operator|=
name|N_SETA
expr_stmt|;
break|break;
case|case
name|N_TEXT
case|:
name|type
operator|=
name|N_SETT
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|type
operator|=
name|N_SETD
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|type
operator|=
name|N_SETB
expr_stmt|;
break|break;
block|}
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cache_ptr
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|&
name|N_TYPE
condition|)
block|{
default|default:
case|case
name|N_ABS
case|:
name|type
operator|=
name|N_WEAKA
expr_stmt|;
break|break;
case|case
name|N_TEXT
case|:
name|type
operator|=
name|N_WEAKT
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|type
operator|=
name|N_WEAKD
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|type
operator|=
name|N_WEAKB
expr_stmt|;
break|break;
case|case
name|N_UNDF
case|:
name|type
operator|=
name|N_WEAKU
expr_stmt|;
break|break;
block|}
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
name|type
expr_stmt|;
block|}
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|sym_pointer
operator|->
name|e_value
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Native-level interface to symbols. */
end_comment

begin_decl_stmt
name|asymbol
modifier|*
name|NAME
argument_list|(
name|aout
argument_list|,
name|make_empty_symbol
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|aout_symbol_type
modifier|*
name|new
init|=
operator|(
name|aout_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|aout_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|NULL
return|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_block

begin_comment
comment|/* Translate a set of internal symbols into external symbols.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|translate_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|in
argument_list|,
name|ext
argument_list|,
name|count
argument_list|,
name|str
argument_list|,
name|strsize
argument_list|,
name|dynamic
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|aout_symbol_type
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|external_nlist
modifier|*
name|ext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|strsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|dynamic
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|external_nlist
modifier|*
name|ext_end
decl_stmt|;
name|ext_end
operator|=
name|ext
operator|+
name|count
expr_stmt|;
for|for
control|(
init|;
name|ext
operator|<
name|ext_end
condition|;
name|ext
operator|++
operator|,
name|in
operator|++
control|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|x
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_strx
argument_list|)
expr_stmt|;
name|in
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
comment|/* For the normal symbols, the zero index points at the number 	 of bytes in the string table but is to be interpreted as the 	 null string.  For the dynamic symbols, the number of bytes in 	 the string table is stored in the __DYNAMIC structure and the 	 zero index points at an actual string.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
operator|!
name|dynamic
condition|)
name|in
operator|->
name|symbol
operator|.
name|name
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|<
name|strsize
condition|)
name|in
operator|->
name|symbol
operator|.
name|name
operator|=
name|str
operator|+
name|x
expr_stmt|;
else|else
return|return
name|false
return|;
name|in
operator|->
name|symbol
operator|.
name|value
operator|=
name|GET_SWORD
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|desc
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_desc
argument_list|)
expr_stmt|;
name|in
operator|->
name|other
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_other
argument_list|)
expr_stmt|;
name|in
operator|->
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|in
operator|->
name|symbol
operator|.
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|translate_from_native_sym_flags
argument_list|(
name|abfd
argument_list|,
name|in
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dynamic
condition|)
name|in
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_DYNAMIC
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* We read the symbols into a buffer, which is discarded when this    function exits.  We read the strings into a buffer large enough to    hold them all plus all the cached symbol entries. */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|external_nlist
modifier|*
name|old_external_syms
decl_stmt|;
name|aout_symbol_type
modifier|*
name|cached
decl_stmt|;
name|size_t
name|cached_size
decl_stmt|;
comment|/* If there's no work to be done, don't do any */
if|if
condition|(
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|aout_symbol_type
operator|*
operator|)
name|NULL
condition|)
return|return
name|true
return|;
name|old_external_syms
operator|=
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aout_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|cached_size
operator|=
operator|(
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|aout_symbol_type
argument_list|)
operator|)
expr_stmt|;
name|cached
operator|=
operator|(
name|aout_symbol_type
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|cached_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached
operator|==
name|NULL
operator|&&
name|cached_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|cached_size
operator|!=
literal|0
condition|)
name|memset
argument_list|(
name|cached
argument_list|,
literal|0
argument_list|,
name|cached_size
argument_list|)
expr_stmt|;
comment|/* Convert from external symbol information to internal.  */
if|if
condition|(
operator|!
operator|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|translate_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|cached
argument_list|,
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|obj_aout_external_string_size
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|false
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|cached
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|cached
expr_stmt|;
comment|/* It is very likely that anybody who calls this function will not      want the external symbol information, so if it was allocated      because of our call to aout_get_external_symbols, we free it up      right away to save space.  */
if|if
condition|(
name|old_external_syms
operator|==
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|NULL
operator|&&
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_MMAP
name|bfd_free_window
argument_list|(
operator|&
name|obj_aout_sym_window
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* We use a hash table when writing out symbols so that we only write    out a particular string once.  This helps particularly when the    linker writes out stabs debugging entries, because each different    contributing object file tends to have many duplicate stabs    strings.     This hash table code breaks dbx on SunOS 4.1.3, so we don't do it    if BFD_TRADITIONAL_FORMAT is set.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_size_type
name|add_to_stringtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_strtab_hash
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|emit_stringtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_strtab_hash
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the index of a string in a strtab, adding it if it is not    already present.  */
end_comment

begin_function
specifier|static
name|INLINE
name|bfd_size_type
name|add_to_stringtab
parameter_list|(
name|abfd
parameter_list|,
name|tab
parameter_list|,
name|str
parameter_list|,
name|copy
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|tab
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
block|{
name|boolean
name|hash
decl_stmt|;
name|bfd_size_type
name|index
decl_stmt|;
comment|/* An index of 0 always means the empty string.  */
if|if
condition|(
name|str
operator|==
literal|0
operator|||
operator|*
name|str
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Don't hash if BFD_TRADITIONAL_FORMAT is set, because SunOS dbx      doesn't understand a hashed string table.  */
name|hash
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_TRADITIONAL_FORMAT
operator|)
operator|!=
literal|0
condition|)
name|hash
operator|=
name|false
expr_stmt|;
name|index
operator|=
name|_bfd_stringtab_add
argument_list|(
name|tab
argument_list|,
name|str
argument_list|,
name|hash
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Add BYTES_IN_WORD to the return value to account for the 	 space taken up by the string table size.  */
name|index
operator|+=
name|BYTES_IN_WORD
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Write out a strtab.  ABFD is already at the right location in the    file.  */
end_comment

begin_function
specifier|static
name|boolean
name|emit_stringtab
parameter_list|(
name|abfd
parameter_list|,
name|tab
parameter_list|)
specifier|register
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|tab
decl_stmt|;
block|{
name|bfd_byte
name|buffer
index|[
name|BYTES_IN_WORD
index|]
decl_stmt|;
comment|/* The string table starts with the size.  */
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|_bfd_stringtab_size
argument_list|(
name|tab
argument_list|)
operator|+
name|BYTES_IN_WORD
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
name|BYTES_IN_WORD
argument_list|,
name|abfd
argument_list|)
operator|!=
name|BYTES_IN_WORD
condition|)
return|return
name|false
return|;
return|return
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|tab
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|write_syms
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|generic
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|strtab
decl_stmt|;
name|strtab
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|strtab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|;
name|count
operator|++
control|)
block|{
name|asymbol
modifier|*
name|g
init|=
name|generic
index|[
name|count
index|]
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|struct
name|external_nlist
name|nsp
decl_stmt|;
name|indx
operator|=
name|add_to_stringtab
argument_list|(
name|abfd
argument_list|,
name|strtab
argument_list|,
name|g
operator|->
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|indx
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|nsp
operator|.
name|e_strx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
name|g
argument_list|)
operator|==
name|abfd
operator|->
name|xvec
operator|->
name|flavour
condition|)
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|aout_symbol
argument_list|(
name|g
argument_list|)
operator|->
name|desc
argument_list|,
name|nsp
operator|.
name|e_desc
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|aout_symbol
argument_list|(
name|g
argument_list|)
operator|->
name|other
argument_list|,
name|nsp
operator|.
name|e_other
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|aout_symbol
argument_list|(
name|g
argument_list|)
operator|->
name|type
argument_list|,
name|nsp
operator|.
name|e_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|nsp
operator|.
name|e_desc
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|nsp
operator|.
name|e_other
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|nsp
operator|.
name|e_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|translate_to_native_sym_flags
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
operator|&
name|nsp
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nsp
argument_list|,
literal|1
argument_list|,
name|EXTERNAL_NLIST_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|EXTERNAL_NLIST_SIZE
condition|)
goto|goto
name|error_return
goto|;
comment|/* NB: `KEEPIT' currently overlays `udata.p', so set this only 	 here, at the end.  */
name|g
operator|->
name|KEEPIT
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|emit_stringtab
argument_list|(
name|abfd
argument_list|,
name|strtab
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|_bfd_stringtab_free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
name|_bfd_stringtab_free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|long
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_symtab
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|location
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|location
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|aout_symbol_type
modifier|*
name|symbase
decl_stmt|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|symbase
operator|=
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
init|;
name|counter
operator|++
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|;
control|)
operator|*
operator|(
name|location
operator|++
operator|)
operator|=
operator|(
name|asymbol
operator|*
operator|)
operator|(
name|symbase
operator|++
operator|)
expr_stmt|;
operator|*
name|location
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Standard reloc stuff */
end_comment

begin_comment
comment|/* Output standard relocation information to a file in target byte order. */
end_comment

begin_function_decl
specifier|extern
name|void
name|NAME
parameter_list|(
name|aout
parameter_list|,
name|swap_std_reloc_out
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|arelent *
operator|,
function_decl|struct reloc_std_external *
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_std_reloc_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|natptr
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|g
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|reloc_std_external
modifier|*
name|natptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|r_index
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_length
decl_stmt|;
name|int
name|r_pcrel
decl_stmt|;
name|int
name|r_baserel
decl_stmt|,
name|r_jmptable
decl_stmt|,
name|r_relative
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|sym
operator|->
name|section
operator|->
name|output_section
decl_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|address
argument_list|,
name|natptr
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|r_length
operator|=
name|g
operator|->
name|howto
operator|->
name|size
expr_stmt|;
comment|/* Size as a power of two */
name|r_pcrel
operator|=
operator|(
name|int
operator|)
name|g
operator|->
name|howto
operator|->
name|pc_relative
expr_stmt|;
comment|/* Relative to PC? */
comment|/* XXX This relies on relocs coming from a.out files.  */
name|r_baserel
operator|=
operator|(
name|g
operator|->
name|howto
operator|->
name|type
operator|&
literal|8
operator|)
operator|!=
literal|0
expr_stmt|;
name|r_jmptable
operator|=
operator|(
name|g
operator|->
name|howto
operator|->
name|type
operator|&
literal|16
operator|)
operator|!=
literal|0
expr_stmt|;
name|r_relative
operator|=
operator|(
name|g
operator|->
name|howto
operator|->
name|type
operator|&
literal|32
operator|)
operator|!=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* For a standard reloc, the addend is in the object file.  */
block|r_addend = g->addend + (*(g->sym_ptr_ptr))->section->output_section->vma;
endif|#
directive|endif
comment|/* name was clobbered by aout_write_syms to be symbol index */
comment|/* If this relocation is relative to a symbol then set the      r_index to the symbols index, and the r_extern bit.       Absolute symbols can come in in two ways, either as an offset      from the abs section, or as a symbol which has an abs value.      check for that here      */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|output_section
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_abs_section_ptr
operator|->
name|symbol
operator|==
name|sym
condition|)
block|{
comment|/* Whoops, looked like an abs symbol, but is really an offset 	   from the abs section */
name|r_index
operator|=
name|N_ABS
expr_stmt|;
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill in symbol */
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_index
operator|=
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|KEEPIT
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just an ordinary section */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
comment|/* now the fun stuff */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_baserel
condition|?
name|RELOC_STD_BITS_BASEREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_jmptable
condition|?
name|RELOC_STD_BITS_JMPTABLE_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_relative
condition|?
name|RELOC_STD_BITS_RELATIVE_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_baserel
condition|?
name|RELOC_STD_BITS_BASEREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_jmptable
condition|?
name|RELOC_STD_BITS_JMPTABLE_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_relative
condition|?
name|RELOC_STD_BITS_RELATIVE_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Extended stuff */
end_comment

begin_comment
comment|/* Output extended relocation information to a file in target byte order. */
end_comment

begin_function_decl
specifier|extern
name|void
name|NAME
parameter_list|(
name|aout
parameter_list|,
name|swap_ext_reloc_out
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|arelent *
operator|,
function_decl|struct reloc_ext_external *
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_ext_reloc_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|natptr
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|g
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|reloc_ext_external
modifier|*
name|natptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|int
name|r_addend
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|sym
operator|->
name|section
operator|->
name|output_section
decl_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|address
argument_list|,
name|natptr
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|r_type
operator|=
operator|(
name|unsigned
name|int
operator|)
name|g
operator|->
name|howto
operator|->
name|type
expr_stmt|;
name|r_addend
operator|=
name|g
operator|->
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|r_addend
operator|+=
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* If this relocation is relative to a symbol then set the      r_index to the symbols index, and the r_extern bit.       Absolute symbols can come in in two ways, either as an offset      from the abs section, or as a symbol which has an abs value.      check for that here.  */
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|N_ABS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
condition|)
name|r_extern
operator|=
literal|1
expr_stmt|;
else|else
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|KEEPIT
expr_stmt|;
block|}
else|else
block|{
comment|/* Just an ordinary section */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
comment|/* now the fun stuff */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|r_extern
condition|?
name|RELOC_EXT_BITS_EXTERN_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_type
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_EXT_BITS_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_type
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
operator|)
expr_stmt|;
block|}
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|r_addend
argument_list|,
name|natptr
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* BFD deals internally with all things based from the section they're    in. so, something in 10 bytes into a text section  with a base of    50 would have a symbol (.text+10) and know .text vma was 50.     Aout keeps all it's symbols based from zero, so the symbol would    contain 60. This macro subs the base of each section from the value    to give the true offset from the section */
end_comment

begin_define
define|#
directive|define
name|MOVE_ADDRESS
parameter_list|(
name|ad
parameter_list|)
define|\
value|if (r_extern) {							\
comment|/* undefined symbol */
value|\      cache_ptr->sym_ptr_ptr = symbols + r_index;			\      cache_ptr->addend = ad;						\      } else {								\
comment|/* defined, section relative. replace symbol with pointer to    	\        symbol which points to section  */
value|\     switch (r_index) {							\     case N_TEXT:							\     case N_TEXT | N_EXT:						\       cache_ptr->sym_ptr_ptr  = obj_textsec(abfd)->symbol_ptr_ptr;	\       cache_ptr->addend = ad  - su->textsec->vma;			\       break;								\     case N_DATA:							\     case N_DATA | N_EXT:						\       cache_ptr->sym_ptr_ptr  = obj_datasec(abfd)->symbol_ptr_ptr;	\       cache_ptr->addend = ad - su->datasec->vma;			\       break;								\     case N_BSS:								\     case N_BSS | N_EXT:							\       cache_ptr->sym_ptr_ptr  = obj_bsssec(abfd)->symbol_ptr_ptr;	\       cache_ptr->addend = ad - su->bsssec->vma;				\       break;								\     default:								\     case N_ABS:								\     case N_ABS | N_EXT:							\      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;	\       cache_ptr->addend = ad;						\       break;								\     }									\   }     								\  void
end_define

begin_macro
name|NAME
argument_list|(
argument|aout
argument_list|,
argument|swap_ext_reloc_in
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|abfd
operator|,
name|bytes
operator|,
name|cache_ptr
operator|,
name|symbols
operator|,
name|symcount
operator|)
name|bfd
operator|*
name|abfd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|reloc_ext_external
modifier|*
name|bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|symcount
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|aoutdata
modifier|*
name|su
init|=
operator|&
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|)
decl_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
operator|(
name|GET_SWORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_address
argument_list|)
operator|)
expr_stmt|;
comment|/* now the fun stuff */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|r_index
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|bytes
operator|->
name|r_index
index|[
literal|2
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_EXTERN_BIG
operator|)
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_BIG
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_BIG
expr_stmt|;
block|}
else|else
block|{
name|r_index
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_EXTERN_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|howto
operator|=
name|howto_table_ext
operator|+
name|r_type
expr_stmt|;
comment|/* Base relative relocs are always against the symbol table,      regardless of the setting of r_extern.  r_extern just reflects      whether the symbol the reloc is against is local or global.  */
if|if
condition|(
name|r_type
operator|==
name|RELOC_BASE10
operator|||
name|r_type
operator|==
name|RELOC_BASE13
operator|||
name|r_type
operator|==
name|RELOC_BASE22
condition|)
name|r_extern
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|r_extern
operator|&&
name|r_index
operator|>
name|symcount
condition|)
block|{
comment|/* We could arrange to return an error, but it might be useful          to see the file even if it is bad.  */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|N_ABS
expr_stmt|;
block|}
name|MOVE_ADDRESS
argument_list|(
name|GET_SWORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_addend
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_std_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|bytes
argument_list|,
name|cache_ptr
argument_list|,
name|symbols
argument_list|,
name|symcount
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|reloc_std_external
modifier|*
name|bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|symcount
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_length
decl_stmt|;
name|int
name|r_pcrel
decl_stmt|;
name|int
name|r_baserel
decl_stmt|,
name|r_jmptable
decl_stmt|,
name|r_relative
decl_stmt|;
name|struct
name|aoutdata
modifier|*
name|su
init|=
operator|&
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|)
decl_stmt|;
name|unsigned
name|int
name|howto_idx
decl_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_address
argument_list|)
expr_stmt|;
comment|/* now the fun stuff */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|r_index
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|bytes
operator|->
name|r_index
index|[
literal|2
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_EXTERN_BIG
operator|)
operator|)
expr_stmt|;
name|r_pcrel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_PCREL_BIG
operator|)
operator|)
expr_stmt|;
name|r_baserel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_BASEREL_BIG
operator|)
operator|)
expr_stmt|;
name|r_jmptable
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_JMPTABLE_BIG
operator|)
operator|)
expr_stmt|;
name|r_relative
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_RELATIVE_BIG
operator|)
operator|)
expr_stmt|;
name|r_length
operator|=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_LENGTH_BIG
operator|)
operator|>>
name|RELOC_STD_BITS_LENGTH_SH_BIG
expr_stmt|;
block|}
else|else
block|{
name|r_index
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_EXTERN_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_pcrel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_PCREL_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_baserel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_BASEREL_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_jmptable
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_JMPTABLE_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_relative
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_RELATIVE_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_length
operator|=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_LENGTH_LITTLE
operator|)
operator|>>
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
expr_stmt|;
block|}
name|howto_idx
operator|=
name|r_length
operator|+
literal|4
operator|*
name|r_pcrel
operator|+
literal|8
operator|*
name|r_baserel
operator|+
literal|16
operator|*
name|r_jmptable
operator|+
literal|32
operator|*
name|r_relative
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|howto_idx
operator|<
name|TABLE_SIZE
argument_list|(
name|howto_table_std
argument_list|)
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|howto_table_std
operator|+
name|howto_idx
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|cache_ptr
operator|->
name|howto
operator|->
name|type
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Base relative relocs are always against the symbol table,      regardless of the setting of r_extern.  r_extern just reflects      whether the symbol the reloc is against is local or global.  */
if|if
condition|(
name|r_baserel
condition|)
name|r_extern
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|r_extern
operator|&&
name|r_index
operator|>
name|symcount
condition|)
block|{
comment|/* We could arrange to return an error, but it might be useful          to see the file even if it is bad.  */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|N_ABS
expr_stmt|;
block|}
name|MOVE_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read and swap the relocs for a section.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_reloc_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|symbols
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sec_ptr
name|asect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|bfd_size_type
name|reloc_size
decl_stmt|;
name|PTR
name|relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
name|size_t
name|each_size
decl_stmt|;
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
expr_stmt|;
elseif|else
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
expr_stmt|;
elseif|else
if|if
condition|(
name|asect
operator|==
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
name|reloc_size
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|each_size
operator|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|count
operator|=
name|reloc_size
operator|/
name|each_size
expr_stmt|;
name|reloc_cache
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_cache
operator|==
name|NULL
operator|&&
name|count
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|reloc_cache
argument_list|,
literal|0
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|relocs
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocs
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|reloc_cache
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
name|relocs
argument_list|,
literal|1
argument_list|,
name|reloc_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|reloc_size
condition|)
block|{
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reloc_cache
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|cache_ptr
operator|=
name|reloc_cache
expr_stmt|;
if|if
condition|(
name|each_size
operator|==
name|RELOC_EXT_SIZE
condition|)
block|{
specifier|register
name|struct
name|reloc_ext_external
modifier|*
name|rptr
init|=
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|relocs
decl_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|count
condition|;
name|counter
operator|++
operator|,
name|rptr
operator|++
operator|,
name|cache_ptr
operator|++
control|)
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_ext_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|rptr
argument_list|,
name|cache_ptr
argument_list|,
name|symbols
argument_list|,
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|reloc_std_external
modifier|*
name|rptr
init|=
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|relocs
decl_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|count
condition|;
name|counter
operator|++
operator|,
name|rptr
operator|++
operator|,
name|cache_ptr
operator|++
control|)
name|MY_swap_std_reloc_in
argument_list|(
name|abfd
argument_list|,
name|rptr
argument_list|,
name|cache_ptr
argument_list|,
name|symbols
argument_list|,
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|cache_ptr
operator|-
name|reloc_cache
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Write out a relocation section into an object file.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|squirt_out_relocs
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|section
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|arelent
modifier|*
modifier|*
name|generic
decl_stmt|;
name|unsigned
name|char
modifier|*
name|native
decl_stmt|,
modifier|*
name|natptr
decl_stmt|;
name|size_t
name|each_size
decl_stmt|;
name|unsigned
name|int
name|count
init|=
name|section
operator|->
name|reloc_count
decl_stmt|;
name|size_t
name|natsize
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|section
operator|->
name|orelocation
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|each_size
operator|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|natsize
operator|=
name|each_size
operator|*
name|count
expr_stmt|;
name|native
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|natsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|native
condition|)
return|return
name|false
return|;
name|generic
operator|=
name|section
operator|->
name|orelocation
expr_stmt|;
if|if
condition|(
name|each_size
operator|==
name|RELOC_EXT_SIZE
condition|)
block|{
for|for
control|(
name|natptr
operator|=
name|native
init|;
name|count
operator|!=
literal|0
condition|;
operator|--
name|count
operator|,
name|natptr
operator|+=
name|each_size
operator|,
operator|++
name|generic
control|)
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_ext_reloc_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|*
name|generic
argument_list|,
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|natptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|natptr
operator|=
name|native
init|;
name|count
operator|!=
literal|0
condition|;
operator|--
name|count
operator|,
name|natptr
operator|+=
name|each_size
operator|,
operator|++
name|generic
control|)
name|MY_swap_std_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|*
name|generic
argument_list|,
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|natptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|native
argument_list|,
literal|1
argument_list|,
name|natsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|natsize
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|native
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|native
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* This is stupid.  This function should be a boolean predicate */
end_comment

begin_decl_stmt
name|long
name|NAME
argument_list|(
name|aout
argument_list|,
name|canonicalize_reloc
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|relptr
argument_list|,
name|symbols
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sec_ptr
name|section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|tblptr
operator|||
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_reloc_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_block

begin_decl_stmt
name|long
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_reloc_upper_bound
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sec_ptr
name|asect
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|/
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|)
operator|+
literal|1
operator|)
operator|)
return|;
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|/
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|)
operator|+
literal|1
operator|)
operator|)
return|;
if|if
condition|(
name|asect
operator|==
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
if|if
condition|(
name|asect
operator|==
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|0
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|long
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_symtab_upper_bound
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|aout_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|alent
modifier|*
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_lineno
argument_list|)
argument_list|(
name|ignore_abfd
argument_list|,
name|ignore_symbol
argument_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
name|ignore_symbol
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|alent
operator|*
operator|)
name|NULL
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_symbol_info
argument_list|)
argument_list|(
name|ignore_abfd
argument_list|,
name|symbol
argument_list|,
name|ret
argument_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbol_info
modifier|*
name|ret
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|type
operator|==
literal|'?'
condition|)
block|{
name|int
name|type_code
init|=
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|type
operator|&
literal|0xff
decl_stmt|;
specifier|const
name|char
modifier|*
name|stab_name
init|=
name|bfd_get_stab_name
argument_list|(
name|type_code
argument_list|)
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|stab_name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d)"
argument_list|,
name|type_code
argument_list|)
expr_stmt|;
name|stab_name
operator|=
name|buf
expr_stmt|;
block|}
name|ret
operator|->
name|type
operator|=
literal|'-'
expr_stmt|;
name|ret
operator|->
name|stab_type
operator|=
name|type_code
expr_stmt|;
name|ret
operator|->
name|stab_other
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|other
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ret
operator|->
name|stab_desc
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|desc
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|ret
operator|->
name|stab_name
operator|=
name|stab_name
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|aout
argument_list|,
name|print_symbol
argument_list|)
argument_list|(
name|ignore_abfd
argument_list|,
name|afile
argument_list|,
name|symbol
argument_list|,
name|how
argument_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|afile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_print_symbol_type
name|how
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
if|if
condition|(
name|symbol
operator|->
name|name
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%4x %2x %2x"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|desc
operator|&
literal|0xffff
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|other
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %04x %02x %02x"
argument_list|,
name|section_name
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|desc
operator|&
literal|0xffff
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|other
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|type
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|name
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_comment
comment|/* If we don't have to allocate more than 1MB to hold the generic    symbols, we use the generic minisymbol methord: it's faster, since    it only translates the symbols once, not multiple times.  */
end_comment

begin_define
define|#
directive|define
name|MINISYM_THRESHOLD
value|(1000000 / sizeof (asymbol))
end_define

begin_comment
comment|/* Read minisymbols.  For minisymbols, we use the unmodified a.out    symbols.  The minisymbol_to_symbol function translates these into    BFD asymbol structures.  */
end_comment

begin_decl_stmt
name|long
name|NAME
argument_list|(
name|aout
argument_list|,
name|read_minisymbols
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisymsp
argument_list|,
name|sizep
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
modifier|*
name|minisymsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
modifier|*
name|sizep
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|dynamic
condition|)
block|{
comment|/* We could handle the dynamic symbols here as well, but it's          easier to hand them off.  */
return|return
name|_bfd_generic_read_minisymbols
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisymsp
argument_list|,
name|sizep
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|aout_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
operator|<
name|MINISYM_THRESHOLD
condition|)
return|return
name|_bfd_generic_read_minisymbols
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisymsp
argument_list|,
name|sizep
argument_list|)
return|;
operator|*
name|minisymsp
operator|=
operator|(
name|PTR
operator|)
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* By passing the external symbols back from this routine, we are      giving up control over the memory block.  Clear      obj_aout_external_syms, so that we do not try to free it      ourselves.  */
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
operator|*
name|sizep
operator|=
name|EXTERNAL_NLIST_SIZE
expr_stmt|;
return|return
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Convert a minisymbol to a BFD asymbol.  A minisymbol is just an    unmodified a.out symbol.  The SYM argument is a structure returned    by bfd_make_empty_symbol, which we fill in here.  */
end_comment

begin_decl_stmt
name|asymbol
modifier|*
name|NAME
argument_list|(
name|aout
argument_list|,
name|minisymbol_to_symbol
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisym
argument_list|,
name|sym
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|PTR
name|minisym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|dynamic
operator|||
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
operator|<
name|MINISYM_THRESHOLD
condition|)
return|return
name|_bfd_generic_minisymbol_to_symbol
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisym
argument_list|,
name|sym
argument_list|)
return|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aout_symbol_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We call translate_symbol_table to translate a single symbol.  */
if|if
condition|(
operator|!
operator|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|translate_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|aout_symbol_type
operator|*
operator|)
name|sym
argument_list|,
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|minisym
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|obj_aout_external_string_size
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|false
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|sym
return|;
block|}
end_block

begin_comment
comment|/*  provided a BFD, a section and an offset into the section, calculate  and return the name of the source file and the line nearest to the  wanted location. */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|find_nearest_line
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONST
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONST
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Run down the file looking for the filename, function and linenumber */
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
name|CONST
name|char
modifier|*
name|directory_name
init|=
name|NULL
decl_stmt|;
name|CONST
name|char
modifier|*
name|main_file_name
init|=
name|NULL
decl_stmt|;
name|CONST
name|char
modifier|*
name|current_file_name
init|=
name|NULL
decl_stmt|;
name|CONST
name|char
modifier|*
name|line_file_name
init|=
name|NULL
decl_stmt|;
comment|/* Value of current_file_name at line number. */
name|bfd_vma
name|low_line_vma
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|low_func_vma
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
name|func
init|=
literal|0
decl_stmt|;
name|size_t
name|filelen
decl_stmt|,
name|funclen
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
operator|*
name|filename_ptr
operator|=
name|abfd
operator|->
name|filename
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
literal|0
expr_stmt|;
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbols
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
name|symbols
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|aout_symbol_type
modifier|*
name|q
init|=
operator|(
name|aout_symbol_type
operator|*
operator|)
operator|(
operator|*
name|p
operator|)
decl_stmt|;
name|next
label|:
switch|switch
condition|(
name|q
operator|->
name|type
condition|)
block|{
case|case
name|N_TEXT
case|:
comment|/* If this looks like a file name symbol, and it comes after            the line number we have found so far, but before the            offset, then we have probably not found the right line            number.  */
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|<=
name|offset
operator|&&
operator|(
operator|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>
name|low_line_vma
operator|&&
operator|(
name|line_file_name
operator|!=
name|NULL
operator|||
operator|*
name|line_ptr
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>
name|low_func_vma
operator|&&
name|func
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|symname
operator|=
name|q
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|symname
operator|+
name|strlen
argument_list|(
name|symname
argument_list|)
operator|-
literal|2
argument_list|,
literal|".o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>
name|low_line_vma
condition|)
block|{
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
name|line_file_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>
name|low_func_vma
condition|)
name|func
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
case|case
name|N_SO
case|:
comment|/* If this symbol is less than the offset, but greater than            the line number we have found so far, then we have not            found the right line number.  */
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|<=
name|offset
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>
name|low_line_vma
condition|)
block|{
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
name|line_file_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>
name|low_func_vma
condition|)
name|func
operator|=
name|NULL
expr_stmt|;
block|}
name|main_file_name
operator|=
name|current_file_name
operator|=
name|q
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
comment|/* Look ahead to next symbol to check if that too is an N_SO. */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
break|break;
name|q
operator|=
operator|(
name|aout_symbol_type
operator|*
operator|)
operator|(
operator|*
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|type
operator|!=
operator|(
name|int
operator|)
name|N_SO
condition|)
goto|goto
name|next
goto|;
comment|/* Found a second N_SO  First is directory; second is filename. */
name|directory_name
operator|=
name|current_file_name
expr_stmt|;
name|main_file_name
operator|=
name|current_file_name
operator|=
name|q
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|!=
name|section
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|N_SOL
case|:
name|current_file_name
operator|=
name|q
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
break|break;
case|case
name|N_SLINE
case|:
case|case
name|N_DSLINE
case|:
case|case
name|N_BSLINE
case|:
comment|/* We'll keep this if it resolves nearer than the one we have            already.  */
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>=
name|low_line_vma
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|<=
name|offset
condition|)
block|{
operator|*
name|line_ptr
operator|=
name|q
operator|->
name|desc
expr_stmt|;
name|low_line_vma
operator|=
name|q
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
name|line_file_name
operator|=
name|current_file_name
expr_stmt|;
block|}
break|break;
case|case
name|N_FUN
case|:
block|{
comment|/* We'll keep this if it is nearer than the one we have already */
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>=
name|low_func_vma
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|<=
name|offset
condition|)
block|{
name|low_func_vma
operator|=
name|q
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
name|func
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|q
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>
name|offset
condition|)
goto|goto
name|done
goto|;
block|}
break|break;
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
operator|*
name|line_ptr
operator|!=
literal|0
condition|)
name|main_file_name
operator|=
name|line_file_name
expr_stmt|;
if|if
condition|(
name|main_file_name
operator|==
name|NULL
operator|||
name|main_file_name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|directory_name
operator|==
name|NULL
condition|)
name|filelen
operator|=
literal|0
expr_stmt|;
else|else
name|filelen
operator|=
name|strlen
argument_list|(
name|directory_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|main_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
name|funclen
operator|=
literal|0
expr_stmt|;
else|else
name|funclen
operator|=
name|strlen
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|func
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|line_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|line_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|filelen
operator|+
name|funclen
operator|==
literal|0
condition|)
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|line_buf
operator|=
name|buf
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|filelen
operator|+
name|funclen
operator|+
literal|3
argument_list|)
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|line_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|main_file_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|main_file_name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|directory_name
operator|==
name|NULL
condition|)
operator|*
name|filename_ptr
operator|=
name|main_file_name
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s"
argument_list|,
name|directory_name
argument_list|,
name|main_file_name
argument_list|)
expr_stmt|;
operator|*
name|filename_ptr
operator|=
name|buf
expr_stmt|;
name|buf
operator|+=
name|filelen
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|func
condition|)
block|{
specifier|const
name|char
modifier|*
name|function
init|=
name|func
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* The caller expects a symbol name.  We actually have a 	 function name, without the leading underscore.  Put the 	 underscore back in, so that the caller gets a symbol name.  */
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|function
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
comment|/* Have to remove : stuff */
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|int
name|NAME
argument_list|(
name|aout
argument_list|,
name|sizeof_headers
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|execable
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|execable
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
return|;
block|}
end_block

begin_comment
comment|/* Free all information we have cached for this BFD.  We can always    read it again later if we need it.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|bfd_free_cached_info
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|asection
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
return|return
name|true
return|;
define|#
directive|define
name|BFCI_FREE
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL) { free (x); x = NULL; }
name|BFCI_FREE
argument_list|(
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|bfd_free_window
argument_list|(
operator|&
name|obj_aout_sym_window
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_free_window
argument_list|(
operator|&
name|obj_aout_string_window
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|BFCI_FREE
argument_list|(
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|BFCI_FREE
argument_list|(
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
name|BFCI_FREE
argument_list|(
name|o
operator|->
name|relocation
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|BFCI_FREE
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* a.out link code.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_add_object_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_check_archive_element
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_free_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_check_ar_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
name|pneeded
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_add_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routine to create an entry in an a.out link hash table.  */
end_comment

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_hash_newfunc
argument_list|)
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
decl|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|aout_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aout_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|_bfd_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|written
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|indx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_block

begin_comment
comment|/* Initialize an a.out link hash table.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_hash_table_init
argument_list|)
argument_list|(
name|table
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
decl|struct
name|aout_link_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|_bfd_link_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Create an a.out link hash table.  */
end_comment

begin_decl_stmt
name|struct
name|bfd_link_hash_table
modifier|*
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_hash_table_create
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|aout_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|aout_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aout_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_hash_table_init
argument_list|)
argument_list|(
name|ret
argument_list|,
name|abfd
argument_list|,
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_hash_newfunc
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_block

begin_comment
comment|/* Given an a.out BFD, add symbols to the global hash table as    appropriate.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_add_symbols
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
name|aout_link_add_object_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
case|case
name|bfd_archive
case|:
return|return
name|_bfd_generic_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|aout_link_check_archive_element
argument_list|)
return|;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_block

begin_comment
comment|/* Add symbols from an a.out object file.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_add_object_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|aout_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|aout_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
block|{
if|if
condition|(
operator|!
name|aout_link_free_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check a single archive element to see if we need to include it in    the link.  *PNEEDED is set according to whether this element is    needed in the link or not.  This is called from    _bfd_generic_link_add_archive_symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_check_archive_element
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|pneeded
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
modifier|*
name|pneeded
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|aout_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|aout_link_check_ar_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|pneeded
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|pneeded
condition|)
block|{
if|if
condition|(
operator|!
name|aout_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
operator|||
operator|!
operator|*
name|pneeded
condition|)
block|{
if|if
condition|(
operator|!
name|aout_link_free_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Free up the internal symbols read from an a.out file.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_free_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_MMAP
name|bfd_free_window
argument_list|(
operator|&
name|obj_aout_sym_window
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_MMAP
name|bfd_free_window
argument_list|(
operator|&
name|obj_aout_string_window
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Look through the internal symbols to see if this object file should    be included in the link.  We should include this object file if it    defines any symbols which are currently undefined.  If this object    file defines a common symbol, then we may adjust the size of the    known symbol but we do not include the object file in the link    (unless there is some other reason to include it).  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_check_ar_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|pneeded
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
modifier|*
name|pneeded
decl_stmt|;
block|{
specifier|register
name|struct
name|external_nlist
modifier|*
name|p
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|pend
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
operator|*
name|pneeded
operator|=
name|false
expr_stmt|;
comment|/* Look through all the symbols.  */
name|p
operator|=
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|strings
operator|=
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|pend
condition|;
name|p
operator|++
control|)
block|{
name|int
name|type
init|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|e_type
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Ignore symbols that are not externally visible.  This is an 	 optimization only, as we check the type more thoroughly 	 below.  */
if|if
condition|(
operator|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|==
literal|0
operator|||
operator|(
name|type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
operator|||
name|type
operator|==
name|N_FN
operator|)
operator|&&
name|type
operator|!=
name|N_WEAKA
operator|&&
name|type
operator|!=
name|N_WEAKT
operator|&&
name|type
operator|!=
name|N_WEAKD
operator|&&
name|type
operator|!=
name|N_WEAKB
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|N_WARNING
operator|||
name|type
operator|==
name|N_INDR
condition|)
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|e_strx
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* We are only interested in symbols that are currently 	 undefined or common.  */
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|||
operator|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
condition|)
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
operator|(
name|N_TEXT
operator||
name|N_EXT
operator|)
operator|||
name|type
operator|==
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
operator|||
name|type
operator|==
operator|(
name|N_BSS
operator||
name|N_EXT
operator|)
operator|||
name|type
operator|==
operator|(
name|N_ABS
operator||
name|N_EXT
operator|)
operator|||
name|type
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
condition|)
block|{
comment|/* This object file defines this symbol.  We must link it 	     in.  This is true regardless of whether the current 	     definition of the symbol is undefined or common.  If the 	     current definition is common, we have a case in which we 	     have already seen an object file including 	         int a; 	     and this object file from the archive includes 	         int a = 5; 	     In such a case we must include this object file.  	     FIXME: The SunOS 4.1.3 linker will pull in the archive 	     element if the symbol is defined in the .data section, 	     but not if it is defined in the .text section.  That 	     seems a bit crazy to me, and I haven't implemented it. 	     However, it might be correct.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|pneeded
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|e_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* This symbol is common in the object from the archive 		 file.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|bfd
modifier|*
name|symbfd
decl_stmt|;
name|unsigned
name|int
name|power
decl_stmt|;
name|symbfd
operator|=
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
if|if
condition|(
name|symbfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* This symbol was created as undefined from 			 outside BFD.  We assume that we should link 			 in the object file.  This is done for the -u 			 option in the linker.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|pneeded
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Turn the current link symbol into a common 		     symbol.  It is already on the undefs list.  */
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_common
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_hash_common_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_hash_common_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
operator|=
name|value
expr_stmt|;
comment|/* FIXME: This isn't quite right.  The maximum 		     alignment of a common symbol should be set by the 		     architecture of the output file, not of the input 		     file.  */
name|power
operator|=
name|bfd_log2
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|power
operator|>
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|section_align_power
condition|)
name|power
operator|=
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|section_align_power
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|power
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|symbfd
argument_list|,
literal|"COMMON"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust the size of the common symbol if 		     necessary.  */
if|if
condition|(
name|value
operator|>
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
condition|)
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|type
operator|==
name|N_WEAKA
operator|||
name|type
operator|==
name|N_WEAKT
operator|||
name|type
operator|==
name|N_WEAKD
operator|||
name|type
operator|==
name|N_WEAKB
condition|)
block|{
comment|/* This symbol is weak but defined.  We must pull it in if 	     the current link symbol is undefined, but we don't want 	     it if the current link symbol is common.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|pneeded
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
comment|/* We do not need this object file.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add all symbols from an object file to the hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_add_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*add_one_symbol
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|flagword
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|,
name|boolean
operator|,
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
name|struct
name|external_nlist
modifier|*
name|syms
decl_stmt|;
name|bfd_size_type
name|sym_count
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
name|struct
name|aout_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
specifier|register
name|struct
name|external_nlist
modifier|*
name|p
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|pend
decl_stmt|;
name|syms
operator|=
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_count
operator|=
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|strings
operator|=
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|keep_memory
condition|)
name|copy
operator|=
name|false
expr_stmt|;
else|else
name|copy
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|add_dynamic_symbols
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|add_dynamic_symbols
operator|)
operator|(
name|abfd
operator|,
name|info
operator|,
operator|&
name|syms
operator|,
operator|&
name|sym_count
operator|,
operator|&
name|strings
operator|)
operator|)
condition|)
return|return
name|false
return|;
block|}
comment|/* We keep a list of the linker hash table entries that correspond      to particular symbols.  We could just look them up in the hash      table, but keeping the list is more efficient.  Perhaps this      should be conditional on info->keep_memory.  */
name|sym_hash
operator|=
operator|(
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|size_t
operator|)
name|sym_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aout_link_hash_entry
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|==
name|NULL
operator|&&
name|sym_count
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|obj_aout_sym_hashes
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_hash
expr_stmt|;
name|add_one_symbol
operator|=
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|add_one_symbol
expr_stmt|;
if|if
condition|(
name|add_one_symbol
operator|==
name|NULL
condition|)
name|add_one_symbol
operator|=
name|_bfd_generic_link_add_one_symbol
expr_stmt|;
name|p
operator|=
name|syms
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|sym_count
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|pend
condition|;
name|p
operator|++
operator|,
name|sym_hash
operator|++
control|)
block|{
name|int
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
operator|*
name|sym_hash
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|e_type
argument_list|)
expr_stmt|;
comment|/* Ignore debugging symbols.  */
if|if
condition|(
operator|(
name|type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|e_strx
argument_list|)
expr_stmt|;
name|value
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|string
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|N_UNDF
case|:
case|case
name|N_ABS
case|:
case|case
name|N_TEXT
case|:
case|case
name|N_DATA
case|:
case|case
name|N_BSS
case|:
case|case
name|N_FN_SEQ
case|:
case|case
name|N_COMM
case|:
case|case
name|N_SETV
case|:
case|case
name|N_FN
case|:
comment|/* Ignore symbols that are not externally visible.  */
continue|continue;
case|case
name|N_INDR
case|:
comment|/* Ignore local indirect symbol.  */
operator|++
name|p
expr_stmt|;
operator|++
name|sym_hash
expr_stmt|;
continue|continue;
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
break|break;
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|section
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|value
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
case|case
name|N_SETV
operator||
name|N_EXT
case|:
comment|/* Treat N_SETV symbols as N_DATA symbol; see comment in 	     translate_from_native_sym_flags.  */
name|section
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|value
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BSS
operator||
name|N_EXT
case|:
name|section
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|value
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_INDR
operator||
name|N_EXT
case|:
comment|/* An indirect symbol.  The next symbol is the symbol 	     which this one really is.  */
name|BFD_ASSERT
argument_list|(
name|p
operator|+
literal|1
operator|<
name|pend
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
name|string
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|e_strx
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_ind_section_ptr
expr_stmt|;
name|flags
operator||=
name|BSF_INDIRECT
expr_stmt|;
break|break;
case|case
name|N_COMM
operator||
name|N_EXT
case|:
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
case|case
name|N_SETA
case|:
case|case
name|N_SETA
operator||
name|N_EXT
case|:
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|flags
operator||=
name|BSF_CONSTRUCTOR
expr_stmt|;
break|break;
case|case
name|N_SETT
case|:
case|case
name|N_SETT
operator||
name|N_EXT
case|:
name|section
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|flags
operator||=
name|BSF_CONSTRUCTOR
expr_stmt|;
name|value
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SETD
case|:
case|case
name|N_SETD
operator||
name|N_EXT
case|:
name|section
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|flags
operator||=
name|BSF_CONSTRUCTOR
expr_stmt|;
name|value
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SETB
case|:
case|case
name|N_SETB
operator||
name|N_EXT
case|:
name|section
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|flags
operator||=
name|BSF_CONSTRUCTOR
expr_stmt|;
name|value
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_WARNING
case|:
comment|/* A warning symbol.  The next symbol is the one to warn 	     about.  */
name|BFD_ASSERT
argument_list|(
name|p
operator|+
literal|1
operator|<
name|pend
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
name|string
operator|=
name|name
expr_stmt|;
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|e_strx
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|flags
operator||=
name|BSF_WARNING
expr_stmt|;
break|break;
case|case
name|N_WEAKU
case|:
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|N_WEAKA
case|:
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|N_WEAKT
case|:
name|section
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|value
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|N_WEAKD
case|:
name|section
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|value
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|N_WEAKB
case|:
name|section
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|value
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|add_one_symbol
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|section
argument_list|,
name|value
argument_list|,
name|string
argument_list|,
name|copy
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|sym_hash
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Restrict the maximum alignment of a common symbol based on 	 the architecture, since a.out has no way to represent 	 alignment requirements of a section in a .o file.  FIXME: 	 This isn't quite right: it should use the architecture of the 	 output file, not the input files.  */
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|&&
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|>
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|section_align_power
operator|)
condition|)
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|section_align_power
expr_stmt|;
comment|/* If this is a set symbol, and we are not building sets, then 	 it is possible for the hash entry to not have been set.  In 	 such a case, treat the symbol as not globally defined.  */
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
operator|||
name|type
operator|==
name|N_WARNING
condition|)
operator|++
name|sym_hash
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A hash table used for header files with N_BINCL entries.  */
end_comment

begin_struct
struct|struct
name|aout_link_includes_table
block|{
name|struct
name|bfd_hash_table
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A linked list of totals that we have found for a particular header    file.  */
end_comment

begin_struct
struct|struct
name|aout_link_includes_totals
block|{
name|struct
name|aout_link_includes_totals
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|total
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An entry in the header file hash table.  */
end_comment

begin_struct
struct|struct
name|aout_link_includes_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* List of totals we have found for this file.  */
name|struct
name|aout_link_includes_totals
modifier|*
name|totals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in an the header file hash table.  */
end_comment

begin_define
define|#
directive|define
name|aout_link_includes_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct aout_link_includes_entry *) \    bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
end_define

begin_comment
comment|/* During the final link step we need to pass around a bunch of    information, so we do it in an instance of this structure.  */
end_comment

begin_struct
struct|struct
name|aout_final_link_info
block|{
comment|/* General link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* Output bfd.  */
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
comment|/* Reloc file positions.  */
name|file_ptr
name|treloff
decl_stmt|,
name|dreloff
decl_stmt|;
comment|/* File position of symbols.  */
name|file_ptr
name|symoff
decl_stmt|;
comment|/* String table.  */
name|struct
name|bfd_strtab_hash
modifier|*
name|strtab
decl_stmt|;
comment|/* Header file hash table.  */
name|struct
name|aout_link_includes_table
name|includes
decl_stmt|;
comment|/* A buffer large enough to hold the contents of any section.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* A buffer large enough to hold the relocs of any section.  */
name|PTR
name|relocs
decl_stmt|;
comment|/* A buffer large enough to hold the symbol map of any input BFD.  */
name|int
modifier|*
name|symbol_map
decl_stmt|;
comment|/* A buffer large enough to hold output symbols of any input BFD.  */
name|struct
name|external_nlist
modifier|*
name|output_syms
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|aout_link_includes_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_input_bfd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|aout_final_link_info
operator|*
operator|,
name|bfd
operator|*
name|input_bfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_write_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|aout_final_link_info
operator|*
operator|,
name|bfd
operator|*
name|input_bfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_write_other_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_input_section
name|PARAMS
argument_list|(
operator|(
expr|struct
name|aout_final_link_info
operator|*
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
name|file_ptr
operator|*
name|reloff_ptr
operator|,
name|bfd_size_type
name|rel_size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_input_section_std
name|PARAMS
argument_list|(
operator|(
expr|struct
name|aout_final_link_info
operator|*
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
expr|struct
name|reloc_std_external
operator|*
operator|,
name|bfd_size_type
name|rel_size
operator|,
name|bfd_byte
operator|*
name|contents
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_input_section_ext
name|PARAMS
argument_list|(
operator|(
expr|struct
name|aout_final_link_info
operator|*
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
expr|struct
name|reloc_ext_external
operator|*
operator|,
name|bfd_size_type
name|rel_size
operator|,
name|bfd_byte
operator|*
name|contents
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|asection
modifier|*
name|aout_reloc_index_to_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|aout_link_reloc_link_order
name|PARAMS
argument_list|(
operator|(
expr|struct
name|aout_final_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function to create a new entry in the header file hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|aout_link_includes_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|aout_link_includes_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|aout_link_includes_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|aout_link_includes_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|aout_link_includes_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aout_link_includes_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|aout_link_includes_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|aout_link_includes_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|totals
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do the final link step.  This is called on the output BFD.  The    INFO structure should point to a list of BFDs linked through the    link_next field which can be used to find each BFD which takes part    in the output.  Also, each section in ABFD should point to a list    of bfd_link_order structures which list all the input sections for    the output section.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|final_link
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|callback
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*callback
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|*
operator|,
name|file_ptr
operator|*
operator|,
name|file_ptr
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|aout_final_link_info
name|aout_info
decl_stmt|;
name|boolean
name|includes_hash_initialized
init|=
name|false
decl_stmt|;
specifier|register
name|bfd
modifier|*
name|sub
decl_stmt|;
name|bfd_size_type
name|trsize
decl_stmt|,
name|drsize
decl_stmt|;
name|size_t
name|max_contents_size
decl_stmt|;
name|size_t
name|max_relocs_size
decl_stmt|;
name|size_t
name|max_sym_count
decl_stmt|;
name|bfd_size_type
name|text_size
decl_stmt|;
name|file_ptr
name|text_end
decl_stmt|;
specifier|register
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|boolean
name|have_link_order_relocs
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
name|aout_info
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|aout_info
operator|.
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|aout_info
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
name|aout_info
operator|.
name|relocs
operator|=
name|NULL
expr_stmt|;
name|aout_info
operator|.
name|symbol_map
operator|=
name|NULL
expr_stmt|;
name|aout_info
operator|.
name|output_syms
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
operator|&
name|aout_info
operator|.
name|includes
operator|.
name|root
argument_list|,
name|aout_link_includes_newfunc
argument_list|,
literal|251
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|includes_hash_initialized
operator|=
name|true
expr_stmt|;
comment|/* Figure out the largest section size.  Also, if generating      relocateable output, count the relocs.  */
name|trsize
operator|=
literal|0
expr_stmt|;
name|drsize
operator|=
literal|0
expr_stmt|;
name|max_contents_size
operator|=
literal|0
expr_stmt|;
name|max_relocs_size
operator|=
literal|0
expr_stmt|;
name|max_sym_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|==
name|bfd_target_aout_flavour
condition|)
block|{
name|trsize
operator|+=
name|exec_hdr
argument_list|(
name|sub
argument_list|)
operator|->
name|a_trsize
expr_stmt|;
name|drsize
operator|+=
name|exec_hdr
argument_list|(
name|sub
argument_list|)
operator|->
name|a_drsize
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: We need to identify the .text and .data sections 		 and call get_reloc_upper_bound and canonicalize_reloc to 		 work out the number of relocs needed, and then multiply 		 by the reloc size.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: relocateable link from %s to %s not supported"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|sub
operator|->
name|xvec
operator|->
name|name
argument_list|,
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|==
name|bfd_target_aout_flavour
condition|)
block|{
name|sz
operator|=
name|bfd_section_size
argument_list|(
name|sub
argument_list|,
name|obj_textsec
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sz
expr_stmt|;
name|sz
operator|=
name|bfd_section_size
argument_list|(
name|sub
argument_list|,
name|obj_datasec
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sz
expr_stmt|;
name|sz
operator|=
name|exec_hdr
argument_list|(
name|sub
argument_list|)
operator|->
name|a_trsize
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|max_relocs_size
condition|)
name|max_relocs_size
operator|=
name|sz
expr_stmt|;
name|sz
operator|=
name|exec_hdr
argument_list|(
name|sub
argument_list|)
operator|->
name|a_drsize
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|max_relocs_size
condition|)
name|max_relocs_size
operator|=
name|sz
expr_stmt|;
name|sz
operator|=
name|obj_aout_external_sym_count
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|max_sym_count
condition|)
name|max_sym_count
operator|=
name|sz
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|trsize
operator|+=
operator|(
name|_bfd_count_link_order_relocs
argument_list|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|link_order_head
argument_list|)
operator|*
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|drsize
operator|+=
operator|(
name|_bfd_count_link_order_relocs
argument_list|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|link_order_head
argument_list|)
operator|*
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
block|}
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|=
name|trsize
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|=
name|drsize
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Adjust the section sizes and vmas according to the magic number.      This sets a_text, a_data and a_bss in the exec_hdr and sets the      filepos for each section.  */
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|adjust_sizes_and_vmas
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|text_size
argument_list|,
operator|&
name|text_end
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* The relocation and symbol file positions differ among a.out      targets.  We are passed a callback routine from the backend      specific code to handle this.      FIXME: At this point we do not know how much space the symbol      table will require.  This will not work for any (nonstandard)      a.out target that needs to know the symbol table size before it      can compute the relocation file positions.  This may or may not      be the case for the hp300hpux target, for example.  */
call|(
modifier|*
name|callback
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|aout_info
operator|.
name|treloff
argument_list|,
operator|&
name|aout_info
operator|.
name|dreloff
argument_list|,
operator|&
name|aout_info
operator|.
name|symoff
argument_list|)
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|aout_info
operator|.
name|treloff
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|aout_info
operator|.
name|dreloff
expr_stmt|;
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|aout_info
operator|.
name|symoff
expr_stmt|;
comment|/* We keep a count of the symbols as we output them.  */
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We accumulate the string table as we write out the symbols.  */
name|aout_info
operator|.
name|strtab
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|aout_info
operator|.
name|strtab
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Allocate buffers to hold section contents and relocs.  */
name|aout_info
operator|.
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_contents_size
argument_list|)
expr_stmt|;
name|aout_info
operator|.
name|relocs
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|max_relocs_size
argument_list|)
expr_stmt|;
name|aout_info
operator|.
name|symbol_map
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|aout_info
operator|.
name|output_syms
operator|=
operator|(
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|max_sym_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|aout_info
operator|.
name|contents
operator|==
name|NULL
operator|&&
name|max_contents_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|aout_info
operator|.
name|relocs
operator|==
name|NULL
operator|&&
name|max_relocs_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|aout_info
operator|.
name|symbol_map
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|!=
literal|0
operator|)
operator|||
name|aout_info
operator|.
name|output_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* If we have a symbol named __DYNAMIC, force it out now.  This is      required by SunOS.  Doing this here rather than in sunos.c is a      hack, but it's easier than exporting everything which would be      needed.  */
block|{
name|struct
name|aout_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|aout_link_hash_lookup
argument_list|(
name|aout_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__DYNAMIC"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|aout_link_write_other_symbol
argument_list|(
name|h
argument_list|,
operator|&
name|aout_info
argument_list|)
expr_stmt|;
block|}
comment|/* The most time efficient way to do the link would be to read all      the input object files into memory and then sort out the      information into the output file.  Unfortunately, that will      probably use too much memory.  Another method would be to step      through everything that composes the text section and write it      out, and then everything that composes the data section and write      it out, and then write out the relocs, and then write out the      symbols.  Unfortunately, that requires reading stuff from each      input file several times, and we will not be able to keep all the      input files open simultaneously, and reopening them will be slow.       What we do is basically process one input file at a time.  We do      everything we need to do with an input file once--copy over the      section contents, handle the relocation information, and write      out the symbols--and then we throw away the information we read      from it.  This approach requires a lot of lseeks of the output      file, which is unfortunate but still faster than reopening a lot      of files.       We use the output_has_begun field of the input BFDs to see      whether we have already handled it.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
name|sub
operator|->
name|output_has_begun
operator|=
name|false
expr_stmt|;
comment|/* Mark all sections which are to be included in the link.  This      will normally be every section.  We need to do this so that we      can identify any sections which the linker has decided to not      include.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|linker_mark
operator|=
name|true
expr_stmt|;
block|}
block|}
name|have_link_order_relocs
operator|=
name|false
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_aout_flavour
operator|)
condition|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|input_bfd
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
operator|!
name|input_bfd
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
operator|!
name|aout_link_input_bfd
argument_list|(
operator|&
name|aout_info
argument_list|,
name|input_bfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|input_bfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
comment|/* These are handled below.  */
name|have_link_order_relocs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* Write out any symbols that we have not already written out.  */
name|aout_link_hash_traverse
argument_list|(
name|aout_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|aout_link_write_other_symbol
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aout_info
argument_list|)
expr_stmt|;
comment|/* Now handle any relocs we were asked to create by the linker.      These did not come from any input file.  We must do these after      we have written out all the symbols, so that we know the symbol      indices to use.  */
if|if
condition|(
name|have_link_order_relocs
condition|)
block|{
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
if|if
condition|(
operator|!
name|aout_link_reloc_link_order
argument_list|(
operator|&
name|aout_info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|aout_info
operator|.
name|contents
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|aout_info
operator|.
name|contents
argument_list|)
expr_stmt|;
name|aout_info
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|aout_info
operator|.
name|relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|aout_info
operator|.
name|relocs
argument_list|)
expr_stmt|;
name|aout_info
operator|.
name|relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|aout_info
operator|.
name|symbol_map
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|aout_info
operator|.
name|symbol_map
argument_list|)
expr_stmt|;
name|aout_info
operator|.
name|symbol_map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|aout_info
operator|.
name|output_syms
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|aout_info
operator|.
name|output_syms
argument_list|)
expr_stmt|;
name|aout_info
operator|.
name|output_syms
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|includes_hash_initialized
condition|)
block|{
name|bfd_hash_table_free
argument_list|(
operator|&
name|aout_info
operator|.
name|includes
operator|.
name|root
argument_list|)
expr_stmt|;
name|includes_hash_initialized
operator|=
name|false
expr_stmt|;
block|}
comment|/* Finish up any dynamic linking we may be doing.  */
if|if
condition|(
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|finish_dynamic_link
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|finish_dynamic_link
operator|)
operator|(
name|abfd
operator|,
name|info
operator|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Update the header information.  */
name|abfd
operator|->
name|symcount
operator|=
name|obj_aout_external_sym_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
operator|=
name|abfd
operator|->
name|symcount
operator|*
name|EXTERNAL_NLIST_SIZE
expr_stmt|;
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_count
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|/
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_count
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|/
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Write out the string table.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
return|return
name|emit_stringtab
argument_list|(
name|abfd
argument_list|,
name|aout_info
operator|.
name|strtab
argument_list|)
return|;
name|error_return
label|:
if|if
condition|(
name|aout_info
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|aout_info
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|aout_info
operator|.
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|aout_info
operator|.
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|aout_info
operator|.
name|symbol_map
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|aout_info
operator|.
name|symbol_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|aout_info
operator|.
name|output_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|aout_info
operator|.
name|output_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|includes_hash_initialized
condition|)
name|bfd_hash_table_free
argument_list|(
operator|&
name|aout_info
operator|.
name|includes
operator|.
name|root
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_comment
comment|/* Link an a.out input BFD into the output file.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_input_bfd
parameter_list|(
name|finfo
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|aout_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|bfd_size_type
name|sym_count
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_format
argument_list|(
name|input_bfd
argument_list|)
operator|==
name|bfd_object
argument_list|)
expr_stmt|;
comment|/* If this is a dynamic object, it may need special handling.  */
if|if
condition|(
operator|(
name|input_bfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|aout_backend_info
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|link_dynamic_object
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
operator|(
operator|*
name|aout_backend_info
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|link_dynamic_object
operator|)
operator|(
name|finfo
operator|->
name|info
operator|,
name|input_bfd
operator|)
operator|)
return|;
block|}
comment|/* Get the symbols.  We probably have them already, unless      finfo->info->keep_memory is false.  */
if|if
condition|(
operator|!
name|aout_get_external_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
return|return
name|false
return|;
name|sym_count
operator|=
name|obj_aout_external_sym_count
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
comment|/* Write out the symbols and get a map of the new indices.  The map      is placed into finfo->symbol_map.  */
if|if
condition|(
operator|!
name|aout_link_write_symbols
argument_list|(
name|finfo
argument_list|,
name|input_bfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Relocate and write out the sections.  These functions use the      symbol map created by aout_link_write_symbols.  The linker_mark      field will be set if these sections are to be included in the      link, which will normally be the case.  */
if|if
condition|(
name|obj_textsec
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|linker_mark
condition|)
block|{
if|if
condition|(
operator|!
name|aout_link_input_section
argument_list|(
name|finfo
argument_list|,
name|input_bfd
argument_list|,
name|obj_textsec
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|&
name|finfo
operator|->
name|treloff
argument_list|,
name|exec_hdr
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|a_trsize
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|obj_datasec
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|linker_mark
condition|)
block|{
if|if
condition|(
operator|!
name|aout_link_input_section
argument_list|(
name|finfo
argument_list|,
name|input_bfd
argument_list|,
name|obj_datasec
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|&
name|finfo
operator|->
name|dreloff
argument_list|,
name|exec_hdr
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|a_drsize
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If we are not keeping memory, we don't need the symbols any      longer.  We still need them if we are keeping memory, because the      strings in the hash table point into them.  */
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|keep_memory
condition|)
block|{
if|if
condition|(
operator|!
name|aout_link_free_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust and write out the symbols for an a.out file.  Set the new    symbol indices into a symbol_map.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_write_symbols
parameter_list|(
name|finfo
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|aout_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd_size_type
name|sym_count
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|enum
name|bfd_link_strip
name|strip
decl_stmt|;
name|enum
name|bfd_link_discard
name|discard
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|outsym
decl_stmt|;
name|bfd_size_type
name|strtab_index
decl_stmt|;
specifier|register
name|struct
name|external_nlist
modifier|*
name|sym
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|sym_end
decl_stmt|;
name|struct
name|aout_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|int
modifier|*
name|symbol_map
decl_stmt|;
name|boolean
name|pass
decl_stmt|;
name|boolean
name|skip_next
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|sym_count
operator|=
name|obj_aout_external_sym_count
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|strings
operator|=
name|obj_aout_external_strings
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|strip
operator|=
name|finfo
operator|->
name|info
operator|->
name|strip
expr_stmt|;
name|discard
operator|=
name|finfo
operator|->
name|info
operator|->
name|discard
expr_stmt|;
name|outsym
operator|=
name|finfo
operator|->
name|output_syms
expr_stmt|;
comment|/* First write out a symbol for this object file, unless we are      discarding such symbols.  */
if|if
condition|(
name|strip
operator|!=
name|strip_all
operator|&&
operator|(
name|strip
operator|!=
name|strip_some
operator|||
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|input_bfd
operator|->
name|filename
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
name|discard
operator|!=
name|discard_all
condition|)
block|{
name|bfd_h_put_8
argument_list|(
name|output_bfd
argument_list|,
name|N_TEXT
argument_list|,
name|outsym
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|outsym
operator|->
name|e_other
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|outsym
operator|->
name|e_desc
argument_list|)
expr_stmt|;
name|strtab_index
operator|=
name|add_to_stringtab
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|strtab
argument_list|,
name|input_bfd
operator|->
name|filename
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab_index
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|strtab_index
argument_list|,
name|outsym
operator|->
name|e_strx
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|obj_textsec
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|output_section
argument_list|)
operator|+
name|obj_textsec
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|output_offset
operator|)
argument_list|,
name|outsym
operator|->
name|e_value
argument_list|)
expr_stmt|;
operator|++
name|obj_aout_external_sym_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
operator|++
name|outsym
expr_stmt|;
block|}
name|pass
operator|=
name|false
expr_stmt|;
name|skip_next
operator|=
name|false
expr_stmt|;
name|sym
operator|=
name|obj_aout_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sym_end
operator|=
name|sym
operator|+
name|sym_count
expr_stmt|;
name|sym_hash
operator|=
name|obj_aout_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|symbol_map
operator|=
name|finfo
operator|->
name|symbol_map
expr_stmt|;
name|memset
argument_list|(
name|symbol_map
argument_list|,
literal|0
argument_list|,
name|sym_count
operator|*
sizeof|sizeof
expr|*
name|symbol_map
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sym
operator|<
name|sym_end
condition|;
name|sym
operator|++
operator|,
name|sym_hash
operator|++
operator|,
name|symbol_map
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|aout_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|skip
decl_stmt|;
name|asection
modifier|*
name|symsec
decl_stmt|;
name|bfd_vma
name|val
init|=
literal|0
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
comment|/* We set *symbol_map to 0 above for all symbols.  If it has          already been set to -1 for this symbol, it means that we are          discarding it because it appears in a duplicate header file.          See the N_BINCL code below.  */
if|if
condition|(
operator|*
name|symbol_map
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Initialize *symbol_map to -1, which means that the symbol was          not copied into the output file.  We will change it later if          we do copy the symbol over.  */
operator|*
name|symbol_map
operator|=
operator|-
literal|1
expr_stmt|;
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_strx
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pass
condition|)
block|{
comment|/* Pass this symbol through.  It is the target of an 	     indirect or warning symbol.  */
name|val
operator|=
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|pass
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_next
condition|)
block|{
comment|/* Skip this symbol, which is the target of an indirect 	     symbol that we have changed to no longer be an indirect 	     symbol.  */
name|skip_next
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|struct
name|aout_link_hash_entry
modifier|*
name|hresolve
decl_stmt|;
comment|/* We have saved the hash table entry for this symbol, if 	     there is one.  Note that we could just look it up again 	     in the hash table, provided we first check that it is an 	     external symbol. */
name|h
operator|=
operator|*
name|sym_hash
expr_stmt|;
comment|/* Use the name from the hash table, in case the symbol was              wrapped.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
comment|/* If this is an indirect or warning symbol, then change 	     hresolve to the base symbol.  We also change *sym_hash so 	     that the relocation routines relocate against the real 	     symbol.  */
name|hresolve
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
operator|)
condition|)
block|{
name|hresolve
operator|=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
while|while
condition|(
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hresolve
operator|=
operator|(
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|hresolve
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|)
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|hresolve
expr_stmt|;
block|}
comment|/* If the symbol has already been written out, skip it.  */
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_warning
operator|&&
name|h
operator|->
name|written
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_INDR
operator|||
name|type
operator|==
name|N_WARNING
condition|)
name|skip_next
operator|=
name|true
expr_stmt|;
operator|*
name|symbol_map
operator|=
name|h
operator|->
name|indx
expr_stmt|;
continue|continue;
block|}
comment|/* See if we are stripping this symbol.  */
name|skip
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|strip
condition|)
block|{
case|case
name|strip_none
case|:
break|break;
case|case
name|strip_debugger
case|:
if|if
condition|(
operator|(
name|type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
name|skip
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|strip_some
case|:
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
condition|)
name|skip
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|strip_all
case|:
name|skip
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|skip
condition|)
block|{
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|h
operator|->
name|written
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
comment|/* Get the value of the symbol.  */
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
operator|||
name|type
operator|==
name|N_WEAKT
condition|)
name|symsec
operator|=
name|obj_textsec
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_DATA
operator|||
name|type
operator|==
name|N_WEAKD
condition|)
name|symsec
operator|=
name|obj_datasec
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_BSS
operator|||
name|type
operator|==
name|N_WEAKB
condition|)
name|symsec
operator|=
name|obj_bsssec
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_ABS
operator|||
name|type
operator|==
name|N_WEAKA
condition|)
name|symsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_INDR
operator|&&
operator|(
name|hresolve
operator|==
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|||
operator|(
name|hresolve
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|hresolve
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|&&
name|hresolve
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_common
operator|)
operator|)
operator|)
operator|||
name|type
operator|==
name|N_WARNING
condition|)
block|{
comment|/* Pass the next symbol through unchanged.  The 		 condition above for indirect symbols is so that if 		 the indirect symbol was defined, we output it with 		 the correct definition so the debugger will 		 understand it.  */
name|pass
operator|=
name|true
expr_stmt|;
name|val
operator|=
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|symsec
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|symsec
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* If we get here with an indirect symbol, it means that 		 we are outputting it with a real definition.  In such 		 a case we do not want to output the next symbol, 		 which is the target of the indirection.  */
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_INDR
condition|)
name|skip_next
operator|=
name|true
expr_stmt|;
name|symsec
operator|=
name|NULL
expr_stmt|;
comment|/* We need to get the value from the hash table.  We use 		 hresolve so that if we have defined an indirect 		 symbol we output the final definition.  */
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
switch|switch
condition|(
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_SETT
case|:
name|symsec
operator|=
name|obj_textsec
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SETD
case|:
name|symsec
operator|=
name|obj_datasec
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SETB
case|:
name|symsec
operator|=
name|obj_bsssec
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SETA
case|:
name|symsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
break|break;
default|default:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
comment|/* This case usually means a common symbol which was 		     turned into a defined symbol.  */
name|input_section
operator|=
name|hresolve
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|input_section
operator|->
name|output_section
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_is_abs_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|hresolve
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Get the correct type based on the section.  If 		     this is a constructed set, force it to be 		     globally visible.  */
if|if
condition|(
name|type
operator|==
name|N_SETT
operator|||
name|type
operator|==
name|N_SETD
operator|||
name|type
operator|==
name|N_SETB
operator|||
name|type
operator|==
name|N_SETA
condition|)
name|type
operator||=
name|N_EXT
expr_stmt|;
name|type
operator|&=
operator|~
name|N_TYPE
expr_stmt|;
if|if
condition|(
name|output_section
operator|==
name|obj_textsec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|type
operator||=
operator|(
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_TEXT
else|:
name|N_WEAKT
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|output_section
operator|==
name|obj_datasec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|type
operator||=
operator|(
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_DATA
else|:
name|N_WEAKD
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|output_section
operator|==
name|obj_bsssec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|type
operator||=
operator|(
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_BSS
else|:
name|N_WEAKB
operator|)
expr_stmt|;
else|else
name|type
operator||=
operator|(
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_ABS
else|:
name|N_WEAKA
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|val
operator|=
name|hresolve
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|hresolve
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|N_WEAKU
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|symsec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|val
operator|=
operator|(
name|symsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symsec
operator|->
name|output_offset
operator|+
operator|(
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_value
argument_list|)
operator|-
name|symsec
operator|->
name|vma
operator|)
operator|)
expr_stmt|;
comment|/* If this is a global symbol set the written flag, and if 	     it is a local symbol see if we should discard it.  */
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|h
operator|->
name|written
operator|=
name|true
expr_stmt|;
name|h
operator|->
name|indx
operator|=
name|obj_aout_external_sym_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETT
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETD
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETB
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETA
condition|)
block|{
switch|switch
condition|(
name|discard
condition|)
block|{
case|case
name|discard_none
case|:
break|break;
case|case
name|discard_l
case|:
if|if
condition|(
operator|(
name|type
operator|&
name|N_STAB
operator|)
operator|==
literal|0
operator|&&
name|bfd_is_local_label_name
argument_list|(
name|input_bfd
argument_list|,
name|name
argument_list|)
condition|)
name|skip
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|discard_all
case|:
name|skip
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|skip
condition|)
block|{
name|pass
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* An N_BINCL symbol indicates the start of the stabs 	     entries for a header file.  We need to scan ahead to the 	     next N_EINCL symbol, ignoring nesting, adding up all the 	     characters in the symbol names, not including the file 	     numbers in types (the first number after an open 	     parenthesis).  */
if|if
condition|(
name|type
operator|==
name|N_BINCL
condition|)
block|{
name|struct
name|external_nlist
modifier|*
name|incl_sym
decl_stmt|;
name|int
name|nest
decl_stmt|;
name|struct
name|aout_link_includes_entry
modifier|*
name|incl_entry
decl_stmt|;
name|struct
name|aout_link_includes_totals
modifier|*
name|t
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|nest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|incl_sym
operator|=
name|sym
operator|+
literal|1
init|;
name|incl_sym
operator|<
name|sym_end
condition|;
name|incl_sym
operator|++
control|)
block|{
name|int
name|incl_type
decl_stmt|;
name|incl_type
operator|=
name|bfd_h_get_8
argument_list|(
name|input_bfd
argument_list|,
name|incl_sym
operator|->
name|e_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|incl_type
operator|==
name|N_EINCL
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
break|break;
operator|--
name|nest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incl_type
operator|==
name|N_BINCL
condition|)
operator|++
name|nest
expr_stmt|;
elseif|else
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|incl_sym
operator|->
name|e_strx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
name|val
operator|+=
operator|*
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
comment|/* Skip the file number.  */
operator|++
name|s
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
operator|--
name|s
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we have already included a header file with the                  same value, then replace this one with an N_EXCL                  symbol.  */
name|copy
operator|=
operator|!
name|finfo
operator|->
name|info
operator|->
name|keep_memory
expr_stmt|;
name|incl_entry
operator|=
name|aout_link_includes_lookup
argument_list|(
operator|&
name|finfo
operator|->
name|includes
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|incl_entry
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|t
operator|=
name|incl_entry
operator|->
name|totals
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|total
operator|==
name|val
condition|)
break|break;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
comment|/* This is the first time we have seen this header                      file with this set of stabs strings.  */
name|t
operator|=
operator|(
operator|(
expr|struct
name|aout_link_includes_totals
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|finfo
operator|->
name|includes
operator|.
name|root
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|t
operator|->
name|total
operator|=
name|val
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|incl_entry
operator|->
name|totals
expr_stmt|;
name|incl_entry
operator|->
name|totals
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|int
modifier|*
name|incl_map
decl_stmt|;
comment|/* This is a duplicate header file.  We must change                      it to be an N_EXCL entry, and mark all the                      included symbols to prevent outputting them.  */
name|type
operator|=
name|N_EXCL
expr_stmt|;
name|nest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|incl_sym
operator|=
name|sym
operator|+
literal|1
operator|,
name|incl_map
operator|=
name|symbol_map
operator|+
literal|1
init|;
name|incl_sym
operator|<
name|sym_end
condition|;
name|incl_sym
operator|++
operator|,
name|incl_map
operator|++
control|)
block|{
name|int
name|incl_type
decl_stmt|;
name|incl_type
operator|=
name|bfd_h_get_8
argument_list|(
name|input_bfd
argument_list|,
name|incl_sym
operator|->
name|e_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|incl_type
operator|==
name|N_EINCL
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
operator|*
name|incl_map
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
operator|--
name|nest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incl_type
operator|==
name|N_BINCL
condition|)
operator|++
name|nest
expr_stmt|;
elseif|else
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
operator|*
name|incl_map
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Copy this symbol into the list of symbols we are going to 	 write out.  */
name|bfd_h_put_8
argument_list|(
name|output_bfd
argument_list|,
name|type
argument_list|,
name|outsym
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|output_bfd
argument_list|,
name|bfd_h_get_8
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_other
argument_list|)
argument_list|,
name|outsym
operator|->
name|e_other
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|output_bfd
argument_list|,
name|bfd_h_get_16
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_desc
argument_list|)
argument_list|,
name|outsym
operator|->
name|e_desc
argument_list|)
expr_stmt|;
name|copy
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|keep_memory
condition|)
block|{
comment|/* name points into a string table which we are going to 	     free.  If there is a hash table entry, use that string. 	     Otherwise, copy name into memory.  */
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
name|copy
operator|=
name|true
expr_stmt|;
block|}
name|strtab_index
operator|=
name|add_to_stringtab
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|strtab
argument_list|,
name|name
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab_index
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|strtab_index
argument_list|,
name|outsym
operator|->
name|e_strx
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|,
name|outsym
operator|->
name|e_value
argument_list|)
expr_stmt|;
operator|*
name|symbol_map
operator|=
name|obj_aout_external_sym_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
operator|++
name|obj_aout_external_sym_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
operator|++
name|outsym
expr_stmt|;
block|}
comment|/* Write out the output symbols we have just constructed.  */
if|if
condition|(
name|outsym
operator|>
name|finfo
operator|->
name|output_syms
condition|)
block|{
name|bfd_size_type
name|outsym_count
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|symoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|outsym_count
operator|=
name|outsym
operator|-
name|finfo
operator|->
name|output_syms
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|finfo
operator|->
name|output_syms
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|EXTERNAL_NLIST_SIZE
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|outsym_count
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|outsym_count
operator|*
name|EXTERNAL_NLIST_SIZE
condition|)
return|return
name|false
return|;
name|finfo
operator|->
name|symoff
operator|+=
name|outsym_count
operator|*
name|EXTERNAL_NLIST_SIZE
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out a symbol that was not associated with an a.out input    object.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_write_other_symbol
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|aout_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|aout_final_link_info
modifier|*
name|finfo
init|=
operator|(
expr|struct
name|aout_final_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|struct
name|external_nlist
name|outsym
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
if|if
condition|(
name|aout_backend_info
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|write_dynamic_symbol
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|aout_backend_info
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|write_dynamic_symbol
operator|)
operator|(
name|output_bfd
operator|,
name|finfo
operator|->
name|info
operator|,
name|h
operator|)
operator|)
condition|)
block|{
comment|/* FIXME: No way to handle errors.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|written
condition|)
return|return
name|true
return|;
name|h
operator|->
name|written
operator|=
name|true
expr_stmt|;
comment|/* An indx of -2 means the symbol must be written.  */
if|if
condition|(
name|h
operator|->
name|indx
operator|!=
operator|-
literal|2
operator|&&
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
operator|)
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Avoid variable not initialized warnings.  */
return|return
name|true
return|;
case|case
name|bfd_link_hash_new
case|:
comment|/* This can happen for set symbols when sets are not being          built.  */
return|return
name|true
return|;
case|case
name|bfd_link_hash_undefined
case|:
name|type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|sec
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|obj_textsec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|type
operator|=
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_TEXT
else|:
name|N_WEAKT
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|obj_datasec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|type
operator|=
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_DATA
else|:
name|N_WEAKD
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|obj_bsssec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|type
operator|=
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_BSS
else|:
name|N_WEAKB
expr_stmt|;
else|else
name|type
operator|=
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_ABS
else|:
name|N_WEAKA
expr_stmt|;
name|type
operator||=
name|N_EXT
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|bfd_link_hash_common
case|:
name|type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|val
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefweak
case|:
name|type
operator|=
name|N_WEAKU
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
case|case
name|bfd_link_hash_indirect
case|:
case|case
name|bfd_link_hash_warning
case|:
comment|/* FIXME: Ignore these for now.  The circumstances under which 	 they should be written out are not clear to me.  */
return|return
name|true
return|;
block|}
name|bfd_h_put_8
argument_list|(
name|output_bfd
argument_list|,
name|type
argument_list|,
name|outsym
operator|.
name|e_type
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|outsym
operator|.
name|e_other
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|outsym
operator|.
name|e_desc
argument_list|)
expr_stmt|;
name|indx
operator|=
name|add_to_stringtab
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|strtab
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* FIXME: No way to handle errors.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|indx
argument_list|,
name|outsym
operator|.
name|e_strx
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|,
name|outsym
operator|.
name|e_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|symoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|outsym
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|EXTERNAL_NLIST_SIZE
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|EXTERNAL_NLIST_SIZE
condition|)
block|{
comment|/* FIXME: No way to handle errors.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|finfo
operator|->
name|symoff
operator|+=
name|EXTERNAL_NLIST_SIZE
expr_stmt|;
name|h
operator|->
name|indx
operator|=
name|obj_aout_external_sym_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
operator|++
name|obj_aout_external_sym_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Link an a.out section into the output file.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_input_section
parameter_list|(
name|finfo
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|reloff_ptr
parameter_list|,
name|rel_size
parameter_list|)
name|struct
name|aout_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|file_ptr
modifier|*
name|reloff_ptr
decl_stmt|;
name|bfd_size_type
name|rel_size
decl_stmt|;
block|{
name|bfd_size_type
name|input_size
decl_stmt|;
name|PTR
name|relocs
decl_stmt|;
comment|/* Get the section contents.  */
name|input_size
operator|=
name|bfd_section_size
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|finfo
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|input_size
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Read in the relocs if we haven't already done it.  */
if|if
condition|(
name|aout_section_data
argument_list|(
name|input_section
argument_list|)
operator|!=
name|NULL
operator|&&
name|aout_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|NULL
condition|)
name|relocs
operator|=
name|aout_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
expr_stmt|;
else|else
block|{
name|relocs
operator|=
name|finfo
operator|->
name|relocs
expr_stmt|;
if|if
condition|(
name|rel_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|input_section
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|relocs
argument_list|,
literal|1
argument_list|,
name|rel_size
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|rel_size
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* Relocate the section contents.  */
if|if
condition|(
name|obj_reloc_entry_size
argument_list|(
name|input_bfd
argument_list|)
operator|==
name|RELOC_STD_SIZE
condition|)
block|{
if|if
condition|(
operator|!
name|aout_link_input_section_std
argument_list|(
name|finfo
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|relocs
argument_list|,
name|rel_size
argument_list|,
name|finfo
operator|->
name|contents
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|aout_link_input_section_ext
argument_list|(
name|finfo
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|relocs
argument_list|,
name|rel_size
argument_list|,
name|finfo
operator|->
name|contents
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Write out the section contents.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|,
operator|(
name|PTR
operator|)
name|finfo
operator|->
name|contents
argument_list|,
name|input_section
operator|->
name|output_offset
argument_list|,
name|input_size
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If we are producing relocateable output, the relocs were      modified, and we now write them out.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|relocateable
operator|&&
name|rel_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|*
name|reloff_ptr
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
name|relocs
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|rel_size
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|!=
name|rel_size
condition|)
return|return
name|false
return|;
operator|*
name|reloff_ptr
operator|+=
name|rel_size
expr_stmt|;
comment|/* Assert that the relocs have not run into the symbols, and 	 that if these are the text relocs they have not run into the 	 data relocs.  */
name|BFD_ASSERT
argument_list|(
operator|*
name|reloff_ptr
operator|<=
name|obj_sym_filepos
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|&&
operator|(
name|reloff_ptr
operator|!=
operator|&
name|finfo
operator|->
name|treloff
operator|||
operator|(
operator|*
name|reloff_ptr
operator|<=
name|obj_datasec
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|rel_filepos
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get the section corresponding to a reloc index.  */
end_comment

begin_function
specifier|static
name|INLINE
name|asection
modifier|*
name|aout_reloc_index_to_section
parameter_list|(
name|abfd
parameter_list|,
name|indx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|indx
decl_stmt|;
block|{
switch|switch
condition|(
name|indx
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_TEXT
case|:
return|return
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
return|;
case|case
name|N_DATA
case|:
return|return
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
return|;
case|case
name|N_BSS
case|:
return|return
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
return|;
case|case
name|N_ABS
case|:
case|case
name|N_UNDF
case|:
return|return
name|bfd_abs_section_ptr
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Relocate an a.out section using standard a.out relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_input_section_std
parameter_list|(
name|finfo
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|relocs
parameter_list|,
name|rel_size
parameter_list|,
name|contents
parameter_list|)
name|struct
name|aout_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|struct
name|reloc_std_external
modifier|*
name|relocs
decl_stmt|;
name|bfd_size_type
name|rel_size
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*check_dynamic_reloc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|aout_link_hash_entry
operator|*
operator|,
name|PTR
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|syms
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|struct
name|aout_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|int
modifier|*
name|symbol_map
decl_stmt|;
name|bfd_size_type
name|reloc_count
decl_stmt|;
specifier|register
name|struct
name|reloc_std_external
modifier|*
name|rel
decl_stmt|;
name|struct
name|reloc_std_external
modifier|*
name|rel_end
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|check_dynamic_reloc
operator|=
name|aout_backend_info
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|check_dynamic_reloc
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|obj_reloc_entry_size
argument_list|(
name|input_bfd
argument_list|)
operator|==
name|RELOC_STD_SIZE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_bfd
operator|->
name|xvec
operator|->
name|header_byteorder
operator|==
name|output_bfd
operator|->
name|xvec
operator|->
name|header_byteorder
argument_list|)
expr_stmt|;
name|relocateable
operator|=
name|finfo
operator|->
name|info
operator|->
name|relocateable
expr_stmt|;
name|syms
operator|=
name|obj_aout_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|strings
operator|=
name|obj_aout_external_strings
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sym_hashes
operator|=
name|obj_aout_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|symbol_map
operator|=
name|finfo
operator|->
name|symbol_map
expr_stmt|;
name|reloc_count
operator|=
name|rel_size
operator|/
name|RELOC_STD_SIZE
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|rel_end
operator|=
name|rel
operator|+
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|bfd_vma
name|r_addr
decl_stmt|;
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|int
name|r_pcrel
decl_stmt|;
name|int
name|r_baserel
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|struct
name|aout_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_addr
operator|=
name|GET_SWORD
argument_list|(
name|input_bfd
argument_list|,
name|rel
operator|->
name|r_address
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MY_reloc_howto
name|howto
operator|=
name|MY_reloc_howto
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|r_index
argument_list|,
name|r_extern
argument_list|,
name|r_pcrel
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|r_jmptable
decl_stmt|;
name|int
name|r_relative
decl_stmt|;
name|int
name|r_length
decl_stmt|;
name|unsigned
name|int
name|howto_idx
decl_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|r_index
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_EXTERN_BIG
operator|)
operator|)
expr_stmt|;
name|r_pcrel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_PCREL_BIG
operator|)
operator|)
expr_stmt|;
name|r_baserel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_BASEREL_BIG
operator|)
operator|)
expr_stmt|;
name|r_jmptable
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_JMPTABLE_BIG
operator|)
operator|)
expr_stmt|;
name|r_relative
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_RELATIVE_BIG
operator|)
operator|)
expr_stmt|;
name|r_length
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_LENGTH_BIG
operator|)
operator|>>
name|RELOC_STD_BITS_LENGTH_SH_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|r_index
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_EXTERN_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_pcrel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_PCREL_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_baserel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_BASEREL_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_jmptable
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_JMPTABLE_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_relative
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_RELATIVE_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_length
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_LENGTH_LITTLE
operator|)
operator|>>
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
operator|)
expr_stmt|;
block|}
name|howto_idx
operator|=
operator|(
name|r_length
operator|+
literal|4
operator|*
name|r_pcrel
operator|+
literal|8
operator|*
name|r_baserel
operator|+
literal|16
operator|*
name|r_jmptable
operator|+
literal|32
operator|*
name|r_relative
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|howto_idx
operator|<
name|TABLE_SIZE
argument_list|(
name|howto_table_std
argument_list|)
argument_list|)
expr_stmt|;
name|howto
operator|=
name|howto_table_std
operator|+
name|howto_idx
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|relocateable
condition|)
block|{
comment|/* We are generating a relocateable output file, and must 	     modify the reloc accordingly.  */
if|if
condition|(
name|r_extern
condition|)
block|{
comment|/* If we know the symbol this relocation is against, 		 convert it into a relocation against a section.  This 		 is what the native linker does.  */
name|h
operator|=
name|sym_hashes
index|[
name|r_index
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
comment|/* Change the r_extern value.  */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&=
operator|~
name|RELOC_STD_BITS_EXTERN_BIG
expr_stmt|;
else|else
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&=
operator|~
name|RELOC_STD_BITS_EXTERN_LITTLE
expr_stmt|;
comment|/* Compute a new r_index.  */
name|output_section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|==
name|obj_textsec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|r_index
operator|=
name|N_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|output_section
operator|==
name|obj_datasec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|r_index
operator|=
name|N_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|output_section
operator|==
name|obj_bsssec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|r_index
operator|=
name|N_BSS
expr_stmt|;
else|else
name|r_index
operator|=
name|N_ABS
expr_stmt|;
comment|/* Add the symbol value and the section VMA to the 		     addend stored in the contents.  */
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We must change r_index according to the symbol 		     map.  */
name|r_index
operator|=
name|symbol_map
index|[
name|r_index
index|]
expr_stmt|;
if|if
condition|(
name|r_index
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* We decided to strip this symbol, but it                              turns out that we can't.  Note that we                              lose the other and desc information here.                              I don't think that will ever matter for a                              global symbol.  */
if|if
condition|(
name|h
operator|->
name|indx
operator|<
literal|0
condition|)
block|{
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
name|h
operator|->
name|written
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|aout_link_write_other_symbol
argument_list|(
name|h
argument_list|,
operator|(
name|PTR
operator|)
name|finfo
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|r_index
operator|=
name|h
operator|->
name|indx
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|syms
index|[
name|r_index
index|]
operator|.
name|e_strx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_addr
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|r_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Write out the new r_index value.  */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
block|}
else|else
block|{
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
block|}
block|}
else|else
block|{
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* This is a relocation against a section.  We must 		 adjust by the amount that the section moved.  */
name|section
operator|=
name|aout_reloc_index_to_section
argument_list|(
name|input_bfd
argument_list|,
name|r_index
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|section
operator|->
name|output_offset
operator|-
name|section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
comment|/* Change the address of the relocation.  */
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|r_addr
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|rel
operator|->
name|r_address
argument_list|)
expr_stmt|;
comment|/* Adjust a PC relative relocation by removing the reference 	     to the original address in the section and including the 	     reference to the new address.  */
if|if
condition|(
name|r_pcrel
condition|)
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|-
name|input_section
operator|->
name|vma
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MY_relocatable_reloc
name|MY_relocatable_reloc
argument_list|(
name|howto
argument_list|,
name|output_bfd
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|,
name|r_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|relocation
operator|==
literal|0
condition|)
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
else|else
name|r
operator|=
name|MY_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|contents
operator|+
name|r_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|hundef
decl_stmt|;
comment|/* We are generating an executable, and must do a full 	     relocation.  */
name|hundef
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|r_extern
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_index
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|hundef
operator|=
name|true
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|section
operator|=
name|aout_reloc_index_to_section
argument_list|(
name|input_bfd
argument_list|,
name|r_index
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|section
operator|->
name|output_offset
operator|-
name|section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|r_pcrel
condition|)
name|relocation
operator|+=
name|input_section
operator|->
name|vma
expr_stmt|;
block|}
if|if
condition|(
name|check_dynamic_reloc
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|skip
decl_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|check_dynamic_reloc
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|h
argument_list|,
operator|(
name|PTR
operator|)
name|rel
argument_list|,
name|contents
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|relocation
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|skip
condition|)
continue|continue;
block|}
comment|/* Now warn if a global symbol is undefined.  We could not              do this earlier, because check_dynamic_reloc might want              to skip this reloc.  */
if|if
condition|(
name|hundef
operator|&&
operator|!
name|finfo
operator|->
name|info
operator|->
name|shared
operator|&&
operator|!
name|r_baserel
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|syms
index|[
name|r_index
index|]
operator|.
name|e_strx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_addr
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
name|r
operator|=
name|MY_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|r_addr
argument_list|,
name|relocation
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
elseif|else
if|if
condition|(
name|r_extern
condition|)
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|syms
index|[
name|r_index
index|]
operator|.
name|e_strx
argument_list|)
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|aout_reloc_index_to_section
argument_list|(
name|input_bfd
argument_list|,
name|r_index
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_addr
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Relocate an a.out section using extended a.out relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_input_section_ext
parameter_list|(
name|finfo
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|relocs
parameter_list|,
name|rel_size
parameter_list|,
name|contents
parameter_list|)
name|struct
name|aout_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|struct
name|reloc_ext_external
modifier|*
name|relocs
decl_stmt|;
name|bfd_size_type
name|rel_size
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*check_dynamic_reloc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|aout_link_hash_entry
operator|*
operator|,
name|PTR
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|syms
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|struct
name|aout_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|int
modifier|*
name|symbol_map
decl_stmt|;
name|bfd_size_type
name|reloc_count
decl_stmt|;
specifier|register
name|struct
name|reloc_ext_external
modifier|*
name|rel
decl_stmt|;
name|struct
name|reloc_ext_external
modifier|*
name|rel_end
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|check_dynamic_reloc
operator|=
name|aout_backend_info
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|check_dynamic_reloc
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|obj_reloc_entry_size
argument_list|(
name|input_bfd
argument_list|)
operator|==
name|RELOC_EXT_SIZE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_bfd
operator|->
name|xvec
operator|->
name|header_byteorder
operator|==
name|output_bfd
operator|->
name|xvec
operator|->
name|header_byteorder
argument_list|)
expr_stmt|;
name|relocateable
operator|=
name|finfo
operator|->
name|info
operator|->
name|relocateable
expr_stmt|;
name|syms
operator|=
name|obj_aout_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|strings
operator|=
name|obj_aout_external_strings
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sym_hashes
operator|=
name|obj_aout_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|symbol_map
operator|=
name|finfo
operator|->
name|symbol_map
expr_stmt|;
name|reloc_count
operator|=
name|rel_size
operator|/
name|RELOC_EXT_SIZE
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|rel_end
operator|=
name|rel
operator|+
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|bfd_vma
name|r_addr
decl_stmt|;
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|bfd_vma
name|r_addend
decl_stmt|;
name|struct
name|aout_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|r_section
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|r_addr
operator|=
name|GET_SWORD
argument_list|(
name|input_bfd
argument_list|,
name|rel
operator|->
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|r_index
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_EXTERN_BIG
operator|)
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_BIG
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|r_index
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_EXTERN_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
operator|)
expr_stmt|;
block|}
name|r_addend
operator|=
name|GET_SWORD
argument_list|(
name|input_bfd
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
name|TABLE_SIZE
argument_list|(
name|howto_table_ext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocateable
condition|)
block|{
comment|/* We are generating a relocateable output file, and must 	     modify the reloc accordingly.  */
if|if
condition|(
name|r_extern
operator|||
name|r_type
operator|==
name|RELOC_BASE10
operator|||
name|r_type
operator|==
name|RELOC_BASE13
operator|||
name|r_type
operator|==
name|RELOC_BASE22
condition|)
block|{
comment|/* If we know the symbol this relocation is against, 		 convert it into a relocation against a section.  This 		 is what the native linker does.  */
if|if
condition|(
name|r_type
operator|==
name|RELOC_BASE10
operator|||
name|r_type
operator|==
name|RELOC_BASE13
operator|||
name|r_type
operator|==
name|RELOC_BASE22
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_index
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
comment|/* Change the r_extern value.  */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&=
operator|~
name|RELOC_EXT_BITS_EXTERN_BIG
expr_stmt|;
else|else
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&=
operator|~
name|RELOC_EXT_BITS_EXTERN_LITTLE
expr_stmt|;
comment|/* Compute a new r_index.  */
name|output_section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|==
name|obj_textsec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|r_index
operator|=
name|N_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|output_section
operator|==
name|obj_datasec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|r_index
operator|=
name|N_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|output_section
operator|==
name|obj_bsssec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|r_index
operator|=
name|N_BSS
expr_stmt|;
else|else
name|r_index
operator|=
name|N_ABS
expr_stmt|;
comment|/* Add the symbol value and the section VMA to the 		     addend.  */
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Now RELOCATION is the VMA of the final 		     destination.  If this is a PC relative reloc, 		     then ADDEND is the negative of the source VMA. 		     We want to set ADDEND to the difference between 		     the destination VMA and the source VMA, which 		     means we must adjust RELOCATION by the change in 		     the source VMA.  This is done below.  */
block|}
else|else
block|{
comment|/* We must change r_index according to the symbol 		     map.  */
name|r_index
operator|=
name|symbol_map
index|[
name|r_index
index|]
expr_stmt|;
if|if
condition|(
name|r_index
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* We decided to strip this symbol, but it                              turns out that we can't.  Note that we                              lose the other and desc information here.                              I don't think that will ever matter for a                              global symbol.  */
if|if
condition|(
name|h
operator|->
name|indx
operator|<
literal|0
condition|)
block|{
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
name|h
operator|->
name|written
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|aout_link_write_other_symbol
argument_list|(
name|h
argument_list|,
operator|(
name|PTR
operator|)
name|finfo
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|r_index
operator|=
name|h
operator|->
name|indx
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|syms
index|[
name|r_index
index|]
operator|.
name|e_strx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_addr
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|r_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|relocation
operator|=
literal|0
expr_stmt|;
comment|/* If this is a PC relative reloc, then the addend 		     is the negative of the source VMA.  We must 		     adjust it by the change in the source VMA.  This 		     is done below.  */
block|}
comment|/* Write out the new r_index value.  */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
block|}
else|else
block|{
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a relocation against a section.  We must 		 adjust by the amount that the section moved.  */
name|r_section
operator|=
name|aout_reloc_index_to_section
argument_list|(
name|input_bfd
argument_list|,
name|r_index
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|r_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|r_section
operator|->
name|output_offset
operator|-
name|r_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* If this is a PC relative reloc, then the addend is 		 the difference in VMA between the destination and the 		 source.  We have just adjusted for the change in VMA 		 of the destination, so we must also adjust by the 		 change in VMA of the source.  This is done below.  */
block|}
comment|/* As described above, we must always adjust a PC relative 	     reloc by the change in VMA of the source.  However, if 	     pcrel_offset is set, then the addend does not include the 	     location within the section, in which case we don't need 	     to adjust anything.  */
if|if
condition|(
name|howto_table_ext
index|[
name|r_type
index|]
operator|.
name|pc_relative
operator|&&
operator|!
name|howto_table_ext
index|[
name|r_type
index|]
operator|.
name|pcrel_offset
condition|)
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|-
name|input_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Change the addend if necessary.  */
if|if
condition|(
name|relocation
operator|!=
literal|0
condition|)
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|r_addend
operator|+
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
comment|/* Change the address of the relocation.  */
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|r_addr
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|rel
operator|->
name|r_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|hundef
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
comment|/* We are generating an executable, and must do a full 	     relocation.  */
name|hundef
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|r_extern
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_index
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|hundef
operator|=
name|true
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|RELOC_BASE10
operator|||
name|r_type
operator|==
name|RELOC_BASE13
operator|||
name|r_type
operator|==
name|RELOC_BASE22
condition|)
block|{
name|struct
name|external_nlist
modifier|*
name|sym
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* For base relative relocs, r_index is always an index                  into the symbol table, even if r_extern is 0.  */
name|sym
operator|=
name|syms
operator|+
name|r_index
expr_stmt|;
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
operator|||
name|type
operator|==
name|N_WEAKT
condition|)
name|r_section
operator|=
name|obj_textsec
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_DATA
operator|||
name|type
operator|==
name|N_WEAKD
condition|)
name|r_section
operator|=
name|obj_datasec
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_BSS
operator|||
name|type
operator|==
name|N_WEAKB
condition|)
name|r_section
operator|=
name|obj_bsssec
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_ABS
operator|||
name|type
operator|==
name|N_WEAKA
condition|)
name|r_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|relocation
operator|=
operator|(
name|r_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|r_section
operator|->
name|output_offset
operator|+
operator|(
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|sym
operator|->
name|e_value
argument_list|)
operator|-
name|r_section
operator|->
name|vma
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|r_section
operator|=
name|aout_reloc_index_to_section
argument_list|(
name|input_bfd
argument_list|,
name|r_index
argument_list|)
expr_stmt|;
comment|/* If this is a PC relative reloc, then R_ADDEND is the 		 difference between the two vmas, or 		   old_dest_sec + old_dest_off - (old_src_sec + old_src_off) 		 where 		   old_dest_sec == section->vma 		 and 		   old_src_sec == input_section->vma 		 and 		   old_src_off == r_addr  		 _bfd_final_link_relocate expects RELOCATION + 		 R_ADDEND to be the VMA of the destination minus 		 r_addr (the minus r_addr is because this relocation 		 is not pcrel_offset, which is a bit confusing and 		 should, perhaps, be changed), or 		   new_dest_sec 		 where 		   new_dest_sec == output_section->vma + output_offset 		 We arrange for this to happen by setting RELOCATION to 		   new_dest_sec + old_src_sec - old_dest_sec  		 If this is not a PC relative reloc, then R_ADDEND is 		 simply the VMA of the destination, so we set 		 RELOCATION to the change in the destination VMA, or 		   new_dest_sec - old_dest_sec 		 */
name|relocation
operator|=
operator|(
name|r_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|r_section
operator|->
name|output_offset
operator|-
name|r_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|howto_table_ext
index|[
name|r_type
index|]
operator|.
name|pc_relative
condition|)
name|relocation
operator|+=
name|input_section
operator|->
name|vma
expr_stmt|;
block|}
if|if
condition|(
name|check_dynamic_reloc
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|skip
decl_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|check_dynamic_reloc
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|h
argument_list|,
operator|(
name|PTR
operator|)
name|rel
argument_list|,
name|contents
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|relocation
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|skip
condition|)
continue|continue;
block|}
comment|/* Now warn if a global symbol is undefined.  We could not              do this earlier, because check_dynamic_reloc might want              to skip this reloc.  */
if|if
condition|(
name|hundef
operator|&&
operator|!
name|finfo
operator|->
name|info
operator|->
name|shared
operator|&&
name|r_type
operator|!=
name|RELOC_BASE10
operator|&&
name|r_type
operator|!=
name|RELOC_BASE13
operator|&&
name|r_type
operator|!=
name|RELOC_BASE22
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|syms
index|[
name|r_index
index|]
operator|.
name|e_strx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_addr
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
name|r
operator|=
name|MY_final_link_relocate
argument_list|(
name|howto_table_ext
operator|+
name|r_type
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|r_addr
argument_list|,
name|relocation
argument_list|,
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
elseif|else
if|if
condition|(
name|r_extern
operator|||
name|r_type
operator|==
name|RELOC_BASE10
operator|||
name|r_type
operator|==
name|RELOC_BASE13
operator|||
name|r_type
operator|==
name|RELOC_BASE22
condition|)
name|name
operator|=
name|strings
operator|+
name|GET_WORD
argument_list|(
name|input_bfd
argument_list|,
name|syms
index|[
name|r_index
index|]
operator|.
name|e_strx
argument_list|)
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|aout_reloc_index_to_section
argument_list|(
name|input_bfd
argument_list|,
name|r_index
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|howto_table_ext
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|r_addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_addr
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle a link order which is supposed to generate a reloc.  */
end_comment

begin_function
specifier|static
name|boolean
name|aout_link_reloc_link_order
parameter_list|(
name|finfo
parameter_list|,
name|o
parameter_list|,
name|p
parameter_list|)
name|struct
name|aout_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|bfd_link_order_reloc
modifier|*
name|pr
decl_stmt|;
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|file_ptr
modifier|*
name|reloff_ptr
decl_stmt|;
name|struct
name|reloc_std_external
name|srel
decl_stmt|;
name|struct
name|reloc_ext_external
name|erel
decl_stmt|;
name|PTR
name|rel_ptr
decl_stmt|;
name|pr
operator|=
name|p
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
block|{
name|r_extern
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|pr
operator|->
name|u
operator|.
name|section
argument_list|)
condition|)
name|r_index
operator|=
name|N_ABS
operator||
name|N_EXT
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|pr
operator|->
name|u
operator|.
name|section
operator|->
name|owner
operator|==
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
name|r_index
operator|=
name|pr
operator|->
name|u
operator|.
name|section
operator|->
name|target_index
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|aout_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
argument_list|)
expr_stmt|;
name|r_extern
operator|=
literal|1
expr_stmt|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|pr
operator|->
name|u
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|aout_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|indx
operator|>=
literal|0
condition|)
name|r_index
operator|=
name|h
operator|->
name|indx
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* We decided to strip this symbol, but it turns out that we 	     can't.  Note that we lose the other and desc information 	     here.  I don't think that will ever matter for a global 	     symbol.  */
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
name|h
operator|->
name|written
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|aout_link_write_other_symbol
argument_list|(
name|h
argument_list|,
operator|(
name|PTR
operator|)
name|finfo
argument_list|)
condition|)
return|return
name|false
return|;
name|r_index
operator|=
name|h
operator|->
name|indx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|pr
operator|->
name|u
operator|.
name|name
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|r_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|pr
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|o
operator|==
name|obj_textsec
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
condition|)
name|reloff_ptr
operator|=
operator|&
name|finfo
operator|->
name|treloff
expr_stmt|;
elseif|else
if|if
condition|(
name|o
operator|==
name|obj_datasec
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
condition|)
name|reloff_ptr
operator|=
operator|&
name|finfo
operator|->
name|dreloff
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|obj_reloc_entry_size
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|==
name|RELOC_STD_SIZE
condition|)
block|{
ifdef|#
directive|ifdef
name|MY_put_reloc
name|MY_put_reloc
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|r_extern
argument_list|,
name|r_index
argument_list|,
name|p
operator|->
name|offset
argument_list|,
name|howto
argument_list|,
operator|&
name|srel
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|r_pcrel
decl_stmt|;
name|int
name|r_baserel
decl_stmt|;
name|int
name|r_jmptable
decl_stmt|;
name|int
name|r_relative
decl_stmt|;
name|int
name|r_length
decl_stmt|;
name|r_pcrel
operator|=
name|howto
operator|->
name|pc_relative
expr_stmt|;
name|r_baserel
operator|=
operator|(
name|howto
operator|->
name|type
operator|&
literal|8
operator|)
operator|!=
literal|0
expr_stmt|;
name|r_jmptable
operator|=
operator|(
name|howto
operator|->
name|type
operator|&
literal|16
operator|)
operator|!=
literal|0
expr_stmt|;
name|r_relative
operator|=
operator|(
name|howto
operator|->
name|type
operator|&
literal|32
operator|)
operator|!=
literal|0
expr_stmt|;
name|r_length
operator|=
name|howto
operator|->
name|size
expr_stmt|;
name|PUT_WORD
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|p
operator|->
name|offset
argument_list|,
name|srel
operator|.
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
condition|)
block|{
name|srel
operator|.
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|srel
operator|.
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|srel
operator|.
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
name|srel
operator|.
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_baserel
condition|?
name|RELOC_STD_BITS_BASEREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_jmptable
condition|?
name|RELOC_STD_BITS_JMPTABLE_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_relative
condition|?
name|RELOC_STD_BITS_RELATIVE_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|srel
operator|.
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|srel
operator|.
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|srel
operator|.
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
name|srel
operator|.
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_baserel
condition|?
name|RELOC_STD_BITS_BASEREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_jmptable
condition|?
name|RELOC_STD_BITS_JMPTABLE_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_relative
condition|?
name|RELOC_STD_BITS_RELATIVE_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
operator|)
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|rel_ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|srel
expr_stmt|;
comment|/* We have to write the addend into the object file, since 	 standard a.out relocs are in place.  It would be more 	 reliable if we had the current contents of the file here, 	 rather than assuming zeroes, but we can't read the file since 	 it was opened using bfd_openw.  */
if|if
condition|(
name|pr
operator|->
name|addend
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|r
operator|=
name|MY_relocate_contents
argument_list|(
name|howto
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
name|pr
operator|->
name|addend
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
operator|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|?
name|bfd_section_name
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|pr
operator|->
name|u
operator|.
name|section
argument_list|)
else|:
name|pr
operator|->
name|u
operator|.
name|name
operator|)
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|pr
operator|->
name|addend
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
block|}
name|ok
operator|=
name|bfd_set_section_contents
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
name|p
operator|->
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
block|}
block|}
else|else
block|{
name|PUT_WORD
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|p
operator|->
name|offset
argument_list|,
name|erel
operator|.
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
condition|)
block|{
name|erel
operator|.
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|erel
operator|.
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|erel
operator|.
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
name|erel
operator|.
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|r_extern
condition|?
name|RELOC_EXT_BITS_EXTERN_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|howto
operator|->
name|type
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|erel
operator|.
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|erel
operator|.
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|erel
operator|.
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
name|erel
operator|.
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_EXT_BITS_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|howto
operator|->
name|type
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
operator|)
expr_stmt|;
block|}
name|PUT_WORD
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|pr
operator|->
name|addend
argument_list|,
name|erel
operator|.
name|r_addend
argument_list|)
expr_stmt|;
name|rel_ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|erel
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|*
name|reloff_ptr
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
name|rel_ptr
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|obj_reloc_entry_size
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|!=
name|obj_reloc_entry_size
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
operator|*
name|reloff_ptr
operator|+=
name|obj_reloc_entry_size
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* Assert that the relocs have not run into the symbols, and that n      the text relocs have not run into the data relocs.  */
name|BFD_ASSERT
argument_list|(
operator|*
name|reloff_ptr
operator|<=
name|obj_sym_filepos
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|&&
operator|(
name|reloff_ptr
operator|!=
operator|&
name|finfo
operator|->
name|treloff
operator|||
operator|(
operator|*
name|reloff_ptr
operator|<=
name|obj_datasec
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|rel_filepos
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

