begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MIPS-specific support for 32-bit ELF    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     Most of the information added by Ian Lance Taylor, Cygnus Support,<ian@cygnus.com>.    N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.<mark@codesourcery.com>    Traditional MIPS targets support added by Koundinya.K, Dansk Data    Elektronik& Operations Research Group.<kk@ddeorg.soft.net>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles MIPS ELF targets.  SGI Irix 5 uses a slightly    different MIPS ELF from other targets.  This matters when linking.    This file supports both, switching at runtime.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"genlink.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_comment
comment|/* Get the ECOFF swapping routines.  */
end_comment

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/mips.h"
end_include

begin_define
define|#
directive|define
name|ECOFF_SIGNED_32
end_define

begin_include
include|#
directive|include
file|"ecoffswap.h"
end_include

begin_comment
comment|/* This structure is used to hold .got information when linking.  It    is stored in the tdata field of the bfd_elf_section_data structure.  */
end_comment

begin_struct
struct|struct
name|mips_got_info
block|{
comment|/* The global symbol in the GOT with the lowest index in the dynamic      symbol table.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|global_gotsym
decl_stmt|;
comment|/* The number of global .got entries.  */
name|unsigned
name|int
name|global_gotno
decl_stmt|;
comment|/* The number of local .got entries.  */
name|unsigned
name|int
name|local_gotno
decl_stmt|;
comment|/* The number of local .got entries we have used.  */
name|unsigned
name|int
name|assigned_gotno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The MIPS ELF linker needs additional information for each symbol in    the global hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* External symbol information.  */
name|EXTR
name|esym
decl_stmt|;
comment|/* Number of R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 relocs against      this symbol.  */
name|unsigned
name|int
name|possibly_dynamic_relocs
decl_stmt|;
comment|/* If the R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 reloc is against      a readonly section.  */
name|boolean
name|readonly_reloc
decl_stmt|;
comment|/* The index of the first dynamic relocation (in the .rel.dyn      section) against this symbol.  */
name|unsigned
name|int
name|min_dyn_reloc_index
decl_stmt|;
comment|/* We must not create a stub for a symbol that has relocations      related to taking the function's address, i.e. any but      R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",      p. 4-20.  */
name|boolean
name|no_fn_stub
decl_stmt|;
comment|/* If there is a stub that 32 bit functions should use to call this      16 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|fn_stub
decl_stmt|;
comment|/* Whether we need the fn_stub; this is set if this symbol appears      in any relocs other than a 16 bit call.  */
name|boolean
name|need_fn_stub
decl_stmt|;
comment|/* If there is a stub that 16 bit functions should use to call this      32 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|call_stub
decl_stmt|;
comment|/* This is like the call_stub field, but it is used if the function      being called returns a floating point value.  */
name|asection
modifier|*
name|call_fp_stub
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips32_64bit_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|mips_rtype_to_howto
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_info_to_howto_rel
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf32_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_info_to_howto_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf32_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_gptab
operator|*
operator|,
name|Elf32_gptab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_gptab
operator|*
operator|,
name|Elf32_External_gptab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void bfd_mips_elf_swap_msym_in   PARAMS ((bfd *, const Elf32_External_Msym *, Elf32_Internal_Msym *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|bfd_mips_elf_swap_msym_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_Internal_Msym
operator|*
operator|,
name|Elf32_External_Msym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_sym_is_global
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_create_procedure_table
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|elf_mips_isa
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|unsigned
name|long
name|elf_mips_mach
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|char
modifier|*
name|elf_mips_abi_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|mips_elf_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gptab_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips16_jump_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips16_gprel_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_create_compact_rel_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf_final_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|boolean
operator|,
name|char
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|elf32_mips_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mips_elf_create_msym_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf_irix6_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_sign_extend
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_overflow_p
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_high
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_higher
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_highest
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_global_got_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_local_got_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_got_offset_from_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_record_global_got_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|mips_got_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_got_page
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|Elf_Internal_Rela
modifier|*
name|mips_elf_next_relocation
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf_calculate_relocation
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|,
name|reloc_howto_type
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_obtain_contents
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_perform_relocation
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|reloc_howto_type
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_assign_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_sort_hash_table_f
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_sort_hash_table
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mips_elf_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mips_got_info
modifier|*
name|mips_elf_got_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_local_relocation_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_create_local_got_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|mips_got_info
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf_got16_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_create_dynamic_relocation
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf_allocate_dynamic_relocations
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_stub_section_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sort_dynamic_relocs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_bfd_mips_elf_hide_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_bfd_mips_elf_copy_indirect_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|_bfd_elf32_mips_grok_prstatus
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Note
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|_bfd_elf32_mips_grok_psinfo
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Note
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|_bfd_elf32_mips_discard_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf_reloc_cookie
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|_bfd_elf32_mips_ignore_discarded_relocs
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|_bfd_elf32_mips_write_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_tradbigmips_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_tradlittlemips_vec
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf64_tradbigmips_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf64_tradlittlemips_vec
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The level of IRIX compatibility we're striving for.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ict_none
block|,
name|ict_irix5
block|,
name|ict_irix6
block|}
name|irix_compat_t
typedef|;
end_typedef

begin_comment
comment|/* This will be used when we sort the dynamic relocation records.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|reldyn_sorting_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if ABFD is using the N32 ABI.  */
end_comment

begin_define
define|#
directive|define
name|ABI_N32_P
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((elf_elfheader (abfd)->e_flags& EF_MIPS_ABI2) != 0)
end_define

begin_comment
comment|/* Nonzero if ABFD is using the 64-bit ABI. */
end_comment

begin_define
define|#
directive|define
name|ABI_64_P
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64) != 0)
end_define

begin_comment
comment|/* Depending on the target vector we generate some version of Irix    executables or "normal" MIPS ELF ABI executables.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_define
define|#
directive|define
name|IRIX_COMPAT
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(((abfd->xvec ==&bfd_elf64_tradbigmips_vec) || \     (abfd->xvec ==&bfd_elf64_tradlittlemips_vec) || \     (abfd->xvec ==&bfd_elf32_tradbigmips_vec) || \     (abfd->xvec ==&bfd_elf32_tradlittlemips_vec)) ? ict_none : \   ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IRIX_COMPAT
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(((abfd->xvec ==&bfd_elf32_tradbigmips_vec) || \     (abfd->xvec ==&bfd_elf32_tradlittlemips_vec)) ? ict_none : \   ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NEWABI_P
parameter_list|(
name|abfd
parameter_list|)
value|(ABI_N32_P(abfd) || ABI_64_P(abfd))
end_define

begin_comment
comment|/* Whether we are trying to be compatible with IRIX at all.  */
end_comment

begin_define
define|#
directive|define
name|SGI_COMPAT
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(IRIX_COMPAT (abfd) != ict_none)
end_define

begin_comment
comment|/* The name of the msym section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_MSYM_SECTION_NAME
parameter_list|(
name|abfd
parameter_list|)
value|".msym"
end_define

begin_comment
comment|/* The name of the srdata section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_SRDATA_SECTION_NAME
parameter_list|(
name|abfd
parameter_list|)
value|".srdata"
end_define

begin_comment
comment|/* The name of the options section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_OPTIONS_SECTION_NAME
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.options" : ".options")
end_define

begin_comment
comment|/* The name of the stub section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_STUB_SECTION_NAME
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.stubs" : ".stub")
end_define

begin_comment
comment|/* The name of the dynamic relocation section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_REL_DYN_SECTION_NAME
parameter_list|(
name|abfd
parameter_list|)
value|".rel.dyn"
end_define

begin_comment
comment|/* The size of an external REL relocation.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_REL_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_rel)
end_define

begin_comment
comment|/* The size of an external dynamic table entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_DYN_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_dyn)
end_define

begin_comment
comment|/* The size of a GOT entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_GOT_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->arch_size / 8)
end_define

begin_comment
comment|/* The size of a symbol-table entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_SYM_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_sym)
end_define

begin_comment
comment|/* The default alignment for sections, as a power of two.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_LOG_FILE_ALIGN
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->file_align == 8 ? 3 : 2)
end_define

begin_comment
comment|/* Get word-sized data.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_GET_WORD
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(ABI_64_P (abfd) ? bfd_get_64 (abfd, ptr) : bfd_get_32 (abfd, ptr))
end_define

begin_comment
comment|/* Put out word-sized data.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_PUT_WORD
parameter_list|(
name|abfd
parameter_list|,
name|val
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(ABI_64_P (abfd) 				\    ? bfd_put_64 (abfd, val, ptr) 		\    : bfd_put_32 (abfd, val, ptr))
end_define

begin_comment
comment|/* Add a dynamic symbol table-entry.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_define
define|#
directive|define
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|val
parameter_list|)
define|\
value|(ABI_64_P (elf_hash_table (info)->dynobj)				\    ? bfd_elf64_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val)	\    : bfd_elf32_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|val
parameter_list|)
define|\
value|(ABI_64_P (elf_hash_table (info)->dynobj)				\    ? (boolean) (abort (), false)					\    : bfd_elf32_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The number of local .got entries we reserve.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_RESERVED_GOTNO
value|(2)
end_define

begin_comment
comment|/* Instructions which appear in a stub.  For some reason the stub is    slightly different on an SGI system.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MIPS_GP_OFFSET
parameter_list|(
name|abfd
parameter_list|)
value|(SGI_COMPAT (abfd) ? 0x7ff0 : 0x8000)
end_define

begin_define
define|#
directive|define
name|STUB_LW
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(SGI_COMPAT (abfd)						\    ? (ABI_64_P (abfd)  						\       ? 0xdf998010
comment|/* ld t9,0x8010(gp) */
value|\       : 0x8f998010)
comment|/* lw t9,0x8010(gp) */
value|\    : 0x8f998010)
end_define

begin_comment
comment|/* lw t9,0x8000(gp) */
end_comment

begin_define
define|#
directive|define
name|STUB_MOVE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(SGI_COMPAT (abfd) ? 0x03e07825 : 0x03e07821)
end_define

begin_comment
comment|/* move t7,ra */
end_comment

begin_define
define|#
directive|define
name|STUB_JALR
value|0x0320f809
end_define

begin_comment
comment|/* jal t9 */
end_comment

begin_define
define|#
directive|define
name|STUB_LI16
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(SGI_COMPAT (abfd) ? 0x34180000 : 0x24180000)
end_define

begin_comment
comment|/* ori t8,zero,0 */
end_comment

begin_define
define|#
directive|define
name|MIPS_FUNCTION_STUB_SIZE
value|(16)
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* We no longer try to identify particular sections for the .dynsym    section.  When we do, we wind up crashing if there are other random    sections with relocations.  */
end_comment

begin_comment
comment|/* Names of sections which appear in the .dynsym section in an Irix 5    executable.  */
end_comment

begin_define
unit|static const char * const mips_elf_dynsym_sec_names[] = {   ".text",   ".init",   ".fini",   ".data",   ".rodata",   ".sdata",   ".sbss",   ".bss",   NULL };
define|#
directive|define
name|SIZEOF_MIPS_DYNSYM_SECNAMES
define|\
value|(sizeof mips_elf_dynsym_sec_names / sizeof mips_elf_dynsym_sec_names[0])
end_define

begin_comment
comment|/* The number of entries in mips_elf_dynsym_sec_names which go in the    text segment.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_TEXT_DYNSYM_SECNO
value|(3)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* The names of the runtime procedure table symbols used on Irix 5.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_elf_dynsym_rtproc_names
index|[]
init|=
block|{
literal|"_procedure_table"
block|,
literal|"_procedure_string_table"
block|,
literal|"_procedure_table_size"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These structures are used to generate the .compact_rel section on    Irix 5.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|id1
decl_stmt|;
comment|/* Always one?  */
name|unsigned
name|long
name|num
decl_stmt|;
comment|/* Number of compact relocation entries.  */
name|unsigned
name|long
name|id2
decl_stmt|;
comment|/* Always two?  */
name|unsigned
name|long
name|offset
decl_stmt|;
comment|/* The file offset of the first relocation.  */
name|unsigned
name|long
name|reserved0
decl_stmt|;
comment|/* Zero?  */
name|unsigned
name|long
name|reserved1
decl_stmt|;
comment|/* Zero?  */
block|}
name|Elf32_compact_rel
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|id1
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|num
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|id2
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|offset
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|reserved0
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|reserved1
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_compact_rel
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|ctype
range|:
literal|1
decl_stmt|;
comment|/* 1: long 0: short format. See below.  */
name|unsigned
name|int
name|rtype
range|:
literal|4
decl_stmt|;
comment|/* Relocation types. See below.  */
name|unsigned
name|int
name|dist2to
range|:
literal|8
decl_stmt|;
name|unsigned
name|int
name|relvaddr
range|:
literal|19
decl_stmt|;
comment|/* (VADDR - vaddr of the previous entry)/ 4 */
name|unsigned
name|long
name|konst
decl_stmt|;
comment|/* KONST field. See below.  */
name|unsigned
name|long
name|vaddr
decl_stmt|;
comment|/* VADDR to be relocated.  */
block|}
name|Elf32_crinfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|ctype
range|:
literal|1
decl_stmt|;
comment|/* 1: long 0: short format. See below.  */
name|unsigned
name|int
name|rtype
range|:
literal|4
decl_stmt|;
comment|/* Relocation types. See below.  */
name|unsigned
name|int
name|dist2to
range|:
literal|8
decl_stmt|;
name|unsigned
name|int
name|relvaddr
range|:
literal|19
decl_stmt|;
comment|/* (VADDR - vaddr of the previous entry)/ 4 */
name|unsigned
name|long
name|konst
decl_stmt|;
comment|/* KONST field. See below.  */
block|}
name|Elf32_crinfo2
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|info
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|konst
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|vaddr
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_crinfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|info
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|konst
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_crinfo2
typedef|;
end_typedef

begin_comment
comment|/* These are the constants used to swap the bitfields in a crinfo.  */
end_comment

begin_define
define|#
directive|define
name|CRINFO_CTYPE
value|(0x1)
end_define

begin_define
define|#
directive|define
name|CRINFO_CTYPE_SH
value|(31)
end_define

begin_define
define|#
directive|define
name|CRINFO_RTYPE
value|(0xf)
end_define

begin_define
define|#
directive|define
name|CRINFO_RTYPE_SH
value|(27)
end_define

begin_define
define|#
directive|define
name|CRINFO_DIST2TO
value|(0xff)
end_define

begin_define
define|#
directive|define
name|CRINFO_DIST2TO_SH
value|(19)
end_define

begin_define
define|#
directive|define
name|CRINFO_RELVADDR
value|(0x7ffff)
end_define

begin_define
define|#
directive|define
name|CRINFO_RELVADDR_SH
value|(0)
end_define

begin_comment
comment|/* A compact relocation info has long (3 words) or short (2 words)    formats.  A short format doesn't have VADDR field and relvaddr    fields contains ((VADDR - vaddr of the previous entry)>> 2).  */
end_comment

begin_define
define|#
directive|define
name|CRF_MIPS_LONG
value|1
end_define

begin_define
define|#
directive|define
name|CRF_MIPS_SHORT
value|0
end_define

begin_comment
comment|/* There are 4 types of compact relocation at least. The value KONST    has different meaning for each type:     (type)		(konst)    CT_MIPS_REL32	Address in data    CT_MIPS_WORD		Address in word (XXX)    CT_MIPS_GPHI_LO	GP - vaddr    CT_MIPS_JMPAD	Address to jump    */
end_comment

begin_define
define|#
directive|define
name|CRT_MIPS_REL32
value|0xa
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_WORD
value|0xb
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_GPHI_LO
value|0xc
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_JMPAD
value|0xd
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_format
parameter_list|(
name|x
parameter_list|,
name|format
parameter_list|)
value|((x).ctype = (format))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_type
parameter_list|(
name|x
parameter_list|,
name|type
parameter_list|)
value|((x).rtype = (type))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_dist2to
parameter_list|(
name|x
parameter_list|,
name|v
parameter_list|)
value|((x).dist2to = (v))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_relvaddr
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
value|((x).relvaddr = (d)<<2)
end_define

begin_decl_stmt
specifier|static
name|void
name|bfd_elf32_swap_compact_rel_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_compact_rel
operator|*
operator|,
name|Elf32_External_compact_rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bfd_elf32_swap_crinfo_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_crinfo
operator|*
operator|,
name|Elf32_External_crinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_comment
comment|/* The relocation table used for SHT_REL sections.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_howto_table_rel
index|[]
init|=
block|{
comment|/* No relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit symbol relative relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_REL32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 26 bit jump address.  */
name|HOWTO
argument_list|(
name|R_MIPS_26
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper four 				   bits must match the PC + 4.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_26"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x03ffffff
argument_list|,
comment|/* src_mask */
literal|0x03ffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_hi16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_lo16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_gprel16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to literal section.  */
name|HOWTO
argument_list|(
name|R_MIPS_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_gprel16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LITERAL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_got16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit PC relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_PC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_PC16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit call through global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_gprel32_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The remaining relocs are defined on Irix 5, although they are      not defined by the ABI.  */
name|EMPTY_HOWTO
argument_list|(
literal|13
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|15
argument_list|)
block|,
comment|/* A 5 bit shift field.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT5
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|5
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT5"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x000007c0
argument_list|,
comment|/* src_mask */
literal|0x000007c0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit shift field.  */
comment|/* FIXME: This is not handled correctly; a special function is      needed to put the most significant bit in the right place.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT6
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT6"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x000007c4
argument_list|,
comment|/* src_mask */
literal|0x000007c4
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 64 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|mips32_64bit_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_64"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement in the global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_DISP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_DISP"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement to page pointer in the global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_PAGE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_PAGE"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Offset from page pointer in the global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_OFST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_OFST"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of displacement in global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit subtraction.  Used in the N32 ABI.  */
name|HOWTO
argument_list|(
name|R_MIPS_SUB
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SUB"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used to cause the linker to insert and delete instructions?  */
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_INSERT_A
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_INSERT_B
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_DELETE
argument_list|)
block|,
comment|/* Get the higher value of a 64 bit addend.  */
name|HOWTO
argument_list|(
name|R_MIPS_HIGHER
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HIGHER"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Get the highest value of a 64 bit addend.  */
name|HOWTO
argument_list|(
name|R_MIPS_HIGHEST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HIGHEST"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of displacement in global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Section displacement.  */
name|HOWTO
argument_list|(
name|R_MIPS_SCN_DISP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SCN_DISP"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_REL16
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_ADD_IMMEDIATE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_PJUMP
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_RELGOT
argument_list|)
block|,
comment|/* Protected jump conversion.  This is an optimization hint.  No      relocation is required for correctness.  */
name|HOWTO
argument_list|(
name|R_MIPS_JALR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_JALR"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0x00000000
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The relocation table used for SHT_RELA sections.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_howto_table_rela
index|[]
init|=
block|{
comment|/* No relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit symbol relative relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_REL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 26 bit jump address.  */
name|HOWTO
argument_list|(
name|R_MIPS_26
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper 36 				   bits must match the PC + 4.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_26"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x03ffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* R_MIPS_HI16 and R_MIPS_LO16 are unsupported for 64 bit REL.  */
comment|/* High 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LO16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_gprel16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to literal section.  */
name|HOWTO
argument_list|(
name|R_MIPS_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_gprel16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LITERAL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to global offset table.  */
comment|/* FIXME: This is not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit PC relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_PC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_PC16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit call through global offset table.  */
comment|/* FIXME: This is not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_gprel32_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|13
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|15
argument_list|)
block|,
comment|/* A 5 bit shift field.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT5
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|5
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT5"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x000007c0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit shift field.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT6
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT6"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x000007c4
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_DISP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_DISP"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement to page pointer in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_PAGE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_PAGE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Offset from page pointer in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_OFST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_OFST"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_LO16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit substraction.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_SUB
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SUB"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Insert the addend as an instruction.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_INSERT_A
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_INSERT_A"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Insert the addend as an instruction, and change all relocations      to refer to the old instruction at the address.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_INSERT_B
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_INSERT_B"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Delete a 32 bit instruction.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_DELETE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_DELETE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Get the higher value of a 64 bit addend.  */
name|HOWTO
argument_list|(
name|R_MIPS_HIGHER
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HIGHER"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Get the highest value of a 64 bit addend.  */
name|HOWTO
argument_list|(
name|R_MIPS_HIGHEST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HIGHEST"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_LO16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Section displacement, used by an associated event location section.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_SCN_DISP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SCN_DISP"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MIPS_REL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_REL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* These two are obsolete.  */
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_ADD_IMMEDIATE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_PJUMP
argument_list|)
block|,
comment|/* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.      It must be used for multigot GOT's (and only there).  */
name|HOWTO
argument_list|(
name|R_MIPS_RELGOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_RELGOT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Protected jump conversion.  This is an optimization hint.  No      relocation is required for correctness.  */
name|HOWTO
argument_list|(
name|R_MIPS_JALR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_JALR"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The reloc used for BFD_RELOC_CTOR when doing a 64 bit link.  This    is a hack to make the linker think that we need 64 bit values.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_ctor64_howto
init|=
name|HOWTO
argument_list|(
name|R_MIPS_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips32_64bit_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_64"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* The reloc used for the mips16 jump instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips16_jump_howto
init|=
name|HOWTO
argument_list|(
name|R_MIPS16_26
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper four 				   bits must match the PC.  */
name|mips16_jump_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS16_26"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3ffffff
argument_list|,
comment|/* src_mask */
literal|0x3ffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* The reloc used for the mips16 gprel instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips16_gprel_howto
init|=
name|HOWTO
argument_list|(
name|R_MIPS16_GPREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips16_gprel_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS16_GPREL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x07ff001f
argument_list|,
comment|/* src_mask */
literal|0x07ff001f
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* GNU extensions for embedded-pic.  */
end_comment

begin_comment
comment|/* High 16 bits of symbol value, pc-relative.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_gnu_rel_hi16
init|=
name|HOWTO
argument_list|(
name|R_MIPS_GNU_REL_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_hi16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GNU_REL_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* Low 16 bits of symbol value, pc-relative.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_gnu_rel_lo16
init|=
name|HOWTO
argument_list|(
name|R_MIPS_GNU_REL_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_lo16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GNU_REL_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* 16 bit offset for pc-relative branches.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_gnu_rel16_s2
init|=
name|HOWTO
argument_list|(
name|R_MIPS_GNU_REL16_S2
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GNU_REL16_S2"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* 64 bit pc-relative.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_gnu_pcrel64
init|=
name|HOWTO
argument_list|(
name|R_MIPS_PC64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_PC64"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* 32 bit pc-relative.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_gnu_pcrel32
init|=
name|HOWTO
argument_list|(
name|R_MIPS_PC32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_PC32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* GNU extension to record C++ vtable hierarchy */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_gnu_vtinherit_howto
init|=
name|HOWTO
argument_list|(
name|R_MIPS_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* GNU extension to record C++ vtable member usage */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_gnu_vtentry_howto
init|=
name|HOWTO
argument_list|(
name|R_MIPS_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* Do a R_MIPS_HI16 relocation.  This has to be done in combination    with a R_MIPS_LO16 reloc, because there is a carry from the LO16 to    the HI16.  Here we just save the information we need; we do the    actual relocation when we see the LO16.     MIPS ELF requires that the LO16 immediately follow the HI16.  As a    GNU extension, for non-pc-relative relocations, we permit an    arbitrary number of HI16 relocs to be associated with a single LO16    reloc.  This extension permits gcc to output the HI and LO relocs    itself.     This cannot be done for PC-relative relocations because both the HI16    and LO16 parts of the relocations must be done relative to the LO16    part, and there can be carry to or borrow from the HI16 part.  */
end_comment

begin_struct
struct|struct
name|mips_hi16
block|{
name|struct
name|mips_hi16
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: This should not be a static variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_hi16
modifier|*
name|mips_hi16_list
decl_stmt|;
end_decl_stmt

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_hi16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|mips_hi16
modifier|*
name|n
decl_stmt|;
comment|/* If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
name|ret
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|bfd_reloc_undefined
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|relocateable
operator|=
name|true
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
name|relocation
operator|=
name|gp
operator|-
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Save the information, and let LO16 do the actual relocation.  */
name|n
operator|=
operator|(
expr|struct
name|mips_hi16
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|->
name|addr
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|n
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|mips_hi16_list
expr_stmt|;
name|mips_hi16_list
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_LO16 relocation.  This is a straightforward 16 bit    inplace relocation; this function exists in order to do the    R_MIPS_HI16 relocation described above.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_lo16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|arelent
name|gp_disp_relent
decl_stmt|;
if|if
condition|(
name|mips_hi16_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mips_hi16
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|mips_hi16_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|vallo
decl_stmt|;
name|struct
name|mips_hi16
modifier|*
name|next
decl_stmt|;
comment|/* Do the HI16 relocation.  Note that we actually don't need 	     to know anything about the LO16 itself, except where to 	     find the low 16 bits of the addend needed by the LO16.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|vallo
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* The low order 16 bits are always treated as a signed 	     value.  */
name|vallo
operator|=
operator|(
operator|(
name|vallo
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|vallo
expr_stmt|;
name|val
operator|+=
name|l
operator|->
name|addend
expr_stmt|;
comment|/* If PC-relative, we need to subtract out the address of the LO 	     half of the HI/LO.  (The actual relocation is relative 	     to that instruction.)  */
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|pc_relative
condition|)
name|val
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
comment|/* At this point, "val" has the value of the combined HI/LO 	     pair.  If the low order 16 bits (which will be used for 	     the LO16 insn) are negative, then we will need an 	     adjustment for the high order 16 bits.  */
name|val
operator|+=
literal|0x8000
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|insn
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffff
expr_stmt|;
name|insn
operator||=
name|val
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gp_disp_relent
operator|=
operator|*
name|reloc_entry
expr_stmt|;
name|reloc_entry
operator|=
operator|&
name|gp_disp_relent
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|=
name|l
operator|->
name|addend
expr_stmt|;
block|}
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
name|mips_hi16_list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|,
name|relocation
decl_stmt|;
comment|/* FIXME: Does this case ever occur?  */
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|true
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
name|relocation
operator|=
name|gp
operator|-
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|gp_disp_relent
operator|=
operator|*
name|reloc_entry
expr_stmt|;
name|reloc_entry
operator|=
operator|&
name|gp_disp_relent
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
operator|-
literal|4
expr_stmt|;
block|}
comment|/* Now do the LO16 reloc in the usual way.  */
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GOT16 reloc.  This is a reloc against the global offset    table used for PIC code.  If the symbol is an external symbol, the    instruction is modified to contain the offset of the appropriate    entry in the global offset table.  If the symbol is a section    symbol, the next reloc is a R_MIPS_LO16 reloc.  The two 16 bit    addends are combined to form the real addend against the section    symbol; the GOT16 is modified to contain the offset of an entry in    the global offset table, and the LO16 is modified to offset it    appropriately.  Thus an offset larger than 16 bits requires a    modified value in the global offset table.     This implementation suffices for the assembler, but the linker does    not yet know how to create global offset tables.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_got16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* If we're relocating, and this is a local symbol, we can handle it      just like HI16.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
return|return
name|_bfd_mips_elf_hi16_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the GP value for OUTPUT_BFD.  Returns false if this is a    dangerous relocation.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_assign_gp
parameter_list|(
name|output_bfd
parameter_list|,
name|pgp
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd_vma
modifier|*
name|pgp
decl_stmt|;
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If we've already figured out what GP will be, just return it.  */
operator|*
name|pgp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pgp
condition|)
return|return
name|true
return|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|sym
operator|=
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* The linker script will have created a symbol named `_gp' with the      appropriate value.  */
if|if
condition|(
name|sym
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
name|i
operator|=
name|count
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pgp
operator|=
name|bfd_asymbol_value
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|count
condition|)
block|{
comment|/* Only get the error once.  */
operator|*
name|pgp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We have to figure out the gp value, so that we can adjust the    symbol value correctly.  We look up the symbol _gp in the output    BFD.  If we can't find it, we're stuck.  We cache it in the ELF    target data.  We don't need to adjust the symbol value for an    external symbol if we are producing relocateable output.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_elf_final_gp
parameter_list|(
name|output_bfd
parameter_list|,
name|symbol
parameter_list|,
name|relocateable
parameter_list|,
name|error_message
parameter_list|,
name|pgp
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
name|bfd_vma
modifier|*
name|pgp
decl_stmt|;
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|relocateable
condition|)
block|{
operator|*
name|pgp
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_reloc_undefined
return|;
block|}
operator|*
name|pgp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pgp
operator|==
literal|0
operator|&&
operator|(
operator|!
name|relocateable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|relocateable
condition|)
block|{
comment|/* Make up a value.  */
operator|*
name|pgp
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|0x4000
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_elf_assign_gp
argument_list|(
name|output_bfd
argument_list|,
name|pgp
argument_list|)
condition|)
block|{
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"GP relative relocation when _gp not defined"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must    become the offset from the gp register.  This function also handles    R_MIPS_LITERAL relocations, although those can be handled more    cleverly because the entries in the .lit8 and .lit4 sections can be    merged.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|gprel16_with_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asection
operator|*
operator|,
name|boolean
operator|,
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ELF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|relocateable
operator|=
name|true
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
return|return
name|gprel16_with_gp
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|reloc_entry
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|gprel16_with_gp
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|reloc_entry
parameter_list|,
name|input_section
parameter_list|,
name|relocateable
parameter_list|,
name|data
parameter_list|,
name|gp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Set val to the offset into the section or symbol.  */
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0
condition|)
block|{
comment|/* This case occurs with the 64-bit MIPS ELF ABI.  */
name|val
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|+
name|reloc_entry
operator|->
name|addend
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x8000
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
block|}
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocateable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocateable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
name|val
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocateable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
comment|/* Make sure it fit in 16 bits.  */
if|if
condition|(
operator|(
name|long
operator|)
name|val
operator|>=
literal|0x8000
operator|||
operator|(
name|long
operator|)
name|val
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GPREL32 relocation.  Is this 32 bit value the offset    from the gp register? XXX */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|gprel32_with_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asection
operator|*
operator|,
name|boolean
operator|,
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel32_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ELF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"32bits gp relative relocation occurs for an external symbol"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|relocateable
operator|=
name|true
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
block|}
return|return
name|gprel32_with_gp
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|reloc_entry
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|gprel32_with_gp
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|reloc_entry
parameter_list|,
name|input_section
parameter_list|,
name|relocateable
parameter_list|,
name|data
parameter_list|,
name|gp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0
condition|)
block|{
comment|/* This case arises with the 64-bit MIPS ELF ABI.  */
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Set val to the offset into the section or symbol.  */
name|val
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocateable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocateable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocateable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Handle a 64 bit reloc in a 32 bit MIPS ELF file.  These are    generated when addresses are 64 bits.  The upper 32 bits are a simple    sign extension.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips32_64bit_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|arelent
name|reloc32
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|bfd_size_type
name|addr
decl_stmt|;
name|r
operator|=
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_continue
condition|)
return|return
name|r
return|;
comment|/* Do a normal 32 bit relocation on the lower 32 bits.  */
name|reloc32
operator|=
operator|*
name|reloc_entry
expr_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|reloc32
operator|.
name|address
operator|+=
literal|4
expr_stmt|;
name|reloc32
operator|.
name|howto
operator|=
operator|&
name|elf_mips_howto_table_rel
index|[
name|R_MIPS_32
index|]
expr_stmt|;
name|r
operator|=
name|bfd_perform_relocation
argument_list|(
name|abfd
argument_list|,
operator|&
name|reloc32
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
comment|/* Sign extend into the upper 32 bits.  */
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc32
operator|.
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|reloc_entry
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|addr
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Handle a mips16 jump.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips16_jump_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* FIXME.  */
block|{
specifier|static
name|boolean
name|warned
decl_stmt|;
if|if
condition|(
operator|!
name|warned
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Linking mips16 objects into %s format is not supported"
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
return|return
name|bfd_reloc_undefined
return|;
block|}
end_function

begin_comment
comment|/* Handle a mips16 GP relative reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips16_gprel_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|unsigned
name|short
name|extend
decl_stmt|,
name|insn
decl_stmt|;
name|unsigned
name|long
name|final
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ELF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|relocateable
operator|=
name|true
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Pick up the mips16 extend instruction and the real instruction.  */
name|extend
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Stuff the current addend back as a 32 bit value, do the usual      relocation, and then clean up.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
operator|(
name|extend
operator|&
literal|0x1f
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
name|extend
operator|&
literal|0x7e0
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x1f
operator|)
argument_list|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gprel16_with_gp
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|reloc_entry
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
expr_stmt|;
name|final
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|extend
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|final
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|final
operator|&
literal|0x7e0
operator|)
argument_list|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator||
operator|(
name|final
operator|&
literal|0x1f
operator|)
argument_list|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return the ISA for a MIPS e_flags value.  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|elf_mips_isa
parameter_list|(
name|flags
parameter_list|)
name|flagword
name|flags
decl_stmt|;
block|{
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_ARCH
condition|)
block|{
case|case
name|E_MIPS_ARCH_1
case|:
return|return
literal|1
return|;
case|case
name|E_MIPS_ARCH_2
case|:
return|return
literal|2
return|;
case|case
name|E_MIPS_ARCH_3
case|:
return|return
literal|3
return|;
case|case
name|E_MIPS_ARCH_4
case|:
return|return
literal|4
return|;
case|case
name|E_MIPS_ARCH_5
case|:
return|return
literal|5
return|;
case|case
name|E_MIPS_ARCH_32
case|:
return|return
literal|32
return|;
case|case
name|E_MIPS_ARCH_64
case|:
return|return
literal|64
return|;
block|}
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Return the MACH for a MIPS e_flags value.  */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|long
name|elf_mips_mach
parameter_list|(
name|flags
parameter_list|)
name|flagword
name|flags
decl_stmt|;
block|{
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_MACH
condition|)
block|{
case|case
name|E_MIPS_MACH_3900
case|:
return|return
name|bfd_mach_mips3900
return|;
case|case
name|E_MIPS_MACH_4010
case|:
return|return
name|bfd_mach_mips4010
return|;
case|case
name|E_MIPS_MACH_4100
case|:
return|return
name|bfd_mach_mips4100
return|;
case|case
name|E_MIPS_MACH_4111
case|:
return|return
name|bfd_mach_mips4111
return|;
case|case
name|E_MIPS_MACH_4650
case|:
return|return
name|bfd_mach_mips4650
return|;
case|case
name|E_MIPS_MACH_SB1
case|:
return|return
name|bfd_mach_mips_sb1
return|;
default|default:
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_ARCH
condition|)
block|{
default|default:
case|case
name|E_MIPS_ARCH_1
case|:
return|return
name|bfd_mach_mips3000
return|;
break|break;
case|case
name|E_MIPS_ARCH_2
case|:
return|return
name|bfd_mach_mips6000
return|;
break|break;
case|case
name|E_MIPS_ARCH_3
case|:
return|return
name|bfd_mach_mips4000
return|;
break|break;
case|case
name|E_MIPS_ARCH_4
case|:
return|return
name|bfd_mach_mips8000
return|;
break|break;
case|case
name|E_MIPS_ARCH_5
case|:
return|return
name|bfd_mach_mips5
return|;
break|break;
case|case
name|E_MIPS_ARCH_32
case|:
return|return
name|bfd_mach_mipsisa32
return|;
break|break;
case|case
name|E_MIPS_ARCH_64
case|:
return|return
name|bfd_mach_mipsisa64
return|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return printable name for ABI.  */
end_comment

begin_function
specifier|static
name|INLINE
name|char
modifier|*
name|elf_mips_abi_name
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_ABI
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|ABI_N32_P
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|"N32"
return|;
elseif|else
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|"64"
return|;
else|else
return|return
literal|"none"
return|;
case|case
name|E_MIPS_ABI_O32
case|:
return|return
literal|"O32"
return|;
case|case
name|E_MIPS_ABI_O64
case|:
return|return
literal|"O64"
return|;
case|case
name|E_MIPS_ABI_EABI32
case|:
return|return
literal|"EABI32"
return|;
case|case
name|E_MIPS_ABI_EABI64
case|:
return|return
literal|"EABI64"
return|;
default|default:
return|return
literal|"unknown abi"
return|;
block|}
block|}
end_function

begin_comment
comment|/* A mapping from BFD reloc types to MIPS ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|enum
name|elf_mips_reloc_type
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_reloc_map
name|mips_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_MIPS_NONE
block|, }
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_MIPS_16
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_MIPS_32
block|}
block|,
block|{
name|BFD_RELOC_64
block|,
name|R_MIPS_64
block|}
block|,
block|{
name|BFD_RELOC_MIPS_JMP
block|,
name|R_MIPS_26
block|}
block|,
block|{
name|BFD_RELOC_HI16_S
block|,
name|R_MIPS_HI16
block|}
block|,
block|{
name|BFD_RELOC_LO16
block|,
name|R_MIPS_LO16
block|}
block|,
block|{
name|BFD_RELOC_GPREL16
block|,
name|R_MIPS_GPREL16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_LITERAL
block|,
name|R_MIPS_LITERAL
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GOT16
block|,
name|R_MIPS_GOT16
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_MIPS_PC16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_CALL16
block|,
name|R_MIPS_CALL16
block|}
block|,
block|{
name|BFD_RELOC_GPREL32
block|,
name|R_MIPS_GPREL32
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GOT_HI16
block|,
name|R_MIPS_GOT_HI16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GOT_LO16
block|,
name|R_MIPS_GOT_LO16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_CALL_HI16
block|,
name|R_MIPS_CALL_HI16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_CALL_LO16
block|,
name|R_MIPS_CALL_LO16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_SUB
block|,
name|R_MIPS_SUB
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GOT_PAGE
block|,
name|R_MIPS_GOT_PAGE
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GOT_OFST
block|,
name|R_MIPS_GOT_OFST
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GOT_DISP
block|,
name|R_MIPS_GOT_DISP
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a BFD reloc type, return a howto structure.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mips_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mips_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_mips_howto_table_rel
index|[
operator|(
name|int
operator|)
name|mips_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_CTOR
case|:
comment|/* We need to handle BFD_RELOC_CTOR specially. 	 Select the right relocation (R_MIPS_32 or R_MIPS_64) based on the 	 size of addresses on this architecture.  */
if|if
condition|(
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
operator|==
literal|32
condition|)
return|return
operator|&
name|elf_mips_howto_table_rel
index|[
operator|(
name|int
operator|)
name|R_MIPS_32
index|]
return|;
else|else
return|return
operator|&
name|elf_mips_ctor64_howto
return|;
case|case
name|BFD_RELOC_MIPS16_JMP
case|:
return|return
operator|&
name|elf_mips16_jump_howto
return|;
case|case
name|BFD_RELOC_MIPS16_GPREL
case|:
return|return
operator|&
name|elf_mips16_gprel_howto
return|;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
return|return
operator|&
name|elf_mips_gnu_vtinherit_howto
return|;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
return|return
operator|&
name|elf_mips_gnu_vtentry_howto
return|;
case|case
name|BFD_RELOC_PCREL_HI16_S
case|:
return|return
operator|&
name|elf_mips_gnu_rel_hi16
return|;
case|case
name|BFD_RELOC_PCREL_LO16
case|:
return|return
operator|&
name|elf_mips_gnu_rel_lo16
return|;
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
return|return
operator|&
name|elf_mips_gnu_rel16_s2
return|;
case|case
name|BFD_RELOC_64_PCREL
case|:
return|return
operator|&
name|elf_mips_gnu_pcrel64
return|;
case|case
name|BFD_RELOC_32_PCREL
case|:
return|return
operator|&
name|elf_mips_gnu_pcrel32
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|mips_rtype_to_howto
parameter_list|(
name|r_type
parameter_list|)
name|unsigned
name|int
name|r_type
decl_stmt|;
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS16_26
case|:
return|return
operator|&
name|elf_mips16_jump_howto
return|;
break|break;
case|case
name|R_MIPS16_GPREL
case|:
return|return
operator|&
name|elf_mips16_gprel_howto
return|;
break|break;
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
return|return
operator|&
name|elf_mips_gnu_vtinherit_howto
return|;
break|break;
case|case
name|R_MIPS_GNU_VTENTRY
case|:
return|return
operator|&
name|elf_mips_gnu_vtentry_howto
return|;
break|break;
case|case
name|R_MIPS_GNU_REL_HI16
case|:
return|return
operator|&
name|elf_mips_gnu_rel_hi16
return|;
break|break;
case|case
name|R_MIPS_GNU_REL_LO16
case|:
return|return
operator|&
name|elf_mips_gnu_rel_lo16
return|;
break|break;
case|case
name|R_MIPS_GNU_REL16_S2
case|:
return|return
operator|&
name|elf_mips_gnu_rel16_s2
return|;
break|break;
case|case
name|R_MIPS_PC64
case|:
return|return
operator|&
name|elf_mips_gnu_pcrel64
return|;
break|break;
case|case
name|R_MIPS_PC32
case|:
return|return
operator|&
name|elf_mips_gnu_pcrel32
return|;
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_MIPS_max
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_mips_howto_table_rel
index|[
name|r_type
index|]
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */
end_comment

begin_function
specifier|static
name|void
name|mips_info_to_howto_rel
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf32_Internal_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|mips_rtype_to_howto
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
comment|/* The addend for a GPREL16 or LITERAL relocation comes from the GP      value for the object file.  We get the addend now, rather than      when we do the relocation, because the symbol manipulations done      by the linker may cause us to lose track of the input BFD.  */
if|if
condition|(
operator|(
operator|(
operator|*
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_MIPS_GPREL16
operator|||
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_MIPS_LITERAL
operator|)
condition|)
name|cache_ptr
operator|->
name|addend
operator|=
name|elf_gp
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a MIPS Elf32_Internal_Rela, fill in an arelent structure.  */
end_comment

begin_function
specifier|static
name|void
name|mips_info_to_howto_rela
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf32_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
comment|/* Since an Elf32_Internal_Rel is an initial prefix of an      Elf32_Internal_Rela, we can just use mips_info_to_howto_rel      above.  */
name|mips_info_to_howto_rel
argument_list|(
name|abfd
argument_list|,
name|cache_ptr
argument_list|,
operator|(
name|Elf32_Internal_Rel
operator|*
operator|)
name|dst
argument_list|)
expr_stmt|;
comment|/* If we ever need to do any extra processing with dst->r_addend      (the field omitted in an Elf32_Internal_Rel) we can do it here.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A .reginfo section holds a single Elf32_RegInfo structure.  These    routines swap this structure in and out.  They are used outside of    BFD, so they are globally visible.  */
end_comment

begin_function
name|void
name|bfd_mips_elf32_swap_reginfo_in
parameter_list|(
name|abfd
parameter_list|,
name|ex
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_External_RegInfo
modifier|*
name|ex
decl_stmt|;
name|Elf32_RegInfo
modifier|*
name|in
decl_stmt|;
block|{
name|in
operator|->
name|ri_gprmask
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_gp_value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_mips_elf32_swap_reginfo_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_RegInfo
modifier|*
name|in
decl_stmt|;
name|Elf32_External_RegInfo
modifier|*
name|ex
decl_stmt|;
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gprmask
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gp_value
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In the 64 bit ABI, the .MIPS.options section holds register    information in an Elf64_Reginfo structure.  These routines swap    them in and out.  They are globally visible because they are used    outside of BFD.  These routines are here so that gas can call them    without worrying about whether the 64 bit ABI has been included.  */
end_comment

begin_function
name|void
name|bfd_mips_elf64_swap_reginfo_in
parameter_list|(
name|abfd
parameter_list|,
name|ex
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf64_External_RegInfo
modifier|*
name|ex
decl_stmt|;
name|Elf64_Internal_RegInfo
modifier|*
name|in
decl_stmt|;
block|{
name|in
operator|->
name|ri_gprmask
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_pad
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_pad
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_gp_value
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_mips_elf64_swap_reginfo_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf64_Internal_RegInfo
modifier|*
name|in
decl_stmt|;
name|Elf64_External_RegInfo
modifier|*
name|ex
decl_stmt|;
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gprmask
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_pad
argument_list|,
name|ex
operator|->
name|ri_pad
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gp_value
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap an entry in a .gptab section.  Note that these routines rely    on the equivalence of the two elements of the union.  */
end_comment

begin_function
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_in
parameter_list|(
name|abfd
parameter_list|,
name|ex
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_External_gptab
modifier|*
name|ex
decl_stmt|;
name|Elf32_gptab
modifier|*
name|in
decl_stmt|;
block|{
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_gptab
modifier|*
name|in
decl_stmt|;
name|Elf32_External_gptab
modifier|*
name|ex
decl_stmt|;
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_elf32_swap_compact_rel_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_compact_rel
modifier|*
name|in
decl_stmt|;
name|Elf32_External_compact_rel
modifier|*
name|ex
decl_stmt|;
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|id1
argument_list|,
name|ex
operator|->
name|id1
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|num
argument_list|,
name|ex
operator|->
name|num
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|id2
argument_list|,
name|ex
operator|->
name|id2
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|offset
argument_list|,
name|ex
operator|->
name|offset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|reserved0
argument_list|,
name|ex
operator|->
name|reserved0
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|reserved1
argument_list|,
name|ex
operator|->
name|reserved1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_elf32_swap_crinfo_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_crinfo
modifier|*
name|in
decl_stmt|;
name|Elf32_External_crinfo
modifier|*
name|ex
decl_stmt|;
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|l
operator|=
operator|(
operator|(
operator|(
name|in
operator|->
name|ctype
operator|&
name|CRINFO_CTYPE
operator|)
operator|<<
name|CRINFO_CTYPE_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|rtype
operator|&
name|CRINFO_RTYPE
operator|)
operator|<<
name|CRINFO_RTYPE_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|dist2to
operator|&
name|CRINFO_DIST2TO
operator|)
operator|<<
name|CRINFO_DIST2TO_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|relvaddr
operator|&
name|CRINFO_RELVADDR
operator|)
operator|<<
name|CRINFO_RELVADDR_SH
operator|)
operator|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|l
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|konst
argument_list|,
name|ex
operator|->
name|konst
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|vaddr
argument_list|,
name|ex
operator|->
name|vaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in an options header.  */
end_comment

begin_function
name|void
name|bfd_mips_elf_swap_options_in
parameter_list|(
name|abfd
parameter_list|,
name|ex
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_External_Options
modifier|*
name|ex
decl_stmt|;
name|Elf_Internal_Options
modifier|*
name|in
decl_stmt|;
block|{
name|in
operator|->
name|kind
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|kind
argument_list|)
expr_stmt|;
name|in
operator|->
name|size
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|size
argument_list|)
expr_stmt|;
name|in
operator|->
name|section
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|section
argument_list|)
expr_stmt|;
name|in
operator|->
name|info
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out an options header.  */
end_comment

begin_function
name|void
name|bfd_mips_elf_swap_options_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Options
modifier|*
name|in
decl_stmt|;
name|Elf_External_Options
modifier|*
name|ex
decl_stmt|;
block|{
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|kind
argument_list|,
name|ex
operator|->
name|kind
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|size
argument_list|,
name|ex
operator|->
name|size
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|section
argument_list|,
name|ex
operator|->
name|section
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|info
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Swap in an MSYM entry.  */
end_comment

begin_endif
unit|static void bfd_mips_elf_swap_msym_in (abfd, ex, in)      bfd *abfd;      const Elf32_External_Msym *ex;      Elf32_Internal_Msym *in; {   in->ms_hash_value = H_GET_32 (abfd, ex->ms_hash_value);   in->ms_info = H_GET_32 (abfd, ex->ms_info); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Swap out an MSYM entry.  */
end_comment

begin_function
specifier|static
name|void
name|bfd_mips_elf_swap_msym_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_Internal_Msym
modifier|*
name|in
decl_stmt|;
name|Elf32_External_Msym
modifier|*
name|ex
decl_stmt|;
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ms_hash_value
argument_list|,
name|ex
operator|->
name|ms_hash_value
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ms_info
argument_list|,
name|ex
operator|->
name|ms_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine whether a symbol is global for the purposes of splitting    the symbol table into global symbols and local symbols.  At least    on Irix 5, this split must be between section symbols and all other    symbols.  On most ELF targets the split is between static symbols    and externally visible symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_sym_is_global
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
return|;
else|else
return|return
operator|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the right machine number for a MIPS ELF file.  This is used for    both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Irix 5 and 6 are broken.  Object file symbol tables are not always      sorted correctly such that local symbols precede global symbols,      and the sh_info field in the symbol table is not always right.  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mips
argument_list|,
name|elf_mips_mach
argument_list|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out a MIPS ELF object    file.  This gets the MIPS architecture right based on the machine    number.  This is used by both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|linker
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_mips3000
case|:
name|val
operator|=
name|E_MIPS_ARCH_1
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips3900
case|:
name|val
operator|=
name|E_MIPS_ARCH_1
operator||
name|E_MIPS_MACH_3900
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips6000
case|:
name|val
operator|=
name|E_MIPS_ARCH_2
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4000
case|:
case|case
name|bfd_mach_mips4300
case|:
case|case
name|bfd_mach_mips4400
case|:
case|case
name|bfd_mach_mips4600
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4010
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4010
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4100
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4100
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4111
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4111
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4650
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4650
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5000
case|:
case|case
name|bfd_mach_mips8000
case|:
case|case
name|bfd_mach_mips10000
case|:
case|case
name|bfd_mach_mips12000
case|:
name|val
operator|=
name|E_MIPS_ARCH_4
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5
case|:
name|val
operator|=
name|E_MIPS_ARCH_5
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips_sb1
case|:
name|val
operator|=
name|E_MIPS_ARCH_64
operator||
name|E_MIPS_MACH_SB1
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa32
case|:
name|val
operator|=
name|E_MIPS_ARCH_32
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa64
case|:
name|val
operator|=
name|E_MIPS_ARCH_64
expr_stmt|;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
comment|/* Set the sh_info field for .gptab sections and other appropriate      info for each special section.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_MSYM
case|:
case|case
name|SHT_MIPS_LIBLIST
case|:
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_GPTAB
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_CONTENT
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|,
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".liblist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_EVENTS
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|,
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|,
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
operator|(
name|name
operator|+
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to keep MIPS specific file flags like as EF_MIPS_PIC.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|old_flags
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
name|boolean
name|null_input_bfd
init|=
name|true
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Check if we have the same endianess */
if|if
condition|(
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_MIPS_NOREORDER
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
comment|/* Check flag compatibility.  */
name|new_flags
operator|&=
operator|~
name|EF_MIPS_NOREORDER
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_NOREORDER
expr_stmt|;
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
return|return
name|true
return|;
comment|/* Check to see if the input BFD actually contains any sections.      If not, its flags may not have been initialised either, but it cannot      actually cause any incompatibility.  */
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
comment|/* Ignore synthetic sections and empty .text, .data and .bss sections 	  which are automatically generated by gas.  */
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".data"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|)
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
operator|)
condition|)
block|{
name|null_input_bfd
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|null_input_bfd
condition|)
return|return
name|true
return|;
name|ok
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_PIC
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_PIC
operator|)
condition|)
block|{
name|new_flags
operator|&=
operator|~
name|EF_MIPS_PIC
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_PIC
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking PIC files with non-PIC files"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_CPIC
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_CPIC
operator|)
condition|)
block|{
name|new_flags
operator|&=
operator|~
name|EF_MIPS_CPIC
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_CPIC
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking abicalls files with non-abicalls files"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
comment|/* Compare the ISA's.  */
if|if
condition|(
operator|(
name|new_flags
operator|&
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator|)
operator|)
operator|!=
operator|(
name|old_flags
operator|&
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator|)
operator|)
condition|)
block|{
name|int
name|new_mach
init|=
name|new_flags
operator|&
name|EF_MIPS_MACH
decl_stmt|;
name|int
name|old_mach
init|=
name|old_flags
operator|&
name|EF_MIPS_MACH
decl_stmt|;
name|int
name|new_isa
init|=
name|elf_mips_isa
argument_list|(
name|new_flags
argument_list|)
decl_stmt|;
name|int
name|old_isa
init|=
name|elf_mips_isa
argument_list|(
name|old_flags
argument_list|)
decl_stmt|;
comment|/* If either has no machine specified, just compare the general isa's. 	 Some combinations of machines are ok, if the isa's match.  */
if|if
condition|(
operator|!
name|new_mach
operator|||
operator|!
name|old_mach
operator|||
name|new_mach
operator|==
name|old_mach
condition|)
block|{
comment|/* Don't warn about mixing code using 32-bit ISAs, or mixing code 	     using 64-bit ISAs.  They will normally use the same data sizes 	     and calling conventions.  */
if|if
condition|(
operator|(
operator|(
name|new_isa
operator|==
literal|1
operator|||
name|new_isa
operator|==
literal|2
operator|||
name|new_isa
operator|==
literal|32
operator|)
operator|^
operator|(
name|old_isa
operator|==
literal|1
operator|||
name|old_isa
operator|==
literal|2
operator|||
name|old_isa
operator|==
literal|32
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: ISA mismatch (-mips%d) with previous modules (-mips%d)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|new_isa
argument_list|,
name|old_isa
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
comment|/* Do we need to update the mach field?  */
if|if
condition|(
name|old_mach
operator|==
literal|0
operator|&&
name|new_mach
operator|!=
literal|0
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_mach
expr_stmt|;
comment|/* Do we need to update the ISA field?  */
if|if
condition|(
name|new_isa
operator|>
name|old_isa
condition|)
block|{
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_MIPS_ARCH
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_MIPS_ARCH
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: ISA mismatch (%d) with previous modules (%d)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|elf_mips_mach
argument_list|(
name|new_flags
argument_list|)
argument_list|,
name|elf_mips_mach
argument_list|(
name|old_flags
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
name|new_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator|)
expr_stmt|;
block|}
comment|/* Compare ABI's.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it      does set EI_CLASS differently from any 32-bit ABI.  */
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|)
condition|)
block|{
comment|/* Only error if both are set (to different values).  */
if|if
condition|(
operator|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|&&
operator|(
name|old_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: ABI mismatch: linking %s module with previous %s modules"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|elf_mips_abi_name
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|elf_mips_abi_name
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
name|new_flags
operator|&=
operator|~
name|EF_MIPS_ABI
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_ABI
expr_stmt|;
block|}
comment|/* Warn about any other mismatches */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|boolean
name|_bfd_mips_elf_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_O32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=O32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_O64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=O64]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=EABI32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=EABI64]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi unknown]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ABI_N32_P
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=N32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=64]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [no abi set]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips1]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_2
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips2]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_3
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips3]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_4
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips4]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_5
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips5]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips64]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [unknown ISA]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_32BITMODE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [32bitmode]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [not 32bitmode]"
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle a MIPS specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.    This routine supports both the 32-bit and 64-bit ELF ABI.     FIXME: We need to handle the SHF_MIPS_GPREL flag, but I'm not sure    how to.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|flagword
name|flags
init|=
literal|0
decl_stmt|;
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  Fortunately, the ABI gives      suggested names for all the MIPS specific sections, so we will      probably get away with this.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_LIBLIST
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".liblist"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_MSYM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_MSYM_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_CONFLICT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".conflict"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_GPTAB
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_UCODE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ucode"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_DEBUG
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|flags
operator|=
name|SEC_DEBUGGING
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_REGINFO
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|!=
literal|0
operator|||
name|hdr
operator|->
name|sh_size
operator|!=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
condition|)
return|return
name|false
return|;
name|flags
operator|=
operator|(
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_SAME_SIZE
operator|)
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_IFACE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.interfaces"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_CONTENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|,
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_OPTIONS
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_DWARF
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|,
sizeof|sizeof
expr|".debug_"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.symlib"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_EVENTS
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|,
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|,
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|flags
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
operator||
name|flags
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* FIXME: We should record sh_info for a .gptab section.  */
comment|/* For a .reginfo section, set the gp value in the tdata information      from the contents of this section.  We need the gp value while      processing relocs, so we just get it now.  The .reginfo section      is not used in the 64-bit MIPS ELF ABI.  */
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_REGINFO
condition|)
block|{
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|Elf32_RegInfo
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|s
operator|.
name|ri_gp_value
expr_stmt|;
block|}
comment|/* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and      set the gp value based on what we find.  We may see both      SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,      they should agree.  */
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|lend
decl_stmt|;
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|l
operator|=
name|contents
expr_stmt|;
name|lend
operator|=
name|contents
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
while|while
condition|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|<=
name|lend
condition|)
block|{
name|Elf_Internal_Options
name|intopt
decl_stmt|;
name|bfd_mips_elf_swap_options_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|l
argument_list|,
operator|&
name|intopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
operator|&&
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|Elf64_Internal_RegInfo
name|intreg
decl_stmt|;
name|bfd_mips_elf64_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|Elf64_External_RegInfo
operator|*
operator|)
operator|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|intreg
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|intreg
operator|.
name|ri_gp_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|Elf32_RegInfo
name|intreg
decl_stmt|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|Elf32_External_RegInfo
operator|*
operator|)
operator|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|intreg
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|intreg
operator|.
name|ri_gp_value
expr_stmt|;
block|}
name|l
operator|+=
name|intopt
operator|.
name|size
expr_stmt|;
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for a MIPS ELF section.  We do this by the    section name, which is a hack, but ought to work.  This routine is    used by both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".liblist"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_LIBLIST
expr_stmt|;
name|hdr
operator|->
name|sh_info
operator|=
name|sec
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_Lib
argument_list|)
expr_stmt|;
comment|/* The sh_link field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".conflict"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_CONFLICT
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_GPTAB
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
comment|/* The sh_info field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ucode"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_UCODE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_DEBUG
expr_stmt|;
comment|/* In a shared object on Irix 5.3, the .mdebug section has an          entsize of 0.  FIXME: Does this matter?  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_REGINFO
expr_stmt|;
comment|/* In a shared object on Irix 5.3, the .reginfo section has an          entsize of 0x18.  FIXME: Does this matter?  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".hash"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't how the Irix 6 linker behaves.  */
block|hdr->sh_info = SIZEOF_MIPS_DYNSYM_SECNAMES;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_SRDATA_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_GPREL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.interfaces"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_IFACE
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|,
name|strlen
argument_list|(
literal|".MIPS.content"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_CONTENT
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
comment|/* The sh_info field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_OPTIONS
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|,
sizeof|sizeof
expr|".debug_"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_DWARF
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.symlib"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_SYMBOL_LIB
expr_stmt|;
comment|/* The sh_link and sh_info fields are set in          final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|,
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|,
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_EVENTS
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
comment|/* The sh_link field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_MSYM_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_MSYM
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
literal|8
expr_stmt|;
block|}
comment|/* The generic elf_fake_sections will set up REL_HDR using the      default kind of relocations.  But, we may actually need both      kinds of relocations, so we set up the second header here.       This is not necessary for the O32 ABI since that only uses Elf32_Rel      relocations (cf. System V ABI, MIPS RISC Processor Supplement,      3rd Edition, p. 4-17).  It breaks the IRIX 5/6 32-bit ld, since one      of the resulting empty .rela.<section> sections starts with      sh_offset == object size, and ld doesn't allow that.  While the check      is arguably bogus for empty or SHT_NOBITS sections, it can easily be      avoided by not emitting those useless sections in the first place.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|!=
name|ict_irix5
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|esd
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
decl_stmt|;
name|esd
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|esd
operator|->
name|rel_hdr2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|esd
operator|->
name|rel_hdr2
operator|=
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|esd
operator|->
name|rel_hdr2
condition|)
return|return
name|false
return|;
name|_bfd_elf_init_reloc_shdr
argument_list|(
name|abfd
argument_list|,
name|esd
operator|->
name|rel_hdr2
argument_list|,
name|sec
argument_list|,
operator|!
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|use_rela_p
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Given a BFD section, try to locate the corresponding ELF section    index.  This is used by both the 32-bit and the 64-bit ABI.    Actually, it's not clear to me that the 64-bit ABI supports these,    but for non-PIC objects we will certainly want support for at least    the .scommon section.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_section_from_bfd_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|retval
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_MIPS_SCOMMON
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".acommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_MIPS_ACOMMON
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* When are writing out the .options or .MIPS.options section,    remember the bytes we are writing out, so that we can install the    GP value in the section_processing routine.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_elf_section_data
argument_list|)
decl_stmt|;
name|section
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|c
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|tdata
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|size
operator|=
name|section
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|size
operator|=
name|section
operator|->
name|_raw_size
expr_stmt|;
name|c
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|c
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|c
operator|+
name|offset
argument_list|,
name|location
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|_bfd_elf_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Work over a section just before writing it out.  This routine is    used by both the 32-bit and the 64-bit ABI.  FIXME: We recognize    sections that need the SHF_MIPS_GPREL flag by name; there has to be    a better way.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_section_processing
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_REGINFO
operator|&&
name|hdr
operator|->
name|sh_size
operator|>
literal|0
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_size
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|contents
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
operator|-
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
operator|&&
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|->
name|tdata
operator|!=
name|NULL
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|lend
decl_stmt|;
comment|/* We stored the section contents in the elf_section_data tdata 	 field in the set_section_contents routine.  We save the 	 section contents so that we don't have to read them again. 	 At this point we know that elf_gp is set, so we can look 	 through the section contents to see if there is an 	 ODK_REGINFO structure.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|l
operator|=
name|contents
expr_stmt|;
name|lend
operator|=
name|contents
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
while|while
condition|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|<=
name|lend
condition|)
block|{
name|Elf_Internal_Options
name|intopt
decl_stmt|;
name|bfd_mips_elf_swap_options_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|l
argument_list|,
operator|&
name|intopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
operator|&&
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|hdr
operator|->
name|sh_offset
operator|+
operator|(
name|l
operator|-
name|contents
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
operator|-
literal|8
operator|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|hdr
operator|->
name|sh_offset
operator|+
operator|(
name|l
operator|-
name|contents
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
operator|-
literal|4
operator|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
block|}
name|l
operator|+=
name|intopt
operator|.
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_SRDATA_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".compact_rel"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rtproc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_addralign
operator|!=
literal|0
operator|&&
name|hdr
operator|->
name|sh_entsize
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|adjust
decl_stmt|;
name|adjust
operator|=
name|hdr
operator|->
name|sh_size
operator|%
name|hdr
operator|->
name|sh_addralign
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_size
operator|+=
name|hdr
operator|->
name|sh_addralign
operator|-
name|adjust
expr_stmt|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* MIPS ELF uses two common sections.  One is the usual one, and the    other is for small objects.  All the small objects are kept    together, and then referenced via the gp pointer, which yields    faster assembler code.  This is what we use for the small common    section.  This approach is copied from ecoff.c.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_scom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MIPS ELF also uses an acommon section, which represents an    allocated common symbol which may be overridden by a    definition in a shared library.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_acom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_acom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_acom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the special MIPS section numbers that a symbol may use.    This is used for both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_symbol_processing
parameter_list|(
name|abfd
parameter_list|,
name|asym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|asym
decl_stmt|;
block|{
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
name|elfsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
expr_stmt|;
switch|switch
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
condition|)
block|{
case|case
name|SHN_MIPS_ACOMMON
case|:
comment|/* This section is used in a dynamically linked executable file. 	 It is an allocated common section.  The dynamic linker can 	 either resolve these symbols to something in a shared 	 library, or it can just leave them here.  For our purposes, 	 we can consider these symbols to be in a new section.  */
if|if
condition|(
name|mips_elf_acom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the acommon section.  */
name|mips_elf_acom_section
operator|.
name|name
operator|=
literal|".acommon"
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|output_section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_acom_symbol
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_acom_symbol_ptr
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|name
operator|=
literal|".acommon"
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
name|mips_elf_acom_symbol_ptr
operator|=
operator|&
name|mips_elf_acom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
break|break;
case|case
name|SHN_COMMON
case|:
comment|/* Common symbols less than the GP size are automatically 	 treated as SHN_MIPS_SCOMMON symbols on IRIX5.  */
if|if
condition|(
name|asym
operator|->
name|value
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_MIPS_SCOMMON
case|:
if|if
condition|(
name|mips_elf_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|mips_elf_scom_section
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|output_section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_scom_symbol
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_scom_symbol_ptr
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|mips_elf_scom_symbol_ptr
operator|=
operator|&
name|mips_elf_scom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_SUNDEFINED
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* for SGI_COMPAT */
block|case SHN_MIPS_TEXT:       asym->section = mips_elf_text_section_ptr;       break;      case SHN_MIPS_DATA:       asym->section = mips_elf_data_section_ptr;       break;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When creating an Irix 5 executable, we need REGINFO and RTPROC    segments.  */
end_comment

begin_function
name|int
name|_bfd_mips_elf_additional_program_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* See if we need a PT_MIPS_REGINFO segment.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
operator|++
name|ret
expr_stmt|;
comment|/* See if we need a PT_MIPS_OPTIONS segment.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
operator|++
name|ret
expr_stmt|;
comment|/* See if we need a PT_MIPS_RTPROC segment.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
condition|)
operator|++
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Modify the segment map for an Irix 5 executable.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_modify_segment_map
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|pm
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* If there is a .reginfo section, we need a PT_MIPS_REGINFO      segment.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_MIPS_REGINFO
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
expr|*
name|m
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_MIPS_REGINFO
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
comment|/* We want to put it after the PHDR and INTERP segments.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_PHDR
operator|||
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_INTERP
operator|)
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* For IRIX 6, we don't have .mdebug sections, nor does anything but      .dynamic end up in PT_DYNAMIC.  However, we do have to insert a      PT_OPTIONS segement immediately following the program header      table.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
condition|)
block|{
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
condition|)
break|break;
if|if
condition|(
name|s
condition|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|options_segment
decl_stmt|;
comment|/* Usually, there's a program header table.  But, sometimes 	     there's not (like when running the `ld' testsuite).  So, 	     if there's no program header table, we just put the 	     options segement at the end.  */
for|for
control|(
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
operator|*
name|pm
operator|!=
name|NULL
condition|;
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_PHDR
condition|)
break|break;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|options_segment
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|options_segment
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
name|options_segment
operator|->
name|p_type
operator|=
name|PT_MIPS_OPTIONS
expr_stmt|;
name|options_segment
operator|->
name|p_flags
operator|=
name|PF_R
expr_stmt|;
name|options_segment
operator|->
name|p_flags_valid
operator|=
name|true
expr_stmt|;
name|options_segment
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|options_segment
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
operator|*
name|pm
operator|=
name|options_segment
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
condition|)
block|{
comment|/* If there are .dynamic and .mdebug sections, we make a room 	     for the RTPROC header.  FIXME: Rewrite without section names.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
operator|==
name|NULL
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_MIPS_RTPROC
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
expr|*
name|m
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_MIPS_RTPROC
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
block|}
comment|/* We want to put it after the DYNAMIC segment.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|!=
name|PT_DYNAMIC
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|pm
operator|!=
name|NULL
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
block|}
comment|/* On Irix 5, the PT_DYNAMIC segment includes the .dynamic, 	 .dynstr, .dynsym, and .hash sections, and everything in 	 between.  */
for|for
control|(
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
operator|*
name|pm
operator|!=
name|NULL
condition|;
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_DYNAMIC
condition|)
break|break;
name|m
operator|=
operator|*
name|pm
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_none
condition|)
block|{
comment|/* For a normal mips executable the permissions for the PT_DYNAMIC 	     segment are read, write and execute. We do that here since 	     the code in elf.c sets only the read permission. This matters 	     sometimes for the dynamic linker.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|p_flags
operator|=
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|count
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|sec_names
index|[]
init|=
block|{
literal|".dynamic"
block|,
literal|".dynstr"
block|,
literal|".dynsym"
block|,
literal|".hash"
block|}
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|n
decl_stmt|;
name|low
operator|=
literal|0xffffffff
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|sec_names
operator|/
sizeof|sizeof
name|sec_names
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sec_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
name|low
operator|>
name|s
operator|->
name|vma
condition|)
name|low
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|sz
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
name|sz
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|high
operator|<
name|s
operator|->
name|vma
operator|+
name|sz
condition|)
name|high
operator|=
name|s
operator|->
name|vma
operator|+
name|sz
expr_stmt|;
block|}
block|}
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|vma
operator|>=
name|low
operator|&&
operator|(
operator|(
name|s
operator|->
name|vma
operator|+
operator|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
operator|)
operator|<=
name|high
operator|)
condition|)
operator|++
name|c
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
expr|*
name|n
operator|+
call|(
name|bfd_size_type
call|)
argument_list|(
name|c
operator|-
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|*
name|n
operator|=
operator|*
name|m
expr_stmt|;
name|n
operator|->
name|count
operator|=
name|c
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|vma
operator|>=
name|low
operator|&&
operator|(
operator|(
name|s
operator|->
name|vma
operator|+
operator|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
operator|)
operator|<=
name|high
operator|)
condition|)
block|{
name|n
operator|->
name|sections
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
operator|*
name|pm
operator|=
name|n
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The structure of the runtime procedure descriptor created by the    loader for use by the static exception system.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|runtime_pdr
block|{
name|bfd_vma
name|adr
decl_stmt|;
comment|/* memory address of start of procedure */
name|long
name|regmask
decl_stmt|;
comment|/* save register mask */
name|long
name|regoffset
decl_stmt|;
comment|/* save register offset */
name|long
name|fregmask
decl_stmt|;
comment|/* save floating point register mask */
name|long
name|fregoffset
decl_stmt|;
comment|/* save floating point register offset */
name|long
name|frameoffset
decl_stmt|;
comment|/* frame size */
name|short
name|framereg
decl_stmt|;
comment|/* frame pointer register */
name|short
name|pcreg
decl_stmt|;
comment|/* offset or reg of return pc */
name|long
name|irpss
decl_stmt|;
comment|/* index into the runtime string table */
name|long
name|reserved
decl_stmt|;
name|struct
name|exception_info
modifier|*
name|exception_info
decl_stmt|;
comment|/* pointer to exception array */
block|}
name|RPDR
operator|,
typedef|*
name|pRPDR
typedef|;
end_typedef

begin_define
define|#
directive|define
name|cbRPDR
value|sizeof (RPDR)
end_define

begin_define
define|#
directive|define
name|rpdNil
value|((pRPDR) 0)
end_define

begin_comment
comment|/* Swap RPDR (runtime procedure table entry) for output.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ecoff_swap_rpdr_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|RPDR
operator|*
operator|,
expr|struct
name|rpdr_ext
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ecoff_swap_rpdr_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|RPDR
modifier|*
name|in
decl_stmt|;
name|struct
name|rpdr_ext
modifier|*
name|ex
decl_stmt|;
block|{
comment|/* ECOFF_PUT_OFF was defined in ecoffswap.h.  */
name|ECOFF_PUT_OFF
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|adr
argument_list|,
name|ex
operator|->
name|p_adr
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|regmask
argument_list|,
name|ex
operator|->
name|p_regmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|regoffset
argument_list|,
name|ex
operator|->
name|p_regoffset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|fregmask
argument_list|,
name|ex
operator|->
name|p_fregmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|fregoffset
argument_list|,
name|ex
operator|->
name|p_fregoffset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|frameoffset
argument_list|,
name|ex
operator|->
name|p_frameoffset
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|framereg
argument_list|,
name|ex
operator|->
name|p_framereg
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|pcreg
argument_list|,
name|ex
operator|->
name|p_pcreg
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|irpss
argument_list|,
name|ex
operator|->
name|p_irpss
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME */
block|ECOFF_PUT_OFF (abfd, in->exception_info, ex->p_exception_info);
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read ECOFF debugging information from a .mdebug section into a    ecoff_debug_info structure.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_read_ecoff_info
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|debug
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|char
modifier|*
name|ext_hdr
init|=
name|NULL
decl_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|memset
argument_list|(
name|debug
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|ext_hdr
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|swap
operator|->
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_hdr
operator|==
name|NULL
operator|&&
name|swap
operator|->
name|external_hdr_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|ext_hdr
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|swap
operator|->
name|external_hdr_size
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
name|symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_hdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ext_hdr
argument_list|,
name|symhdr
argument_list|)
expr_stmt|;
comment|/* The symbolic header contains absolute file offsets and sizes to      read.  */
define|#
directive|define
name|READ
parameter_list|(
name|ptr
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|,
name|type
parameter_list|)
define|\
value|if (symhdr->count == 0)						\     debug->ptr = NULL;							\   else									\     {									\       bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\       debug->ptr = (type) bfd_malloc (amt);				\       if (debug->ptr == NULL)						\ 	goto error_return;						\       if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\ 	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\ 	goto error_return;						\     }
name|READ
argument_list|(
argument|line
argument_list|,
argument|cbLineOffset
argument_list|,
argument|cbLine
argument_list|,
argument|sizeof (unsigned char)
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|READ
argument_list|(
name|external_dnr
argument_list|,
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_pdr
argument_list|,
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_sym
argument_list|,
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_opt
argument_list|,
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_aux
argument_list|,
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ss
argument_list|,
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ssext
argument_list|,
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_fdr
argument_list|,
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_rfd
argument_list|,
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_ext
argument_list|,
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|READ
name|debug
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|adjust
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|ext_hdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ext_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_dnr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_dnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_pdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_pdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_sym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_aux
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ssext
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_fdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_fdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_rfd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_ext
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* MIPS ELF local labels start with '$', not 'L'.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
return|return
name|true
return|;
comment|/* On Irix 6, the labels go back to starting with '.', so we accept      the generic ELF local label syntax as well.  */
return|return
name|_bfd_elf_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* MIPS ELF uses a special find_nearest_line routine in order the    handle the ECOFF debugging information.  */
end_comment

begin_struct
struct|struct
name|mips_elf_find_line
block|{
name|struct
name|ecoff_debug_info
name|d
decl_stmt|;
name|struct
name|ecoff_find_line
name|i
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|boolean
name|_bfd_mips_elf_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|_bfd_dwarf1_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|_bfd_dwarf2_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|?
literal|8
else|:
literal|0
argument_list|)
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
condition|)
return|return
name|true
return|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msec
operator|!=
name|NULL
condition|)
block|{
name|flagword
name|origflags
decl_stmt|;
name|struct
name|mips_elf_find_line
modifier|*
name|fi
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
comment|/* If we are called during a link, mips_elf_final_link may have 	 cleared the SEC_HAS_CONTENTS field.  We force it back on here 	 if appropriate (which it normally will be).  */
name|origflags
operator|=
name|msec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|msec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|msec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|fi
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|external_fdr_size
decl_stmt|;
name|char
modifier|*
name|fraw_src
decl_stmt|;
name|char
modifier|*
name|fraw_end
decl_stmt|;
name|struct
name|fdr
modifier|*
name|fdr_ptr
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_find_line
argument_list|)
decl_stmt|;
name|fi
operator|=
operator|(
expr|struct
name|mips_elf_find_line
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_mips_elf_read_ecoff_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Swap in the FDR information.  */
name|amt
operator|=
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fdr
argument_list|)
expr_stmt|;
name|fi
operator|->
name|d
operator|.
name|fdr
operator|=
operator|(
expr|struct
name|fdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|d
operator|.
name|fdr
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|false
return|;
block|}
name|external_fdr_size
operator|=
name|swap
operator|->
name|external_fdr_size
expr_stmt|;
name|fdr_ptr
operator|=
name|fi
operator|->
name|d
operator|.
name|fdr
expr_stmt|;
name|fraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|fi
operator|->
name|d
operator|.
name|external_fdr
expr_stmt|;
name|fraw_end
operator|=
operator|(
name|fraw_src
operator|+
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
name|external_fdr_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|fraw_src
operator|<
name|fraw_end
condition|;
name|fraw_src
operator|+=
name|external_fdr_size
operator|,
name|fdr_ptr
operator|++
control|)
call|(
modifier|*
name|swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|fraw_src
argument_list|,
name|fdr_ptr
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
operator|=
name|fi
expr_stmt|;
comment|/* Note that we don't bother to ever free this information.              find_nearest_line is either called all the time, as in              objdump -l, so the information should be saved, or it is              rarely called, as in ld error messages, so the memory              wasted is unimportant.  Still, it would probably be a              good idea for free_cached_info to throw it away.  */
block|}
if|if
condition|(
name|_bfd_ecoff_locate_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|,
name|swap
argument_list|,
operator|&
name|fi
operator|->
name|i
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|true
return|;
block|}
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
block|}
comment|/* Fall back on the generic ELF find_nearest_line routine.  */
return|return
name|_bfd_elf_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The mips16 compiler uses a couple of special sections to handle      floating point arguments.       Section names that look like .mips16.fn.FNNAME contain stubs that      copy floating point arguments from the fp regs to the gp regs and      then jump to FNNAME.  If any 32 bit function calls FNNAME, the      call should be redirected to the stub instead.  If no 32 bit      function calls FNNAME, the stub should be discarded.  We need to      consider any reference to the function, not just a call, because      if the address of the function is taken we will need the stub,      since the address might be passed to a 32 bit function.       Section names that look like .mips16.call.FNNAME contain stubs      that copy floating point arguments from the gp regs to the fp      regs and then jump to FNNAME.  If FNNAME is a 32 bit function,      then any 16 bit function that calls FNNAME should be redirected      to the stub instead.  If FNNAME is not a 32 bit function, the      stub should be discarded.       .mips16.call.fp.FNNAME sections are similar, but contain stubs      which call FNNAME and then copy the return value from the fp regs      to the gp regs.  These stubs store the return value in $18 while      calling FNNAME; any function which might call one of these stubs      must arrange to save $18 around the call.  (This case is not      needed for 32 bit functions that call 16 bit functions, because      16 bit functions always return floating point values in both      $f0/$f1 and $2/$3.)       Note that in all cases FNNAME might be defined statically.      Therefore, FNNAME is not used literally.  Instead, the relocation      information will indicate which symbol the section is for.       We record any stubs that we find in the symbol table.  */
end_comment

begin_define
define|#
directive|define
name|FN_STUB
value|".mips16.fn."
end_define

begin_define
define|#
directive|define
name|CALL_STUB
value|".mips16.call."
end_define

begin_define
define|#
directive|define
name|CALL_FP_STUB
value|".mips16.call.fp."
end_define

begin_comment
comment|/* MIPS ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
if|#
directive|if
literal|0
comment|/* We no longer use this.  */
comment|/* String section indices for the dynamic section symbols.  */
block|bfd_size_type dynsym_sec_strindex[SIZEOF_MIPS_DYNSYM_SECNAMES];
endif|#
directive|endif
comment|/* The number of .rtproc entries.  */
name|bfd_size_type
name|procedure_count
decl_stmt|;
comment|/* The size of the .compact_rel section (if SGI_COMPAT).  */
name|bfd_size_type
name|compact_rel_size
decl_stmt|;
comment|/* This flag indicates that the value of DT_MIPS_RLD_MAP dynamic      entry is set to the address of __rld_obj_head as in Irix 5.  */
name|boolean
name|use_rld_obj_head
decl_stmt|;
comment|/* This is the value of the __rld_map or __rld_obj_head symbol.  */
name|bfd_vma
name|rld_value
decl_stmt|;
comment|/* This is set if we see any mips16 stub sections.  */
name|boolean
name|mips16_stubs_seen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in a MIPS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct mips_elf_link_hash_entry *)					\    elf_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse a MIPS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the MIPS ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct mips_elf_link_hash_table *) ((p)->hash))
end_define

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_output_extsym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an entry in a MIPS ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|mips_elf_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|esym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use -2 as a marker to indicate that the information has 	 not been set.  -1 means there is no associated ifd.  */
name|ret
operator|->
name|esym
operator|.
name|ifd
operator|=
operator|-
literal|2
expr_stmt|;
name|ret
operator|->
name|possibly_dynamic_relocs
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|readonly_reloc
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|min_dyn_reloc_index
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|no_fn_stub
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|fn_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|need_fn_stub
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|call_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|call_fp_stub
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_bfd_mips_elf_hide_symbol
parameter_list|(
name|info
parameter_list|,
name|entry
parameter_list|,
name|force_local
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|entry
decl_stmt|;
name|boolean
name|force_local
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|got
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
comment|/* FIXME: Do we allocate too much GOT space here?  */
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|got
operator|->
name|_raw_size
operator|+=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a MIPS ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_mips_elf_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|mips_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|mips_elf_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|mips_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
literal|0
comment|/* We no longer use this.  */
block|for (i = 0; i< SIZEOF_MIPS_DYNSYM_SECNAMES; i++)     ret->dynsym_sec_strindex[i] = (bfd_size_type) -1;
endif|#
directive|endif
name|ret
operator|->
name|procedure_count
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|compact_rel_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|use_rld_obj_head
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|rld_value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|mips16_stubs_seen
operator|=
name|false
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We must handle the special MIPS section numbers here.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_rld_new_interface"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip Irix 5 rld entry name.  */
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|sym
operator|->
name|st_shndx
condition|)
block|{
case|case
name|SHN_COMMON
case|:
comment|/* Common symbols less than the GP size are automatically 	 treated as SHN_MIPS_SCOMMON symbols.  */
if|if
condition|(
name|sym
operator|->
name|st_size
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_MIPS_SCOMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_TEXT
case|:
comment|/* This section is used in a shared object.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_section
operator|==
name|NULL
condition|)
block|{
name|asymbol
modifier|*
name|elf_text_symbol
decl_stmt|;
name|asection
modifier|*
name|elf_text_section
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
decl_stmt|;
name|elf_text_section
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_text_section
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
expr_stmt|;
name|elf_text_symbol
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_text_symbol
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Initialize the section.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_section
operator|=
name|elf_text_section
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_symbol
operator|=
name|elf_text_symbol
expr_stmt|;
name|elf_text_section
operator|->
name|symbol
operator|=
name|elf_text_symbol
expr_stmt|;
name|elf_text_section
operator|->
name|symbol_ptr_ptr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_symbol
expr_stmt|;
name|elf_text_section
operator|->
name|name
operator|=
literal|".text"
expr_stmt|;
name|elf_text_section
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|elf_text_section
operator|->
name|output_section
operator|=
name|NULL
expr_stmt|;
name|elf_text_section
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|elf_text_symbol
operator|->
name|name
operator|=
literal|".text"
expr_stmt|;
name|elf_text_symbol
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
operator||
name|BSF_DYNAMIC
expr_stmt|;
name|elf_text_symbol
operator|->
name|section
operator|=
name|elf_text_section
expr_stmt|;
block|}
comment|/* This code used to do *secp = bfd_und_section_ptr if          info->shared.  I don't know why, and that doesn't make sense,          so I took it out.  */
operator|*
name|secp
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_section
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_ACOMMON
case|:
comment|/* Fall through. XXX Can we treat this as allocated data?  */
case|case
name|SHN_MIPS_DATA
case|:
comment|/* This section is used in a shared object.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_section
operator|==
name|NULL
condition|)
block|{
name|asymbol
modifier|*
name|elf_data_symbol
decl_stmt|;
name|asection
modifier|*
name|elf_data_section
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
decl_stmt|;
name|elf_data_section
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_data_section
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
expr_stmt|;
name|elf_data_symbol
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_data_symbol
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Initialize the section.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_section
operator|=
name|elf_data_section
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_symbol
operator|=
name|elf_data_symbol
expr_stmt|;
name|elf_data_section
operator|->
name|symbol
operator|=
name|elf_data_symbol
expr_stmt|;
name|elf_data_section
operator|->
name|symbol_ptr_ptr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_symbol
expr_stmt|;
name|elf_data_section
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|elf_data_section
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|elf_data_section
operator|->
name|output_section
operator|=
name|NULL
expr_stmt|;
name|elf_data_section
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|elf_data_symbol
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|elf_data_symbol
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
operator||
name|BSF_DYNAMIC
expr_stmt|;
name|elf_data_symbol
operator|->
name|section
operator|=
name|elf_data_section
expr_stmt|;
block|}
comment|/* This code used to do *secp = bfd_und_section_ptr if          info->shared.  I don't know why, and that doesn't make sense,          so I took it out.  */
operator|*
name|secp
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_section
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_SUNDEFINED
case|:
operator|*
name|secp
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
operator|&&
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"__rld_obj_head"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Mark __rld_obj_head as dynamic.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|BSF_GLOBAL
argument_list|,
operator|*
name|secp
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|*
name|valp
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|=
name|true
expr_stmt|;
block|}
comment|/* If this is a mips16 text symbol, add 1 to the value to make it      odd.  This will cause something like .word SYM to come up with      the right value when it is loaded into the PC.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
operator|++
operator|*
name|valp
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Structure used to pass information to mips_elf_output_extsym.  */
end_comment

begin_struct
struct|struct
name|extsym_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|boolean
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This routine is used to write out ECOFF debugging external symbol    information.  It is called via mips_elf_link_hash_traverse.  The    ECOFF external symbol information must match the ELF external    symbol information.  Unfortunately, at this point we don't know    whether a symbol is required by reloc information, so the two    tables may wind up being different.  We must sort out the external    symbol information before we can set the final size of the .mdebug    section, and we must set the size of the .mdebug section before we    can relocate any sections, and we can't know which symbols are    required by relocation until we relocate the sections.    Fortunately, it is relatively unlikely that any symbol will be    stripped but required by a reloc.  In particular, it can not happen    when generating a final executable.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_output_extsym
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|extsym_info
modifier|*
name|einfo
init|=
operator|(
expr|struct
name|extsym_info
operator|*
operator|)
name|data
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|output_section
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|einfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|true
expr_stmt|;
else|else
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strip
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|ifd
operator|==
operator|-
literal|2
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Use undefined class.  Also, set class and type for some              special symbols.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|mips_elf_hash_table
argument_list|(
name|einfo
operator|->
name|info
argument_list|)
operator|->
name|procedure_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|elf_gp
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
comment|/* When making a shared library and symbol h is the one from 	     the another shared library, OUTPUT_SECTION may be null.  */
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_section_name
argument_list|(
name|output_section
operator|->
name|owner
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scText
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rodata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scRData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scInit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scFini
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
block|}
block|}
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hd
init|=
name|h
decl_stmt|;
name|boolean
name|no_fn_stub
init|=
name|h
operator|->
name|no_fn_stub
decl_stmt|;
while|while
condition|(
name|hd
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|hd
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|no_fn_stub
operator|=
name|no_fn_stub
operator|||
name|hd
operator|->
name|no_fn_stub
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_fn_stub
condition|)
block|{
comment|/* Set type and value for a symbol with a function stub.  */
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stProc
expr_stmt|;
name|sec
operator|=
name|hd
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|hd
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME?  */
block|h->esym.ifd = 0;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|,
name|einfo
operator|->
name|debug
argument_list|,
name|einfo
operator|->
name|swap
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|h
operator|->
name|esym
argument_list|)
condition|)
block|{
name|einfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a runtime procedure table from the .mdebug section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_create_procedure_table
parameter_list|(
name|handle
parameter_list|,
name|abfd
parameter_list|,
name|info
parameter_list|,
name|s
parameter_list|,
name|debug
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|HDRR
modifier|*
name|hdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|RPDR
modifier|*
name|rpdr
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|struct
name|rpdr_ext
modifier|*
name|erp
decl_stmt|;
name|PTR
name|rtproc
decl_stmt|;
name|struct
name|pdr_ext
modifier|*
name|epdr
decl_stmt|;
name|struct
name|sym_ext
modifier|*
name|esym
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|,
modifier|*
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|unsigned
name|long
name|sindex
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|PDR
name|pdr
decl_stmt|;
name|SYMR
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|no_name_func
init|=
name|_
argument_list|(
literal|"static procedure (no name)"
argument_list|)
decl_stmt|;
name|epdr
operator|=
name|NULL
expr_stmt|;
name|rpdr
operator|=
name|NULL
expr_stmt|;
name|esym
operator|=
name|NULL
expr_stmt|;
name|ss
operator|=
name|NULL
expr_stmt|;
name|sv
operator|=
name|NULL
expr_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|sindex
operator|=
name|strlen
argument_list|(
name|no_name_func
argument_list|)
operator|+
literal|1
expr_stmt|;
name|count
operator|=
name|hdr
operator|->
name|ipdMax
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|size
operator|=
name|swap
operator|->
name|external_pdr_size
expr_stmt|;
name|epdr
operator|=
operator|(
expr|struct
name|pdr_ext
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|epdr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_pdr
argument_list|(
name|handle
argument_list|,
operator|(
name|PTR
operator|)
name|epdr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|RPDR
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rpdr
operator|=
operator|(
name|RPDR
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|isymMax
expr_stmt|;
name|size
operator|=
name|swap
operator|->
name|external_sym_size
expr_stmt|;
name|esym
operator|=
operator|(
expr|struct
name|sym_ext
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_sym
argument_list|(
name|handle
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|issMax
expr_stmt|;
name|ss
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_ss
argument_list|(
name|handle
argument_list|,
operator|(
name|PTR
operator|)
name|ss
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|ipdMax
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|long
operator|)
name|count
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
call|(
modifier|*
name|swap
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|epdr
operator|+
name|i
argument_list|)
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|esym
index|[
name|pdr
operator|.
name|isym
index|]
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|rp
operator|->
name|adr
operator|=
name|sym
operator|.
name|value
expr_stmt|;
name|rp
operator|->
name|regmask
operator|=
name|pdr
operator|.
name|regmask
expr_stmt|;
name|rp
operator|->
name|regoffset
operator|=
name|pdr
operator|.
name|regoffset
expr_stmt|;
name|rp
operator|->
name|fregmask
operator|=
name|pdr
operator|.
name|fregmask
expr_stmt|;
name|rp
operator|->
name|fregoffset
operator|=
name|pdr
operator|.
name|fregoffset
expr_stmt|;
name|rp
operator|->
name|frameoffset
operator|=
name|pdr
operator|.
name|frameoffset
expr_stmt|;
name|rp
operator|->
name|framereg
operator|=
name|pdr
operator|.
name|framereg
expr_stmt|;
name|rp
operator|->
name|pcreg
operator|=
name|pdr
operator|.
name|pcreg
expr_stmt|;
name|rp
operator|->
name|irpss
operator|=
name|sindex
expr_stmt|;
name|sv
index|[
name|i
index|]
operator|=
name|ss
operator|+
name|sym
operator|.
name|iss
expr_stmt|;
name|sindex
operator|+=
name|strlen
argument_list|(
name|sv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
operator|*
operator|(
name|count
operator|+
literal|2
operator|)
operator|+
name|sindex
expr_stmt|;
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|rtproc
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc
operator|==
name|NULL
condition|)
block|{
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
operator|=
literal|0
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
operator|=
name|count
operator|+
literal|2
expr_stmt|;
name|erp
operator|=
operator|(
expr|struct
name|rpdr_ext
operator|*
operator|)
name|rtproc
expr_stmt|;
name|memset
argument_list|(
name|erp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
argument_list|)
expr_stmt|;
name|erp
operator|++
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|rtproc
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
operator|*
operator|(
name|count
operator|+
literal|2
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|no_name_func
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|no_name_func
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ecoff_swap_rpdr_out
argument_list|(
name|abfd
argument_list|,
name|rpdr
operator|+
name|i
argument_list|,
name|erp
operator|+
name|i
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|sv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|sv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|ECOFF_PUT_OFF
argument_list|(
name|abfd
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|erp
operator|+
name|count
operator|)
operator|->
name|p_adr
argument_list|)
expr_stmt|;
comment|/* Set the size and contents of .rtproc section.  */
name|s
operator|->
name|_raw_size
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|rtproc
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently      matters, but someday it might).  */
name|s
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|epdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|epdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rpdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|epdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|epdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rpdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A comparison routine used to sort .gptab entries.  */
end_comment

begin_function
specifier|static
name|int
name|gptab_compare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
specifier|const
name|Elf32_gptab
modifier|*
name|a1
init|=
operator|(
specifier|const
name|Elf32_gptab
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|Elf32_gptab
modifier|*
name|a2
init|=
operator|(
specifier|const
name|Elf32_gptab
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|a1
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|-
name|a2
operator|->
name|gt_entry
operator|.
name|gt_g_value
return|;
block|}
end_function

begin_comment
comment|/* We need to use a special link routine to handle the .reginfo and    the .mdebug sections.  We need to merge all instances of these    sections together, not write them all out sequentially.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|reginfo_sec
decl_stmt|,
modifier|*
name|mdebug_sec
decl_stmt|,
modifier|*
name|gptab_data_sec
decl_stmt|,
modifier|*
name|gptab_bss_sec
decl_stmt|;
name|asection
modifier|*
name|rtproc_sec
decl_stmt|;
name|Elf32_RegInfo
name|reginfo
decl_stmt|;
name|struct
name|ecoff_debug_info
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
init|=
operator|&
name|debug
operator|.
name|symbolic_header
decl_stmt|;
name|PTR
name|mdebug_handle
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|secname
index|[]
init|=
block|{
literal|".text"
block|,
literal|".init"
block|,
literal|".fini"
block|,
literal|".data"
block|,
literal|".rodata"
block|,
literal|".sdata"
block|,
literal|".sbss"
block|,
literal|".bss"
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|sc
index|[]
init|=
block|{
name|scText
block|,
name|scInit
block|,
name|scFini
block|,
name|scData
block|,
name|scRData
block|,
name|scSData
block|,
name|scSBss
block|,
name|scBss
block|}
decl_stmt|;
comment|/* If all the things we linked together were PIC, but we're      producing an executable (rather than a shared object), then the      resulting file is CPIC (i.e., it calls PIC code.)  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_PIC
condition|)
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_MIPS_PIC
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_CPIC
expr_stmt|;
block|}
comment|/* We'd carefully arranged the dynamic symbol indices, and then the      generic size_dynamic_sections renumbered them out from under us.      Rather than trying somehow to prevent the renumbering, just do      the sort again.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
comment|/* When we resort, we must tell mips_elf_sort_hash_table what 	 the lowest index it may use is.  That's the number of section 	 symbols we're going to add.  The generic ELF linker only 	 adds these symbols when building a shared object.  Note that 	 we count the sections after (possibly) removing the .options 	 section above.  */
if|if
condition|(
operator|!
name|mips_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
operator|(
name|info
operator|->
name|shared
condition|?
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
else|:
literal|1
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Make sure we didn't grow the global .got region.  */
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|got
argument_list|)
operator|->
name|tdata
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|BFD_ASSERT
argument_list|(
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
operator|)
operator|<=
name|g
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
block|}
comment|/* On IRIX5, we omit the .options section.  On IRIX6, however, we      include it, even though we don't process it quite right.  (Some      entries are supposed to be merged.)  Empirically, we seem to be      better off including it then not.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_none
condition|)
for|for
control|(
name|secpp
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|secpp
operator|!=
name|NULL
condition|;
name|secpp
operator|=
operator|&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|secpp
operator|)
operator|->
name|name
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
operator|(
operator|*
name|secpp
operator|)
operator|->
name|link_order_head
operator|=
name|NULL
expr_stmt|;
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|secpp
argument_list|)
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
break|break;
block|}
block|}
comment|/* Get a value for the GP register.  */
if|if
condition|(
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|bfd_vma
name|lo
decl_stmt|;
comment|/* Find the GP-relative section with the lowest offset.  */
name|lo
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|o
operator|->
name|vma
operator|<
name|lo
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator|&
name|SHF_MIPS_GPREL
operator|)
condition|)
name|lo
operator|=
name|o
operator|->
name|vma
expr_stmt|;
comment|/* And calculate GP relative to that.  */
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|lo
operator|+
name|ELF_MIPS_GP_OFFSET
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the relocate_section function needs to do a reloc 	     involving the GP value, it should make a reloc_dangerous 	     callback to warn that GP is not defined.  */
block|}
block|}
comment|/* Go through the sections and collect the .reginfo and .mdebug      information.  */
name|reginfo_sec
operator|=
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_data_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_bss_sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|reginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|reginfo
argument_list|)
expr_stmt|;
comment|/* We have found the .reginfo section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|Elf32_RegInfo
name|sub
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* The linker emulation code has probably clobbered the                  size to be zero bytes.  */
if|if
condition|(
name|input_section
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|input_section
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|sub
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator||=
name|sub
operator|.
name|ri_gprmask
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|0
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|1
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|2
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|3
index|]
expr_stmt|;
comment|/* ri_gp_value is set by the function 		 mips_elf32_section_processing when the section is 		 finally written out.  */
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Size has been set in mips_elf_always_size_sections  */
name|BFD_ASSERT
argument_list|(
name|o
operator|->
name|_raw_size
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
name|reginfo_sec
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|extsym_info
name|einfo
decl_stmt|;
name|bfd_vma
name|last
decl_stmt|;
comment|/* We have found the .mdebug section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
name|symhdr
operator|->
name|magic
operator|=
name|swap
operator|->
name|sym_magic
expr_stmt|;
comment|/* FIXME: What should the version stamp be?  */
name|symhdr
operator|->
name|vstamp
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* We accumulate the debugging information itself in the 	     debug_info structure.  */
name|debug
operator|.
name|line
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_dnr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_pdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_sym
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_opt
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_aux
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ss
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ssext
operator|=
name|debug
operator|.
name|ssext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_rfd
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_ext
operator|=
name|debug
operator|.
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
name|mdebug_handle
operator|=
name|bfd_ecoff_debug_init
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdebug_handle
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|iss
operator|=
name|issNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLocal
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|secname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|secname
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|sc
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|secname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|last
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|secname
index|[
name|i
index|]
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
return|return
name|false
return|;
block|}
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|input_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
name|input_debug
decl_stmt|;
name|char
modifier|*
name|eraw_src
decl_stmt|;
name|char
modifier|*
name|eraw_end
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* I don't know what a non MIPS ELF bfd would be 		     doing with a .mdebug section, but I don't really 		     want to deal with it.  */
continue|continue;
block|}
name|input_swap
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|size
operator|==
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
comment|/* The ECOFF linking code expects that we have already 		 read in the debugging information and set up an 		 ecoff_debug_info structure, so we do that now.  */
if|if
condition|(
operator|!
name|_bfd_mips_elf_read_ecoff_info
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|input_debug
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
operator|(
name|bfd_ecoff_debug_accumulate
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|input_bfd
argument_list|,
operator|&
name|input_debug
argument_list|,
name|input_swap
argument_list|,
name|info
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Loop through the external symbols.  For each one with 		 interesting information, try to find the symbol in 		 the linker global hash table and save the information 		 for the output external symbols.  */
name|eraw_src
operator|=
name|input_debug
operator|.
name|external_ext
expr_stmt|;
name|eraw_end
operator|=
operator|(
name|eraw_src
operator|+
operator|(
name|input_debug
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|*
name|input_swap
operator|->
name|external_ext_size
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|eraw_src
operator|<
name|eraw_end
condition|;
name|eraw_src
operator|+=
name|input_swap
operator|->
name|external_ext_size
control|)
block|{
name|EXTR
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|eraw_src
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scNil
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
condition|)
continue|continue;
name|name
operator|=
name|input_debug
operator|.
name|ssext
operator|+
name|ext
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|h
operator|=
name|mips_elf_link_hash_lookup
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|esym
operator|.
name|ifd
operator|!=
operator|-
literal|2
condition|)
continue|continue;
if|if
condition|(
name|ext
operator|.
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ext
operator|.
name|ifd
operator|<
name|input_debug
operator|.
name|symbolic_header
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
name|ext
operator|.
name|ifd
operator|=
name|input_debug
operator|.
name|ifdmap
index|[
name|ext
operator|.
name|ifd
index|]
expr_stmt|;
block|}
name|h
operator|->
name|esym
operator|=
name|ext
expr_stmt|;
block|}
comment|/* Free up the information we just read.  */
name|free
argument_list|(
name|input_debug
operator|.
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_dnr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_pdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_opt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_aux
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ssext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_fdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_rfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_ext
argument_list|)
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Create .rtproc section.  */
name|rtproc_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
init|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
decl_stmt|;
name|rtproc_sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|mips_elf_create_procedure_table
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|rtproc_sec
argument_list|,
operator|&
name|debug
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Build the external symbol information.  */
name|einfo
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|einfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|einfo
operator|.
name|debug
operator|=
operator|&
name|debug
expr_stmt|;
name|einfo
operator|.
name|swap
operator|=
name|swap
expr_stmt|;
name|einfo
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|mips_elf_link_hash_traverse
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_output_extsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|einfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|einfo
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* Set the size of the .mdebug section.  */
name|o
operator|->
name|_raw_size
operator|=
name|bfd_ecoff_debug_size
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|subname
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|Elf32_gptab
modifier|*
name|tab
decl_stmt|;
name|Elf32_External_gptab
modifier|*
name|ext_tab
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* The .gptab.sdata and .gptab.sbss sections hold 	     information describing how the small data area would 	     change depending upon the -G switch.  These sections 	     not used in executables files.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		     elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Skip this section later on (I don't think this 		 currently matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Really remove the section.  */
for|for
control|(
name|secpp
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|secpp
operator|!=
name|o
condition|;
name|secpp
operator|=
operator|&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|secpp
argument_list|)
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
continue|continue;
block|}
comment|/* There is one gptab for initialized data, and one for 	     uninitialized data.  */
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sdata"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_data_sec
operator|=
name|o
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sbss"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_bss_sec
operator|=
name|o
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: illegal section name `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* The linker script always combines .gptab.data and 	     .gptab.sdata into .gptab.sdata, and likewise for 	     .gptab.bss and .gptab.sbss.  It is possible that there is 	     no .sdata or .sbss section in the output file, in which 	     case we must change the name of the output section.  */
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|o
operator|==
name|gptab_data_sec
condition|)
name|o
operator|->
name|name
operator|=
literal|".gptab.data"
expr_stmt|;
else|else
name|o
operator|->
name|name
operator|=
literal|".gptab.bss"
expr_stmt|;
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the first entry.  */
name|c
operator|=
literal|1
expr_stmt|;
name|amt
operator|=
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
expr_stmt|;
name|tab
operator|=
operator|(
name|Elf32_gptab
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_current_g_value
operator|=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_unused
operator|=
literal|0
expr_stmt|;
comment|/* Combine the input sections.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|unsigned
name|long
name|last
decl_stmt|;
name|bfd_size_type
name|gpentry
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* Combine the gptab entries for this input section one 		 by one.  We know that the input gptab entries are 		 sorted by ascending -G value.  */
name|size
operator|=
name|bfd_section_size
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gpentry
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
init|;
name|gpentry
operator|<
name|size
condition|;
name|gpentry
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
control|)
block|{
name|Elf32_External_gptab
name|ext_gptab
decl_stmt|;
name|Elf32_gptab
name|int_gptab
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|add
decl_stmt|;
name|boolean
name|exact
decl_stmt|;
name|unsigned
name|int
name|look
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext_gptab
argument_list|,
operator|(
name|file_ptr
operator|)
name|gpentry
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_mips_elf32_swap_gptab_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext_gptab
argument_list|,
operator|&
name|int_gptab
argument_list|)
expr_stmt|;
name|val
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_g_value
expr_stmt|;
name|add
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|-
name|last
expr_stmt|;
name|exact
operator|=
name|false
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>=
name|val
condition|)
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|==
name|val
condition|)
name|exact
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exact
condition|)
block|{
name|Elf32_gptab
modifier|*
name|new_tab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
comment|/* We need a new table entry.  */
name|amt
operator|=
call|(
name|bfd_size_type
call|)
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
expr_stmt|;
name|new_tab
operator|=
operator|(
name|Elf32_gptab
operator|*
operator|)
name|bfd_realloc
argument_list|(
operator|(
name|PTR
operator|)
name|tab
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tab
operator|=
name|new_tab
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|val
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|add
expr_stmt|;
comment|/* Merge in the size for the next smallest -G 			 value, since that will be implied by this new 			 value.  */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|<
name|val
operator|&&
operator|(
name|max
operator|==
literal|0
operator|||
operator|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|)
operator|)
condition|)
name|max
operator|=
name|look
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
literal|0
condition|)
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|last
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
block|}
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* The table must be sorted by -G value.  */
if|if
condition|(
name|c
operator|>
literal|2
condition|)
name|qsort
argument_list|(
name|tab
operator|+
literal|1
argument_list|,
name|c
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tab
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gptab_compare
argument_list|)
expr_stmt|;
comment|/* Swap out the table.  */
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
name|ext_tab
operator|=
operator|(
name|Elf32_External_gptab
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c
condition|;
name|j
operator|++
control|)
name|bfd_mips_elf32_swap_gptab_out
argument_list|(
name|abfd
argument_list|,
name|tab
operator|+
name|j
argument_list|,
name|ext_tab
operator|+
name|j
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|o
operator|->
name|_raw_size
operator|=
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
name|o
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_tab
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Invoke the regular ELF backend linker to do all the work.  */
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
operator|!
name|bfd_elf64_bfd_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
endif|#
directive|endif
comment|/* BFD64 */
block|}
elseif|else
if|if
condition|(
operator|!
name|bfd_elf32_bfd_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now write out the computed sections.  */
if|if
condition|(
name|reginfo_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|bfd_mips_elf32_swap_reginfo_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reginfo
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|reginfo_sec
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|mdebug_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_write_accumulated_debug
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|,
name|mdebug_sec
operator|->
name|filepos
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_ecoff_debug_free
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gptab_data_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_data_sec
argument_list|,
name|gptab_data_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|gptab_data_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|gptab_bss_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_bss_sec
argument_list|,
name|gptab_bss_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|gptab_bss_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|rtproc_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
name|rtproc_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|rtproc_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function is called via qsort() to sort the dynamic relocation    entries by increasing r_symndx value.  */
end_comment

begin_function
specifier|static
name|int
name|sort_dynamic_relocs
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
specifier|const
name|Elf32_External_Rel
modifier|*
name|ext_reloc1
init|=
operator|(
specifier|const
name|Elf32_External_Rel
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|Elf32_External_Rel
modifier|*
name|ext_reloc2
init|=
operator|(
specifier|const
name|Elf32_External_Rel
operator|*
operator|)
name|arg2
decl_stmt|;
name|Elf_Internal_Rel
name|int_reloc1
decl_stmt|;
name|Elf_Internal_Rel
name|int_reloc2
decl_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|reldyn_sorting_bfd
argument_list|,
name|ext_reloc1
argument_list|,
operator|&
name|int_reloc1
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|reldyn_sorting_bfd
argument_list|,
name|ext_reloc2
argument_list|,
operator|&
name|int_reloc2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ELF32_R_SYM
argument_list|(
name|int_reloc1
operator|.
name|r_info
argument_list|)
operator|-
name|ELF32_R_SYM
argument_list|(
name|int_reloc2
operator|.
name|r_info
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT section for ABFD.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mips_elf_got_section
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT information associated with the link indicated by    INFO.  If SGOTP is non-NULL, it is filled in with the GOT    section.  */
end_comment

begin_function
specifier|static
name|struct
name|mips_got_info
modifier|*
name|mips_elf_got_info
parameter_list|(
name|abfd
parameter_list|,
name|sgotp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sgotp
decl_stmt|;
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgotp
condition|)
operator|*
name|sgotp
operator|=
name|sgot
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Return whether a relocation is against a local symbol.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_local_relocation_p
parameter_list|(
name|input_bfd
parameter_list|,
name|relocation
parameter_list|,
name|local_sections
parameter_list|,
name|check_forced
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
name|boolean
name|check_forced
decl_stmt|;
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
return|return
name|true
return|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|local_sections
index|[
name|r_symndx
index|]
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|check_forced
condition|)
block|{
comment|/* Look up the hash table to check whether the symbol  	 was forced local.  */
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Sign-extend VALUE, which has the indicated number of BITS.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_sign_extend
parameter_list|(
name|value
parameter_list|,
name|bits
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
name|int
name|bits
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* VALUE is negative.  */
name|value
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bits
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the indicated VALUE has overflowed the maximum    range expressable by a signed number with the indicated number of    BITS.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_overflow_p
parameter_list|(
name|value
parameter_list|,
name|bits
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
name|int
name|bits
decl_stmt|;
block|{
name|bfd_signed_vma
name|svalue
init|=
operator|(
name|bfd_signed_vma
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|svalue
operator|>
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
condition|)
comment|/* The value is too big.  */
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|svalue
operator|<
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* The value is too small.  */
return|return
name|true
return|;
comment|/* All is well.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Calculate the %high function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_high
parameter_list|(
name|value
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* Calculate the %higher function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_higher
parameter_list|(
name|value
parameter_list|)
name|bfd_vma
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x80008000
operator|)
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Calculate the %highest function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_highest
parameter_list|(
name|value
parameter_list|)
name|bfd_vma
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x800080008000
operator|)
operator|>>
literal|48
operator|)
operator|&
literal|0xffff
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Returns the GOT index for the global symbol indicated by H.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_global_got_index
parameter_list|(
name|abfd
parameter_list|,
name|h
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd_vma
name|index
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
comment|/* Once we determine the global GOT entry with the lowest dynamic      symbol table index, we must put all dynamic symbols with greater      indices into the GOT.  That makes it easy to calculate the GOT      offset.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|>=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
operator|(
name|h
operator|->
name|dynindx
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
operator|+
name|g
operator|->
name|local_gotno
operator|)
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|index
operator|<
name|sgot
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Returns the offset for the entry at the INDEXth position    in the GOT.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_got_offset_from_index
parameter_list|(
name|dynobj
parameter_list|,
name|output_bfd
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd_vma
name|index
decl_stmt|;
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|index
operator|-
name|gp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If H is a symbol that needs a global GOT entry, but has a dynamic    symbol table index lower than any we've seen to date, record it for    posterity.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_record_global_got_symbol
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|,
name|g
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* A global symbol in the GOT must also be in the dynamic symbol      table.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If we've already marked this entry as needing GOT space, we don't      need to do it again.  */
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|true
return|;
comment|/* By setting this to a value other than -1, we are indicating that      there needs to be a GOT entry for H.  Avoid using zero, as the      generic ELF copy_indirect_symbol tests for<= 0.  */
name|h
operator|->
name|got
operator|.
name|offset
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This structure is passed to mips_elf_sort_hash_table_f when sorting    the dynamic symbols.  */
end_comment

begin_struct
struct|struct
name|mips_elf_hash_sort_data
block|{
comment|/* The symbol in the global GOT with the lowest dynamic symbol table      index.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|low
decl_stmt|;
comment|/* The least dynamic symbol table index corresponding to a symbol      with a GOT entry.  */
name|long
name|min_got_dynindx
decl_stmt|;
comment|/* The greatest dynamic symbol table index not corresponding to a      symbol without a GOT entry.  */
name|long
name|max_non_got_dynindx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If H needs a GOT entry, assign it the highest available dynamic    index.  Otherwise, assign it the lowest available dynamic    index.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_sort_hash_table_f
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|mips_elf_hash_sort_data
modifier|*
name|hsd
init|=
operator|(
expr|struct
name|mips_elf_hash_sort_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Symbols without dynamic symbol table entries aren't interesting      at all.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|!=
literal|1
condition|)
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
name|hsd
operator|->
name|max_non_got_dynindx
operator|++
expr_stmt|;
else|else
block|{
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
operator|--
name|hsd
operator|->
name|min_got_dynindx
expr_stmt|;
name|hsd
operator|->
name|low
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Sort the dynamic symbol table so that symbols that need GOT entries    appear towards the end.  This reduces the amount of GOT space    required.  MAX_LOCAL is used to set the number of local symbols    known to be in the dynamic symbol table.  During    mips_elf_size_dynamic_sections, this value is 1.  Afterward, the    section symbols are added and the count is higher.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_sort_hash_table
parameter_list|(
name|info
parameter_list|,
name|max_local
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|max_local
decl_stmt|;
block|{
name|struct
name|mips_elf_hash_sort_data
name|hsd
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|hsd
operator|.
name|low
operator|=
name|NULL
expr_stmt|;
name|hsd
operator|.
name|min_got_dynindx
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|hsd
operator|.
name|max_non_got_dynindx
operator|=
name|max_local
expr_stmt|;
name|mips_elf_link_hash_traverse
argument_list|(
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_table
operator|*
operator|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|)
argument_list|,
name|mips_elf_sort_hash_table_f
argument_list|,
operator|&
name|hsd
argument_list|)
expr_stmt|;
comment|/* There should have been enough room in the symbol table to      accomodate both the GOT and non-GOT symbols.  */
name|BFD_ASSERT
argument_list|(
name|hsd
operator|.
name|max_non_got_dynindx
operator|<=
name|hsd
operator|.
name|min_got_dynindx
argument_list|)
expr_stmt|;
comment|/* Now we know which dynamic symbol has the lowest dynamic symbol      table index in the GOT.  */
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|->
name|global_gotsym
operator|=
name|hsd
operator|.
name|low
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a local GOT entry for VALUE.  Return the index of the entry,    or -1 if it could not be created.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_create_local_got_entry
parameter_list|(
name|abfd
parameter_list|,
name|g
parameter_list|,
name|sgot
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
if|if
condition|(
name|g
operator|->
name|assigned_gotno
operator|>=
name|g
operator|->
name|local_gotno
condition|)
block|{
comment|/* We didn't allocate enough space in the GOT.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"not enough GOT space for local GOT entries"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
block|}
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
operator|(
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|g
operator|->
name|assigned_gotno
operator|)
argument_list|)
expr_stmt|;
return|return
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|g
operator|->
name|assigned_gotno
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT offset at which the indicated address can be found.    If there is not yet a GOT entry for this value, create one.  Returns    -1 if no satisfactory GOT offset can be found.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_local_got_index
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_byte
modifier|*
name|entry
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
comment|/* Look to see if we already have an appropriate entry.  */
for|for
control|(
name|entry
operator|=
operator|(
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|MIPS_RESERVED_GOTNO
operator|)
init|;
name|entry
operator|!=
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|g
operator|->
name|assigned_gotno
condition|;
name|entry
operator|+=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
control|)
block|{
name|bfd_vma
name|address
init|=
name|MIPS_ELF_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|==
name|value
condition|)
return|return
name|entry
operator|-
name|sgot
operator|->
name|contents
return|;
block|}
return|return
name|mips_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a GOT entry that is within 32KB of the VALUE.  These entries    are supposed to be placed at small offsets in the GOT, i.e.,    within 32KB of GP.  Return the index into the GOT for this page,    and store the offset from this entry to the desired address in    OFFSETP, if it is non-NULL.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_got_page
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|value
parameter_list|,
name|offsetp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
modifier|*
name|offsetp
decl_stmt|;
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_byte
modifier|*
name|entry
decl_stmt|;
name|bfd_byte
modifier|*
name|last_entry
decl_stmt|;
name|bfd_vma
name|index
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
comment|/* Look to see if we aleady have an appropriate entry.  */
name|last_entry
operator|=
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|g
operator|->
name|assigned_gotno
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|(
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|MIPS_RESERVED_GOTNO
operator|)
init|;
name|entry
operator|!=
name|last_entry
condition|;
name|entry
operator|+=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
control|)
block|{
name|address
operator|=
name|MIPS_ELF_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_overflow_p
argument_list|(
name|value
operator|-
name|address
argument_list|,
literal|16
argument_list|)
condition|)
block|{
comment|/* This entry will serve as the page pointer.  We can add a 	     16-bit number to it to get the actual address.  */
name|index
operator|=
name|entry
operator|-
name|sgot
operator|->
name|contents
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we didn't have an appropriate entry, we create one now.  */
if|if
condition|(
name|entry
operator|==
name|last_entry
condition|)
name|index
operator|=
name|mips_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsetp
condition|)
block|{
name|address
operator|=
name|MIPS_ELF_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|*
name|offsetp
operator|=
name|value
operator|-
name|address
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Find a GOT entry whose higher-order 16 bits are the same as those    for value.  Return the index into the GOT for this entry.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_got16_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|value
parameter_list|,
name|external
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|boolean
name|external
decl_stmt|;
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_byte
modifier|*
name|entry
decl_stmt|;
name|bfd_byte
modifier|*
name|last_entry
decl_stmt|;
name|bfd_vma
name|index
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
if|if
condition|(
operator|!
name|external
condition|)
block|{
comment|/* Although the ABI says that it is "the high-order 16 bits" that we 	 want, it is really the %high value.  The complete value is 	 calculated with a `addiu' of a LO16 relocation, just as with a 	 HI16/LO16 pair.  */
name|value
operator|=
name|mips_elf_high
argument_list|(
name|value
argument_list|)
operator|<<
literal|16
expr_stmt|;
block|}
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
comment|/* Look to see if we already have an appropriate entry.  */
name|last_entry
operator|=
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|g
operator|->
name|assigned_gotno
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|(
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|MIPS_RESERVED_GOTNO
operator|)
init|;
name|entry
operator|!=
name|last_entry
condition|;
name|entry
operator|+=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
control|)
block|{
name|address
operator|=
name|MIPS_ELF_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|==
name|value
condition|)
block|{
comment|/* This entry has the right high-order 16 bits, and the low-order 	     16 bits are set to zero.  */
name|index
operator|=
name|entry
operator|-
name|sgot
operator|->
name|contents
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we didn't have an appropriate entry, we create one now.  */
if|if
condition|(
name|entry
operator|==
name|last_entry
condition|)
name|index
operator|=
name|mips_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Returns the first relocation of type r_type found, beginning with    RELOCATION.  RELEND is one-past-the-end of the relocation table.  */
end_comment

begin_function
specifier|static
specifier|const
name|Elf_Internal_Rela
modifier|*
name|mips_elf_next_relocation
parameter_list|(
name|r_type
parameter_list|,
name|relocation
parameter_list|,
name|relend
parameter_list|)
name|unsigned
name|int
name|r_type
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
block|{
comment|/* According to the MIPS ELF ABI, the R_MIPS_LO16 relocation must be      immediately following.  However, for the IRIX6 ABI, the next      relocation may be a composed relocation consisting of several      relocations for the same address.  In that case, the R_MIPS_LO16      relocation may occur as one of these.  We permit a similar      extension in general, as that is useful for GCC.  */
while|while
condition|(
name|relocation
operator|<
name|relend
condition|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|r_type
condition|)
return|return
name|relocation
return|;
operator|++
name|relocation
expr_stmt|;
block|}
comment|/* We didn't find it.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL    is the original relocation, which is now being transformed into a    dynamic relocation.  The ADDENDP is adjusted if necessary; the    caller should store the result in place of the original addend.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_create_dynamic_relocation
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sec
parameter_list|,
name|symbol
parameter_list|,
name|addendp
parameter_list|,
name|input_section
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|symbol
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
block|{
name|Elf_Internal_Rel
name|outrel
decl_stmt|;
name|boolean
name|skip
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_REL_DYN_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|->
name|reloc_count
operator|*
name|MIPS_ELF_REL_SIZE
argument_list|(
name|output_bfd
argument_list|)
operator|<
name|sreloc
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|skip
operator|=
name|false
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
comment|/* FIXME: For -2 runtime relocation needs to be skipped, but      properly resolved statically and installed.  */
name|BFD_ASSERT
argument_list|(
name|outrel
operator|.
name|r_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* If we've decided to skip this relocation, just output an empty      record.  Note that R_MIPS_NONE == 0, so that this call to memset      is a way of setting R_TYPE to R_MIPS_NONE.  */
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|outrel
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|long
name|indx
decl_stmt|;
name|bfd_vma
name|section_offset
decl_stmt|;
comment|/* We must now calculate the dynamic symbol table index to use 	 in the relocation.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|indx
operator|=
name|h
operator|->
name|root
operator|.
name|dynindx
expr_stmt|;
comment|/* h->root.dynindx may be -1 if this symbol was marked to 	     become local.  */
if|if
condition|(
name|indx
operator|==
operator|-
literal|1
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|indx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Figure out how far the target of the relocation is from 	     the beginning of its section.  */
name|section_offset
operator|=
name|symbol
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* The relocation we're building is section-relative. 	     Therefore, the original addend must be adjusted by the 	     section offset.  */
operator|*
name|addendp
operator|+=
name|section_offset
expr_stmt|;
comment|/* Now, the relocation is just against the section.  */
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
comment|/* If the relocation was previously an absolute relocation and 	 this symbol will not be referred to by the relocation, we must 	 adjust it by the value we give it in the dynamic symbol table. 	 Otherwise leave the job up to the dynamic linker.  */
if|if
condition|(
operator|!
name|indx
operator|&&
name|r_type
operator|!=
name|R_MIPS_REL32
condition|)
operator|*
name|addendp
operator|+=
name|symbol
expr_stmt|;
comment|/* The relocation is always an REL32 relocation because we don't 	 know where the shared library will wind up at load-time.  */
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_MIPS_REL32
argument_list|)
expr_stmt|;
comment|/* Adjust the output offset of the relocation to reference the 	 correct location in the output file.  */
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* Put the relocation back out.  We have to use the special      relocation outputter in the 64-bit case since the 64-bit      relocation format is non-standard.  */
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|swap_reloc_out
operator|)
operator|(
name|output_bfd
operator|,
operator|&
name|outrel
operator|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Rel
operator|*
operator|)
name|sreloc
operator|->
name|contents
operator|)
operator|+
name|sreloc
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
comment|/* Record the index of the first relocation referencing H.  This      information is later emitted in the .msym section.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|min_dyn_reloc_index
operator|==
literal|0
operator|||
name|sreloc
operator|->
name|reloc_count
operator|<
name|h
operator|->
name|min_dyn_reloc_index
operator|)
condition|)
name|h
operator|->
name|min_dyn_reloc_index
operator|=
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* We've now added another relocation.  */
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* Make sure the output section is writable.  The dynamic linker      will be writing to it.  */
name|elf_section_data
argument_list|(
name|input_section
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
comment|/* On IRIX5, make an entry of compact relocation info.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix5
condition|)
block|{
name|asection
modifier|*
name|scpt
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".compact_rel"
argument_list|)
decl_stmt|;
name|bfd_byte
modifier|*
name|cr
decl_stmt|;
if|if
condition|(
name|scpt
condition|)
block|{
name|Elf32_crinfo
name|cptrel
decl_stmt|;
name|mips_elf_set_cr_format
argument_list|(
name|cptrel
argument_list|,
name|CRF_MIPS_LONG
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|vaddr
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_REL32
condition|)
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_REL32
argument_list|)
expr_stmt|;
else|else
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_WORD
argument_list|)
expr_stmt|;
name|mips_elf_set_cr_dist2to
argument_list|(
name|cptrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|konst
operator|=
operator|*
name|addendp
expr_stmt|;
name|cr
operator|=
operator|(
name|scpt
operator|->
name|contents
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_crinfo_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cptrel
argument_list|,
operator|(
operator|(
name|Elf32_External_crinfo
operator|*
operator|)
name|cr
operator|+
name|scpt
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|scpt
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Calculate the value produced by the RELOCATION (which comes from    the INPUT_BFD).  The ADDEND is the addend to use for this    RELOCATION; RELOCATION->R_ADDEND is ignored.     The result of the relocation calculation is stored in VALUEP.    REQUIRE_JALXP indicates whether or not the opcode used with this    relocation must be JALX.     This function returns bfd_reloc_continue if the caller need take no    further action regarding this relocation, bfd_reloc_notsupported if    something goes dramatically wrong, bfd_reloc_overflow if an    overflow occurs, and bfd_reloc_ok to indicate success.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_elf_calculate_relocation
parameter_list|(
name|abfd
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|info
parameter_list|,
name|relocation
parameter_list|,
name|addend
parameter_list|,
name|howto
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|,
name|valuep
parameter_list|,
name|namep
parameter_list|,
name|require_jalxp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
name|bfd_vma
modifier|*
name|valuep
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
name|boolean
modifier|*
name|require_jalxp
decl_stmt|;
block|{
comment|/* The eventual value we will return.  */
name|bfd_vma
name|value
decl_stmt|;
comment|/* The address of the symbol against which the relocation is      occurring.  */
name|bfd_vma
name|symbol
init|=
literal|0
decl_stmt|;
comment|/* The final GP value to be used for the relocatable, executable, or      shared object file being produced.  */
name|bfd_vma
name|gp
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* The place (section offset or address) of the storage unit being      relocated.  */
name|bfd_vma
name|p
decl_stmt|;
comment|/* The value of GP used to create the relocatable object.  */
name|bfd_vma
name|gp0
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* The offset into the global offset table at which the address of      the relocation entry symbol, adjusted by the addend, resides      during execution.  */
name|bfd_vma
name|g
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* The section in which the symbol referenced by the relocation is      located.  */
name|asection
modifier|*
name|sec
init|=
name|NULL
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
comment|/* True if the symbol referred to by this relocation is a local      symbol.  */
name|boolean
name|local_p
decl_stmt|;
comment|/* True if the symbol referred to by this relocation is "_gp_disp".  */
name|boolean
name|gp_disp_p
init|=
name|false
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|r_type
decl_stmt|;
comment|/* True if overflow occurred during the calculation of the      relocation value.  */
name|boolean
name|overflowed_p
decl_stmt|;
comment|/* True if this relocation refers to a MIPS16 function.  */
name|boolean
name|target_is_16_bit_code_p
init|=
name|false
decl_stmt|;
comment|/* Parse the relocation.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|relocation
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* Assume that there will be no overflow.  */
name|overflowed_p
operator|=
name|false
expr_stmt|;
comment|/* Figure out whether or not the symbol is local, and get the offset      used in the array of hash table entries.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|local_p
operator|=
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
else|else
block|{
comment|/* The symbol table does not follow the rule that local symbols 	 must come before globals.  */
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Figure out the value of the symbol.  */
if|if
condition|(
name|local_p
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
name|symbol
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
comment|/* MIPS16 text labels should be treated as odd.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
operator|++
name|symbol
expr_stmt|;
comment|/* Record the name of this symbol, for our caller.  */
operator|*
name|namep
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|namep
operator|==
literal|'\0'
condition|)
operator|*
name|namep
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|target_is_16_bit_code_p
operator|=
operator|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For global symbols we look up the symbol in the hash-table.  */
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Record the name of this symbol, for our caller.  */
operator|*
name|namep
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
comment|/* See if this is the special _gp_disp symbol.  Note that such a 	 symbol must always be a global symbol.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Relocations against _gp_disp are permitted only with 	     R_MIPS_HI16 and R_MIPS_LO16 relocations.  */
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_HI16
operator|&&
name|r_type
operator|!=
name|R_MIPS_LO16
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|gp_disp_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* If this symbol is defined, calculate its address.  Note that 	 _gp_disp is a magic symbol, always implicitly defined by the 	 linker, so it's inappropriate to check to see whether or not 	 its defined.  */
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
condition|)
name|symbol
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
name|symbol
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
comment|/* We allow relocations against undefined weak symbols, giving 	   it the value zero, so that you can undefined weak functions 	   and check to see if they exist by looking at their 	   addresses.  */
name|symbol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|allow_shlib_undefined
operator|)
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|symbol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC_LINKING"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If this is a dynamic link, we should have created a 	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol 	     in in mips_elf_create_dynamic_sections. 	     Otherwise, we should define the symbol with a value of 0. 	     FIXME: It should probably get into the symbol table 	     somehow as well.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|relocation
operator|->
name|r_offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
name|target_is_16_bit_code_p
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
operator|)
expr_stmt|;
block|}
comment|/* If this is a 32-bit call to a 16-bit function with a stub, we      need to redirect the call to the stub, unless we're already *in*      a stub.  */
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
operator|(
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|local_p
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
operator|!=
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|!
name|mips_elf_stub_section_p
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
condition|)
block|{
comment|/* This is a 32-bit call to a 16-bit function.  We should 	 have already noticed that we were going to need the 	 stub.  */
if|if
condition|(
name|local_p
condition|)
name|sec
operator|=
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|need_fn_stub
argument_list|)
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|fn_stub
expr_stmt|;
block|}
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* If this is a 16-bit call to a 32-bit function with a stub, we      need to redirect the call to the stub.  */
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|||
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|target_is_16_bit_code_p
condition|)
block|{
comment|/* If both call_stub and call_fp_stub are defined, we can figure 	 out which one to use by seeing which one appears in the input 	 file.  */
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|call_fp_stub
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|sec
operator|=
name|h
operator|->
name|call_stub
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
condition|)
name|sec
operator|=
name|h
operator|->
name|call_stub
expr_stmt|;
else|else
name|sec
operator|=
name|h
operator|->
name|call_fp_stub
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|_raw_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* Calls from 16-bit code to 32-bit code and vice versa require the      special jalx instruction.  */
operator|*
name|require_jalxp
operator|=
operator|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
operator|(
operator|(
operator|(
name|r_type
operator|==
name|R_MIPS16_26
operator|)
operator|&&
operator|!
name|target_is_16_bit_code_p
operator|)
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_MIPS_26
operator|)
operator|&&
name|target_is_16_bit_code_p
operator|)
operator|)
operator|)
expr_stmt|;
name|local_p
operator|=
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If we haven't already determined the GOT offset, or the GP value,      and we're going to need it, get it now.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
comment|/* Find the index into the GOT where this value is located.  */
if|if
condition|(
operator|!
name|local_p
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_global_got_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is a static link or a -Bsymbolic link.  The 		 symbol is defined locally, or was forced to be local. 		 We must initialize this entry in the GOT.  */
name|asection
modifier|*
name|sgot
init|=
name|mips_elf_got_section
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|)
decl_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|g
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|||
name|r_type
operator|==
name|R_MIPS_CALL16
condition|)
comment|/* There's no need to create a local GOT entry here; the 	   calculation for a local GOT16 entry does not involve G.  */
break|break;
else|else
block|{
name|g
operator|=
name|mips_elf_local_got_index
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
block|}
comment|/* Convert GOT indices to actual offsets.  */
name|g
operator|=
name|mips_elf_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|g
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_HI16
case|:
case|case
name|R_MIPS_LO16
case|:
case|case
name|R_MIPS16_GPREL
case|:
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_GPREL32
case|:
case|case
name|R_MIPS_LITERAL
case|:
name|gp0
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Figure out what kind of relocation is being performed.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_NONE
case|:
return|return
name|bfd_reloc_continue
return|;
case|case
name|R_MIPS_16
case|:
name|value
operator|=
name|symbol
operator|+
name|mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If we're creating a shared library, or this relocation is 	     against a symbol in a shared library, then we can't know 	     where the symbol will end up.  So, we create a relocation 	     record in the output, and leave the job up to the dynamic 	     linker.  */
name|value
operator|=
name|addend
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_create_dynamic_relocation
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|relocation
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|symbol
argument_list|,
operator|&
name|value
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
block|}
else|else
block|{
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_REL32
condition|)
name|value
operator|=
name|symbol
operator|+
name|addend
expr_stmt|;
else|else
name|value
operator|=
name|addend
expr_stmt|;
block|}
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PC32
case|:
case|case
name|R_MIPS_PC64
case|:
case|case
name|R_MIPS_GNU_REL_LO16
case|:
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|p
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GNU_REL16_S2
case|:
name|value
operator|=
name|symbol
operator|+
name|mips_elf_sign_extend
argument_list|(
name|addend
operator|<<
literal|2
argument_list|,
literal|18
argument_list|)
operator|-
name|p
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|>>
literal|2
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GNU_REL_HI16
case|:
comment|/* Instead of subtracting 'p' here, we should be subtracting the 	 equivalent value for the LO part of the reloc, since the value 	 here is relative to that address.  Because that's not easy to do, 	 we adjust 'addend' in _bfd_mips_elf_relocate_section().  See also 	 the comment there for more information.  */
name|value
operator|=
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|symbol
operator|-
name|p
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS16_26
case|:
comment|/* The calculation for R_MIPS16_26 is just the same as for an 	 R_MIPS_26.  It's only the storage of the relocated field into 	 the output file that's different.  That's handled in 	 mips_elf_perform_relocation.  So, we just fall through to the 	 R_MIPS_26 case here.  */
case|case
name|R_MIPS_26
case|:
if|if
condition|(
name|local_p
condition|)
name|value
operator|=
operator|(
operator|(
operator|(
name|addend
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|p
operator|+
literal|4
operator|)
operator|&
literal|0xf0000000
operator|)
operator|)
operator|+
name|symbol
operator|)
operator|>>
literal|2
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|mips_elf_sign_extend
argument_list|(
name|addend
operator|<<
literal|2
argument_list|,
literal|28
argument_list|)
operator|+
name|symbol
operator|)
operator|>>
literal|2
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HI16
case|:
if|if
condition|(
operator|!
name|gp_disp_p
condition|)
block|{
name|value
operator|=
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|gp
operator|-
name|p
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_LO16
case|:
if|if
condition|(
operator|!
name|gp_disp_p
condition|)
name|value
operator|=
operator|(
name|symbol
operator|+
name|addend
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
else|else
block|{
name|value
operator|=
name|addend
operator|+
name|gp
operator|-
name|p
operator|+
literal|4
expr_stmt|;
comment|/* The MIPS ABI requires checking the R_MIPS_LO16 relocation 	     for overflow.  But, on, say, Irix 5, relocations against 	     _gp_disp are normally generated from the .cpload 	     pseudo-op.  It generates code that normally looks like 	     this:  	       lui    $gp,%hi(_gp_disp) 	       addiu  $gp,$gp,%lo(_gp_disp) 	       addu   $gp,$gp,$t9  	     Here $t9 holds the address of the function being called, 	     as required by the MIPS ELF ABI.  The R_MIPS_LO16 	     relocation can easily overflow in this situation, but the 	     R_MIPS_HI16 relocation will handle the overflow. 	     Therefore, we consider this a bug in the MIPS ABI, and do 	     not check for overflow here.  */
block|}
break|break;
case|case
name|R_MIPS_LITERAL
case|:
comment|/* Because we don't merge literal sections, we can handle this 	 just like R_MIPS_GPREL16.  In the long run, we should merge 	 shared literals, and then we will need to additional work 	 here.  */
comment|/* Fall through.  */
case|case
name|R_MIPS16_GPREL
case|:
comment|/* The R_MIPS16_GPREL performs the same calculation as 	 R_MIPS_GPREL16, but stores the relocated bits in a different 	 order.  We don't need to do anything special here; the 	 differences are handled in mips_elf_perform_relocation.  */
case|case
name|R_MIPS_GPREL16
case|:
if|if
condition|(
name|local_p
condition|)
name|value
operator|=
name|mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
operator|+
name|symbol
operator|+
name|gp0
operator|-
name|gp
expr_stmt|;
else|else
name|value
operator|=
name|mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
operator|+
name|symbol
operator|-
name|gp
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_CALL16
case|:
if|if
condition|(
name|local_p
condition|)
block|{
name|boolean
name|forced
decl_stmt|;
comment|/* The special case is when the symbol is forced to be local.  We 	     need the full address in the GOT since no R_MIPS_LO16 relocation 	     follows.  */
name|forced
operator|=
operator|!
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|value
operator|=
name|mips_elf_got16_entry
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|forced
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|value
operator|=
name|mips_elf_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_GOT_DISP
case|:
name|value
operator|=
name|g
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GPREL32
case|:
name|value
operator|=
operator|(
name|addend
operator|+
name|symbol
operator|+
name|gp0
operator|-
name|gp
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PC16
case|:
name|value
operator|=
name|mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
operator|+
name|symbol
operator|-
name|p
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|value
operator|/
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
comment|/* We're allowed to handle these two relocations identically. 	 The dynamic linker is allowed to handle the CALL relocations 	 differently by creating a lazy evaluation stub.  */
name|value
operator|=
name|g
expr_stmt|;
name|value
operator|=
name|mips_elf_high
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
name|value
operator|=
name|g
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_PAGE
case|:
name|value
operator|=
name|mips_elf_got_page
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|value
operator|=
name|mips_elf_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_OFST
case|:
name|mips_elf_got_page
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_SUB
case|:
name|value
operator|=
name|symbol
operator|-
name|addend
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HIGHER
case|:
name|value
operator|=
name|mips_elf_higher
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HIGHEST
case|:
name|value
operator|=
name|mips_elf_highest
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_SCN_DISP
case|:
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|sec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PJUMP
case|:
case|case
name|R_MIPS_JALR
case|:
comment|/* Both of these may be ignored.  R_MIPS_JALR is an optimization 	 hint; we could improve performance by honoring that hint.  */
return|return
name|bfd_reloc_continue
return|;
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
case|case
name|R_MIPS_GNU_VTENTRY
case|:
comment|/* We don't do anything with these at present.  */
return|return
name|bfd_reloc_continue
return|;
default|default:
comment|/* An unrecognized relocation type.  */
return|return
name|bfd_reloc_notsupported
return|;
block|}
comment|/* Store the VALUE for our caller.  */
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
return|return
name|overflowed_p
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Obtain the field relocated by RELOCATION.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_obtain_contents
parameter_list|(
name|howto
parameter_list|,
name|relocation
parameter_list|,
name|input_bfd
parameter_list|,
name|contents
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|bfd_vma
name|x
decl_stmt|;
name|bfd_byte
modifier|*
name|location
init|=
name|contents
operator|+
name|relocation
operator|->
name|r_offset
decl_stmt|;
comment|/* Obtain the bytes.  */
name|x
operator|=
name|bfd_get
argument_list|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
literal|8
operator|*
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|)
operator|)
argument_list|,
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ELF32_R_TYPE
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS16_26
operator|||
name|ELF32_R_TYPE
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS16_GPREL
operator|)
operator|&&
name|bfd_little_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
comment|/* The two 16-bit words will be reversed on a little-endian        system.  See mips_elf_perform_relocation for more details.  */
name|x
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* It has been determined that the result of the RELOCATION is the    VALUE.  Use HOWTO to place VALUE into the output file at the    appropriate position.  The SECTION is the section to which the    relocation applies.  If REQUIRE_JALX is true, then the opcode used    for the relocation must be either JAL or JALX, and it is    unconditionally converted to JALX.     Returns false if anything goes wrong.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_perform_relocation
parameter_list|(
name|info
parameter_list|,
name|howto
parameter_list|,
name|relocation
parameter_list|,
name|value
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|require_jalx
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|boolean
name|require_jalx
decl_stmt|;
block|{
name|bfd_vma
name|x
decl_stmt|;
name|bfd_byte
modifier|*
name|location
decl_stmt|;
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
decl_stmt|;
comment|/* Figure out where the relocation is occurring.  */
name|location
operator|=
name|contents
operator|+
name|relocation
operator|->
name|r_offset
expr_stmt|;
comment|/* Obtain the current value.  */
name|x
operator|=
name|mips_elf_obtain_contents
argument_list|(
name|howto
argument_list|,
name|relocation
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|/* Clear the field we are setting.  */
name|x
operator|&=
operator|~
name|howto
operator|->
name|dst_mask
expr_stmt|;
comment|/* If this is the R_MIPS16_26 relocation, we must store the      value in a funny way.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
comment|/* R_MIPS16_26 is used for the mips16 jal and jalx instructions. 	 Most mips16 instructions are 16 bits, but these instructions 	 are 32 bits.  	 The format of these instructions is:  	 +--------------+--------------------------------+ 	 !     JALX     ! X!   Imm 20:16  !   Imm 25:21  ! 	 +--------------+--------------------------------+ 	 !	  	  Immediate  15:0		    ! 	 +-----------------------------------------------+  	 JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx. 	 Note that the immediate value in the first word is swapped.  	 When producing a relocateable object file, R_MIPS16_26 is 	 handled mostly like R_MIPS_26.  In particular, the addend is 	 stored as a straight 26-bit value in a 32-bit instruction. 	 (gas makes life simpler for itself by never adjusting a 	 R_MIPS16_26 reloc to be against a section, so the addend is 	 always zero).  However, the 32 bit instruction is stored as 2 	 16-bit values, rather than a single 32-bit value.  In a 	 big-endian file, the result is the same; in a little-endian 	 file, the two 16-bit halves of the 32 bit value are swapped. 	 This is so that a disassembler can recognize the jal 	 instruction.  	 When doing a final link, R_MIPS16_26 is treated as a 32 bit 	 instruction stored as two 16-bit values.  The addend A is the 	 contents of the targ26 field.  The calculation is the same as 	 R_MIPS_26.  When storing the calculated value, reorder the 	 immediate value as shown above, and don't forget to store the 	 value as two 16-bit values.  	 To put it in MIPS ABI terms, the relocation field is T-targ26-16, 	 defined as  	 big-endian: 	 +--------+----------------------+ 	 |        |                      | 	 |        |    targ26-16         | 	 |31    26|25                   0| 	 +--------+----------------------+  	 little-endian: 	 +----------+------+-------------+ 	 |          |      |             | 	 |  sub1    |      |     sub2    | 	 |0        9|10  15|16         31| 	 +----------+--------------------+ 	 where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is 	 ((sub1<< 16) | sub2)).  	 When producing a relocateable object file, the calculation is 	 (((A< 2) | ((P + 4)& 0xf0000000) + S)>> 2) 	 When producing a fully linked file, the calculation is 	 let R = (((A< 2) | ((P + 4)& 0xf0000000) + S)>> 2) 	 ((R& 0x1f0000)<< 5) | ((R& 0x3e00000)>> 5) | (R& 0xffff)  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
comment|/* Shuffle the bits according to the formula above.  */
name|value
operator|=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0x1f0000
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x3e00000
operator|)
operator|>>
literal|5
operator|)
operator||
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
condition|)
block|{
comment|/* R_MIPS16_GPREL is used for GP-relative addressing in mips16 	 mode.  A typical instruction will have a format like this:  	 +--------------+--------------------------------+ 	 !    EXTEND    !     Imm 10:5    !   Imm 15:11  ! 	 +--------------+--------------------------------+ 	 !    Major     !   rx   !   ry   !   Imm  4:0   ! 	 +--------------+--------------------------------+  	 EXTEND is the five bit value 11110.  Major is the instruction 	 opcode.  	 This is handled exactly like R_MIPS_GPREL16, except that the 	 addend is retrieved and stored as shown in this diagram; that 	 is, the Imm fields above replace the V-rel16 field.           All we need to do here is shuffle the bits appropriately.  As 	 above, the two 16-bit halves must be swapped on a 	 little-endian system.  */
name|value
operator|=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0x7e0
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0xf800
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|value
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Set the field.  */
name|x
operator||=
operator|(
name|value
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
comment|/* If required, turn JAL into JALX.  */
if|if
condition|(
name|require_jalx
condition|)
block|{
name|boolean
name|ok
decl_stmt|;
name|bfd_vma
name|opcode
init|=
name|x
operator|>>
literal|26
decl_stmt|;
name|bfd_vma
name|jalx_opcode
decl_stmt|;
comment|/* Check to see if the opcode is already JAL or JALX.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
name|ok
operator|=
operator|(
operator|(
name|opcode
operator|==
literal|0x6
operator|)
operator|||
operator|(
name|opcode
operator|==
literal|0x7
operator|)
operator|)
expr_stmt|;
name|jalx_opcode
operator|=
literal|0x7
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
operator|(
operator|(
name|opcode
operator|==
literal|0x3
operator|)
operator|||
operator|(
name|opcode
operator|==
literal|0x1d
operator|)
operator|)
expr_stmt|;
name|jalx_opcode
operator|=
literal|0x1d
expr_stmt|;
block|}
comment|/* If the opcode is not JAL or JALX, there's a problem.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: %s+0x%lx: jump to stub routine which is not jal"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Make this the JALX opcode.  */
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator|)
operator||
operator|(
name|jalx_opcode
operator|<<
literal|26
operator|)
expr_stmt|;
block|}
comment|/* Swap the high- and low-order 16 bits on little-endian systems      when doing a MIPS16 relocation.  */
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_MIPS16_GPREL
operator|||
name|r_type
operator|==
name|R_MIPS16_26
operator|)
operator|&&
name|bfd_little_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|x
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
comment|/* Put the value into the output.  */
name|bfd_put
argument_list|(
literal|8
operator|*
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns true if SECTION is a MIPS16 stub section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_stub_section_p
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
decl_stmt|;
return|return
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Relocate a MIPS ELF section.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|;
name|boolean
name|use_saved_addend_p
init|=
name|false
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|boolean
name|require_jalx
decl_stmt|;
comment|/* True if the relocation is a RELA relocation, rather than a          REL relocation.  */
name|boolean
name|rela_relocation_p
init|=
name|true
decl_stmt|;
name|unsigned
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Find the relocation howto for this relocation.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* Some 32-bit code uses R_MIPS_64.  In particular, people use 	     64-bit code, but make sure all their addresses are in the 	     lowermost or uppermost 32-bit section of the 64-bit address 	     space.  Thus, when they use an R_MIPS_64 they mean what is 	     usually meant by R_MIPS_32, with the exception that the 	     stored value is sign-extended to 64 bits.  */
name|howto
operator|=
name|elf_mips_howto_table_rel
operator|+
name|R_MIPS_32
expr_stmt|;
comment|/* On big-endian systems, we need to lie about the position 	     of the reloc.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|rel
operator|->
name|r_offset
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|howto
operator|=
name|mips_rtype_to_howto
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_saved_addend_p
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
comment|/* If these relocations were originally of the REL variety, 	     we must pull the addend out of the field that will be 	     relocated.  Otherwise, we simply use the contents of the 	     RELA relocation.  To determine which flavor or relocation 	     this is, we depend on the fact that the INPUT_SECTION's 	     REL_HDR is read before its REL_HDR2.  */
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|rel
operator|-
name|relocs
argument_list|)
operator|>=
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
condition|)
name|rel_hdr
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr2
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
name|MIPS_ELF_REL_SIZE
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Note that this is a REL relocation.  */
name|rela_relocation_p
operator|=
name|false
expr_stmt|;
comment|/* Get the addend, which is stored in the input file.  */
name|addend
operator|=
name|mips_elf_obtain_contents
argument_list|(
name|howto
argument_list|,
name|rel
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|addend
operator|&=
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* For some kinds of relocations, the ADDEND is a 		 combination of the addend stored in two different 		 relocations.   */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
operator|||
operator|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|&&
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|false
argument_list|)
operator|)
condition|)
block|{
name|bfd_vma
name|l
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|lo16_relocation
decl_stmt|;
name|reloc_howto_type
modifier|*
name|lo16_howto
decl_stmt|;
name|unsigned
name|int
name|lo
decl_stmt|;
comment|/* The combined value is the sum of the HI16 addend, 		     left-shifted by sixteen bits, and the LO16 		     addend, sign extended.  (Usually, the code does 		     a `lui' of the HI16 value, and then an `addiu' of 		     the LO16 value.)  		     Scan ahead to find a matching LO16 relocation.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
condition|)
name|lo
operator|=
name|R_MIPS_GNU_REL_LO16
expr_stmt|;
else|else
name|lo
operator|=
name|R_MIPS_LO16
expr_stmt|;
name|lo16_relocation
operator|=
name|mips_elf_next_relocation
argument_list|(
name|lo
argument_list|,
name|rel
argument_list|,
name|relend
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo16_relocation
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Obtain the addend kept there.  */
name|lo16_howto
operator|=
name|mips_rtype_to_howto
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|l
operator|=
name|mips_elf_obtain_contents
argument_list|(
name|lo16_howto
argument_list|,
name|lo16_relocation
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|l
operator|&=
name|lo16_howto
operator|->
name|src_mask
expr_stmt|;
name|l
operator|=
name|mips_elf_sign_extend
argument_list|(
name|l
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|addend
operator|<<=
literal|16
expr_stmt|;
comment|/* Compute the combined addend.  */
name|addend
operator|+=
name|l
expr_stmt|;
comment|/* If PC-relative, subtract the difference between the 		     address of the LO part of the reloc and the address of 		     the HI part.  The relocation is relative to the LO 		     part, but mips_elf_calculate_relocation() doesn't know 		     it address or the difference from the HI part, so 		     we subtract that difference here.  See also the 		     comment in mips_elf_calculate_relocation().  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
condition|)
name|addend
operator|-=
operator|(
name|lo16_relocation
operator|->
name|r_offset
operator|-
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
condition|)
block|{
comment|/* The addend is scrambled in the object file.  See 		     mips_elf_perform_relocation for details on the 		     format.  */
name|addend
operator|=
operator|(
operator|(
operator|(
name|addend
operator|&
literal|0x1f0000
operator|)
operator|>>
literal|5
operator|)
operator||
operator|(
operator|(
name|addend
operator|&
literal|0x7e00000
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
name|addend
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|rel
operator|->
name|r_offset
operator|-=
literal|4
expr_stmt|;
comment|/* Since we're just relocating, all we need to do is copy 	     the relocations back out to the object file, unless 	     they're against a section symbol, in which case we need 	     to adjust by the section offset, or unless they're GP 	     relative in which case we need to adjust by the amount 	     that we're adjusting GP in this relocateable object.  */
if|if
condition|(
operator|!
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|false
argument_list|)
condition|)
comment|/* There's nothing to do for non-local relocations.  */
continue|continue;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
operator|||
name|r_type
operator|==
name|R_MIPS_GPREL16
operator|||
name|r_type
operator|==
name|R_MIPS_GPREL32
operator|||
name|r_type
operator|==
name|R_MIPS_LITERAL
condition|)
name|addend
operator|-=
operator|(
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
operator|-
name|_bfd_get_gp_value
argument_list|(
name|input_bfd
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_26
operator|||
name|r_type
operator|==
name|R_MIPS16_26
operator|||
name|r_type
operator|==
name|R_MIPS_GNU_REL16_S2
condition|)
comment|/* The addend is stored without its two least 	       significant bits (which are always zero.)  In a 	       non-relocateable link, calculate_relocation will do 	       this shift; here, we must do it ourselves.  */
name|addend
operator|<<=
literal|2
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
comment|/* Adjust the addend appropriately.  */
name|addend
operator|+=
name|local_sections
index|[
name|r_symndx
index|]
operator|->
name|output_offset
expr_stmt|;
comment|/* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16, 	     then we only want to write out the high-order 16 bits. 	     The subsequent R_MIPS_LO16 will handle the low-order bits.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT16
operator|||
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
condition|)
name|addend
operator|=
name|mips_elf_high
argument_list|(
name|addend
argument_list|)
expr_stmt|;
comment|/* If the relocation is for an R_MIPS_26 relocation, then 	     the two low-order bits are not stored in the object file; 	     they are implicitly zero.  */
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_26
operator|||
name|r_type
operator|==
name|R_MIPS16_26
operator|||
name|r_type
operator|==
name|R_MIPS_GNU_REL16_S2
condition|)
name|addend
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|rela_relocation_p
condition|)
comment|/* If this is a RELA relocation, just update the addend. 	       We have to cast away constness for REL.  */
name|rel
operator|->
name|r_addend
operator|=
name|addend
expr_stmt|;
else|else
block|{
comment|/* Otherwise, we have to write the value back out.  Note 		 that we use the source mask, rather than the 		 destination mask because the place to which we are 		 writing will be source of the addend in the final 		 link.  */
name|addend
operator|&=
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
comment|/* See the comment above about using R_MIPS_64 in the 32-bit 		   ABI.  Here, we need to update the addend.  It would be 		   possible to get away with just using the R_MIPS_32 reloc 		   but for endianness.  */
block|{
name|bfd_vma
name|sign_bits
decl_stmt|;
name|bfd_vma
name|low_bits
decl_stmt|;
name|bfd_vma
name|high_bits
decl_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
ifdef|#
directive|ifdef
name|BFD64
name|sign_bits
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|sign_bits
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
else|else
name|sign_bits
operator|=
literal|0
expr_stmt|;
comment|/* If we don't know that we have a 64-bit type, 		     do two separate stores.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Store the sign-bits (which are most significant) 			 first.  */
name|low_bits
operator|=
name|sign_bits
expr_stmt|;
name|high_bits
operator|=
name|addend
expr_stmt|;
block|}
else|else
block|{
name|low_bits
operator|=
name|addend
expr_stmt|;
name|high_bits
operator|=
name|sign_bits
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|low_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|high_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|mips_elf_perform_relocation
argument_list|(
name|info
argument_list|,
name|howto
argument_list|,
name|rel
argument_list|,
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Go on to the next relocation.  */
continue|continue;
block|}
comment|/* In the N32 and 64-bit ABIs there may be multiple consecutive 	 relocations for the same offset.  In that case we are 	 supposed to treat the output of each relocation as the addend 	 for the next.  */
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|rel
operator|->
name|r_offset
operator|==
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_MIPS_NONE
condition|)
name|use_saved_addend_p
operator|=
name|true
expr_stmt|;
else|else
name|use_saved_addend_p
operator|=
name|false
expr_stmt|;
comment|/* Figure out what value we are supposed to relocate.  */
switch|switch
condition|(
name|mips_elf_calculate_relocation
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|addend
argument_list|,
name|howto
argument_list|,
name|local_syms
argument_list|,
name|local_sections
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|require_jalx
argument_list|)
condition|)
block|{
case|case
name|bfd_reloc_continue
case|:
comment|/* There's nothing to do.  */
continue|continue;
case|case
name|bfd_reloc_undefined
case|:
comment|/* mips_elf_calculate_relocation already called the 	     undefined_symbol callback.  There's no real point in 	     trying to perform the relocation at this point, so we 	     just skip ahead to the next relocation.  */
continue|continue;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
name|use_saved_addend_p
condition|)
comment|/* Ignore overflow until we reach the last relocation for 	       a given location.  */
empty_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* If we've got another relocation for the address, keep going 	 until we reach the last one.  */
if|if
condition|(
name|use_saved_addend_p
condition|)
block|{
name|addend
operator|=
name|value
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
comment|/* See the comment above about using R_MIPS_64 in the 32-bit 	   ABI.  Until now, we've been using the HOWTO for R_MIPS_32; 	   that calculated the right value.  Now, however, we 	   sign-extend the 32-bit result to 64-bits, and store it as a 	   64-bit value.  We are especially generous here in that we 	   go to extreme lengths to support this usage on systems with 	   only a 32-bit VMA.  */
block|{
name|bfd_vma
name|sign_bits
decl_stmt|;
name|bfd_vma
name|low_bits
decl_stmt|;
name|bfd_vma
name|high_bits
decl_stmt|;
if|if
condition|(
name|value
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
ifdef|#
directive|ifdef
name|BFD64
name|sign_bits
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|sign_bits
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
else|else
name|sign_bits
operator|=
literal|0
expr_stmt|;
comment|/* If we don't know that we have a 64-bit type, 	     do two separate stores.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Undo what we did above.  */
name|rel
operator|->
name|r_offset
operator|-=
literal|4
expr_stmt|;
comment|/* Store the sign-bits (which are most significant) 		 first.  */
name|low_bits
operator|=
name|sign_bits
expr_stmt|;
name|high_bits
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|low_bits
operator|=
name|value
expr_stmt|;
name|high_bits
operator|=
name|sign_bits
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|low_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|high_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Actually perform the relocation.  */
if|if
condition|(
operator|!
name|mips_elf_perform_relocation
argument_list|(
name|info
argument_list|,
name|howto
argument_list|,
name|rel
argument_list|,
name|value
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|require_jalx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This hook function is called before the linker writes out a global    symbol.  We mark symbols as small common if appropriate.  This is    also where we undo the increment of the value for a mips16 symbol.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_link_output_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|name
parameter_list|,
name|sym
parameter_list|,
name|input_sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
block|{
comment|/* If we see a common symbol, which implies a relocatable link, then      if a symbol was small common in an input file, mark it as small      common in the output file.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
name|strcmp
argument_list|(
name|input_sec
operator|->
name|name
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_SCOMMON
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|&&
operator|(
name|sym
operator|->
name|st_value
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|sym
operator|->
name|st_value
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for the dynamic linker.  */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(ABI_N32_P (abfd) ? "/usr/lib32/libc.so.1" 	\     : ABI_64_P (abfd) ? "/usr/lib64/libc.so.1" 	\     : "/usr/lib/libc.so.1")
end_define

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|namep
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
comment|/* Mips ABI requests the .dynamic section to be read only.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* We need to create .got section.  */
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create the .msym section on IRIX6.  It is used by the dynamic      linker to speed up dynamic relocations, and to avoid computing      the ELF hash for symbols.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
operator|&&
operator|!
name|mips_elf_create_msym_section
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create .stub section.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_CODE
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_none
operator|)
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator|&
operator|~
operator|(
name|flagword
operator|)
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* On IRIX5, we adjust add some additional symbols and change the      alignments of several sections.  There is no ABI documentation      indicating that this is necessary on IRIX6, nor any evidence that      the linker takes such action.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
condition|)
block|{
for|for
control|(
name|namep
operator|=
name|mips_elf_dynsym_rtproc_names
init|;
operator|*
name|namep
operator|!=
name|NULL
condition|;
name|namep
operator|++
control|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_und_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_SECTION
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* We need to create a .compact_rel section.  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf_create_compact_rel_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Change aligments of some sections.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* For normal mips it is _DYNAMIC_LINKING.  */
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_DYNAMIC_LINKING"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_SECTION
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
condition|)
block|{
comment|/* __rld_map is a four byte word located in the .data section 	     and is filled in by the rtld to contain a pointer to 	     the _r_debug structure. Its symbol value will be set in 	     mips_elf_finish_dynamic_symbol.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"__rld_map"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* For normal mips the symbol is __RLD_MAP.  */
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"__RLD_MAP"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create the .compact_rel section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_create_compact_rel_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".compact_rel"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".compact_rel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create the .got section to hold the global offset table.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_create_got_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* This function may be called more than once.  */
if|if
condition|(
name|mips_elf_got_section
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|true
return|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the      linker script because we don't want to define the symbol if we      are not creating a global offset table.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The first several global offset table entries are reserved.  */
name|s
operator|->
name|_raw_size
operator|=
name|MIPS_RESERVED_GOTNO
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_got_info
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|g
operator|->
name|global_gotsym
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|=
name|MIPS_RESERVED_GOTNO
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|MIPS_RESERVED_GOTNO
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_elf_section_data
argument_list|)
expr_stmt|;
name|s
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|g
expr_stmt|;
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns the .msym section for ABFD, creating it if it does not    already exist.  Returns NULL to indicate error.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mips_elf_create_msym_section
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_MSYM_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_MSYM_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Add room for N relocations to the .rel.dyn section in ABFD.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_allocate_dynamic_relocations
parameter_list|(
name|abfd
parameter_list|,
name|n
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_REL_DYN_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* Make room for a null element.  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_ELF_REL_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
name|s
operator|->
name|_raw_size
operator|+=
name|n
operator|*
name|MIPS_ELF_REL_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
comment|/* Check for the mips16 stub sections.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* This stub is for a local symbol.  This stub will only be              needed if there is some relocation in this BFD, other              than a 16 bit function call, which refers to this symbol.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|sec_relocs
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|r
decl_stmt|,
modifier|*
name|rend
decl_stmt|;
comment|/* We can ignore stub sections when looking for relocs.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sec_relocs
operator|=
operator|(
name|_bfd_elf32_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sec_relocs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|rend
operator|=
name|sec_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|r
operator|=
name|sec_relocs
init|;
name|r
operator|<
name|rend
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|r
operator|->
name|r_info
argument_list|)
operator|==
name|r_symndx
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|r
operator|->
name|r_info
argument_list|)
operator|!=
name|R_MIPS16_26
condition|)
break|break;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|sec_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|rend
condition|)
break|break;
block|}
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
comment|/* There is no non-call reloc for this stub, so we do                  not need it.  Since this function is called before                  the linker maps input sections to output sections, we                  can easily discard it by setting the SEC_EXCLUDE                  flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Record this stub in an array of local symbol stubs for              this BFD.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|long
name|symcount
decl_stmt|;
name|asection
modifier|*
modifier|*
name|n
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|symcount
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|=
name|n
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|=
name|sec
expr_stmt|;
comment|/* We don't need to set mips16_stubs_seen in this case.              That flag is used to see whether we need to look through              the global symbol table for stubs.  We don't need to set              it here, because we just have a local stub.  */
block|}
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
name|h
operator|->
name|fn_stub
operator|=
name|sec
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* This stub was actually built for a static symbol defined 	     in the same file.  We assume that all static symbols in 	     mips16 code are themselves mips16, so we can simply 	     discard this stub.  Since this function is called before 	     the linker maps input sections to output sections, we can 	     easily discard it by setting the SEC_EXCLUDE flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|true
return|;
block|}
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|loc
operator|=
operator|&
name|h
operator|->
name|call_fp_stub
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|h
operator|->
name|call_stub
expr_stmt|;
comment|/* If we already have an appropriate stub for this function, we 	 don't need another one, so we can discard this one.  Since 	 this function is called before the linker maps input sections 	 to output sections, we can easily discard it by setting the 	 SEC_EXCLUDE flag.  We can also discard this section if we 	 happen to already know that this is a mips16 function; it is 	 not necessary to check this here, as it is checked later, but 	 it is slightly faster to check now.  */
if|if
condition|(
operator|*
name|loc
operator|!=
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|true
return|;
block|}
operator|*
name|loc
operator|=
name|sec
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|NULL
expr_stmt|;
name|g
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
operator|++
name|rel
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|r_symndx
operator|>=
name|extsymoff
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Malformed reloc detected for section %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* This may be an indirect symbol created because of a version.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
block|}
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|||
name|sgot
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_GOT_PAGE
case|:
case|case
name|R_MIPS_GOT_OFST
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|h
operator|&&
operator|(
name|r_type
operator|==
name|R_MIPS_CALL_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_DISP
operator|)
condition|)
block|{
comment|/* We may need a local GOT entry for this relocation.  We 	     don't count R_MIPS_GOT_PAGE because we can estimate the 	     maximum number of pages needed by looking at the size of 	     the segment.  Similar comments apply to R_MIPS_GOT16 and 	     R_MIPS_CALL16.  We don't count R_MIPS_GOT_HI16, or 	     R_MIPS_CALL_HI16 because these are always followed by an 	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.  	     This estimation is very conservative since we can merge 	     duplicate entries in the GOT.  In order to be less 	     conservative, we could actually build the GOT here, 	     rather than in relocate_section.  */
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|sgot
operator|->
name|_raw_size
operator|+=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_CALL16
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: CALL16 reloc at 0x%lx not against global symbol"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We need a stub, not a plt entry for the undefined 		 function.  But we record it as if it needs plt.  See 		 elf_adjust_dynamic_symbol in elflink.h.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|h
operator|&&
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|dname
init|=
name|MIPS_ELF_REL_DYN_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
decl_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
define|#
directive|define
name|MIPS_READONLY_SECTION
value|(SEC_ALLOC | SEC_LOAD | SEC_READONLY)
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* When creating a shared object, we must copy these 		     reloc types into the output file as R_MIPS_REL32 		     relocs.  We make room for this reloc in the 		     .rel.dyn reloc section.  */
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|MIPS_READONLY_SECTION
operator|)
operator|==
name|MIPS_READONLY_SECTION
condition|)
comment|/* We tell the dynamic linker that there are 		       relocations against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
comment|/* We only need to copy this reloc if the symbol is                      defined in a dynamic object.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
operator|++
name|hmips
operator|->
name|possibly_dynamic_relocs
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|MIPS_READONLY_SECTION
operator|)
operator|==
name|MIPS_READONLY_SECTION
condition|)
comment|/* We need it to tell the dynamic linker if there 		       are relocations against the text segment.  */
name|hmips
operator|->
name|readonly_reloc
operator|=
name|true
expr_stmt|;
block|}
comment|/* Even though we don't directly need a GOT entry for 		 this symbol, a symbol must have a dynamic symbol 		 table index greater that DT_MIPS_GOTSYM if there are 		 dynamic relocations against it.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_crinfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_26
case|:
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_LITERAL
case|:
case|case
name|R_MIPS_GPREL32
case|:
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_crinfo
argument_list|)
expr_stmt|;
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|_bfd_elf32_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_MIPS_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|_bfd_elf32_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
comment|/* We must not create a stub for a symbol that has relocations          related to taking the function's address.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|mh
decl_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|mh
operator|->
name|no_fn_stub
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
break|break;
block|}
comment|/* If this reloc is not a 16 bit call, and it has a global          symbol, then we will need the fn_stub if there is one.          References from a stub section do not count.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|mh
decl_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|mh
operator|->
name|need_fn_stub
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
name|asection
modifier|*
name|_bfd_mips_elf_gc_mark_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
comment|/* ??? Do mips16 stub sections need to be handled special?  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
case|case
name|R_MIPS_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
return|return
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|Elf_Internal_Shdr *symtab_hdr;   struct elf_link_hash_entry **sym_hashes;   bfd_signed_vma *local_got_refcounts;   const Elf_Internal_Rela *rel, *relend;   unsigned long r_symndx;   struct elf_link_hash_entry *h;    symtab_hdr =&elf_tdata (abfd)->symtab_hdr;   sym_hashes = elf_sym_hashes (abfd);   local_got_refcounts = elf_local_got_refcounts (abfd);    relend = relocs + sec->reloc_count;   for (rel = relocs; rel< relend; rel++)     switch (ELF32_R_TYPE (rel->r_info))       {       case R_MIPS_GOT16:       case R_MIPS_CALL16:       case R_MIPS_CALL_HI16:       case R_MIPS_CALL_LO16:       case R_MIPS_GOT_HI16:       case R_MIPS_GOT_LO16:
comment|/* ??? It would seem that the existing MIPS code does no sort 	   of reference counting or whatnot on its GOT and PLT entries, 	   so it is not possible to garbage collect them at this time.  */
block|break;        default: 	break;       }
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy data from a MIPS ELF indirect symbol to its direct symbol,    hiding the old indirect symbol.  Process additional relocation    information.  Also called for weakdefs, in which case we just let    _bfd_elf_link_hash_copy_indirect copy the flags for us.  */
end_comment

begin_function
specifier|static
name|void
name|_bfd_mips_elf_copy_indirect_symbol
parameter_list|(
name|dir
parameter_list|,
name|ind
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
decl_stmt|,
decl|*
name|ind
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|dirmips
decl_stmt|,
modifier|*
name|indmips
decl_stmt|;
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return;
name|dirmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|indmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
name|dirmips
operator|->
name|possibly_dynamic_relocs
operator|+=
name|indmips
operator|->
name|possibly_dynamic_relocs
expr_stmt|;
if|if
condition|(
name|indmips
operator|->
name|readonly_reloc
condition|)
name|dirmips
operator|->
name|readonly_reloc
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|dirmips
operator|->
name|min_dyn_reloc_index
operator|==
literal|0
operator|||
operator|(
name|indmips
operator|->
name|min_dyn_reloc_index
operator|!=
literal|0
operator|&&
name|indmips
operator|->
name|min_dyn_reloc_index
operator|<
name|dirmips
operator|->
name|min_dyn_reloc_index
operator|)
condition|)
name|dirmips
operator|->
name|min_dyn_reloc_index
operator|=
name|indmips
operator|->
name|min_dyn_reloc_index
expr_stmt|;
if|if
condition|(
name|indmips
operator|->
name|no_fn_stub
condition|)
name|dirmips
operator|->
name|no_fn_stub
operator|=
name|true
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this symbol is defined in a dynamic object, we need to copy      any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output      file.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|hmips
operator|->
name|possibly_dynamic_relocs
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|hmips
operator|->
name|possibly_dynamic_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmips
operator|->
name|readonly_reloc
condition|)
comment|/* We tell the dynamic linker that there are relocations 	   against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
comment|/* For a function, create a stub, if allowed.  */
if|if
condition|(
operator|!
name|hmips
operator|->
name|no_fn_stub
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|true
return|;
comment|/* If this symbol is not defined in a regular file, then set 	 the symbol to the stub location.  This is required to make 	 function pointers compare as equal between the normal 	 executable and the shared library.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We need .stub section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* XXX Write this stub address somewhere.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make room for this stub code.  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
comment|/* The last half word of the stub will be filled with the index 	     of this symbol in .dynsym section.  */
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* This will set the entry for this symbol in the GOT to 0, and          the dynamic linker will take care of this.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function is called after all the input files have been read,    and the input sections have been assigned to output sections.  We    check for any mips16 stub sections that we can discard.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_check_mips16_stubs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|boolean
name|_bfd_mips_elf_always_size_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|ri
decl_stmt|;
comment|/* The .reginfo section has a fixed size.  */
name|ri
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ri
operator|!=
name|NULL
condition|)
name|bfd_set_section_size
argument_list|(
name|output_bfd
argument_list|,
name|ri
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
condition|)
return|return
name|true
return|;
name|mips_elf_link_hash_traverse
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_check_mips16_stubs
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check the mips16 stubs for a particular symbol, and see if we can    discard them.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_check_mips16_stubs
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
operator|&&
operator|!
name|h
operator|->
name|need_fn_stub
condition|)
block|{
comment|/* We don't need the fn_stub; the only references to this symbol          are 16 bit calls.  Clobber the size to 0 to prevent it from          being included in the link.  */
name|h
operator|->
name|fn_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_fp_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|reltext
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|NULL
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|strlen
argument_list|(
name|ELF_DYNAMIC_INTERPRETER
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|reltext
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* We only strip the section if the output section name                  has the same name.  Otherwise, there might be several                  input sections for this output section.  FIXME: This                  code is probably not needed these days anyhow, since                  the linker now does not create empty output sections.  */
if|if
condition|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|s
operator|->
name|output_section
operator|->
name|owner
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* If this relocation section applies to a read only                  section, then we probably need a DT_TEXTREL entry.                  If the relocation section is .rel.dyn, we always                  assert a DT_TEXTREL entry rather than testing whether                  there exists a relocation to a read only section or                  not.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|outname
argument_list|,
name|MIPS_ELF_REL_DYN_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|reltext
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_REL_DYN_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|loadable_size
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|local_gotno
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Calculate the total loadable size of the output.  That 	     will give us the maximum number of GOT_PAGE entries 	     required.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
for|for
control|(
name|subsection
operator|=
name|sub
operator|->
name|sections
init|;
name|subsection
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|loadable_size
operator|+=
operator|(
operator|(
name|subsection
operator|->
name|_raw_size
operator|+
literal|0xf
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0xf
operator|)
expr_stmt|;
block|}
block|}
name|loadable_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
comment|/* Assume there are two loadable segments consisting of 	     contiguous sections.  Is 5 enough?  */
name|local_gotno
operator|=
operator|(
name|loadable_size
operator|>>
literal|16
operator|)
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix6
condition|)
comment|/* It's possible we will need GOT_PAGE entries as well as 	       GOT16 entries.  Often, these will be able to share GOT 	       entries, but not always.  */
name|local_gotno
operator|*=
literal|2
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|+=
name|local_gotno
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|local_gotno
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
comment|/* There has to be a global GOT entry for every symbol with 	     a dynamic symbol table index of DT_MIPS_GOTSYM or 	     higher.  Therefore, it make sense to put those symbols 	     that need GOT entries at the end of the symbol table.  We 	     do that here.  */
if|if
condition|(
operator|!
name|mips_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|i
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
else|else
comment|/* If there are no global symbols, or none requiring 	       relocations, then GLOBAL_GOTSYM will be NULL.  */
name|i
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|i
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Irix rld assumes that the function stub isn't at the end 	     of .text section. So put a dummy. XXX  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rld_map"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We add a room for __rld_map. It will be filled in by the 	     rtld to contain a pointer to the _r_debug structure.  */
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".compact_rel"
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_MSYM_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Msym
argument_list|)
operator|*
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|+
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf_mips_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* SGI object has the equivalence of DT_DEBUG in the 	     DT_MIPS_RLD_MAP entry.  */
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_MAP
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
else|else
block|{
comment|/* Shared libraries on traditional mips have DT_DEBUG.  */
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|reltext
operator|&&
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_REL_DYN_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_REL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELENT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_CONFLICTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LIBLISTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".conflict"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_CONFLICT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".liblist"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LIBLIST
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_VERSION
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_FLAGS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|#
directive|if
literal|0
comment|/* Time stamps in executable files are a bad idea.  */
block|if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_TIME_STAMP, 0)) 	return false;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* FIXME  */
block|if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_ICHECKSUM, 0)) 	return false;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* FIXME  */
block|if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_IVERSION, 0)) 	return false;
endif|#
directive|endif
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_BASE_ADDRESS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LOCAL_GOTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_SYMTABNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_UNREFEXTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_GOTSYM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|dynobj
argument_list|)
operator|==
name|ict_irix5
operator|&&
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_HIPAGENO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|dynobj
argument_list|)
operator|==
name|ict_irix6
operator|&&
operator|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_OPTIONS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_MSYM_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
operator|&&
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_MSYM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If NAME is one of the special IRIX6 symbols defined by the linker,    adjust it appropriately now.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_irix6_finish_dynamic_symbol
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
comment|/* The linker script takes care of providing names and values for      these, but we must place them into the right sections.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|text_section_symbols
index|[]
init|=
block|{
literal|"_ftext"
block|,
literal|"_etext"
block|,
literal|"__dso_displacement"
block|,
literal|"__elf_header"
block|,
literal|"__program_header_table"
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|data_section_symbols
index|[]
init|=
block|{
literal|"_fdata"
block|,
literal|"_edata"
block|,
literal|"_end"
block|,
literal|"_fbss"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
for|for
control|(
name|p
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|text_section_symbols
else|:
name|data_section_symbols
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* All of these symbols are given type STT_SECTION by the 	     IRIX6 linker.  */
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
comment|/* The IRIX linker puts these symbols in special sections.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_TEXT
expr_stmt|;
else|else
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
name|gval
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|smsym
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|mh
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|gval
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_byte
name|stub
index|[
name|MIPS_FUNCTION_STUB_SIZE
index|]
decl_stmt|;
comment|/* This symbol has a stub.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fill the stub.  */
name|p
operator|=
name|stub
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|STUB_LW
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|STUB_MOVE
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* FIXME: Can h->dynindex be more than 64K?  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|&
literal|0xffff0000
condition|)
return|return
name|false
return|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|STUB_JALR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|STUB_LI16
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|h
operator|->
name|dynindx
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|<=
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|stub
argument_list|,
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as undefined.  plt.offset != -1 occurs 	 only for the referenced symbol.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* The run-time linker uses the st_value field of the symbol 	 to reset the global offset table entry for this external 	 to its stub address when unlinking a shared object.  */
name|gval
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|gval
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Run through the global symbol table, creating GOT entries for all      the symbols that need them.  */
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|>=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_value
condition|)
name|value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
else|else
block|{
comment|/* For an entity defined in a shared object, this will be 	     NULL.  (For functions in shared objects for 	     which we have created stubs, ST_VALUE will be non-NULL. 	     That's because such the functions are now no longer defined 	     in a shared object.)  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
name|offset
operator|=
name|mips_elf_global_got_index
argument_list|(
name|dynobj
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Create a .msym entry, if appropriate.  */
name|smsym
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_MSYM_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsym
condition|)
block|{
name|Elf32_Internal_Msym
name|msym
decl_stmt|;
name|msym
operator|.
name|ms_hash_value
operator|=
name|bfd_elf_hash
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* It is undocumented what the `1' indicates, but IRIX6 uses 	 this value.  */
name|msym
operator|.
name|ms_info
operator|=
name|ELF32_MS_INFO
argument_list|(
name|mh
operator|->
name|min_dyn_reloc_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bfd_mips_elf_swap_msym_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|msym
argument_list|,
operator|(
operator|(
name|Elf32_External_Msym
operator|*
operator|)
name|smsym
operator|->
name|contents
operator|)
operator|+
name|h
operator|->
name|dynindx
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINKING"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_ABS
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_OBJECT
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
block|}
block|}
comment|/* Handle the IRIX6-specific symbols.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix6
condition|)
name|mips_elf_irix6_finish_dynamic_symbol
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__rld_map"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__RLD_MAP"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rld_map"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|==
literal|0
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__rld_obj_head"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* IRIX6 does not use a .rld_map section.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix5
operator|||
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_none
condition|)
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rld_map"
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
comment|/* If this is a mips16 symbol, force the value to be even.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|&&
operator|(
name|sym
operator|->
name|st_value
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|sym
operator|->
name|st_value
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_byte
modifier|*
name|b
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|sdyn
operator|->
name|contents
init|;
name|b
operator|<
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
condition|;
name|b
operator|+=
name|MIPS_ELF_DYN_SIZE
argument_list|(
name|dynobj
argument_list|)
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|elemsize
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|swap_out_p
decl_stmt|;
comment|/* Read in the current dynamic entry.  */
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_in
operator|)
operator|(
name|dynobj
operator|,
name|b
operator|,
operator|&
name|dyn
operator|)
expr_stmt|;
comment|/* Assume that we're going to modify it and write it out.  */
name|swap_out_p
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_RELENT
case|:
name|s
operator|=
operator|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_REL_DYN_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|MIPS_ELF_REL_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
comment|/* Rewrite DT_STRSZ.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_MIPS_CONFLICT
case|:
name|name
operator|=
literal|".conflict"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_MIPS_LIBLIST
case|:
name|name
operator|=
literal|".liblist"
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_MIPS_RLD_VERSION
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|DT_MIPS_FLAGS
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|RHF_NOTPOT
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|DT_MIPS_CONFLICTNO
case|:
name|name
operator|=
literal|".conflict"
expr_stmt|;
name|elemsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Conflict
argument_list|)
expr_stmt|;
goto|goto
name|set_elemno
goto|;
case|case
name|DT_MIPS_LIBLISTNO
case|:
name|name
operator|=
literal|".liblist"
expr_stmt|;
name|elemsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Lib
argument_list|)
expr_stmt|;
name|set_elemno
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
operator|/
name|elemsize
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|elemsize
expr_stmt|;
block|}
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DT_MIPS_TIME_STAMP
case|:
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_ICHECKSUM
case|:
comment|/* XXX FIXME: */
name|swap_out_p
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_MIPS_IVERSION
case|:
comment|/* XXX FIXME: */
name|swap_out_p
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
name|s
operator|=
name|output_bfd
operator|->
name|sections
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffff
expr_stmt|;
break|break;
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
expr_stmt|;
break|break;
case|case
name|DT_MIPS_UNREFEXTNO
case|:
comment|/* The index into the dynamic symbol table which is the 		 entry of the first external symbol that is not 		 referenced within the same object.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|DT_MIPS_GOTSYM
case|:
if|if
condition|(
name|g
operator|->
name|global_gotsym
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
break|break;
block|}
comment|/* In case if we don't have global got symbols we default 		 to setting DT_MIPS_GOTSYM to the same value as 		 DT_MIPS_SYMTABNO, so we just fall through.  */
case|case
name|DT_MIPS_SYMTABNO
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
name|elemsize
operator|=
name|MIPS_ELF_SYM_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
operator|/
name|elemsize
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|elemsize
expr_stmt|;
break|break;
case|case
name|DT_MIPS_HIPAGENO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
operator|-
name|MIPS_RESERVED_GOTNO
expr_stmt|;
break|break;
case|case
name|DT_MIPS_RLD_MAP
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
expr_stmt|;
break|break;
case|case
name|DT_MIPS_OPTIONS
case|:
name|s
operator|=
operator|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_MIPS_MSYM
case|:
name|s
operator|=
operator|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|MIPS_ELF_MSYM_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
default|default:
name|swap_out_p
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|swap_out_p
condition|)
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_out
operator|)
operator|(
name|dynobj
operator|,
operator|&
name|dyn
operator|,
name|b
operator|)
expr_stmt|;
block|}
block|}
comment|/* The first entry of the global offset table will be filled at      runtime. The second entry will be used by some runtime loaders.      This isn't the case of Irix rld.  */
if|if
condition|(
name|sgot
operator|!=
name|NULL
operator|&&
name|sgot
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x80000000
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sgot
operator|!=
name|NULL
condition|)
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|{
name|asection
modifier|*
name|smsym
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf32_compact_rel
name|cpt
decl_stmt|;
comment|/* ??? The section symbols for the output sections were set up in        _bfd_elf_final_link.  SGI sets the STT_NOTYPE attribute for these        symbols.  Should we do so?  */
name|smsym
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_MSYM_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsym
operator|!=
name|NULL
condition|)
block|{
name|Elf32_Internal_Msym
name|msym
decl_stmt|;
name|msym
operator|.
name|ms_hash_value
operator|=
literal|0
expr_stmt|;
name|msym
operator|.
name|ms_info
operator|=
name|ELF32_MS_INFO
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|long
name|dynindx
init|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|dynindx
decl_stmt|;
name|bfd_mips_elf_swap_msym_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|msym
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Msym
operator|*
operator|)
name|smsym
operator|->
name|contents
operator|)
operator|+
name|dynindx
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* Write .compact_rel section out.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".compact_rel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|cpt
operator|.
name|id1
operator|=
literal|1
expr_stmt|;
name|cpt
operator|.
name|num
operator|=
name|s
operator|->
name|reloc_count
expr_stmt|;
name|cpt
operator|.
name|id2
operator|=
literal|2
expr_stmt|;
name|cpt
operator|.
name|offset
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
operator|)
expr_stmt|;
name|cpt
operator|.
name|reserved0
operator|=
literal|0
expr_stmt|;
name|cpt
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_compact_rel_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cpt
argument_list|,
operator|(
operator|(
name|Elf32_External_compact_rel
operator|*
operator|)
name|s
operator|->
name|contents
operator|)
argument_list|)
expr_stmt|;
comment|/* Clean up a dummy stub function entry in .text.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|file_ptr
name|dummy_offset
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|_raw_size
operator|>=
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
name|dummy_offset
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
name|memset
argument_list|(
name|s
operator|->
name|contents
operator|+
name|dummy_offset
argument_list|,
literal|0
argument_list|,
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We need to sort the entries of the dynamic relocation section.  */
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|reldyn
decl_stmt|;
name|reldyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_REL_DYN_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reldyn
operator|!=
name|NULL
operator|&&
name|reldyn
operator|->
name|reloc_count
operator|>
literal|2
condition|)
block|{
name|reldyn_sorting_bfd
operator|=
name|output_bfd
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|Elf32_External_Rel
operator|*
operator|)
name|reldyn
operator|->
name|contents
operator|+
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|reldyn
operator|->
name|reloc_count
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|,
name|sort_dynamic_relocs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean up a first relocation in .rel.dyn.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_REL_DYN_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|>
literal|0
condition|)
name|memset
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|MIPS_ELF_REL_SIZE
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for core dump NOTE sections */
end_comment

begin_function
specifier|static
name|boolean
name|_bfd_elf32_mips_grok_prstatus
parameter_list|(
name|abfd
parameter_list|,
name|note
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Note
modifier|*
name|note
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|raw_size
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
literal|256
case|:
comment|/* Linux/MIPS */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|72
expr_stmt|;
name|raw_size
operator|=
literal|180
expr_stmt|;
break|break;
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|raw_size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|_bfd_elf32_mips_grok_psinfo
parameter_list|(
name|abfd
parameter_list|,
name|note
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Note
modifier|*
name|note
decl_stmt|;
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
literal|128
case|:
comment|/* Linux/MIPS elf_prpsinfo */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|32
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|48
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PDR_SIZE
value|32
end_define

begin_function
specifier|static
name|boolean
name|_bfd_elf32_mips_discard_info
parameter_list|(
name|abfd
parameter_list|,
name|cookie
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
name|ret
init|=
name|false
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tdata
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|skip
decl_stmt|;
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".pdr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|false
return|;
if|if
condition|(
name|o
operator|->
name|_raw_size
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|o
operator|->
name|_raw_size
operator|%
name|PDR_SIZE
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|o
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
condition|)
return|return
name|false
return|;
name|tdata
operator|=
name|bfd_zmalloc
argument_list|(
name|o
operator|->
name|_raw_size
operator|/
name|PDR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdata
condition|)
return|return
name|false
return|;
name|cookie
operator|->
name|rels
operator|=
name|_bfd_elf32_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cookie
operator|->
name|rels
condition|)
block|{
name|free
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|cookie
operator|->
name|rel
operator|=
name|cookie
operator|->
name|rels
expr_stmt|;
name|cookie
operator|->
name|relend
operator|=
name|cookie
operator|->
name|rels
operator|+
name|o
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|skip
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|_raw_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_bfd_elf32_reloc_symbol_deleted_p
argument_list|(
name|i
operator|*
name|PDR_SIZE
argument_list|,
name|cookie
argument_list|)
condition|)
block|{
name|tdata
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|skip
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|tdata
operator|=
name|tdata
expr_stmt|;
name|o
operator|->
name|_cooked_size
operator|=
name|o
operator|->
name|_raw_size
operator|-
name|skip
operator|*
name|PDR_SIZE
expr_stmt|;
name|ret
operator|=
name|true
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|cookie
operator|->
name|rels
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|_bfd_elf32_mips_ignore_discarded_relocs
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".pdr"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|_bfd_elf32_mips_write_section
parameter_list|(
name|output_bfd
parameter_list|,
name|sec
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".pdr"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|to
operator|=
name|contents
expr_stmt|;
name|end
operator|=
name|contents
operator|+
name|sec
operator|->
name|_raw_size
expr_stmt|;
for|for
control|(
name|from
operator|=
name|contents
operator|,
name|i
operator|=
literal|0
init|;
name|from
operator|<
name|end
condition|;
name|from
operator|+=
name|PDR_SIZE
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tdata
operator|)
index|[
name|i
index|]
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|to
operator|!=
name|from
condition|)
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|PDR_SIZE
argument_list|)
expr_stmt|;
name|to
operator|+=
name|PDR_SIZE
expr_stmt|;
block|}
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a data section and an in-memory embedded reloc section, store    relocation information into the embedded reloc section which can be    used at runtime to relocate the data section.  This is called by the    linker when the --embedded-relocs switch is used.  This is called    after the add_symbols entry point has been called for all the    objects, and before the final_link entry point is called.  */
end_comment

begin_function
name|boolean
name|bfd_mips_elf32_create_embedded_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|datasec
parameter_list|,
name|relsec
parameter_list|,
name|errmsg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|datasec
decl_stmt|;
name|asection
modifier|*
name|relsec
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|extsyms
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|free_extsyms
init|=
name|NULL
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx_buf
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|relocateable
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|datasec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Read this BFD's symbols if we haven't done so already, or get the cached      copy if it exists.  */
if|if
condition|(
name|symtab_hdr
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|extsyms
operator|=
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
name|info
operator|->
name|keep_memory
condition|)
name|extsyms
operator|=
operator|(
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_size
argument_list|)
operator|)
expr_stmt|;
else|else
name|extsyms
operator|=
operator|(
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extsyms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free_extsyms
operator|=
name|extsyms
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|extsyms
argument_list|,
name|symtab_hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symtab_hdr
operator|->
name|sh_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|info
operator|->
name|keep_memory
condition|)
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|extsyms
expr_stmt|;
block|}
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
if|if
condition|(
name|shndx_hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|shndx_buf
operator|=
operator|(
name|Elf_External_Sym_Shndx
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx_buf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|shndx_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|shndx_buf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf32_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|datasec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free_relocs
operator|=
name|internal_relocs
expr_stmt|;
name|relsec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|datasec
operator|->
name|reloc_count
operator|*
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsec
operator|->
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
name|relsec
operator|->
name|contents
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|datasec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|p
operator|+=
literal|12
control|)
block|{
name|asection
modifier|*
name|targetsec
decl_stmt|;
comment|/* We are going to write a four byte longword into the runtime        reloc section.  The longword will be the address in the data        section which must be relocated.  It is followed by the name        of the target section NUL-padded or truncated to 8        characters.  */
comment|/* We can only relocate absolute longword relocs at run time.  */
if|if
condition|(
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_MIPS_32
operator|)
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_MIPS_64
operator|)
condition|)
block|{
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"unsupported reloc type"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the target section referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf32_External_Sym
modifier|*
name|esym
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|Elf_Internal_Sym
name|isym
decl_stmt|;
comment|/* A local symbol.  */
name|esym
operator|=
name|extsyms
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|shndx
operator|=
name|shndx_buf
operator|+
operator|(
name|shndx_buf
condition|?
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|bfd_elf32_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
name|shndx
argument_list|,
operator|&
name|isym
argument_list|)
expr_stmt|;
name|targetsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|targetsec
operator|=
name|NULL
expr_stmt|;
comment|/* 	   * For some reason, in certain programs, the symbol will 	   * not be in the hash table.  It seems to happen when you 	   * declare a static table of pointers to const external structures. 	   * In this case, the relocs are relative to data, not 	   * text, so just treating it like an undefined link 	   * should be sufficient. 	   */
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|targetsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
comment|/*        * Set the low bit of the relocation offset if it's a MIPS64 reloc.        * Relocations will always be on (at least) 32-bit boundaries.        */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|irel
operator|->
name|r_offset
operator|+
name|datasec
operator|->
name|output_offset
operator|)
operator|+
operator|(
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MIPS_64
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetsec
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
name|p
operator|+
literal|4
argument_list|,
name|targetsec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shndx_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|shndx_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|shndx_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|shndx_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is almost identical to bfd_generic_get_... except that some    MIPS relocations need to be handled specially.  Sigh.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|elf32_mips_get_relocated_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
comment|/* Get enough memory to hold the stuff */
name|bfd
modifier|*
name|input_bfd
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|reloc_vector
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* read in the section */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* We're not relaxing the section, so just copy the size info */
name|input_section
operator|->
name|_cooked_size
operator|=
name|input_section
operator|->
name|_raw_size
expr_stmt|;
name|input_section
operator|->
name|reloc_done
operator|=
name|true
expr_stmt|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
decl_stmt|;
comment|/* for mips */
name|int
name|gp_found
decl_stmt|;
name|bfd_vma
name|gp
init|=
literal|0x12345678
decl_stmt|;
comment|/* initialize just to shut gcc up */
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|lh
decl_stmt|;
comment|/* Skip all this stuff if we aren't mixing formats.  */
if|if
condition|(
name|abfd
operator|&&
name|input_bfd
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|input_bfd
operator|->
name|xvec
condition|)
name|lh
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|h
operator|=
name|bfd_hash_lookup
argument_list|(
operator|&
name|link_info
operator|->
name|hash
operator|->
name|table
argument_list|,
literal|"_gp"
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|lh
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
block|}
name|lookup
label|:
if|if
condition|(
name|lh
condition|)
block|{
switch|switch
condition|(
name|lh
operator|->
name|type
condition|)
block|{
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
case|case
name|bfd_link_hash_common
case|:
name|gp_found
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|gp_found
operator|=
literal|1
expr_stmt|;
name|gp
operator|=
name|lh
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
case|case
name|bfd_link_hash_warning
case|:
name|lh
operator|=
name|lh
operator|->
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* @@FIXME  ignoring warning for now */
goto|goto
name|lookup
goto|;
case|case
name|bfd_link_hash_new
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|gp_found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end mips */
for|for
control|(
name|parent
operator|=
name|reloc_vector
init|;
operator|*
name|parent
operator|!=
operator|(
name|arelent
operator|*
operator|)
name|NULL
condition|;
name|parent
operator|++
control|)
block|{
name|char
modifier|*
name|error_message
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
comment|/* Specific to MIPS: Deal with relocation types that require 	     knowing the gp of the output bfd.  */
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|&&
name|abfd
condition|)
block|{
comment|/* The special_function wouldn't get called anyways.  */
block|}
elseif|else
if|if
condition|(
operator|!
name|gp_found
condition|)
block|{
comment|/* The gp isn't there; let the special function code 		 fall over on its own.  */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|parent
operator|)
operator|->
name|howto
operator|->
name|special_function
operator|==
name|_bfd_mips_elf_gprel16_reloc
condition|)
block|{
comment|/* bypass special_function call */
name|r
operator|=
name|gprel16_with_gp
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|,
operator|*
name|parent
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
name|gp
argument_list|)
expr_stmt|;
goto|goto
name|skip_bfd_perform_relocation
goto|;
block|}
comment|/* end mips specific stuff */
name|r
operator|=
name|bfd_perform_relocation
argument_list|(
name|input_bfd
argument_list|,
operator|*
name|parent
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
name|input_section
argument_list|,
name|relocateable
condition|?
name|abfd
else|:
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
name|skip_bfd_perform_relocation
label|:
if|if
condition|(
name|relocateable
condition|)
block|{
name|asection
modifier|*
name|os
init|=
name|input_section
operator|->
name|output_section
decl_stmt|;
comment|/* A partial link, so keep the relocs */
name|os
operator|->
name|orelocation
index|[
name|os
operator|->
name|reloc_count
index|]
operator|=
operator|*
name|parent
expr_stmt|;
name|os
operator|->
name|reloc_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|,
name|true
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|BFD_ASSERT
argument_list|(
name|error_message
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|link_info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|howto
operator|->
name|name
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|elf32_mips_get_relocated_section_contents
end_define

begin_escape
end_escape

begin_comment
comment|/* ECOFF swapping routines.  These are used when dealing with the    .mdebug section, which is in the ECOFF debugging format.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ecoff_debug_swap
name|mips_elf32_ecoff_debug_swap
init|=
block|{
comment|/* Symbol table magic number.  */
name|magicSym
block|,
comment|/* Alignment of debugging information.  E.g., 4.  */
literal|4
block|,
comment|/* Sizes of external symbolic information.  */
sizeof|sizeof
argument_list|(
expr|struct
name|hdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opt_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|rfd_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ext_ext
argument_list|)
block|,
comment|/* Functions to swap in external symbolic data.  */
name|ecoff_swap_hdr_in
block|,
name|ecoff_swap_dnr_in
block|,
name|ecoff_swap_pdr_in
block|,
name|ecoff_swap_sym_in
block|,
name|ecoff_swap_opt_in
block|,
name|ecoff_swap_fdr_in
block|,
name|ecoff_swap_rfd_in
block|,
name|ecoff_swap_ext_in
block|,
name|_bfd_ecoff_swap_tir_in
block|,
name|_bfd_ecoff_swap_rndx_in
block|,
comment|/* Functions to swap out external symbolic data.  */
name|ecoff_swap_hdr_out
block|,
name|ecoff_swap_dnr_out
block|,
name|ecoff_swap_pdr_out
block|,
name|ecoff_swap_sym_out
block|,
name|ecoff_swap_opt_out
block|,
name|ecoff_swap_fdr_out
block|,
name|ecoff_swap_rfd_out
block|,
name|ecoff_swap_ext_out
block|,
name|_bfd_ecoff_swap_tir_out
block|,
name|_bfd_ecoff_swap_rndx_out
block|,
comment|/* Function to read in symbolic data.  */
name|_bfd_mips_elf_read_ecoff_info
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_mips
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_MIPS
end_define

begin_comment
comment|/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses    a value of 0x1000, and we are compatible.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_backend_collect
value|true
end_define

begin_define
define|#
directive|define
name|elf_backend_type_change_ok
value|true
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|true
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|mips_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|mips_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|elf_backend_sym_is_global
value|mips_elf_sym_is_global
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|_bfd_mips_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|_bfd_mips_elf_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_section_processing
value|_bfd_mips_elf_section_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|_bfd_mips_elf_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|_bfd_mips_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_bfd_section
define|\
value|_bfd_mips_elf_section_from_bfd_section
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|_bfd_mips_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|_bfd_mips_elf_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|_bfd_mips_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|_bfd_mips_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|_bfd_mips_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|_bfd_mips_elf_always_size_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|_bfd_mips_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|_bfd_mips_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|_bfd_mips_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|_bfd_mips_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|_bfd_mips_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
define|\
value|_bfd_mips_elf_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|_bfd_mips_elf_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|_bfd_mips_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|_bfd_mips_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
define|\
value|_bfd_mips_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|_bfd_mips_elf_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|_bfd_elf32_mips_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|_bfd_elf32_mips_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_ecoff_debug_swap
value|&mips_elf32_ecoff_debug_swap
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|(4 * MIPS_RESERVED_GOTNO)
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_sign_extend_vma
value|true
end_define

begin_define
define|#
directive|define
name|elf_backend_discard_info
value|_bfd_elf32_mips_discard_info
end_define

begin_define
define|#
directive|define
name|elf_backend_ignore_discarded_relocs
define|\
value|_bfd_elf32_mips_ignore_discarded_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_write_section
value|_bfd_elf32_mips_write_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_is_local_label_name
define|\
value|mips_elf_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elf32_find_nearest_line
value|_bfd_mips_elf_find_nearest_line
end_define

begin_define
define|#
directive|define
name|bfd_elf32_set_section_contents
value|_bfd_mips_elf_set_section_contents
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|_bfd_mips_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_final_link
value|_bfd_mips_elf_final_link
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
define|\
value|_bfd_mips_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|_bfd_mips_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
define|\
value|_bfd_mips_elf_print_private_bfd_data
end_define

begin_comment
comment|/* Support for SGI-ish mips targets.  */
end_comment

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_littlemips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-littlemips"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_bigmips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-bigmips"
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_comment
comment|/* Support for traditional mips targets.  */
end_comment

begin_define
define|#
directive|define
name|INCLUDED_TARGET_FILE
end_define

begin_comment
comment|/* More a type of flag.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_tradlittlemips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-tradlittlemips"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_tradbigmips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-tradbigmips"
end_define

begin_comment
comment|/* Include the target file again for this target */
end_comment

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

