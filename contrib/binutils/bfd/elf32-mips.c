begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MIPS-specific support for 32-bit ELF    Copyright 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.     Most of the information added by Ian Lance Taylor, Cygnus Support,<ian@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles MIPS ELF targets.  SGI Irix 5 uses a slightly    different MIPS ELF from other targets.  This matters when linking.    This file supports both, switching at runtime.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"genlink.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_comment
comment|/* Get the ECOFF swapping routines.  */
end_comment

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/mips.h"
end_include

begin_define
define|#
directive|define
name|ECOFF_32
end_define

begin_include
include|#
directive|include
file|"ecoffswap.h"
end_include

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips32_64bit_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_info_to_howto_rel
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf32_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_gptab
operator|*
operator|,
name|Elf32_gptab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_gptab
operator|*
operator|,
name|Elf32_External_gptab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_sym_is_global
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf32_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_create_procedure_table
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_elf_additional_program_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_modify_segment_map
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|elf_mips_isa
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf32_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf32_section_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|mips_elf_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|mips_elf_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gptab_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf_relocate_hi16
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_relocate_got_local
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf_relocate_global_got
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips16_jump_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips16_gprel_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_adjust_dynindx
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_link_output_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_create_compact_rel_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_always_size_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf_final_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|boolean
operator|,
name|char
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|elf32_mips_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is true for Irix 5 executables, false for normal MIPS ELF ABI    executables.  FIXME: At the moment, we default to always generating    Irix 5 executables.  */
end_comment

begin_define
define|#
directive|define
name|SGI_COMPAT
parameter_list|(
name|abfd
parameter_list|)
value|(1)
end_define

begin_comment
comment|/* This structure is used to hold .got information when linking.  It    is stored in the tdata field of the bfd_elf_section_data structure.  */
end_comment

begin_struct
struct|struct
name|mips_got_info
block|{
comment|/* The symbol index of the first global .got symbol.  */
name|unsigned
name|long
name|global_gotsym
decl_stmt|;
comment|/* The number of local .got entries.  */
name|unsigned
name|int
name|local_gotno
decl_stmt|;
comment|/* The number of local .got entries we have used.  */
name|unsigned
name|int
name|assigned_gotno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The number of local .got entries we reserve.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_RESERVED_GOTNO
value|(2)
end_define

begin_comment
comment|/* Instructions which appear in a stub.  For some reason the stub is    slightly different on an SGI system.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MIPS_GP_OFFSET
parameter_list|(
name|abfd
parameter_list|)
value|(SGI_COMPAT (abfd) ? 0x7ff0 : 0x8000)
end_define

begin_define
define|#
directive|define
name|STUB_LW
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(SGI_COMPAT (abfd)					\    ? 0x8f998010
comment|/* lw t9,0x8010(gp) */
value|\    : 0x8f998000)
end_define

begin_comment
comment|/* lw t9,0x8000(gp) */
end_comment

begin_define
define|#
directive|define
name|STUB_MOVE
value|0x03e07825
end_define

begin_comment
comment|/* move t7,ra */
end_comment

begin_define
define|#
directive|define
name|STUB_JALR
value|0x0320f809
end_define

begin_comment
comment|/* jal t9 */
end_comment

begin_define
define|#
directive|define
name|STUB_LI16
value|0x34180000
end_define

begin_comment
comment|/* ori t8,zero,0 */
end_comment

begin_define
define|#
directive|define
name|MIPS_FUNCTION_STUB_SIZE
value|(16)
end_define

begin_comment
comment|/* Names of sections which appear in the .dynsym section in an Irix 5    executable.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_elf_dynsym_sec_names
index|[]
init|=
block|{
literal|".text"
block|,
literal|".init"
block|,
literal|".fini"
block|,
literal|".data"
block|,
literal|".rodata"
block|,
literal|".sdata"
block|,
literal|".sbss"
block|,
literal|".bss"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIZEOF_MIPS_DYNSYM_SECNAMES
define|\
value|(sizeof mips_elf_dynsym_sec_names / sizeof mips_elf_dynsym_sec_names[0])
end_define

begin_comment
comment|/* The number of entries in mips_elf_dynsym_sec_names which go in the    text segment.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_TEXT_DYNSYM_SECNO
value|(3)
end_define

begin_comment
comment|/* The names of the runtime procedure table symbols used on Irix 5.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_elf_dynsym_rtproc_names
index|[]
init|=
block|{
literal|"_procedure_table"
block|,
literal|"_procedure_string_table"
block|,
literal|"_procedure_table_size"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These structures are used to generate the .compact_rel section on    Irix 5.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|id1
decl_stmt|;
comment|/* Always one?  */
name|unsigned
name|long
name|num
decl_stmt|;
comment|/* Number of compact relocation entries.  */
name|unsigned
name|long
name|id2
decl_stmt|;
comment|/* Always two?  */
name|unsigned
name|long
name|offset
decl_stmt|;
comment|/* The file offset of the first relocation.  */
name|unsigned
name|long
name|reserved0
decl_stmt|;
comment|/* Zero?  */
name|unsigned
name|long
name|reserved1
decl_stmt|;
comment|/* Zero?  */
block|}
name|Elf32_compact_rel
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|id1
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|num
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|id2
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|offset
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|reserved0
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|reserved1
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_compact_rel
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|ctype
range|:
literal|1
decl_stmt|;
comment|/* 1: long 0: short format. See below.  */
name|unsigned
name|int
name|rtype
range|:
literal|4
decl_stmt|;
comment|/* Relocation types. See below. */
name|unsigned
name|int
name|dist2to
range|:
literal|8
decl_stmt|;
name|unsigned
name|int
name|relvaddr
range|:
literal|19
decl_stmt|;
comment|/* (VADDR - vaddr of the previous entry)/ 4 */
name|unsigned
name|long
name|konst
decl_stmt|;
comment|/* KONST field. See below.  */
name|unsigned
name|long
name|vaddr
decl_stmt|;
comment|/* VADDR to be relocated.  */
block|}
name|Elf32_crinfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|ctype
range|:
literal|1
decl_stmt|;
comment|/* 1: long 0: short format. See below.  */
name|unsigned
name|int
name|rtype
range|:
literal|4
decl_stmt|;
comment|/* Relocation types. See below. */
name|unsigned
name|int
name|dist2to
range|:
literal|8
decl_stmt|;
name|unsigned
name|int
name|relvaddr
range|:
literal|19
decl_stmt|;
comment|/* (VADDR - vaddr of the previous entry)/ 4 */
name|unsigned
name|long
name|konst
decl_stmt|;
comment|/* KONST field. See below.  */
block|}
name|Elf32_crinfo2
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|info
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|konst
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|vaddr
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_crinfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|info
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|konst
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_crinfo2
typedef|;
end_typedef

begin_comment
comment|/* These are the constants used to swap the bitfields in a crinfo.  */
end_comment

begin_define
define|#
directive|define
name|CRINFO_CTYPE
value|(0x1)
end_define

begin_define
define|#
directive|define
name|CRINFO_CTYPE_SH
value|(31)
end_define

begin_define
define|#
directive|define
name|CRINFO_RTYPE
value|(0xf)
end_define

begin_define
define|#
directive|define
name|CRINFO_RTYPE_SH
value|(27)
end_define

begin_define
define|#
directive|define
name|CRINFO_DIST2TO
value|(0xff)
end_define

begin_define
define|#
directive|define
name|CRINFO_DIST2TO_SH
value|(19)
end_define

begin_define
define|#
directive|define
name|CRINFO_RELVADDR
value|(0x7ffff)
end_define

begin_define
define|#
directive|define
name|CRINFO_RELVADDR_SH
value|(0)
end_define

begin_comment
comment|/* A compact relocation info has long (3 words) or short (2 words)    formats.  A short format doesn't have VADDR field and relvaddr    fields contains ((VADDR - vaddr of the previous entry)>> 2).  */
end_comment

begin_define
define|#
directive|define
name|CRF_MIPS_LONG
value|1
end_define

begin_define
define|#
directive|define
name|CRF_MIPS_SHORT
value|0
end_define

begin_comment
comment|/* There are 4 types of compact relocation at least. The value KONST    has different meaning for each type:     (type)		(konst)    CT_MIPS_REL32	Address in data    CT_MIPS_WORD		Address in word (XXX)    CT_MIPS_GPHI_LO	GP - vaddr    CT_MIPS_JMPAD	Address to jump    */
end_comment

begin_define
define|#
directive|define
name|CRT_MIPS_REL32
value|0xa
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_WORD
value|0xb
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_GPHI_LO
value|0xc
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_JMPAD
value|0xd
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_format
parameter_list|(
name|x
parameter_list|,
name|format
parameter_list|)
value|((x).ctype = (format))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_type
parameter_list|(
name|x
parameter_list|,
name|type
parameter_list|)
value|((x).rtype = (type))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_dist2to
parameter_list|(
name|x
parameter_list|,
name|v
parameter_list|)
value|((x).dist2to = (v))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_relvaddr
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
value|((x).relvaddr = (d)<<2)
end_define

begin_decl_stmt
specifier|static
name|void
name|bfd_elf32_swap_compact_rel_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_compact_rel
operator|*
operator|,
name|Elf32_External_compact_rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bfd_elf32_swap_crinfo_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_crinfo
operator|*
operator|,
name|Elf32_External_crinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USE_REL
value|1
end_define

begin_comment
comment|/* MIPS uses REL relocations instead of RELA */
end_comment

begin_enum
enum|enum
name|reloc_type
block|{
name|R_MIPS_NONE
init|=
literal|0
block|,
name|R_MIPS_16
block|,
name|R_MIPS_32
block|,
name|R_MIPS_REL32
block|,
name|R_MIPS_26
block|,
name|R_MIPS_HI16
block|,
name|R_MIPS_LO16
block|,
name|R_MIPS_GPREL16
block|,
name|R_MIPS_LITERAL
block|,
name|R_MIPS_GOT16
block|,
name|R_MIPS_PC16
block|,
name|R_MIPS_CALL16
block|,
name|R_MIPS_GPREL32
block|,
comment|/* The remaining relocs are defined on Irix, although they are not      in the MIPS ELF ABI.  */
name|R_MIPS_UNUSED1
block|,
name|R_MIPS_UNUSED2
block|,
name|R_MIPS_UNUSED3
block|,
name|R_MIPS_SHIFT5
block|,
name|R_MIPS_SHIFT6
block|,
name|R_MIPS_64
block|,
name|R_MIPS_GOT_DISP
block|,
name|R_MIPS_GOT_PAGE
block|,
name|R_MIPS_GOT_OFST
block|,
name|R_MIPS_GOT_HI16
block|,
name|R_MIPS_GOT_LO16
block|,
name|R_MIPS_SUB
block|,
name|R_MIPS_INSERT_A
block|,
name|R_MIPS_INSERT_B
block|,
name|R_MIPS_DELETE
block|,
name|R_MIPS_HIGHER
block|,
name|R_MIPS_HIGHEST
block|,
name|R_MIPS_CALL_HI16
block|,
name|R_MIPS_CALL_LO16
block|,
name|R_MIPS_max
block|,
comment|/* These relocs are used for the mips16.  */
name|R_MIPS16_26
init|=
literal|100
block|,
name|R_MIPS16_GPREL
init|=
literal|101
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_howto_table
index|[]
init|=
block|{
comment|/* No relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit symbol relative relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_REL32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 26 bit branch address.  */
name|HOWTO
argument_list|(
name|R_MIPS_26
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper four 				   bits must match the PC.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_26"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3ffffff
argument_list|,
comment|/* src_mask */
literal|0x3ffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_hi16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_lo16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_gprel16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to literal section.  */
name|HOWTO
argument_list|(
name|R_MIPS_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_gprel16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LITERAL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_got16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit PC relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_PC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_PC16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit call through global offset table.  */
comment|/* FIXME: This is not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_mips_elf_gprel32_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The remaining relocs are defined on Irix 5, although they are        not defined by the ABI.  */
block|{
literal|13
block|}
block|,
block|{
literal|14
block|}
block|,
block|{
literal|15
block|}
block|,
comment|/* A 5 bit shift field.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT5
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|5
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT5"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x000007c0
argument_list|,
comment|/* src_mask */
literal|0x000007c0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit shift field.  */
comment|/* FIXME: This is not handled correctly; a special function is      needed to put the most significant bit in the right place.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT6
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT6"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x000007c4
argument_list|,
comment|/* src_mask */
literal|0x000007c4
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 64 bit relocation.  This is used in 32 bit ELF when addresses      are 64 bits long; the upper 32 bits are simply a sign extension.      The fields of the howto should be the same as for R_MIPS_32,      other than the type, name, and special_function.  */
name|HOWTO
argument_list|(
name|R_MIPS_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips32_64bit_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_64"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_DISP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_DISP"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement to page pointer in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_PAGE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_PAGE"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Offset from page pointer in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_OFST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_OFST"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit subtraction.  Presumably not used in 32 bit ELF.  */
block|{
name|R_MIPS_SUB
block|}
block|,
comment|/* Used to cause the linker to insert and delete instructions?  */
block|{
name|R_MIPS_INSERT_A
block|}
block|,
block|{
name|R_MIPS_INSERT_B
block|}
block|,
block|{
name|R_MIPS_DELETE
block|}
block|,
comment|/* Get the higher values of a 64 bit addend.  Presumably not used in      32 bit ELF.  */
block|{
name|R_MIPS_HIGHER
block|}
block|,
block|{
name|R_MIPS_HIGHEST
block|}
block|,
comment|/* High 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The reloc used for BFD_RELOC_CTOR when doing a 64 bit link.  This    is a hack to make the linker think that we need 64 bit values.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips_ctor64_howto
init|=
name|HOWTO
argument_list|(
name|R_MIPS_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips32_64bit_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_64"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* The reloc used for the mips16 jump instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips16_jump_howto
init|=
name|HOWTO
argument_list|(
name|R_MIPS16_26
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper four 				   bits must match the PC.  */
name|mips16_jump_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS16_26"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3ffffff
argument_list|,
comment|/* src_mask */
literal|0x3ffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* The reloc used for the mips16 gprel instruction.  The src_mask and    dsk_mask for this howto do not reflect the actual instruction, in    which the value is not contiguous; the masks are for the    convenience of the relocate_section routine.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mips16_gprel_howto
init|=
name|HOWTO
argument_list|(
name|R_MIPS16_GPREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips16_gprel_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS16_GPREL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* Do a R_MIPS_HI16 relocation.  This has to be done in combination    with a R_MIPS_LO16 reloc, because there is a carry from the LO16 to    the HI16.  Here we just save the information we need; we do the    actual relocation when we see the LO16.  MIPS ELF requires that the    LO16 immediately follow the HI16.  As a GNU extension, we permit an    arbitrary number of HI16 relocs to be associated with a single LO16    reloc.  This extension permits gcc to output the HI and LO relocs    itself.  */
end_comment

begin_struct
struct|struct
name|mips_hi16
block|{
name|struct
name|mips_hi16
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: This should not be a static variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_hi16
modifier|*
name|mips_hi16_list
decl_stmt|;
end_decl_stmt

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_hi16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|mips_hi16
modifier|*
name|n
decl_stmt|;
comment|/* If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
name|ret
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|bfd_reloc_undefined
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|relocateable
operator|=
name|true
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
name|relocation
operator|=
name|gp
operator|-
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Save the information, and let LO16 do the actual relocation.  */
name|n
operator|=
operator|(
expr|struct
name|mips_hi16
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|->
name|addr
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|n
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|mips_hi16_list
expr_stmt|;
name|mips_hi16_list
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_LO16 relocation.  This is a straightforward 16 bit    inplace relocation; this function exists in order to do the    R_MIPS_HI16 relocation described above.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_lo16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|arelent
name|gp_disp_relent
decl_stmt|;
if|if
condition|(
name|mips_hi16_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mips_hi16
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|mips_hi16_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|vallo
decl_stmt|;
name|struct
name|mips_hi16
modifier|*
name|next
decl_stmt|;
comment|/* Do the HI16 relocation.  Note that we actually don't need 	     to know anything about the LO16 itself, except where to 	     find the low 16 bits of the addend needed by the LO16.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|vallo
operator|=
operator|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|vallo
expr_stmt|;
name|val
operator|+=
name|l
operator|->
name|addend
expr_stmt|;
comment|/* The low order 16 bits are always treated as a signed 	     value.  Therefore, a negative value in the low order bits 	     requires an adjustment in the high order bits.  We need 	     to make this adjustment in two ways: once for the bits we 	     took from the data, and once for the bits we are putting 	     back in to the data.  */
if|if
condition|(
operator|(
name|vallo
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
literal|0x10000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gp_disp_relent
operator|=
operator|*
name|reloc_entry
expr_stmt|;
name|reloc_entry
operator|=
operator|&
name|gp_disp_relent
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|=
name|l
operator|->
name|addend
expr_stmt|;
block|}
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
name|mips_hi16_list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|,
name|relocation
decl_stmt|;
comment|/* FIXME: Does this case ever occur?  */
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|true
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
name|relocation
operator|=
name|gp
operator|-
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|gp_disp_relent
operator|=
operator|*
name|reloc_entry
expr_stmt|;
name|reloc_entry
operator|=
operator|&
name|gp_disp_relent
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
operator|-
literal|4
expr_stmt|;
block|}
comment|/* Now do the LO16 reloc in the usual way.  */
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GOT16 reloc.  This is a reloc against the global offset    table used for PIC code.  If the symbol is an external symbol, the    instruction is modified to contain the offset of the appropriate    entry in the global offset table.  If the symbol is a section    symbol, the next reloc is a R_MIPS_LO16 reloc.  The two 16 bit    addends are combined to form the real addend against the section    symbol; the GOT16 is modified to contain the offset of an entry in    the global offset table, and the LO16 is modified to offset it    appropriately.  Thus an offset larger than 16 bits requires a    modified value in the global offset table.     This implementation suffices for the assembler, but the linker does    not yet know how to create global offset tables.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_got16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* If we're relocating, and this is a local symbol, we can handle it      just like HI16.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
return|return
name|_bfd_mips_elf_hi16_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We have to figure out the gp value, so that we can adjust the    symbol value correctly.  We look up the symbol _gp in the output    BFD.  If we can't find it, we're stuck.  We cache it in the ELF    target data.  We don't need to adjust the symbol value for an    external symbol if we are producing relocateable output.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_elf_final_gp
parameter_list|(
name|output_bfd
parameter_list|,
name|symbol
parameter_list|,
name|relocateable
parameter_list|,
name|error_message
parameter_list|,
name|pgp
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
name|bfd_vma
modifier|*
name|pgp
decl_stmt|;
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|relocateable
condition|)
block|{
operator|*
name|pgp
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_reloc_undefined
return|;
block|}
operator|*
name|pgp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pgp
operator|==
literal|0
operator|&&
operator|(
operator|!
name|relocateable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|relocateable
condition|)
block|{
comment|/* Make up a value.  */
operator|*
name|pgp
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|0x4000
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|sym
operator|=
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
name|i
operator|=
name|count
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
specifier|register
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pgp
operator|=
name|bfd_asymbol_value
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|count
condition|)
block|{
comment|/* Only get the error once.  */
operator|*
name|pgp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
literal|"GP relative relocation when _gp not defined"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must    become the offset from the gp register.  This function also handles    R_MIPS_LITERAL relocations, although those can be handled more    cleverly because the entries in the .lit8 and .lit4 sections can be    merged.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|gprel16_with_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asection
operator|*
operator|,
name|boolean
operator|,
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ELF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|relocateable
operator|=
name|true
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
return|return
name|gprel16_with_gp
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|reloc_entry
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|gprel16_with_gp
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|reloc_entry
parameter_list|,
name|input_section
parameter_list|,
name|relocateable
parameter_list|,
name|data
parameter_list|,
name|gp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Set val to the offset into the section or symbol.  */
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0
condition|)
block|{
comment|/* This case occurs with the 64-bit MIPS ELF ABI.  */
name|val
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|+
name|reloc_entry
operator|->
name|addend
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x8000
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
block|}
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocateable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocateable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
name|val
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocateable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
comment|/* Make sure it fit in 16 bits.  */
if|if
condition|(
name|val
operator|>=
literal|0x8000
operator|&&
name|val
operator|<
literal|0xffff8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GPREL32 relocation.  Is this 32 bit value the offset    from the gp register? XXX */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|gprel32_with_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asection
operator|*
operator|,
name|boolean
operator|,
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel32_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ELF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
literal|"32bits gp relative relocation occurs for an external symbol"
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|relocateable
operator|=
name|true
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
block|}
return|return
name|gprel32_with_gp
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|reloc_entry
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|gprel32_with_gp
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|reloc_entry
parameter_list|,
name|input_section
parameter_list|,
name|relocateable
parameter_list|,
name|data
parameter_list|,
name|gp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0
condition|)
block|{
comment|/* This case arises with the 64-bit MIPS ELF ABI.  */
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Set val to the offset into the section or symbol.  */
name|val
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocateable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocateable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocateable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Handle a 64 bit reloc in a 32 bit MIPS ELF file.  These are    generated when addreses are 64 bits.  The upper 32 bits are a simle    sign extension.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips32_64bit_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|arelent
name|reloc32
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|bfd_size_type
name|addr
decl_stmt|;
name|r
operator|=
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_continue
condition|)
return|return
name|r
return|;
comment|/* Do a normal 32 bit relocation on the lower 32 bits.  */
name|reloc32
operator|=
operator|*
name|reloc_entry
expr_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|reloc32
operator|.
name|address
operator|+=
literal|4
expr_stmt|;
name|reloc32
operator|.
name|howto
operator|=
operator|&
name|elf_mips_howto_table
index|[
name|R_MIPS_32
index|]
expr_stmt|;
name|r
operator|=
name|bfd_perform_relocation
argument_list|(
name|abfd
argument_list|,
operator|&
name|reloc32
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
comment|/* Sign extend into the upper 32 bits.  */
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc32
operator|.
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|reloc_entry
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|addr
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Handle a mips16 jump.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips16_jump_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* FIXME.  */
block|{
specifier|static
name|boolean
name|warned
decl_stmt|;
if|if
condition|(
operator|!
name|warned
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Linking mips16 objects into %s format is not supported"
argument_list|,
name|bfd_get_target
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
return|return
name|bfd_reloc_undefined
return|;
block|}
end_function

begin_comment
comment|/* Handle a mips16 GP relative reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips16_gprel_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|unsigned
name|short
name|extend
decl_stmt|,
name|insn
decl_stmt|;
name|unsigned
name|long
name|final
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ELF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|relocateable
operator|=
name|true
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
name|ret
operator|=
name|mips_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Pick up the mips16 extend instruction and the real instruction.  */
name|extend
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Stuff the current addend back as a 32 bit value, do the usual      relocation, and then clean up.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
operator|(
name|extend
operator|&
literal|0x1f
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
name|extend
operator|&
literal|0x7e0
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x1f
operator|)
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gprel16_with_gp
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|reloc_entry
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
expr_stmt|;
name|final
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|extend
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|final
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|final
operator|&
literal|0x7e0
operator|)
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator||
operator|(
name|final
operator|&
literal|0x1f
operator|)
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return the ISA for a MIPS e_flags value.  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|elf_mips_isa
parameter_list|(
name|flags
parameter_list|)
name|flagword
name|flags
decl_stmt|;
block|{
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_ARCH
condition|)
block|{
case|case
name|E_MIPS_ARCH_1
case|:
return|return
literal|1
return|;
case|case
name|E_MIPS_ARCH_2
case|:
return|return
literal|2
return|;
case|case
name|E_MIPS_ARCH_3
case|:
return|return
literal|3
return|;
case|case
name|E_MIPS_ARCH_4
case|:
return|return
literal|4
return|;
block|}
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* A mapping from BFD reloc types to MIPS ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|enum
name|reloc_type
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|elf_reloc_map
name|mips_reloc_map
index|[]
operator|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_MIPS_NONE
block|, }
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_MIPS_16
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_MIPS_32
block|}
block|,
block|{
name|BFD_RELOC_64
block|,
name|R_MIPS_64
block|}
block|,
block|{
name|BFD_RELOC_MIPS_JMP
block|,
name|R_MIPS_26
block|}
block|,
block|{
name|BFD_RELOC_HI16_S
block|,
name|R_MIPS_HI16
block|}
block|,
block|{
name|BFD_RELOC_LO16
block|,
name|R_MIPS_LO16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GPREL
block|,
name|R_MIPS_GPREL16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_LITERAL
block|,
name|R_MIPS_LITERAL
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GOT16
block|,
name|R_MIPS_GOT16
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_MIPS_PC16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_CALL16
block|,
name|R_MIPS_CALL16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GPREL32
block|,
name|R_MIPS_GPREL32
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GOT_HI16
block|,
name|R_MIPS_GOT_HI16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_GOT_LO16
block|,
name|R_MIPS_GOT_LO16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_CALL_HI16
block|,
name|R_MIPS_CALL_HI16
block|}
block|,
block|{
name|BFD_RELOC_MIPS_CALL_LO16
block|,
name|R_MIPS_CALL_LO16
block|}
block|, }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Given a BFD reloc type, return a howto structure.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mips_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mips_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_mips_howto_table
index|[
operator|(
name|int
operator|)
name|mips_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
comment|/* We need to handle BFD_RELOC_CTOR specially.       Select the right relocation (R_MIPS_32 or R_MIPS_64) based on the      size of addresses on this architecture.  */
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_CTOR
condition|)
block|{
if|if
condition|(
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
operator|==
literal|32
condition|)
return|return
operator|&
name|elf_mips_howto_table
index|[
operator|(
name|int
operator|)
name|R_MIPS_32
index|]
return|;
else|else
return|return
operator|&
name|elf_mips_ctor64_howto
return|;
block|}
comment|/* Special handling for the MIPS16 relocs, since they are made up      reloc types with a large value.  */
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_MIPS16_JMP
condition|)
return|return
operator|&
name|elf_mips16_jump_howto
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_MIPS16_GPREL
condition|)
return|return
operator|&
name|elf_mips16_gprel_howto
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given a MIPS reloc type, fill in an arelent structure.  */
end_comment

begin_function
specifier|static
name|void
name|mips_info_to_howto_rel
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf32_Internal_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_mips16_jump_howto
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
condition|)
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_mips16_gprel_howto
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_MIPS_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_mips_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
comment|/* The addend for a GPREL16 or LITERAL relocation comes from the GP      value for the object file.  We get the addend now, rather than      when we do the relocation, because the symbol manipulations done      by the linker may cause us to lose track of the input BFD.  */
if|if
condition|(
operator|(
operator|(
operator|*
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_MIPS_GPREL16
operator|||
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_MIPS_LITERAL
operator|)
condition|)
name|cache_ptr
operator|->
name|addend
operator|=
name|elf_gp
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A .reginfo section holds a single Elf32_RegInfo structure.  These    routines swap this structure in and out.  They are used outside of    BFD, so they are globally visible.  */
end_comment

begin_function
name|void
name|bfd_mips_elf32_swap_reginfo_in
parameter_list|(
name|abfd
parameter_list|,
name|ex
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_External_RegInfo
modifier|*
name|ex
decl_stmt|;
name|Elf32_RegInfo
modifier|*
name|in
decl_stmt|;
block|{
name|in
operator|->
name|ri_gprmask
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_gp_value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_mips_elf32_swap_reginfo_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_RegInfo
modifier|*
name|in
decl_stmt|;
name|Elf32_External_RegInfo
modifier|*
name|ex
decl_stmt|;
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_gprmask
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_gp_value
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In the 64 bit ABI, the .MIPS.options section holds register    information in an Elf64_Reginfo structure.  These routines swap    them in and out.  They are globally visible because they are used    outside of BFD.  These routines are here so that gas can call them    without worrying about whether the 64 bit ABI has been included.  */
end_comment

begin_function
name|void
name|bfd_mips_elf64_swap_reginfo_in
parameter_list|(
name|abfd
parameter_list|,
name|ex
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf64_External_RegInfo
modifier|*
name|ex
decl_stmt|;
name|Elf64_Internal_RegInfo
modifier|*
name|in
decl_stmt|;
block|{
name|in
operator|->
name|ri_gprmask
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_pad
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_pad
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_gp_value
operator|=
name|bfd_h_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_mips_elf64_swap_reginfo_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf64_Internal_RegInfo
modifier|*
name|in
decl_stmt|;
name|Elf64_External_RegInfo
modifier|*
name|ex
decl_stmt|;
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_gprmask
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_pad
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_pad
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|ri_gp_value
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap an entry in a .gptab section.  Note that these routines rely    on the equivalence of the two elements of the union.  */
end_comment

begin_function
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_in
parameter_list|(
name|abfd
parameter_list|,
name|ex
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_External_gptab
modifier|*
name|ex
decl_stmt|;
name|Elf32_gptab
modifier|*
name|in
decl_stmt|;
block|{
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_gptab
modifier|*
name|in
decl_stmt|;
name|Elf32_External_gptab
modifier|*
name|ex
decl_stmt|;
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_elf32_swap_compact_rel_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_compact_rel
modifier|*
name|in
decl_stmt|;
name|Elf32_External_compact_rel
modifier|*
name|ex
decl_stmt|;
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|id1
argument_list|,
name|ex
operator|->
name|id1
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|num
argument_list|,
name|ex
operator|->
name|num
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|id2
argument_list|,
name|ex
operator|->
name|id2
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|offset
argument_list|,
name|ex
operator|->
name|offset
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|reserved0
argument_list|,
name|ex
operator|->
name|reserved0
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|reserved1
argument_list|,
name|ex
operator|->
name|reserved1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_elf32_swap_crinfo_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_crinfo
modifier|*
name|in
decl_stmt|;
name|Elf32_External_crinfo
modifier|*
name|ex
decl_stmt|;
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|l
operator|=
operator|(
operator|(
operator|(
name|in
operator|->
name|ctype
operator|&
name|CRINFO_CTYPE
operator|)
operator|<<
name|CRINFO_CTYPE_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|rtype
operator|&
name|CRINFO_RTYPE
operator|)
operator|<<
name|CRINFO_RTYPE_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|dist2to
operator|&
name|CRINFO_DIST2TO
operator|)
operator|<<
name|CRINFO_DIST2TO_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|relvaddr
operator|&
name|CRINFO_RELVADDR
operator|)
operator|<<
name|CRINFO_RELVADDR_SH
operator|)
operator|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|l
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|konst
argument_list|,
name|ex
operator|->
name|konst
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|vaddr
argument_list|,
name|ex
operator|->
name|vaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in an options header.  */
end_comment

begin_function
name|void
name|bfd_mips_elf_swap_options_in
parameter_list|(
name|abfd
parameter_list|,
name|ex
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_External_Options
modifier|*
name|ex
decl_stmt|;
name|Elf_Internal_Options
modifier|*
name|in
decl_stmt|;
block|{
name|in
operator|->
name|kind
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|kind
argument_list|)
expr_stmt|;
name|in
operator|->
name|size
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|size
argument_list|)
expr_stmt|;
name|in
operator|->
name|section
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|section
argument_list|)
expr_stmt|;
name|in
operator|->
name|info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out an options header.  */
end_comment

begin_function
name|void
name|bfd_mips_elf_swap_options_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Options
modifier|*
name|in
decl_stmt|;
name|Elf_External_Options
modifier|*
name|ex
decl_stmt|;
block|{
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|kind
argument_list|,
name|ex
operator|->
name|kind
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|size
argument_list|,
name|ex
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|section
argument_list|,
name|ex
operator|->
name|section
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|info
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine whether a symbol is global for the purposes of splitting    the symbol table into global symbols and local symbols.  At least    on Irix 5, this split must be between section symbols and all other    symbols.  On most ELF targets the split is between static symbols    and externally visible symbols.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_sym_is_global
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
return|return
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the right machine number for a MIPS ELF file.  This is used for    both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
switch|switch
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
condition|)
block|{
default|default:
case|case
name|E_MIPS_ARCH_1
case|:
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mips
argument_list|,
literal|3000
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_2
case|:
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mips
argument_list|,
literal|6000
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_3
case|:
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mips
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_4
case|:
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mips
argument_list|,
literal|8000
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the right machine number for a 32-bit MIPS ELF file.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf32_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Irix 5 is broken.  Object file symbol tables are not always      sorted correctly such that local symbols precede global symbols,      and the sh_info field in the symbol table is not always right.  */
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|_bfd_mips_elf_object_p
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out a MIPS ELF object    file.  This gets the MIPS architecture right based on the machine    number.  This is used by both the 32-bit and the 64-bit ABI.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|_bfd_mips_elf_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|linker
decl_stmt|;
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
literal|3000
case|:
name|val
operator|=
name|E_MIPS_ARCH_1
expr_stmt|;
break|break;
case|case
literal|6000
case|:
name|val
operator|=
name|E_MIPS_ARCH_2
expr_stmt|;
break|break;
case|case
literal|4000
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
expr_stmt|;
break|break;
case|case
literal|8000
case|:
name|val
operator|=
name|E_MIPS_ARCH_4
expr_stmt|;
break|break;
default|default:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_MIPS_ARCH
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
comment|/* Set the sh_info field for .gptab sections.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_LIBLIST
case|:
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_GPTAB
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_CONTENT
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|,
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".liblist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_EVENTS
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|,
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|,
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
operator|(
name|name
operator|+
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to keep MIPS specific file flags like as EF_MIPS_PIC. */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy backend specific data from one object module to another */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|==
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
operator|)
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|obfd
argument_list|)
operator|=
name|elf_gp
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|old_flags
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
comment|/* Check if we have the same endianess */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|&&
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: compiled for a %s endian system and target is %s endian"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_big_endian
argument_list|(
name|ibfd
argument_list|)
condition|?
literal|"big"
else|:
literal|"little"
argument_list|,
name|bfd_big_endian
argument_list|(
name|obfd
argument_list|)
condition|?
literal|"big"
else|:
literal|"little"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_MIPS_NOREORDER
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
comment|/* Check flag compatibility.  */
name|new_flags
operator|&=
operator|~
name|EF_MIPS_NOREORDER
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_NOREORDER
expr_stmt|;
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
return|return
name|true
return|;
name|ok
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_PIC
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_PIC
operator|)
condition|)
block|{
name|new_flags
operator|&=
operator|~
name|EF_MIPS_PIC
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_PIC
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: linking PIC files with non-PIC files"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_CPIC
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_CPIC
operator|)
condition|)
block|{
name|new_flags
operator|&=
operator|~
name|EF_MIPS_CPIC
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_CPIC
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: linking abicalls files with non-abicalls files"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
comment|/* Don't warn about mixing -mips1 and -mips2 code, or mixing -mips3      and -mips4 code.  They will normally use the same data sizes and      calling conventions.  */
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_ARCH
operator|)
condition|)
block|{
name|int
name|new_isa
decl_stmt|,
name|old_isa
decl_stmt|;
name|new_isa
operator|=
name|elf_mips_isa
argument_list|(
name|new_flags
argument_list|)
expr_stmt|;
name|old_isa
operator|=
name|elf_mips_isa
argument_list|(
name|old_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_isa
operator|==
literal|1
operator|||
name|new_isa
operator|==
literal|2
operator|)
condition|?
operator|(
name|old_isa
operator|!=
literal|1
operator|&&
name|old_isa
operator|!=
literal|2
operator|)
else|:
operator|(
name|old_isa
operator|==
literal|1
operator|||
name|old_isa
operator|==
literal|2
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: ISA mismatch (-mips%d) with previous modules (-mips%d)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|new_isa
argument_list|,
name|old_isa
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
name|new_flags
operator|&=
operator|~
name|EF_MIPS_ARCH
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_ARCH
expr_stmt|;
block|}
comment|/* Warn about any other mismatches */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle a MIPS specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.    This routine supports both the 32-bit and 64-bit ELF ABI.     FIXME: We need to handle the SHF_MIPS_GPREL flag, but I'm not sure    how to.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  Fortunately, the ABI gives      suggested names for all the MIPS specific sections, so we will      probably get away with this.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_LIBLIST
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".liblist"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_MSYM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".msym"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_CONFLICT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".conflict"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_GPTAB
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_UCODE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ucode"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_DEBUG
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_REGINFO
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|!=
literal|0
operator|||
name|hdr
operator|->
name|sh_size
operator|!=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_IFACE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.interfaces"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_CONTENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|,
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_OPTIONS
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".options"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.options"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_DWARF
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|,
sizeof|sizeof
expr|".debug_"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.symlib"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SHT_MIPS_EVENTS
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|,
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|,
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_DEBUG
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
operator||
name|SEC_DEBUGGING
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle a 32-bit MIPS ELF specific section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf32_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|_bfd_mips_elf_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* FIXME: We should record sh_info for a .gptab section.  */
comment|/* For a .reginfo section, set the gp value in the tdata information      from the contents of this section.  We need the gp value while      processing relocs, so we just get it now.  The .reginfo section      is not used in the 64-bit MIPS ELF ABI.  */
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_REGINFO
condition|)
block|{
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|Elf32_RegInfo
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|s
operator|.
name|ri_gp_value
expr_stmt|;
block|}
comment|/* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and      set the gp value based on what we find.  We may see both      SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,      they should agree.  */
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|lend
decl_stmt|;
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|l
operator|=
name|contents
expr_stmt|;
name|lend
operator|=
name|contents
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
while|while
condition|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|<=
name|lend
condition|)
block|{
name|Elf_Internal_Options
name|intopt
decl_stmt|;
name|bfd_mips_elf_swap_options_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|l
argument_list|,
operator|&
name|intopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|Elf32_RegInfo
name|intreg
decl_stmt|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|Elf32_External_RegInfo
operator|*
operator|)
operator|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|intreg
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|intreg
operator|.
name|ri_gp_value
expr_stmt|;
block|}
name|l
operator|+=
name|intopt
operator|.
name|size
expr_stmt|;
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for a MIPS ELF section.  We do this by the    section name, which is a hack, but ought to work.  This routine is    used by both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".liblist"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_LIBLIST
expr_stmt|;
name|hdr
operator|->
name|sh_info
operator|=
name|sec
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_Lib
argument_list|)
expr_stmt|;
comment|/* The sh_link field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".msym"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_MSYM
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
literal|8
expr_stmt|;
comment|/* FIXME: Set the sh_info field.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".conflict"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_CONFLICT
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_GPTAB
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
comment|/* The sh_info field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ucode"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_UCODE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_DEBUG
expr_stmt|;
comment|/* In a shared object on Irix 5.3, the .mdebug section has an          entsize of 0.  FIXME: Does this matter?  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_REGINFO
expr_stmt|;
comment|/* In a shared object on Irix 5.3, the .reginfo section has an          entsize of 0x18.  FIXME: Does this matter?  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
comment|/* Force the section size to the correct value, even if the 	 linker thinks it is larger.  The link routine below will only 	 write out this much data for .reginfo.  */
name|hdr
operator|->
name|sh_size
operator|=
name|sec
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".hash"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|sh_info
operator|=
name|SIZEOF_MIPS_DYNSYM_SECNAMES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_GPREL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.interfaces"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_IFACE
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_CONTENT
expr_stmt|;
comment|/* The sh_info field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".options"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.options"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_OPTIONS
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|,
sizeof|sizeof
expr|".debug_"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_DWARF
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.symlib"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_SYMBOL_LIB
expr_stmt|;
comment|/* The sh_link and sh_info fields are set in          final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|,
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|,
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_EVENTS
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
comment|/* The sh_link field is set in final_write_processing.  */
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Given a BFD section, try to locate the corresponding ELF section    index.  This is used by both the 32-bit and the 64-bit ABI.    Actually, it's not clear to me that the 64-bit ABI supports these,    but for non-PIC objects we will certainly want support for at least    the .scommon section.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_section_from_bfd_section
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|,
name|retval
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_MIPS_SCOMMON
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".acommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_MIPS_ACOMMON
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* When are writing out the .options or .MIPS.options section,    remember the bytes we are writing out, so that we can install the    GP value in the section_processing routine.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".options"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".MIPS.options"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|section
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_elf_section_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|c
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|tdata
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|size
operator|=
name|section
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|size
operator|=
name|section
operator|->
name|_raw_size
expr_stmt|;
name|c
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|c
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|c
operator|+
name|offset
argument_list|,
name|location
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|_bfd_elf_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Work over a section just before writing it out.  This routine is    used by both the 32-bit and the 64-bit ABI.  FIXME: We recognize    sections that need the SHF_MIPS_GPREL flag by name; there has to be    a better way.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_section_processing
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
block|{
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".compact_rel"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rtproc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_addralign
operator|!=
literal|0
operator|&&
name|hdr
operator|->
name|sh_entsize
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|adjust
decl_stmt|;
name|adjust
operator|=
name|hdr
operator|->
name|sh_size
operator|%
name|hdr
operator|->
name|sh_addralign
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_size
operator|+=
name|hdr
operator|->
name|sh_addralign
operator|-
name|adjust
expr_stmt|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Work over a section just before writing it out.  We update the GP    value in the SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS sections based    on the value we are using.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf32_section_processing
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_REGINFO
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_size
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|contents
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
operator|-
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
operator|&&
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|->
name|tdata
operator|!=
name|NULL
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|lend
decl_stmt|;
comment|/* We stored the section contents in the elf_section_data tdata 	 field in the set_section_contents routine.  We save the 	 section contents so that we don't have to read them again. 	 At this point we know that elf_gp is set, so we can look 	 through the section contents to see if there is an 	 ODK_REGINFO structure.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|l
operator|=
name|contents
expr_stmt|;
name|lend
operator|=
name|contents
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
while|while
condition|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|<=
name|lend
condition|)
block|{
name|Elf_Internal_Options
name|intopt
decl_stmt|;
name|bfd_mips_elf_swap_options_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|l
argument_list|,
operator|&
name|intopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|hdr
operator|->
name|sh_offset
operator|+
operator|(
name|l
operator|-
name|contents
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
operator|-
literal|4
operator|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
block|}
name|l
operator|+=
name|intopt
operator|.
name|size
expr_stmt|;
block|}
block|}
return|return
name|_bfd_mips_elf_section_processing
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* MIPS ELF uses two common sections.  One is the usual one, and the    other is for small objects.  All the small objects are kept    together, and then referenced via the gp pointer, which yields    faster assembler code.  This is what we use for the small common    section.  This approach is copied from ecoff.c.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_scom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MIPS ELF also uses an acommon section, which represents an    allocated common symbol which may be overridden by a    definition in a shared library.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_acom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_acom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_acom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Irix 5 support uses two virtual sections, which represent    text/data symbols defined in dynamic objects.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_text_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mips_elf_text_section_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_text_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_text_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_data_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mips_elf_data_section_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_data_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_data_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the special MIPS section numbers that a symbol may use.    This is used for both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_symbol_processing
parameter_list|(
name|abfd
parameter_list|,
name|asym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|asym
decl_stmt|;
block|{
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
name|elfsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
expr_stmt|;
switch|switch
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
condition|)
block|{
case|case
name|SHN_MIPS_ACOMMON
case|:
comment|/* This section is used in a dynamically linked executable file. 	 It is an allocated common section.  The dynamic linker can 	 either resolve these symbols to something in a shared 	 library, or it can just leave them here.  For our purposes, 	 we can consider these symbols to be in a new section.  */
if|if
condition|(
name|mips_elf_acom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the acommon section.  */
name|mips_elf_acom_section
operator|.
name|name
operator|=
literal|".acommon"
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|output_section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_acom_symbol
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_acom_symbol_ptr
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|name
operator|=
literal|".acommon"
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
name|mips_elf_acom_symbol_ptr
operator|=
operator|&
name|mips_elf_acom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
break|break;
case|case
name|SHN_COMMON
case|:
comment|/* Common symbols less than the GP size are automatically 	 treated as SHN_MIPS_SCOMMON symbols.  */
if|if
condition|(
name|asym
operator|->
name|value
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_MIPS_SCOMMON
case|:
if|if
condition|(
name|mips_elf_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|mips_elf_scom_section
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|output_section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_scom_symbol
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_scom_symbol_ptr
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|mips_elf_scom_symbol_ptr
operator|=
operator|&
name|mips_elf_scom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_SUNDEFINED
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* for SGI_COMPAT */
block|case SHN_MIPS_TEXT:       asym->section = mips_elf_text_section_ptr;       break;      case SHN_MIPS_DATA:       asym->section = mips_elf_data_section_ptr;       break;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When creating an Irix 5 executable, we need REGINFO and RTPROC    segments.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_additional_program_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|ret
return|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We need a PT_MIPS_REGINFO segment.  */
operator|++
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* We need a PT_MIPS_RTPROC segment.  */
operator|++
name|ret
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Modify the segment map for an Irix 5 executable.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_modify_segment_map
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|pm
decl_stmt|;
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If there is a .reginfo section, we need a PT_MIPS_REGINFO      segment.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_MIPS_REGINFO
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_MIPS_REGINFO
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
comment|/* We want to put it after the PHDR and INTERP segments.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_PHDR
operator|||
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_INTERP
operator|)
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* If there are .dynamic and .mdebug sections, we make a room for      the RTPROC header.  FIXME: Rewrite without section names.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
operator|==
name|NULL
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_MIPS_RTPROC
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_MIPS_RTPROC
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
block|}
comment|/* We want to put it after the DYNAMIC segment.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|!=
name|PT_DYNAMIC
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|pm
operator|!=
name|NULL
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* On Irix 5, the PT_DYNAMIC segment includes the .dynamic, .dynstr,      .dynsym, and .hash sections, and everything in between.  */
for|for
control|(
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
operator|*
name|pm
operator|!=
name|NULL
condition|;
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_DYNAMIC
condition|)
break|break;
name|m
operator|=
operator|*
name|pm
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|count
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|sec_names
index|[]
init|=
block|{
literal|".dynamic"
block|,
literal|".dynstr"
block|,
literal|".dynsym"
block|,
literal|".hash"
block|}
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|n
decl_stmt|;
name|low
operator|=
literal|0xffffffff
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|sec_names
operator|/
sizeof|sizeof
name|sec_names
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sec_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
name|low
operator|>
name|s
operator|->
name|vma
condition|)
name|low
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|sz
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
name|sz
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|high
operator|<
name|s
operator|->
name|vma
operator|+
name|sz
condition|)
name|high
operator|=
name|s
operator|->
name|vma
operator|+
name|sz
expr_stmt|;
block|}
block|}
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|vma
operator|>=
name|low
operator|&&
operator|(
operator|(
name|s
operator|->
name|vma
operator|+
operator|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
operator|)
operator|<=
name|high
operator|)
condition|)
operator|++
name|c
expr_stmt|;
name|n
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
expr|*
name|n
operator|+
operator|(
name|c
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|*
name|n
operator|=
operator|*
name|m
expr_stmt|;
name|n
operator|->
name|count
operator|=
name|c
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|vma
operator|>=
name|low
operator|&&
operator|(
operator|(
name|s
operator|->
name|vma
operator|+
operator|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
operator|)
operator|<=
name|high
operator|)
condition|)
block|{
name|n
operator|->
name|sections
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
operator|*
name|pm
operator|=
name|n
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The structure of the runtime procedure descriptor created by the    loader for use by the static exception system.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|runtime_pdr
block|{
name|bfd_vma
name|adr
decl_stmt|;
comment|/* memory address of start of procedure */
name|long
name|regmask
decl_stmt|;
comment|/* save register mask */
name|long
name|regoffset
decl_stmt|;
comment|/* save register offset */
name|long
name|fregmask
decl_stmt|;
comment|/* save floating point register mask */
name|long
name|fregoffset
decl_stmt|;
comment|/* save floating point register offset */
name|long
name|frameoffset
decl_stmt|;
comment|/* frame size */
name|short
name|framereg
decl_stmt|;
comment|/* frame pointer register */
name|short
name|pcreg
decl_stmt|;
comment|/* offset or reg of return pc */
name|long
name|irpss
decl_stmt|;
comment|/* index into the runtime string table */
name|long
name|reserved
decl_stmt|;
name|struct
name|exception_info
modifier|*
name|exception_info
decl_stmt|;
comment|/* pointer to exception array */
block|}
name|RPDR
operator|,
typedef|*
name|pRPDR
typedef|;
end_typedef

begin_define
define|#
directive|define
name|cbRPDR
value|sizeof(RPDR)
end_define

begin_define
define|#
directive|define
name|rpdNil
value|((pRPDR) 0)
end_define

begin_comment
comment|/* Swap RPDR (runtime procedure table entry) for output.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ecoff_swap_rpdr_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|RPDR
operator|*
operator|,
expr|struct
name|rpdr_ext
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ecoff_swap_rpdr_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|RPDR
modifier|*
name|in
decl_stmt|;
name|struct
name|rpdr_ext
modifier|*
name|ex
decl_stmt|;
block|{
comment|/* ecoff_put_off was defined in ecoffswap.h.  */
name|ecoff_put_off
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|adr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|p_adr
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|regmask
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|p_regmask
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|regoffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|p_regoffset
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|fregmask
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|p_fregmask
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|fregoffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|p_fregoffset
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|frameoffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|p_frameoffset
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|framereg
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|p_framereg
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|pcreg
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|p_pcreg
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|irpss
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ex
operator|->
name|p_irpss
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME */
block|ecoff_put_off (abfd, in->exception_info, (bfd_byte *) ex->p_exception_info);
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read ECOFF debugging information from a .mdebug section into a    ecoff_debug_info structure.  */
end_comment

begin_function
name|boolean
name|_bfd_mips_elf_read_ecoff_info
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|debug
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|char
modifier|*
name|ext_hdr
init|=
name|NULL
decl_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|ext_hdr
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|swap
operator|->
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_hdr
operator|==
name|NULL
operator|&&
name|swap
operator|->
name|external_hdr_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|ext_hdr
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|swap
operator|->
name|external_hdr_size
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
name|symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_hdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ext_hdr
argument_list|,
name|symhdr
argument_list|)
expr_stmt|;
comment|/* The symbolic header contains absolute file offsets and sizes to      read.  */
define|#
directive|define
name|READ
parameter_list|(
name|ptr
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|,
name|type
parameter_list|)
define|\
value|if (symhdr->count == 0)						\     debug->ptr = NULL;							\   else									\     {									\       debug->ptr = (type) bfd_malloc ((size_t) (size * symhdr->count));	\       if (debug->ptr == NULL)						\ 	goto error_return;						\       if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\ 	  || (bfd_read (debug->ptr, size, symhdr->count,		\ 			abfd) != size * symhdr->count))			\ 	goto error_return;						\     }
name|READ
argument_list|(
argument|line
argument_list|,
argument|cbLineOffset
argument_list|,
argument|cbLine
argument_list|,
argument|sizeof (unsigned char)
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|READ
argument_list|(
name|external_dnr
argument_list|,
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_pdr
argument_list|,
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_sym
argument_list|,
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_opt
argument_list|,
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_aux
argument_list|,
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ss
argument_list|,
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ssext
argument_list|,
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_fdr
argument_list|,
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_rfd
argument_list|,
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_ext
argument_list|,
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|READ
name|debug
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|adjust
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|ext_hdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ext_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_dnr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_dnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_pdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_pdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_sym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_aux
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ssext
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_fdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_fdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_rfd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_ext
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* MIPS ELF local labels start with '$', not 'L'.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
return|return
name|true
return|;
comment|/* On Irix 6, the labels go back to starting with '.', so we accept      the generic ELF local label syntax as well.  */
return|return
name|_bfd_elf_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* MIPS ELF uses a special find_nearest_line routine in order the    handle the ECOFF debugging information.  */
end_comment

begin_struct
struct|struct
name|mips_elf_find_line
block|{
name|struct
name|ecoff_debug_info
name|d
decl_stmt|;
name|struct
name|ecoff_find_line
name|i
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|boolean
name|_bfd_mips_elf_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|_bfd_dwarf2_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
return|return
name|true
return|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msec
operator|!=
name|NULL
condition|)
block|{
name|flagword
name|origflags
decl_stmt|;
name|struct
name|mips_elf_find_line
modifier|*
name|fi
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
comment|/* If we are called during a link, mips_elf_final_link may have 	 cleared the SEC_HAS_CONTENTS field.  We force it back on here 	 if appropriate (which it normally will be).  */
name|origflags
operator|=
name|msec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|msec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|msec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|fi
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|external_fdr_size
decl_stmt|;
name|char
modifier|*
name|fraw_src
decl_stmt|;
name|char
modifier|*
name|fraw_end
decl_stmt|;
name|struct
name|fdr
modifier|*
name|fdr_ptr
decl_stmt|;
name|fi
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_find_line
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_find_line
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_mips_elf_read_ecoff_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Swap in the FDR information.  */
name|fi
operator|->
name|d
operator|.
name|fdr
operator|=
operator|(
operator|(
expr|struct
name|fdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fdr
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|d
operator|.
name|fdr
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|false
return|;
block|}
name|external_fdr_size
operator|=
name|swap
operator|->
name|external_fdr_size
expr_stmt|;
name|fdr_ptr
operator|=
name|fi
operator|->
name|d
operator|.
name|fdr
expr_stmt|;
name|fraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|fi
operator|->
name|d
operator|.
name|external_fdr
expr_stmt|;
name|fraw_end
operator|=
operator|(
name|fraw_src
operator|+
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
name|external_fdr_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|fraw_src
operator|<
name|fraw_end
condition|;
name|fraw_src
operator|+=
name|external_fdr_size
operator|,
name|fdr_ptr
operator|++
control|)
call|(
modifier|*
name|swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|fraw_src
argument_list|,
name|fdr_ptr
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
operator|=
name|fi
expr_stmt|;
comment|/* Note that we don't bother to ever free this information.              find_nearest_line is either called all the time, as in              objdump -l, so the information should be saved, or it is              rarely called, as in ld error messages, so the memory              wasted is unimportant.  Still, it would probably be a              good idea for free_cached_info to throw it away.  */
block|}
if|if
condition|(
name|_bfd_ecoff_locate_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|,
name|swap
argument_list|,
operator|&
name|fi
operator|->
name|i
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|true
return|;
block|}
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
block|}
comment|/* Fall back on the generic ELF find_nearest_line routine.  */
return|return
name|_bfd_elf_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The mips16 compiler uses a couple of special sections to handle      floating point arguments.       Section names that look like .mips16.fn.FNNAME contain stubs that      copy floating point arguments from the fp regs to the gp regs and      then jump to FNNAME.  If any 32 bit function calls FNNAME, the      call should be redirected to the stub instead.  If no 32 bit      function calls FNNAME, the stub should be discarded.  We need to      consider any reference to the function, not just a call, because      if the address of the function is taken we will need the stub,      since the address might be passed to a 32 bit function.       Section names that look like .mips16.call.FNNAME contain stubs      that copy floating point arguments from the gp regs to the fp      regs and then jump to FNNAME.  If FNNAME is a 32 bit function,      then any 16 bit function that calls FNNAME should be redirected      to the stub instead.  If FNNAME is not a 32 bit function, the      stub should be discarded.       .mips16.call.fp.FNNAME sections are similar, but contain stubs      which call FNNAME and then copy the return value from the fp regs      to the gp regs.  These stubs store the return value in $18 while      calling FNNAME; any function which might call one of these stubs      must arrange to save $18 around the call.  (This case is not      needed for 32 bit functions that call 16 bit functions, because      16 bit functions always return floating point values in both      $f0/$f1 and $2/$3.)       Note that in all cases FNNAME might be defined statically.      Therefore, FNNAME is not used literally.  Instead, the relocation      information will indicate which symbol the section is for.       We record any stubs that we find in the symbol table.  */
end_comment

begin_define
define|#
directive|define
name|FN_STUB
value|".mips16.fn."
end_define

begin_define
define|#
directive|define
name|CALL_STUB
value|".mips16.call."
end_define

begin_define
define|#
directive|define
name|CALL_FP_STUB
value|".mips16.call.fp."
end_define

begin_comment
comment|/* The MIPS ELF linker needs additional information for each symbol in    the global hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* External symbol information.  */
name|EXTR
name|esym
decl_stmt|;
comment|/* Number of MIPS_32 or MIPS_REL32 relocs against this symbol.  */
name|unsigned
name|int
name|mips_32_relocs
decl_stmt|;
comment|/* If there is a stub that 32 bit functions should use to call this      16 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|fn_stub
decl_stmt|;
comment|/* Whether we need the fn_stub; this is set if this symbol appears      in any relocs other than a 16 bit call.  */
name|boolean
name|need_fn_stub
decl_stmt|;
comment|/* If there is a stub that 16 bit functions should use to call this      32 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|call_stub
decl_stmt|;
comment|/* This is like the call_stub field, but it is used if the function      being called returns a floating point value.  */
name|asection
modifier|*
name|call_fp_stub
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* MIPS ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* String section indices for the dynamic section symbols.  */
name|bfd_size_type
name|dynsym_sec_strindex
index|[
name|SIZEOF_MIPS_DYNSYM_SECNAMES
index|]
decl_stmt|;
comment|/* The number of .rtproc entries.  */
name|bfd_size_type
name|procedure_count
decl_stmt|;
comment|/* The size of the .compact_rel section (if SGI_COMPAT).  */
name|bfd_size_type
name|compact_rel_size
decl_stmt|;
comment|/* This flag indicates that the value of DT_MIPS_RLD_MAP dynamic      entry is set to the address of __rld_obj_head as in Irix 5. */
name|boolean
name|use_rld_obj_head
decl_stmt|;
comment|/* This is the value of the __rld_map or __rld_obj_head symbol.  */
name|bfd_vma
name|rld_value
decl_stmt|;
comment|/* This is set if we see any mips16 stub sections. */
name|boolean
name|mips16_stubs_seen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in a MIPS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct mips_elf_link_hash_entry *)					\    elf_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse a MIPS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the MIPS ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct mips_elf_link_hash_table *) ((p)->hash))
end_define

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_output_extsym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an entry in a MIPS ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|mips_elf_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|esym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use -2 as a marker to indicate that the information has 	 not been set.  -1 means there is no associated ifd.  */
name|ret
operator|->
name|esym
operator|.
name|ifd
operator|=
operator|-
literal|2
expr_stmt|;
name|ret
operator|->
name|mips_32_relocs
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|fn_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|need_fn_stub
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|call_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|call_fp_stub
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create a MIPS ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|mips_elf_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|mips_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|mips_elf_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|mips_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF_MIPS_DYNSYM_SECNAMES
condition|;
name|i
operator|++
control|)
name|ret
operator|->
name|dynsym_sec_strindex
index|[
name|i
index|]
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|procedure_count
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|compact_rel_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|use_rld_obj_head
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|rld_value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|mips16_stubs_seen
operator|=
name|false
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We must handle the special MIPS section numbers here.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
name|flagword
modifier|*
name|flagsp
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_rld_new_interface"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip Irix 5 rld entry name.  */
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|sym
operator|->
name|st_shndx
condition|)
block|{
case|case
name|SHN_COMMON
case|:
comment|/* Common symbols less than the GP size are automatically 	 treated as SHN_MIPS_SCOMMON symbols.  */
if|if
condition|(
name|sym
operator|->
name|st_size
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_MIPS_SCOMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_TEXT
case|:
comment|/* This section is used in a shared object.  */
if|if
condition|(
name|mips_elf_text_section_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the section.  */
name|mips_elf_text_section
operator|.
name|name
operator|=
literal|".text"
expr_stmt|;
name|mips_elf_text_section
operator|.
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|mips_elf_text_section
operator|.
name|output_section
operator|=
name|NULL
expr_stmt|;
name|mips_elf_text_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_text_symbol
expr_stmt|;
name|mips_elf_text_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_text_symbol_ptr
expr_stmt|;
name|mips_elf_text_symbol
operator|.
name|name
operator|=
literal|".text"
expr_stmt|;
name|mips_elf_text_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_text_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_text_section
expr_stmt|;
name|mips_elf_text_symbol_ptr
operator|=
operator|&
name|mips_elf_text_symbol
expr_stmt|;
name|mips_elf_text_section_ptr
operator|=
operator|&
name|mips_elf_text_section
expr_stmt|;
block|}
comment|/* This code used to do *secp = bfd_und_section_ptr if          info->shared.  I don't know why, and that doesn't make sense,          so I took it out.  */
operator|*
name|secp
operator|=
name|mips_elf_text_section_ptr
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_ACOMMON
case|:
comment|/* Fall through. XXX Can we treat this as allocated data?  */
case|case
name|SHN_MIPS_DATA
case|:
comment|/* This section is used in a shared object.  */
if|if
condition|(
name|mips_elf_data_section_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the section.  */
name|mips_elf_data_section
operator|.
name|name
operator|=
literal|".data"
expr_stmt|;
name|mips_elf_data_section
operator|.
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|mips_elf_data_section
operator|.
name|output_section
operator|=
name|NULL
expr_stmt|;
name|mips_elf_data_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_data_symbol
expr_stmt|;
name|mips_elf_data_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_data_symbol_ptr
expr_stmt|;
name|mips_elf_data_symbol
operator|.
name|name
operator|=
literal|".data"
expr_stmt|;
name|mips_elf_data_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_data_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_data_section
expr_stmt|;
name|mips_elf_data_symbol_ptr
operator|=
operator|&
name|mips_elf_data_symbol
expr_stmt|;
name|mips_elf_data_section_ptr
operator|=
operator|&
name|mips_elf_data_section
expr_stmt|;
block|}
comment|/* This code used to do *secp = bfd_und_section_ptr if          info->shared.  I don't know why, and that doesn't make sense,          so I took it out.  */
operator|*
name|secp
operator|=
name|mips_elf_data_section_ptr
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_SUNDEFINED
case|:
operator|*
name|secp
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
operator|&&
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"__rld_obj_head"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Mark __rld_obj_head as dynamic.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|BSF_GLOBAL
argument_list|,
operator|*
name|secp
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|*
name|valp
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|=
name|true
expr_stmt|;
block|}
comment|/* If this is a mips16 text symbol, add 1 to the value to make it      odd.  This will cause something like .word SYM to come up with      the right value when it is loaded into the PC.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
operator|++
operator|*
name|valp
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Structure used to pass information to mips_elf_output_extsym.  */
end_comment

begin_struct
struct|struct
name|extsym_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|boolean
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This routine is used to write out ECOFF debugging external symbol    information.  It is called via mips_elf_link_hash_traverse.  The    ECOFF external symbol information must match the ELF external    symbol information.  Unfortunately, at this point we don't know    whether a symbol is required by reloc information, so the two    tables may wind up being different.  We must sort out the external    symbol information before we can set the final size of the .mdebug    section, and we must set the size of the .mdebug section before we    can relocate any sections, and we can't know which symbols are    required by relocation until we relocate the sections.    Fortunately, it is relatively unlikely that any symbol will be    stripped but required by a reloc.  In particular, it can not happen    when generating a final executable.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_output_extsym
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|extsym_info
modifier|*
name|einfo
init|=
operator|(
expr|struct
name|extsym_info
operator|*
operator|)
name|data
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|output_section
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|einfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|true
expr_stmt|;
else|else
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strip
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|ifd
operator|==
operator|-
literal|2
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Use undefined class.  Also, set class and type for some              special symbols.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|mips_elf_hash_table
argument_list|(
name|einfo
operator|->
name|info
argument_list|)
operator|->
name|procedure_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|elf_gp
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
comment|/* When making a shared library and symbol h is the one from 	     the another shared library, OUTPUT_SECTION may be null.  */
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_section_name
argument_list|(
name|output_section
operator|->
name|owner
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scText
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rodata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scRData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scInit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scFini
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
block|}
block|}
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Set type and value for a symbol with a function stub.  */
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stProc
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|plt_offset
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME?  */
block|h->esym.ifd = 0;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|,
name|einfo
operator|->
name|debug
argument_list|,
name|einfo
operator|->
name|swap
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|h
operator|->
name|esym
argument_list|)
condition|)
block|{
name|einfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a runtime procedure table from the .mdebug section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_create_procedure_table
parameter_list|(
name|handle
parameter_list|,
name|abfd
parameter_list|,
name|info
parameter_list|,
name|s
parameter_list|,
name|debug
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|HDRR
modifier|*
name|hdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|RPDR
modifier|*
name|rpdr
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|struct
name|rpdr_ext
modifier|*
name|erp
decl_stmt|;
name|PTR
name|rtproc
decl_stmt|;
name|struct
name|pdr_ext
modifier|*
name|epdr
decl_stmt|;
name|struct
name|sym_ext
modifier|*
name|esym
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|,
modifier|*
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|long
name|sindex
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|PDR
name|pdr
decl_stmt|;
name|SYMR
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|no_name_func
init|=
literal|"static procedure (no name)"
decl_stmt|;
name|epdr
operator|=
name|NULL
expr_stmt|;
name|rpdr
operator|=
name|NULL
expr_stmt|;
name|esym
operator|=
name|NULL
expr_stmt|;
name|ss
operator|=
name|NULL
expr_stmt|;
name|sv
operator|=
name|NULL
expr_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|sindex
operator|=
name|strlen
argument_list|(
name|no_name_func
argument_list|)
operator|+
literal|1
expr_stmt|;
name|count
operator|=
name|hdr
operator|->
name|ipdMax
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|size
operator|=
name|swap
operator|->
name|external_pdr_size
expr_stmt|;
name|epdr
operator|=
operator|(
expr|struct
name|pdr_ext
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|epdr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_pdr
argument_list|(
name|handle
argument_list|,
operator|(
name|PTR
operator|)
name|epdr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|RPDR
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rpdr
operator|=
operator|(
name|RPDR
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|isymMax
expr_stmt|;
name|size
operator|=
name|swap
operator|->
name|external_sym_size
expr_stmt|;
name|esym
operator|=
operator|(
expr|struct
name|sym_ext
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_sym
argument_list|(
name|handle
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|issMax
expr_stmt|;
name|ss
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_ss
argument_list|(
name|handle
argument_list|,
operator|(
name|PTR
operator|)
name|ss
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|ipdMax
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
call|(
modifier|*
name|swap
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|epdr
operator|+
name|i
argument_list|)
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|esym
index|[
name|pdr
operator|.
name|isym
index|]
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|rp
operator|->
name|adr
operator|=
name|sym
operator|.
name|value
expr_stmt|;
name|rp
operator|->
name|regmask
operator|=
name|pdr
operator|.
name|regmask
expr_stmt|;
name|rp
operator|->
name|regoffset
operator|=
name|pdr
operator|.
name|regoffset
expr_stmt|;
name|rp
operator|->
name|fregmask
operator|=
name|pdr
operator|.
name|fregmask
expr_stmt|;
name|rp
operator|->
name|fregoffset
operator|=
name|pdr
operator|.
name|fregoffset
expr_stmt|;
name|rp
operator|->
name|frameoffset
operator|=
name|pdr
operator|.
name|frameoffset
expr_stmt|;
name|rp
operator|->
name|framereg
operator|=
name|pdr
operator|.
name|framereg
expr_stmt|;
name|rp
operator|->
name|pcreg
operator|=
name|pdr
operator|.
name|pcreg
expr_stmt|;
name|rp
operator|->
name|irpss
operator|=
name|sindex
expr_stmt|;
name|sv
index|[
name|i
index|]
operator|=
name|ss
operator|+
name|sym
operator|.
name|iss
expr_stmt|;
name|sindex
operator|+=
name|strlen
argument_list|(
name|sv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
operator|*
operator|(
name|count
operator|+
literal|2
operator|)
operator|+
name|sindex
expr_stmt|;
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|rtproc
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc
operator|==
name|NULL
condition|)
block|{
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
operator|=
literal|0
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
operator|=
name|count
operator|+
literal|2
expr_stmt|;
name|erp
operator|=
operator|(
expr|struct
name|rpdr_ext
operator|*
operator|)
name|rtproc
expr_stmt|;
name|memset
argument_list|(
name|erp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
argument_list|)
expr_stmt|;
name|erp
operator|++
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|rtproc
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
operator|*
operator|(
name|count
operator|+
literal|2
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|no_name_func
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|no_name_func
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ecoff_swap_rpdr_out
argument_list|(
name|abfd
argument_list|,
name|rpdr
operator|+
name|i
argument_list|,
name|erp
operator|+
name|i
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|sv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|sv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|ecoff_put_off
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|erp
operator|+
name|count
operator|)
operator|->
name|p_adr
argument_list|)
expr_stmt|;
comment|/* Set the size and contents of .rtproc section.  */
name|s
operator|->
name|_raw_size
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|rtproc
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently      matters, but someday it might).  */
name|s
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|epdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|epdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rpdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|epdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|epdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rpdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A comparison routine used to sort .gptab entries.  */
end_comment

begin_function
specifier|static
name|int
name|gptab_compare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
specifier|const
name|Elf32_gptab
modifier|*
name|a1
init|=
operator|(
specifier|const
name|Elf32_gptab
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|Elf32_gptab
modifier|*
name|a2
init|=
operator|(
specifier|const
name|Elf32_gptab
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|a1
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|-
name|a2
operator|->
name|gt_entry
operator|.
name|gt_g_value
return|;
block|}
end_function

begin_comment
comment|/* We need to use a special link routine to handle the .reginfo and    the .mdebug sections.  We need to merge all instances of these    sections together, not write them all out sequentially.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|reginfo_sec
decl_stmt|,
modifier|*
name|mdebug_sec
decl_stmt|,
modifier|*
name|gptab_data_sec
decl_stmt|,
modifier|*
name|gptab_bss_sec
decl_stmt|;
name|asection
modifier|*
name|rtproc_sec
decl_stmt|;
name|Elf32_RegInfo
name|reginfo
decl_stmt|;
name|struct
name|ecoff_debug_info
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
init|=
operator|&
name|debug
operator|.
name|symbolic_header
decl_stmt|;
name|PTR
name|mdebug_handle
init|=
name|NULL
decl_stmt|;
comment|/* Drop the .options section, since it has special semantics which I      haven't bothered to figure out.  */
for|for
control|(
name|secpp
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|secpp
operator|!=
name|NULL
condition|;
name|secpp
operator|=
operator|&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|secpp
operator|)
operator|->
name|name
argument_list|,
literal|".options"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
operator|(
operator|*
name|secpp
operator|)
operator|->
name|link_order_head
operator|=
name|NULL
expr_stmt|;
operator|*
name|secpp
operator|=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
break|break;
block|}
block|}
comment|/* Get a value for the GP register.  */
if|if
condition|(
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|bfd_vma
name|lo
decl_stmt|;
comment|/* Make up a value.  */
name|lo
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|o
operator|->
name|vma
operator|<
name|lo
operator|&&
operator|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|lo
operator|=
name|o
operator|->
name|vma
expr_stmt|;
block|}
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|lo
operator|+
name|ELF_MIPS_GP_OFFSET
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the relocate_section function needs to do a reloc 	     involving the GP value, it should make a reloc_dangerous 	     callback to warn that GP is not defined.  */
block|}
block|}
comment|/* Go through the sections and collect the .reginfo and .mdebug      information.  */
name|reginfo_sec
operator|=
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_data_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_bss_sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|reginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|reginfo
argument_list|)
expr_stmt|;
comment|/* We have found the .reginfo section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|Elf32_RegInfo
name|sub
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* The linker emulation code has probably clobbered the                  size to be zero bytes.  */
if|if
condition|(
name|input_section
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|input_section
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|sub
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator||=
name|sub
operator|.
name|ri_gprmask
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|0
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|1
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|2
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|3
index|]
expr_stmt|;
comment|/* ri_gp_value is set by the function 		 mips_elf32_section_processing when the section is 		 finally written out.  */
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Force the section size to the value we want.  */
name|o
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
name|reginfo_sec
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|extsym_info
name|einfo
decl_stmt|;
comment|/* We have found the .mdebug section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
name|symhdr
operator|->
name|magic
operator|=
name|swap
operator|->
name|sym_magic
expr_stmt|;
comment|/* FIXME: What should the version stamp be?  */
name|symhdr
operator|->
name|vstamp
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* We accumulate the debugging information itself in the 	     debug_info structure.  */
name|debug
operator|.
name|line
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_dnr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_pdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_sym
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_opt
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_aux
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ss
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ssext
operator|=
name|debug
operator|.
name|ssext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_rfd
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_ext
operator|=
name|debug
operator|.
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
name|mdebug_handle
operator|=
name|bfd_ecoff_debug_init
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdebug_handle
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|bfd_vma
name|last
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|name
index|[]
init|=
block|{
literal|".text"
block|,
literal|".init"
block|,
literal|".fini"
block|,
literal|".data"
block|,
literal|".rodata"
block|,
literal|".sdata"
block|,
literal|".sbss"
block|,
literal|".bss"
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|sc
index|[]
init|=
block|{
name|scText
block|,
name|scInit
block|,
name|scFini
block|,
name|scData
block|,
name|scRData
block|,
name|scSData
block|,
name|scSBss
block|,
name|scBss
block|}
decl_stmt|;
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|iss
operator|=
name|issNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLocal
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|sc
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|last
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|name
index|[
name|i
index|]
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|input_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
name|input_debug
decl_stmt|;
name|char
modifier|*
name|eraw_src
decl_stmt|;
name|char
modifier|*
name|eraw_end
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* I don't know what a non MIPS ELF bfd would be 		     doing with a .mdebug section, but I don't really 		     want to deal with it.  */
continue|continue;
block|}
name|input_swap
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|size
operator|==
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
comment|/* The ECOFF linking code expects that we have already 		 read in the debugging information and set up an 		 ecoff_debug_info structure, so we do that now.  */
if|if
condition|(
operator|!
name|_bfd_mips_elf_read_ecoff_info
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|input_debug
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
operator|(
name|bfd_ecoff_debug_accumulate
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|input_bfd
argument_list|,
operator|&
name|input_debug
argument_list|,
name|input_swap
argument_list|,
name|info
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Loop through the external symbols.  For each one with 		 interesting information, try to find the symbol in 		 the linker global hash table and save the information 		 for the output external symbols.  */
name|eraw_src
operator|=
name|input_debug
operator|.
name|external_ext
expr_stmt|;
name|eraw_end
operator|=
operator|(
name|eraw_src
operator|+
operator|(
name|input_debug
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|*
name|input_swap
operator|->
name|external_ext_size
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|eraw_src
operator|<
name|eraw_end
condition|;
name|eraw_src
operator|+=
name|input_swap
operator|->
name|external_ext_size
control|)
block|{
name|EXTR
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|eraw_src
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scNil
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
condition|)
continue|continue;
name|name
operator|=
name|input_debug
operator|.
name|ssext
operator|+
name|ext
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|h
operator|=
name|mips_elf_link_hash_lookup
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|esym
operator|.
name|ifd
operator|!=
operator|-
literal|2
condition|)
continue|continue;
if|if
condition|(
name|ext
operator|.
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ext
operator|.
name|ifd
operator|<
name|input_debug
operator|.
name|symbolic_header
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
name|ext
operator|.
name|ifd
operator|=
name|input_debug
operator|.
name|ifdmap
index|[
name|ext
operator|.
name|ifd
index|]
expr_stmt|;
block|}
name|h
operator|->
name|esym
operator|=
name|ext
expr_stmt|;
block|}
comment|/* Free up the information we just read.  */
name|free
argument_list|(
name|input_debug
operator|.
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_dnr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_pdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_opt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_aux
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ssext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_fdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_rfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_ext
argument_list|)
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Create .rtproc section.  */
name|rtproc_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
init|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
decl_stmt|;
name|rtproc_sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|mips_elf_create_procedure_table
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|rtproc_sec
argument_list|,
operator|&
name|debug
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Build the external symbol information.  */
name|einfo
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|einfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|einfo
operator|.
name|debug
operator|=
operator|&
name|debug
expr_stmt|;
name|einfo
operator|.
name|swap
operator|=
name|swap
expr_stmt|;
name|einfo
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|mips_elf_link_hash_traverse
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_output_extsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|einfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|einfo
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* Set the size of the .mdebug section.  */
name|o
operator|->
name|_raw_size
operator|=
name|bfd_ecoff_debug_size
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|subname
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|Elf32_gptab
modifier|*
name|tab
decl_stmt|;
name|Elf32_External_gptab
modifier|*
name|ext_tab
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* The .gptab.sdata and .gptab.sbss sections hold 	     information describing how the small data area would 	     change depending upon the -G switch.  These sections 	     not used in executables files.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		     elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Skip this section later on (I don't think this 		 currently matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Really remove the section.  */
for|for
control|(
name|secpp
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|secpp
operator|!=
name|o
condition|;
name|secpp
operator|=
operator|&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|secpp
operator|=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
continue|continue;
block|}
comment|/* There is one gptab for initialized data, and one for 	     uninitialized data.  */
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sdata"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_data_sec
operator|=
name|o
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sbss"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_bss_sec
operator|=
name|o
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: illegal section name `%s'"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* The linker script always combines .gptab.data and 	     .gptab.sdata into .gptab.sdata, and likewise for 	     .gptab.bss and .gptab.sbss.  It is possible that there is 	     no .sdata or .sbss section in the output file, in which 	     case we must change the name of the output section.  */
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|o
operator|==
name|gptab_data_sec
condition|)
name|o
operator|->
name|name
operator|=
literal|".gptab.data"
expr_stmt|;
else|else
name|o
operator|->
name|name
operator|=
literal|".gptab.bss"
expr_stmt|;
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the first entry.  */
name|c
operator|=
literal|1
expr_stmt|;
name|tab
operator|=
operator|(
name|Elf32_gptab
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_current_g_value
operator|=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_unused
operator|=
literal|0
expr_stmt|;
comment|/* Combine the input sections.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|unsigned
name|long
name|last
decl_stmt|;
name|bfd_size_type
name|gpentry
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* Combine the gptab entries for this input section one 		 by one.  We know that the input gptab entries are 		 sorted by ascending -G value.  */
name|size
operator|=
name|bfd_section_size
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gpentry
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
init|;
name|gpentry
operator|<
name|size
condition|;
name|gpentry
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
control|)
block|{
name|Elf32_External_gptab
name|ext_gptab
decl_stmt|;
name|Elf32_gptab
name|int_gptab
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|add
decl_stmt|;
name|boolean
name|exact
decl_stmt|;
name|unsigned
name|int
name|look
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext_gptab
argument_list|,
name|gpentry
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_mips_elf32_swap_gptab_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext_gptab
argument_list|,
operator|&
name|int_gptab
argument_list|)
expr_stmt|;
name|val
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_g_value
expr_stmt|;
name|add
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|-
name|last
expr_stmt|;
name|exact
operator|=
name|false
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>=
name|val
condition|)
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|==
name|val
condition|)
name|exact
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exact
condition|)
block|{
name|Elf32_gptab
modifier|*
name|new_tab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
comment|/* We need a new table entry.  */
name|new_tab
operator|=
operator|(
operator|(
name|Elf32_gptab
operator|*
operator|)
name|bfd_realloc
argument_list|(
operator|(
name|PTR
operator|)
name|tab
argument_list|,
operator|(
name|c
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tab
operator|=
name|new_tab
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|val
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|add
expr_stmt|;
comment|/* Merge in the size for the next smallest -G 			 value, since that will be implied by this new 			 value.  */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|<
name|val
operator|&&
operator|(
name|max
operator|==
literal|0
operator|||
operator|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|)
operator|)
condition|)
name|max
operator|=
name|look
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
literal|0
condition|)
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|last
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
block|}
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* The table must be sorted by -G value.  */
if|if
condition|(
name|c
operator|>
literal|2
condition|)
name|qsort
argument_list|(
name|tab
operator|+
literal|1
argument_list|,
name|c
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tab
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gptab_compare
argument_list|)
expr_stmt|;
comment|/* Swap out the table.  */
name|ext_tab
operator|=
operator|(
operator|(
name|Elf32_External_gptab
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ext_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|bfd_mips_elf32_swap_gptab_out
argument_list|(
name|abfd
argument_list|,
name|tab
operator|+
name|i
argument_list|,
name|ext_tab
operator|+
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|o
operator|->
name|_raw_size
operator|=
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
name|o
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_tab
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Invoke the regular ELF backend linker to do all the work.  */
if|if
condition|(
operator|!
name|bfd_elf32_bfd_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now write out the computed sections.  */
if|if
condition|(
name|reginfo_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|bfd_mips_elf32_swap_reginfo_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reginfo
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|reginfo_sec
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|mdebug_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_write_accumulated_debug
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|,
name|mdebug_sec
operator|->
name|filepos
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_ecoff_debug_free
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gptab_data_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_data_sec
argument_list|,
name|gptab_data_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|gptab_data_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|gptab_bss_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_bss_sec
argument_list|,
name|gptab_bss_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|gptab_bss_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|rtproc_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
name|rtproc_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|rtproc_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle a MIPS ELF HI16 reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_relocate_hi16
parameter_list|(
name|input_bfd
parameter_list|,
name|relhi
parameter_list|,
name|rello
parameter_list|,
name|contents
parameter_list|,
name|addend
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relhi
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rello
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|addlo
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|relhi
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|addlo
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rello
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|addlo
operator|&=
literal|0xffff
expr_stmt|;
name|addend
operator|+=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|addlo
expr_stmt|;
if|if
condition|(
operator|(
name|addlo
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|addend
operator|-=
literal|0x10000
expr_stmt|;
if|if
condition|(
operator|(
name|addend
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|addend
operator|+=
literal|0x10000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
argument_list|,
name|contents
operator|+
name|relhi
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a MIPS ELF local GOT16 reloc.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_relocate_got_local
parameter_list|(
name|output_bfd
parameter_list|,
name|input_bfd
parameter_list|,
name|sgot
parameter_list|,
name|relhi
parameter_list|,
name|rello
parameter_list|,
name|contents
parameter_list|,
name|addend
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relhi
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rello
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|{
name|unsigned
name|int
name|assigned_gotno
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|addlo
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_vma
name|hipage
decl_stmt|;
name|bfd_byte
modifier|*
name|got_contents
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|relhi
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|addlo
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rello
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|addlo
operator|&=
literal|0xffff
expr_stmt|;
name|addend
operator|+=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|addlo
expr_stmt|;
if|if
condition|(
operator|(
name|addlo
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|addend
operator|-=
literal|0x10000
expr_stmt|;
if|if
condition|(
operator|(
name|addend
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|addend
operator|+=
literal|0x10000
expr_stmt|;
comment|/* Get a got entry representing requested hipage.  */
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assigned_gotno
operator|=
name|g
operator|->
name|assigned_gotno
expr_stmt|;
name|got_contents
operator|=
name|sgot
operator|->
name|contents
expr_stmt|;
name|hipage
operator|=
name|addend
operator|&
literal|0xffff0000
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIPS_RESERVED_GOTNO
init|;
name|i
operator|<
name|assigned_gotno
condition|;
name|i
operator|++
control|)
block|{
name|address
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|got_contents
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|hipage
operator|==
operator|(
name|address
operator|&
literal|0xffff0000
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|assigned_gotno
condition|)
block|{
if|if
condition|(
name|assigned_gotno
operator|>=
name|g
operator|->
name|local_gotno
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"more got entries are needed for hipage relocations"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|hipage
argument_list|,
name|got_contents
operator|+
name|assigned_gotno
operator|*
literal|4
argument_list|)
expr_stmt|;
operator|++
name|g
operator|->
name|assigned_gotno
expr_stmt|;
block|}
name|i
operator|=
operator|-
name|ELF_MIPS_GP_OFFSET
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|i
operator|*
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|i
operator|&
literal|0xffff
operator|)
argument_list|,
name|contents
operator|+
name|relhi
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle MIPS ELF CALL16 reloc and global GOT16 reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_relocate_global_got
parameter_list|(
name|input_bfd
parameter_list|,
name|rel
parameter_list|,
name|contents
parameter_list|,
name|offset
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|offset
operator|&
literal|0xffff
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relocate a MIPS ELF section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|size_t
name|locsymcount
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|,
modifier|*
name|sreloc
decl_stmt|,
modifier|*
name|scpt
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|||
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|scpt
operator|=
name|NULL
expr_stmt|;
else|else
name|scpt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".compact_rel"
argument_list|)
expr_stmt|;
name|g
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
block|}
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|mh
decl_stmt|;
name|int
name|other
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_MIPS_max
operator|)
operator|&&
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
name|r_type
operator|!=
name|R_MIPS16_GPREL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
name|howto
operator|=
operator|&
name|elf_mips16_jump_howto
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
condition|)
name|howto
operator|=
operator|&
name|elf_mips16_gprel_howto
expr_stmt|;
else|else
name|howto
operator|=
name|elf_mips_howto_table
operator|+
name|r_type
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|r_type
operator|==
name|R_MIPS_CALL16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT16
operator|||
name|r_type
operator|==
name|R_MIPS_CALL_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_CALL_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_LO16
operator|)
condition|)
block|{
comment|/* We need the .got section.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Mix in the change in GP address for a GP relative reloc.  */
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_GPREL16
operator|&&
name|r_type
operator|!=
name|R_MIPS_LITERAL
operator|&&
name|r_type
operator|!=
name|R_MIPS_GPREL32
operator|&&
name|r_type
operator|!=
name|R_MIPS16_GPREL
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
literal|"GP relative relocation when GP not defined"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Only give the error once per link.  */
name|gp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|local_sections
index|[
name|r_symndx
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* This is a relocation against a section.  The current 		 addend in the instruction is the difference between 		 INPUT_SECTION->vma and the GP value of INPUT_BFD.  We 		 must change this to be the difference between the 		 final definition (which will end up in RELOCATION) 		 and the GP value of OUTPUT_BFD (which is in GP).  */
name|addend
operator|=
name|elf_gp
argument_list|(
name|input_bfd
argument_list|)
operator|-
name|gp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* We are doing a final link.  The current addend in the 		 instruction is simply the desired offset into the 		 symbol (normally zero).  We want the instruction to 		 hold the difference between the final definition of 		 the symbol (which will end up in RELOCATION) and the 		 GP value of OUTPUT_BFD (which is in GP).  */
name|addend
operator|=
operator|-
name|gp
expr_stmt|;
block|}
else|else
block|{
comment|/* We are generating relocateable output, and we aren't 		 going to define this symbol, so we just leave the 		 instruction alone.  */
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|>=
name|locsymcount
operator|||
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|local_sections
index|[
name|r_symndx
index|]
operator|==
name|NULL
operator|)
condition|)
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
else|else
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
else|else
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* It would be logical to add sym->st_value here, 		     but Irix 5 sometimes generates a garbage symbol 		     value.  */
name|addend
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
comment|/* If this is HI16 or GOT16 with an associated LO16, 		     adjust the addend accordingly.  Otherwise, just 		     relocate.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_HI16
operator|&&
name|r_type
operator|!=
name|R_MIPS_GOT16
condition|)
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|Elf_Internal_Rela
modifier|*
name|lorel
decl_stmt|;
comment|/* As a GNU extension, permit an arbitrary 			 number of R_MIPS_HI16 relocs before the 			 R_MIPS_LO16 reloc.  This permits gcc to emit 			 the HI and LO relocs itself.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GOT16
condition|)
name|lorel
operator|=
name|rel
operator|+
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|lorel
operator|=
name|rel
operator|+
literal|1
init|;
operator|(
name|lorel
operator|<
name|relend
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS_HI16
operator|)
operator|)
condition|;
name|lorel
operator|++
control|)
empty_stmt|;
block|}
if|if
condition|(
name|lorel
operator|<
name|relend
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS_LO16
condition|)
block|{
name|mips_elf_relocate_hi16
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|lorel
argument_list|,
name|contents
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
else|else
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|boolean
name|local
decl_stmt|;
comment|/* This is a final link.  */
name|sym
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|local_sections
index|[
name|r_symndx
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|local
operator|=
name|true
expr_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* It would be logical to always add sym->st_value here, 		 but Irix 5 sometimes generates a garbage symbol 		 value.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
name|relocation
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
comment|/* mips16 text labels should be treated as odd.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
operator|++
name|relocation
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
name|local
operator|=
name|false
expr_stmt|;
name|indx
operator|=
name|r_symndx
operator|-
name|extsymoff
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
literal|"_gp_disp used when GP not defined"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Only give the error once per link.  */
name|gp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|input_section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|relocation
operator|=
operator|(
name|gp
operator|-
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
operator|)
expr_stmt|;
else|else
name|relocation
operator|=
name|gp
operator|-
name|rel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_LO16
condition|)
name|relocation
operator|+=
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If this is a dynamic link, we should have created                      a _DYNAMIC_LINK symbol in                      mips_elf_create_dynamic_sections.  Otherwise, we                      should define the symbol with a value of 0.                      FIXME: It should probably get into the symbol                      table somehow as well.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mh
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|other
operator|=
name|h
operator|->
name|other
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
name|other
operator|=
name|sym
operator|->
name|st_other
expr_stmt|;
else|else
name|other
operator|=
literal|0
expr_stmt|;
comment|/* If this function has an fn_stub, then it is a mips16 	     function which needs a stub if it is called by a 32 bit 	     function.  If this reloc is anything other than a 16 bit 	     call, redirect the reloc to the stub.  We don't redirect 	     relocs from other stub functions.  */
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
operator|(
operator|(
name|mh
operator|!=
name|NULL
operator|&&
name|mh
operator|->
name|fn_stub
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|mh
operator|==
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
operator|!=
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|!=
name|NULL
operator|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mh
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|mh
operator|->
name|need_fn_stub
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|mh
operator|->
name|fn_stub
operator|->
name|output_section
operator|->
name|vma
operator|+
name|mh
operator|->
name|fn_stub
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|fn_stub
decl_stmt|;
name|fn_stub
operator|=
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|fn_stub
operator|->
name|output_section
operator|->
name|vma
operator|+
name|fn_stub
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* RELOCATION now points to 32 bit code.  */
name|other
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this function has a call_stub, then it is called by a              mips16 function; the call needs to go through a stub if              this function is a 32 bit function.  If this reloc is a              16 bit call, and the symbol is not a 16 bit function,              then redirect the reloc to the stub.  Note that we don't              need to worry about calling the function through a              function pointer; such calls are handled by routing              through a special mips16 routine.  We don't have to check              whether this call is from a stub; it can't be, because a              stub contains 32 bit code, and hence can not have a 16              bit reloc.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
operator|&&
name|mh
operator|!=
name|NULL
operator|&&
operator|(
name|mh
operator|->
name|call_stub
operator|!=
name|NULL
operator|||
name|mh
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|)
operator|&&
name|other
operator|!=
name|STO_MIPS16
condition|)
block|{
name|asection
modifier|*
name|stub
decl_stmt|;
comment|/* If both call_stub and call_fp_stub are defined, we                  can figure out which one to use by seeing which one                  appears in the input file.  */
if|if
condition|(
name|mh
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|mh
operator|->
name|call_fp_stub
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|stub
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stub
operator|=
name|mh
operator|->
name|call_fp_stub
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stub
operator|==
name|NULL
condition|)
name|stub
operator|=
name|mh
operator|->
name|call_stub
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mh
operator|->
name|call_stub
operator|!=
name|NULL
condition|)
name|stub
operator|=
name|mh
operator|->
name|call_stub
expr_stmt|;
else|else
name|stub
operator|=
name|mh
operator|->
name|call_fp_stub
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|stub
operator|->
name|_raw_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|stub
operator|->
name|output_section
operator|->
name|vma
operator|+
name|stub
operator|->
name|output_offset
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HI16
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|lorel
decl_stmt|;
comment|/* As a GNU extension, permit an arbitrary number of 		 R_MIPS_HI16 relocs before the R_MIPS_LO16 reloc. 		 This permits gcc to emit the HI and LO relocs itself.  */
for|for
control|(
name|lorel
operator|=
name|rel
operator|+
literal|1
init|;
operator|(
name|lorel
operator|<
name|relend
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS_HI16
operator|)
condition|;
name|lorel
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|lorel
operator|<
name|relend
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS_LO16
condition|)
block|{
name|mips_elf_relocate_hi16
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|lorel
argument_list|,
name|contents
argument_list|,
name|relocation
operator|+
name|addend
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
else|else
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|&&
name|local
condition|)
block|{
comment|/* GOT16 must also have an associated LO16 in the local 		 case.  In this case, the addend is extracted and the 		 section in which the referenced object is determined. 		 Then the final address of the object is computed and 		 the GOT entry for the hipage (an aligned 64kb chunk) 		 is added to .got section if needed.  The offset field 		 of the GOT16-relocated instruction is replaced by the 		 index of this GOT entry for the hipage.  */
if|if
condition|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|<
name|relend
operator|&&
name|ELF32_R_TYPE
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS_LO16
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf_relocate_got_local
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|sgot
argument_list|,
name|rel
argument_list|,
name|rel
operator|+
literal|1
argument_list|,
name|contents
argument_list|,
name|relocation
operator|+
name|addend
argument_list|)
condition|)
return|return
name|false
return|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
else|else
name|r
operator|=
name|bfd_reloc_outofrange
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_CALL16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT16
operator|||
name|r_type
operator|==
name|R_MIPS_CALL_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_LO16
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
comment|/* This symbol must be registered as a global symbol 		 having the corresponding got entry.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|got_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|h
operator|->
name|dynindx
operator|-
name|g
operator|->
name|global_gotsym
operator|+
name|g
operator|->
name|local_gotno
operator|)
operator|*
literal|4
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|local_gotno
operator|<=
name|offset
operator|&&
name|offset
operator|<
name|sgot
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|+
name|addend
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|offset
operator|-
name|gp
operator|)
expr_stmt|;
name|mips_elf_relocate_global_got
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|contents
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_CALL_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_HI16
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
comment|/* This must be a global symbol with a got entry.  The                  next reloc must be the corresponding LO16 reloc.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|got_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|<
name|relend
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|r_type
operator|==
name|R_MIPS_CALL_HI16
condition|?
operator|(
name|int
operator|)
name|R_MIPS_CALL_LO16
else|:
operator|(
name|int
operator|)
name|R_MIPS_GOT_LO16
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|h
operator|->
name|dynindx
operator|-
name|g
operator|->
name|global_gotsym
operator|+
name|g
operator|->
name|local_gotno
operator|)
operator|*
literal|4
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|local_gotno
operator|<=
name|offset
operator|&&
name|offset
operator|<
name|sgot
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|+
name|addend
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|offset
operator|-
name|gp
operator|)
expr_stmt|;
name|mips_elf_relocate_hi16
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|rel
operator|+
literal|1
argument_list|,
name|contents
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_REL32
operator|||
name|r_type
operator|==
name|R_MIPS_32
condition|)
block|{
name|Elf_Internal_Rel
name|outrel
decl_stmt|;
name|Elf32_crinfo
name|cptrel
decl_stmt|;
name|bfd_byte
modifier|*
name|cr
decl_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|boolean
name|skip
decl_stmt|;
comment|/* When generating a shared object, these 		     relocations are copied into the output file to be 		     resolved at run time.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.dyn"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|stab_info
operator|==
name|NULL
condition|)
name|outrel
operator|.
name|r_offset
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|_bfd_stab_section_offset
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
argument_list|,
name|input_section
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|stab_info
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|off
expr_stmt|;
block|}
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_MIPS_REL32
argument_list|)
expr_stmt|;
name|sec
operator|=
name|input_section
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_MIPS_REL32
argument_list|)
expr_stmt|;
name|addend
operator|+=
name|relocation
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|addend
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Rel
operator|*
operator|)
name|sreloc
operator|->
name|contents
operator|)
operator|+
name|sreloc
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
operator|!
name|skip
operator|&&
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|scpt
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Make an entry of compact relocation info.  */
name|mips_elf_set_cr_format
argument_list|(
name|cptrel
argument_list|,
name|CRF_MIPS_LONG
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|vaddr
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_REL32
condition|)
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_REL32
argument_list|)
expr_stmt|;
else|else
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_WORD
argument_list|)
expr_stmt|;
name|mips_elf_set_cr_dist2to
argument_list|(
name|cptrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|konst
operator|=
name|addend
expr_stmt|;
name|cr
operator|=
operator|(
name|scpt
operator|->
name|contents
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_crinfo_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cptrel
argument_list|,
operator|(
operator|(
name|Elf32_External_crinfo
operator|*
operator|)
name|cr
operator|+
name|scpt
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|scpt
operator|->
name|reloc_count
expr_stmt|;
block|}
comment|/* This reloc will be computed at runtime, so 		     there's no need to do anything now.  */
continue|continue;
block|}
else|else
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
condition|)
block|{
name|bfd_size_type
name|addr
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
comment|/* Do a 32 bit relocation, and sign extend to 64 bits.  */
name|addr
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|addr
operator|+=
literal|4
expr_stmt|;
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|addr
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|addr
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|val
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_26
operator|&&
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
comment|/* This is a jump to a mips16 routine from a mips32                  routine.  We need to change jal into jalx.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|insn
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x3
operator|&&
operator|(
operator|(
name|insn
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x1d
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: %s+0x%lx: jump to mips16 routine which is not jal"
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0x3ffffff
operator|)
operator||
operator|(
literal|0x1d
operator|<<
literal|26
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
comment|/* It's easiest to do the normal relocation, and then                  dig out the instruction and swap the first word the                  way the mips16 expects it.  If this is little endian,                  though, we need to swap the two words first, and then                  swap them back again later, so that the address looks                  right.  */
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xfc00
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0x1f
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0x3e0
operator|)
operator|>>
literal|5
operator|)
operator|)
expr_stmt|;
comment|/* If this is a jump to a 32 bit routine, then make 		     it jalx.  */
if|if
condition|(
name|other
operator|!=
name|STO_MIPS16
condition|)
name|insn
operator||=
literal|0x400
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
condition|)
block|{
name|unsigned
name|short
name|extend
decl_stmt|,
name|insn
decl_stmt|;
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|final
decl_stmt|;
comment|/* Extract the addend into buf, run the regular reloc,                  and stuff the resulting value back into the                  instructions.  */
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|>
name|input_section
operator|->
name|_raw_size
condition|)
name|r
operator|=
name|bfd_reloc_outofrange
expr_stmt|;
else|else
block|{
name|extend
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
operator|(
operator|(
name|extend
operator|&
literal|0x1f
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
name|extend
operator|&
literal|0x7e0
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x1f
operator|)
operator|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|buf
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|final
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
operator|(
name|extend
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|final
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|final
operator|&
literal|0x7e0
operator|)
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator||
operator|(
name|final
operator|&
literal|0x1f
operator|)
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
comment|/* The jal instruction can only jump to an address which is              divisible by 4, and it can only jump to an address with              the same upper 4 bits as the PC.  */
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
operator|&&
operator|(
name|r_type
operator|==
name|R_MIPS16_26
operator|||
name|r_type
operator|==
name|R_MIPS_26
operator|)
condition|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|addr
operator|=
name|relocation
expr_stmt|;
if|if
condition|(
name|other
operator|==
name|STO_MIPS16
condition|)
name|addr
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
name|addr
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|&
literal|3
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|addr
operator|&
literal|0xf0000000
operator|)
operator|!=
operator|(
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
operator|&
literal|0xf0000000
operator|)
operator|)
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
name|scpt
operator|!=
name|NULL
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf32_crinfo
name|cptrel
decl_stmt|;
name|bfd_byte
modifier|*
name|cr
decl_stmt|;
comment|/* Make an entry of compact relocation info.  */
name|mips_elf_set_cr_format
argument_list|(
name|cptrel
argument_list|,
name|CRF_MIPS_LONG
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|vaddr
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_26
case|:
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_JMPAD
argument_list|)
expr_stmt|;
comment|/* XXX How should we set dist2to in this case. */
name|mips_elf_set_cr_dist2to
argument_list|(
name|cptrel
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|konst
operator|=
name|addend
operator|+
name|relocation
expr_stmt|;
name|cr
operator|=
name|scpt
operator|->
name|contents
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_crinfo_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cptrel
argument_list|,
operator|(
operator|(
name|Elf32_External_crinfo
operator|*
operator|)
name|cr
operator|+
name|scpt
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|scpt
operator|->
name|reloc_count
expr_stmt|;
break|break;
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_LITERAL
case|:
case|case
name|R_MIPS_GPREL32
case|:
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_GPHI_LO
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|konst
operator|=
name|gp
operator|-
name|cptrel
operator|.
name|vaddr
expr_stmt|;
name|mips_elf_set_cr_dist2to
argument_list|(
name|cptrel
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cr
operator|=
name|scpt
operator|->
name|contents
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_crinfo_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cptrel
argument_list|,
operator|(
operator|(
name|Elf32_External_crinfo
operator|*
operator|)
name|cr
operator|+
name|scpt
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|scpt
operator|->
name|reloc_count
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This hook function is called before the linker writes out a global    symbol.  We mark symbols as small common if appropriate.  This is    also where we undo the increment of the value for a mips16 symbol.  */
end_comment

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_link_output_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|name
parameter_list|,
name|sym
parameter_list|,
name|input_sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
block|{
comment|/* If we see a common symbol, which implies a relocatable link, then      if a symbol was small common in an input file, mark it as small      common in the output file.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
name|strcmp
argument_list|(
name|input_sec
operator|->
name|name
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_SCOMMON
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|&&
operator|(
name|sym
operator|->
name|st_value
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|sym
operator|->
name|st_value
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for the dynamic linker.  */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/libc.so.1"
end_define

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|namep
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
comment|/* Mips ABI requests the .dynamic section to be read only.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* We need to create .got section.  */
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create .stub section.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stub"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".stub"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator|&
operator|~
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
for|for
control|(
name|namep
operator|=
name|mips_elf_dynsym_rtproc_names
init|;
operator|*
name|namep
operator|!=
name|NULL
condition|;
name|namep
operator|++
control|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_und_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_SECTION
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* We need to create a .compact_rel section.  */
if|if
condition|(
operator|!
name|mips_elf_create_compact_rel_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Change aligments of some sections.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_SECTION
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
condition|)
block|{
comment|/* __rld_map is a four byte word located in the .data section 	     and is filled in by the rtld to contain a pointer to 	     the _r_debug structure. Its symbol value will be set in 	     mips_elf_finish_dynamic_symbol.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"__rld_map"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create the .compact_rel section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_create_compact_rel_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".compact_rel"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".compact_rel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create the .got section to hold the global offset table. */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_create_got_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
comment|/* This function may be called more than once.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the      linker script because we don't want to define the symbol if we      are not creating a global offset table.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The first several global offset table entries are reserved.  */
name|s
operator|->
name|_raw_size
operator|=
name|MIPS_RESERVED_GOTNO
operator|*
literal|4
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_got_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|g
operator|->
name|global_gotsym
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|=
name|MIPS_RESERVED_GOTNO
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|MIPS_RESERVED_GOTNO
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_elf_section_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|g
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
comment|/* Check for the mips16 stub sections.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* This stub is for a local symbol.  This stub will only be              needed if there is some relocation in this BFD, other              than a 16 bit function call, which refers to this symbol.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|sec_relocs
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|r
decl_stmt|,
modifier|*
name|rend
decl_stmt|;
comment|/* We can ignore stub sections when looking for relocs.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sec_relocs
operator|=
operator|(
name|_bfd_elf32_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sec_relocs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|rend
operator|=
name|sec_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|r
operator|=
name|sec_relocs
init|;
name|r
operator|<
name|rend
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|r
operator|->
name|r_info
argument_list|)
operator|==
name|r_symndx
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|r
operator|->
name|r_info
argument_list|)
operator|!=
name|R_MIPS16_26
condition|)
break|break;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|sec_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|rend
condition|)
break|break;
block|}
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
comment|/* There is no non-call reloc for this stub, so we do                  not need it.  Since this function is called before                  the linker maps input sections to output sections, we                  can easily discard it by setting the SEC_EXCLUDE                  flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Record this stub in an array of local symbol stubs for              this BFD. */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|long
name|symcount
decl_stmt|;
name|asection
modifier|*
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|symcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|n
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|=
name|n
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|=
name|sec
expr_stmt|;
comment|/* We don't need to set mips16_stubs_seen in this case.              That flag is used to see whether we need to look through              the global symbol table for stubs.  We don't need to set              it here, because we just have a local stub.  */
block|}
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
name|h
operator|->
name|fn_stub
operator|=
name|sec
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* This stub was actually built for a static symbol defined 	     in the same file.  We assume that all static symbols in 	     mips16 code are themselves mips16, so we can simply 	     discard this stub.  Since this function is called before 	     the linker maps input sections to output sections, we can 	     easily discard it by setting the SEC_EXCLUDE flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|true
return|;
block|}
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|loc
operator|=
operator|&
name|h
operator|->
name|call_fp_stub
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|h
operator|->
name|call_stub
expr_stmt|;
comment|/* If we already have an appropriate stub for this function, we 	 don't need another one, so we can discard this one.  Since 	 this function is called before the linker maps input sections 	 to output sections, we can easily discard it by setting the 	 SEC_EXCLUDE flag.  We can also discard this section if we 	 happen to already know that this is a mips16 function; it is 	 not necessary to check this here, as it is checked later, but 	 it is slightly faster to check now.  */
if|if
condition|(
operator|*
name|loc
operator|!=
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|true
return|;
block|}
operator|*
name|loc
operator|=
name|sec
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|NULL
expr_stmt|;
name|g
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* This may be an indirect symbol created because of a version.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
block|}
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|||
name|sgot
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: CALL16 reloc at 0x%lx not against global symbol"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|h
operator|->
name|got_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We have already allocated space in the .got.  */
break|break;
block|}
comment|/* Note the index of the first global got symbol in .dynsym.  */
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|==
literal|0
operator|||
name|g
operator|->
name|global_gotsym
operator|>
operator|(
name|unsigned
name|long
operator|)
name|h
operator|->
name|dynindx
condition|)
name|g
operator|->
name|global_gotsym
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
comment|/* Make this symbol to have the corresponding got entry.  */
name|h
operator|->
name|got_offset
operator|=
literal|0
expr_stmt|;
comment|/* We need a stub, not a plt entry for the undefined 	     function.  But we record it as if it needs plt.  See 	     elf_adjust_dynamic_symbol in elflink.h.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|h
operator|->
name|got_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We have already allocated space in the .got.  */
break|break;
block|}
comment|/* Note the index of the first global got symbol in                  .dynsym.  */
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|==
literal|0
operator|||
name|g
operator|->
name|global_gotsym
operator|>
operator|(
name|unsigned
name|long
operator|)
name|h
operator|->
name|dynindx
condition|)
name|g
operator|->
name|global_gotsym
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
comment|/* Make this symbol to be the global got symbol.  */
name|h
operator|->
name|got_offset
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|".rel.dyn"
decl_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* When creating a shared object, we must copy these 		     reloc types into the output file as R_MIPS_REL32 		     relocs.  We make room for this reloc in the 		     .rel.dyn reloc section */
if|if
condition|(
name|sreloc
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* Add a null element. */
name|sreloc
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
block|}
name|sreloc
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
comment|/* We only need to copy this reloc if the symbol is                      defined in a dynamic object.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
operator|++
name|hmips
operator|->
name|mips_32_relocs
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_crinfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_26
case|:
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_LITERAL
case|:
case|case
name|R_MIPS_GPREL32
case|:
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_crinfo
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If this reloc is not a 16 bit call, and it has a global          symbol, then we will need the fn_stub if there is one.          References from a stub section do not count. */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_MIPS16_26
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|mh
decl_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|mh
operator|->
name|need_fn_stub
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this symbol is defined in a dynamic object, we need to copy      any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output      file.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|hmips
operator|->
name|mips_32_relocs
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.dyn"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* Make room for a null element. */
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
name|s
operator|->
name|_raw_size
operator|+=
name|hmips
operator|->
name|mips_32_relocs
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
comment|/* For a function, create a stub, if needed. */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|true
return|;
comment|/* If this symbol is not defined in a regular file, then set 	 the symbol to the stub location.  This is required to make 	 function pointers compare as equal between the normal 	 executable and the shared library.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We need .stub section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".stub"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* XXX Write this stub address somewhere.  */
name|h
operator|->
name|plt_offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make room for this stub code.  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
comment|/* The last half word of the stub will be filled with the index 	     of this symbol in .dynsym section.  */
return|return
name|true
return|;
block|}
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function is called after all the input files have been read,    and the input sections have been assigned to output sections.  We    check for any mips16 stub sections that we can discard.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf_check_mips16_stubs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|mips_elf_always_size_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
condition|)
return|return
name|true
return|;
name|mips_elf_link_hash_traverse
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_check_mips16_stubs
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check the mips16 stubs for a particular symbol, and see if we can    discard them.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_check_mips16_stubs
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
operator|&&
operator|!
name|h
operator|->
name|need_fn_stub
condition|)
block|{
comment|/* We don't need the fn_stub; the only references to this symbol          are 16 bit calls.  Clobber the size to 0 to prevent it from          being included in the link.  */
name|h
operator|->
name|fn_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_fp_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|reltext
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Recompute the size of .got for local entires (reserved and      hipages) if needed.  To estimate it, get the upper bound of total      size of loadable sections.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|loadable_size
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|local_gotno
decl_stmt|;
name|struct
name|_bfd
modifier|*
name|sub
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
for|for
control|(
name|s
operator|=
name|sub
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|loadable_size
operator|+=
operator|(
name|s
operator|->
name|_raw_size
operator|+
literal|0xf
operator|)
operator|&
operator|~
literal|0xf
expr_stmt|;
block|}
name|loadable_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
comment|/* Assume there are two loadable segments consisting of 	 contiguous sections.  Is 5 enough? */
name|local_gotno
operator|=
operator|(
name|loadable_size
operator|>>
literal|16
operator|)
operator|+
literal|5
operator|+
name|MIPS_RESERVED_GOTNO
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|=
name|local_gotno
expr_stmt|;
name|sgot
operator|->
name|_raw_size
operator|+=
name|local_gotno
operator|*
literal|4
expr_stmt|;
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|reltext
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* If this relocation section applies to a read only                  section, then we probably need a DT_TEXTREL entry.                  If the relocation section is .rel.dyn, we always                  assert a DT_TEXTREL entry rather than testing whether                  there exists a relocation to a read only section or                  not.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|outname
argument_list|,
literal|".rel.dyn"
argument_list|)
operator|==
literal|0
condition|)
name|reltext
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rel.dyn"
argument_list|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fix the size of .got section for the correspondence of 	     global symbols and got entries. This adds some useless 	     got entries. Is this required by ABI really?  */
name|i
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|i
operator|*
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".stub"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Irix rld assumes that the function stub isn't at the end 	     of .text section. So put a dummy. XXX  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rld_map"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We add a room for __rld_map. It will be filled in by the 	     rtld to contain a pointer to the _r_debug structure.  */
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".compact_rel"
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
block|{
name|asection
modifier|*
modifier|*
name|spp
decl_stmt|;
for|for
control|(
name|spp
operator|=
operator|&
name|s
operator|->
name|output_section
operator|->
name|owner
operator|->
name|sections
init|;
operator|*
name|spp
operator|!=
name|s
operator|->
name|output_section
condition|;
name|spp
operator|=
operator|&
operator|(
operator|*
name|spp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|spp
operator|=
name|s
operator|->
name|output_section
operator|->
name|next
expr_stmt|;
operator|--
name|s
operator|->
name|output_section
operator|->
name|owner
operator|->
name|section_count
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|memset
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf_mips_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* SGI object has the equivalence of DT_DEBUG in the 		 DT_MIPS_RLD_MAP entry.  */
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_MAP
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|reltext
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.dyn"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_REL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELENT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_CONFLICTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LIBLISTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".conflict"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_CONFLICT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".liblist"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LIBLIST
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_VERSION
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_FLAGS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|#
directive|if
literal|0
comment|/* Time stamps in executable files are a bad idea.  */
block|if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_TIME_STAMP, 0)) 	return false;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* FIXME  */
block|if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_ICHECKSUM, 0)) 	return false;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* FIXME  */
block|if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_IVERSION, 0)) 	return false;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_BASE_ADDRESS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LOCAL_GOTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_SYMTABNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_UNREFEXTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_GOTSYM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_HIPAGENO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|#
directive|if
literal|0
comment|/* (SGI_COMPAT) */
block|if (! bfd_get_section_by_name (dynobj, ".init")) 	if (! bfd_elf32_add_dynamic_entry (info, DT_INIT, 0)) 	  return false;        if (! bfd_get_section_by_name (dynobj, ".fini")) 	if (! bfd_elf32_add_dynamic_entry (info, DT_FINI, 0)) 	  return false;
endif|#
directive|endif
block|}
comment|/* If we use dynamic linking, we generate a section symbol for each      output section.  These are local symbols, which means that they      must come first in the dynamic symbol table.      That means we must increment the dynamic symbol index of every      other dynamic symbol.  */
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|namep
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|bfd_size_type
name|strindex
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|dynstr
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|c
operator|=
name|SIZEOF_MIPS_DYNSYM_SECNAMES
operator|-
literal|1
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_adjust_dynindx
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|c
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|+=
name|c
expr_stmt|;
name|dynstr
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynstr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|namep
operator|=
name|mips_elf_dynsym_sec_names
init|;
operator|*
name|namep
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|namep
operator|++
control|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|dynindx
operator|=
name|i
expr_stmt|;
name|strindex
operator|=
name|_bfd_stringtab_add
argument_list|(
name|dynstr
argument_list|,
operator|*
name|namep
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|strindex
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsym_sec_strindex
index|[
name|i
index|]
operator|=
name|strindex
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_adjust_dynindx
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|c
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|+=
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|dynindx
operator|=
name|i
expr_stmt|;
comment|/* These symbols will have no names, so we don't need to 		   fiddle with dynstr_index.  */
block|}
block|}
block|}
if|if
condition|(
name|sgot
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If there are no global got symbols, fake the last symbol so 	   for safety.  */
if|if
condition|(
name|g
operator|->
name|global_gotsym
condition|)
name|g
operator|->
name|global_gotsym
operator|+=
name|c
expr_stmt|;
else|else
name|g
operator|->
name|global_gotsym
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Increment the index of a dynamic symbol by a given amount.  Called    via elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_adjust_dynindx
parameter_list|(
name|h
parameter_list|,
name|cparg
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|cparg
decl_stmt|;
block|{
name|unsigned
name|int
modifier|*
name|cp
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|cparg
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|h
operator|->
name|dynindx
operator|+=
operator|*
name|cp
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
name|gval
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|gval
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_byte
name|stub
index|[
name|MIPS_FUNCTION_STUB_SIZE
index|]
decl_stmt|;
comment|/* This symbol has a stub.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".stub"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fill the stub.  */
name|p
operator|=
name|stub
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LW
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_MOVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* FIXME: Can h->dynindex be more than 64K?  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|&
literal|0xffff0000
condition|)
return|return
name|false
return|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_JALR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LI16
operator|+
name|h
operator|->
name|dynindx
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|plt_offset
operator|<=
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|contents
operator|+
name|h
operator|->
name|plt_offset
argument_list|,
name|stub
argument_list|,
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as undefined.  plt_offset != -1 occurs 	 only for the referenced symbol.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* The run-time linker uses the st_value field of the symbol 	 to reset the global offset table entry for this external 	 to its stub address when unlinking a shared object.  */
name|gval
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt_offset
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|gval
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|h
operator|->
name|dynindx
operator|>=
name|g
operator|->
name|global_gotsym
condition|)
block|{
name|bfd_size_type
name|offset
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set its 	 value to the corresponding got entry, if needed.  */
if|if
condition|(
name|h
operator|->
name|got_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|offset
operator|=
operator|(
name|h
operator|->
name|dynindx
operator|-
name|g
operator|->
name|global_gotsym
operator|+
name|g
operator|->
name|local_gotno
operator|)
operator|*
literal|4
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|local_gotno
operator|*
literal|4
operator|<=
name|offset
operator|&&
name|offset
operator|<
name|sgot
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|gval
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_ABS
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_OBJECT
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__rld_map"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rld_map"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|==
literal|0
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__rld_obj_head"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rld_map"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
comment|/* If this is a mips16 symbol, force the value to be even.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|&&
operator|(
name|sym
operator|->
name|st_value
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|sym
operator|->
name|st_value
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|elemsize
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_RELENT
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.dyn"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
comment|/* Rewrite DT_STRSZ.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_bfd_stringtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_MIPS_CONFLICT
case|:
name|name
operator|=
literal|".conflict"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_MIPS_LIBLIST
case|:
name|name
operator|=
literal|".liblist"
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_RLD_VERSION
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_FLAGS
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|RHF_NOTPOT
expr_stmt|;
comment|/* XXX */
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_CONFLICTNO
case|:
name|name
operator|=
literal|".conflict"
expr_stmt|;
name|elemsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Conflict
argument_list|)
expr_stmt|;
goto|goto
name|set_elemno
goto|;
case|case
name|DT_MIPS_LIBLISTNO
case|:
name|name
operator|=
literal|".liblist"
expr_stmt|;
name|elemsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Lib
argument_list|)
expr_stmt|;
name|set_elemno
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
operator|/
name|elemsize
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|elemsize
expr_stmt|;
block|}
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_TIME_STAMP
case|:
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_ICHECKSUM
case|:
comment|/* XXX FIXME: */
break|break;
case|case
name|DT_MIPS_IVERSION
case|:
comment|/* XXX FIXME: */
break|break;
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
name|s
operator|=
name|output_bfd
operator|->
name|sections
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
operator|&
operator|~
operator|(
literal|0xffff
operator|)
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_SYMTABNO
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
name|elemsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
operator|/
name|elemsize
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|elemsize
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_UNREFEXTNO
case|:
comment|/* XXX FIXME: */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|SIZEOF_MIPS_DYNSYM_SECNAMES
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_GOTSYM
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|global_gotsym
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_HIPAGENO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
operator|-
name|MIPS_RESERVED_GOTNO
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_RLD_MAP
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* The first entry of the global offset table will be filled at      runtime. The second entry will be used by some runtime loaders.      This isn't the case of Irix rld. */
if|if
condition|(
name|sgot
operator|!=
name|NULL
operator|&&
name|sgot
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x80000000
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sgot
operator|!=
name|NULL
condition|)
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|{
name|asection
modifier|*
name|sdynsym
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_vma
name|last
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|long
name|dindx
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|namep
init|=
name|mips_elf_dynsym_sec_names
decl_stmt|;
name|Elf32_compact_rel
name|cpt
decl_stmt|;
comment|/* Set up the section symbols for the output sections. SGI sets        the STT_NOTYPE attribute for these symbols.  Should we do so?  */
name|sdynsym
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdynsym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_NOTYPE
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
name|dindx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|name
operator|=
operator|*
name|namep
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|sym
operator|.
name|st_value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|dindx
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|last
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|.
name|st_value
operator|=
name|last
expr_stmt|;
name|dindx
operator|++
expr_stmt|;
block|}
name|sym
operator|.
name|st_shndx
operator|=
operator|(
name|i
operator|<
name|MIPS_TEXT_DYNSYM_SECNO
condition|?
name|SHN_MIPS_TEXT
else|:
name|SHN_MIPS_DATA
operator|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|sym
operator|.
name|st_name
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsym_sec_strindex
index|[
name|dindx
index|]
expr_stmt|;
name|bfd_elf32_swap_symbol_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|sym
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|sdynsym
operator|->
name|contents
operator|)
operator|+
name|dindx
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set the sh_info field of the output .dynsym section to 	       the index of the first global symbol.  */
name|elf_section_data
argument_list|(
name|sdynsym
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|SIZEOF_MIPS_DYNSYM_SECNAMES
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|int
name|indx
decl_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|indx
expr_stmt|;
name|bfd_elf32_swap_symbol_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|sym
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|sdynsym
operator|->
name|contents
operator|)
operator|+
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|dynindx
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set the sh_info field of the output .dynsym section to 	       the index of the first global symbol.  */
name|elf_section_data
argument_list|(
name|sdynsym
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* Write .compact_rel section out.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".compact_rel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|cpt
operator|.
name|id1
operator|=
literal|1
expr_stmt|;
name|cpt
operator|.
name|num
operator|=
name|s
operator|->
name|reloc_count
expr_stmt|;
name|cpt
operator|.
name|id2
operator|=
literal|2
expr_stmt|;
name|cpt
operator|.
name|offset
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
operator|)
expr_stmt|;
name|cpt
operator|.
name|reserved0
operator|=
literal|0
expr_stmt|;
name|cpt
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_compact_rel_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cpt
argument_list|,
operator|(
operator|(
name|Elf32_External_compact_rel
operator|*
operator|)
name|s
operator|->
name|contents
operator|)
argument_list|)
expr_stmt|;
comment|/* Clean up a dummy stub function entry in .text.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".stub"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|file_ptr
name|dummy_offset
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|_raw_size
operator|>=
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
name|dummy_offset
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
name|memset
argument_list|(
name|s
operator|->
name|contents
operator|+
name|dummy_offset
argument_list|,
literal|0
argument_list|,
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Clean up a first relocation in .rel.dyn.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.dyn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|>
literal|0
condition|)
name|memset
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is almost identical to bfd_generic_get_... except that some    MIPS relocations need to be handled specially.  Sigh.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|elf32_mips_get_relocated_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
comment|/* Get enough memory to hold the stuff */
name|bfd
modifier|*
name|input_bfd
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|reloc_vector
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* read in the section */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
literal|0
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* We're not relaxing the section, so just copy the size info */
name|input_section
operator|->
name|_cooked_size
operator|=
name|input_section
operator|->
name|_raw_size
expr_stmt|;
name|input_section
operator|->
name|reloc_done
operator|=
name|true
expr_stmt|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
decl_stmt|;
comment|/* for mips */
name|int
name|gp_found
decl_stmt|;
name|bfd_vma
name|gp
init|=
literal|0x12345678
decl_stmt|;
comment|/* initialize just to shut gcc up */
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|lh
decl_stmt|;
comment|/* Skip all this stuff if we aren't mixing formats.  */
if|if
condition|(
name|abfd
operator|&&
name|input_bfd
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|input_bfd
operator|->
name|xvec
condition|)
name|lh
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|h
operator|=
name|bfd_hash_lookup
argument_list|(
operator|&
name|link_info
operator|->
name|hash
operator|->
name|table
argument_list|,
literal|"_gp"
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|lh
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
block|}
name|lookup
label|:
if|if
condition|(
name|lh
condition|)
block|{
switch|switch
condition|(
name|lh
operator|->
name|type
condition|)
block|{
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
case|case
name|bfd_link_hash_common
case|:
name|gp_found
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|gp_found
operator|=
literal|1
expr_stmt|;
name|gp
operator|=
name|lh
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
case|case
name|bfd_link_hash_warning
case|:
name|lh
operator|=
name|lh
operator|->
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* @@FIXME  ignoring warning for now */
goto|goto
name|lookup
goto|;
case|case
name|bfd_link_hash_new
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|gp_found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end mips */
for|for
control|(
name|parent
operator|=
name|reloc_vector
init|;
operator|*
name|parent
operator|!=
operator|(
name|arelent
operator|*
operator|)
name|NULL
condition|;
name|parent
operator|++
control|)
block|{
name|char
modifier|*
name|error_message
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
comment|/* Specific to MIPS: Deal with relocation types that require 	     knowing the gp of the output bfd.  */
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|&&
name|abfd
condition|)
block|{
comment|/* The special_function wouldn't get called anyways.  */
block|}
elseif|else
if|if
condition|(
operator|!
name|gp_found
condition|)
block|{
comment|/* The gp isn't there; let the special function code 		 fall over on its own.  */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|parent
operator|)
operator|->
name|howto
operator|->
name|special_function
operator|==
name|_bfd_mips_elf_gprel16_reloc
condition|)
block|{
comment|/* bypass special_function call */
name|r
operator|=
name|gprel16_with_gp
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|,
operator|*
name|parent
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
name|gp
argument_list|)
expr_stmt|;
goto|goto
name|skip_bfd_perform_relocation
goto|;
block|}
comment|/* end mips specific stuff */
name|r
operator|=
name|bfd_perform_relocation
argument_list|(
name|input_bfd
argument_list|,
operator|*
name|parent
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
name|input_section
argument_list|,
name|relocateable
condition|?
name|abfd
else|:
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
name|skip_bfd_perform_relocation
label|:
if|if
condition|(
name|relocateable
condition|)
block|{
name|asection
modifier|*
name|os
init|=
name|input_section
operator|->
name|output_section
decl_stmt|;
comment|/* A partial link, so keep the relocs */
name|os
operator|->
name|orelocation
index|[
name|os
operator|->
name|reloc_count
index|]
operator|=
operator|*
name|parent
expr_stmt|;
name|os
operator|->
name|reloc_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|BFD_ASSERT
argument_list|(
name|error_message
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|link_info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|howto
operator|->
name|name
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|elf32_mips_get_relocated_section_contents
end_define

begin_escape
end_escape

begin_comment
comment|/* ECOFF swapping routines.  These are used when dealing with the    .mdebug section, which is in the ECOFF debugging format.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ecoff_debug_swap
name|mips_elf32_ecoff_debug_swap
init|=
block|{
comment|/* Symbol table magic number.  */
name|magicSym
block|,
comment|/* Alignment of debugging information.  E.g., 4.  */
literal|4
block|,
comment|/* Sizes of external symbolic information.  */
sizeof|sizeof
argument_list|(
expr|struct
name|hdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opt_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|rfd_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ext_ext
argument_list|)
block|,
comment|/* Functions to swap in external symbolic data.  */
name|ecoff_swap_hdr_in
block|,
name|ecoff_swap_dnr_in
block|,
name|ecoff_swap_pdr_in
block|,
name|ecoff_swap_sym_in
block|,
name|ecoff_swap_opt_in
block|,
name|ecoff_swap_fdr_in
block|,
name|ecoff_swap_rfd_in
block|,
name|ecoff_swap_ext_in
block|,
name|_bfd_ecoff_swap_tir_in
block|,
name|_bfd_ecoff_swap_rndx_in
block|,
comment|/* Functions to swap out external symbolic data.  */
name|ecoff_swap_hdr_out
block|,
name|ecoff_swap_dnr_out
block|,
name|ecoff_swap_pdr_out
block|,
name|ecoff_swap_sym_out
block|,
name|ecoff_swap_opt_out
block|,
name|ecoff_swap_fdr_out
block|,
name|ecoff_swap_rfd_out
block|,
name|ecoff_swap_ext_out
block|,
name|_bfd_ecoff_swap_tir_out
block|,
name|_bfd_ecoff_swap_rndx_out
block|,
comment|/* Function to read in symbolic data.  */
name|_bfd_mips_elf_read_ecoff_info
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_littlemips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-littlemips"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_bigmips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-bigmips"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_mips
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_MIPS
end_define

begin_comment
comment|/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses    a value of 0x1000, and we are compatible.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_backend_collect
value|true
end_define

begin_define
define|#
directive|define
name|elf_backend_type_change_ok
value|true
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|0
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|mips_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|elf_backend_sym_is_global
value|mips_elf_sym_is_global
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|mips_elf32_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|mips_elf32_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|_bfd_mips_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_bfd_section
define|\
value|_bfd_mips_elf_section_from_bfd_section
end_define

begin_define
define|#
directive|define
name|elf_backend_section_processing
value|mips_elf32_section_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|_bfd_mips_elf_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
define|\
value|mips_elf_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|mips_elf_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|_bfd_mips_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_ecoff_debug_swap
value|&mips_elf32_ecoff_debug_swap
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_is_local_label_name
define|\
value|mips_elf_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elf32_find_nearest_line
value|_bfd_mips_elf_find_nearest_line
end_define

begin_define
define|#
directive|define
name|bfd_elf32_set_section_contents
value|_bfd_mips_elf_set_section_contents
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|mips_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_final_link
value|mips_elf_final_link
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
define|\
value|_bfd_mips_elf_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
define|\
value|_bfd_mips_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|_bfd_mips_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|mips_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|mips_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|mips_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|mips_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|mips_elf_always_size_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|mips_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|mips_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|mips_elf_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|mips_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|mips_elf_finish_dynamic_sections
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

