begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Main header file for the bfd library -- portable access to object files.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__BFD_H_SEEN__
end_ifndef

begin_define
define|#
directive|define
name|__BFD_H_SEEN__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
include|#
directive|include
file|"ansidecl.h"
include|#
directive|include
file|"symcat.h"
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALMOST_STDC
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_STRINGIZE
argument_list|)
ifndef|#
directive|ifndef
name|SABER
comment|/* This hack is to avoid a problem with some strict ANSI C preprocessors.    The problem is, "32_" is not a valid preprocessing token, and we don't    want extra underscores (e.g., "nlm_32_").  The XCONCAT2 macro will    cause the inner CONCAT2 macros to be evaluated first, producing    still-valid pp-tokens.  Then the final concatenation can be done.  */
undef|#
directive|undef
name|CONCAT4
define|#
directive|define
name|CONCAT4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|XCONCAT2(CONCAT2(a,b),CONCAT2(c,d))
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|BFD_VERSION
value|@bfd_version@
define|#
directive|define
name|BFD_VERSION_DATE
value|@bfd_version_date@
define|#
directive|define
name|BFD_VERSION_STRING
value|@bfd_version_string@
comment|/* The word size used by BFD on the host.  This may be 64 with a 32    bit target if the host is 64 bit, or if other 64 bit targets have    been selected with --enable-targets, or if --enable-64-bit-bfd.  */
define|#
directive|define
name|BFD_ARCH_SIZE
value|@wordsize@
comment|/* The word size of the default bfd target.  */
define|#
directive|define
name|BFD_DEFAULT_TARGET_SIZE
value|@bfd_default_target_size@
define|#
directive|define
name|BFD_HOST_64BIT_LONG
value|@BFD_HOST_64BIT_LONG@
if|#
directive|if
if|@
name|BFD_HOST_64_BIT_DEFINED
expr|@
define|#
directive|define
name|BFD_HOST_64_BIT
value|@BFD_HOST_64_BIT@
define|#
directive|define
name|BFD_HOST_U_64_BIT
value|@BFD_HOST_U_64_BIT@
endif|#
directive|endif
if|#
directive|if
name|BFD_ARCH_SIZE
operator|>=
literal|64
define|#
directive|define
name|BFD64
endif|#
directive|endif
ifndef|#
directive|ifndef
name|INLINE
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
define|#
directive|define
name|INLINE
value|__inline__
else|#
directive|else
define|#
directive|define
name|INLINE
endif|#
directive|endif
endif|#
directive|endif
comment|/* Forward declaration.  */
typedef|typedef
name|struct
name|_bfd
name|bfd
typedef|;
comment|/* To squelch erroneous compiler warnings ("illegal pointer    combination") from the SVR3 compiler, we would like to typedef    boolean to int (it doesn't like functions which return boolean.    Making sure they are never implicitly declared to return int    doesn't seem to help).  But this file is not configured based on    the host.  */
comment|/* General rules: functions which are boolean return true on success    and false on failure (unless they're a predicate).   -- bfd.doc */
comment|/* I'm sure this is going to break something and someone is going to    force me to change it.  */
comment|/* typedef enum boolean {false, true} boolean; */
comment|/* Yup, SVR4 has a "typedef enum boolean" in<sys/types.h>  -fnf */
comment|/* It gets worse if the host also defines a true/false enum... -sts */
comment|/* And even worse if your compiler has built-in boolean types... -law */
comment|/* And even worse if your compiler provides a stdbool.h that conflicts    with these definitions... gcc 2.95 and later do.  If so, it must    be included first.  -drow */
if|#
directive|if
name|defined
argument_list|(
name|__GNUG__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|6
operator|)
operator|)
define|#
directive|define
name|TRUE_FALSE_ALREADY_DEFINED
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|__bool_true_false_are_defined
argument_list|)
comment|/* We have<stdbool.h>.  */
define|#
directive|define
name|TRUE_FALSE_ALREADY_DEFINED
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MPW
comment|/* Pre-emptive strike - get the file with the enum.  */
include|#
directive|include
file|<Types.h>
define|#
directive|define
name|TRUE_FALSE_ALREADY_DEFINED
endif|#
directive|endif
comment|/* MPW */
ifndef|#
directive|ifndef
name|TRUE_FALSE_ALREADY_DEFINED
typedef|typedef
enum|enum
name|bfd_boolean
block|{
name|false
block|,
name|true
block|}
name|boolean
typedef|;
define|#
directive|define
name|BFD_TRUE_FALSE
else|#
directive|else
comment|/* Use enum names that will appear nowhere else.  */
typedef|typedef
enum|enum
name|bfd_boolean
block|{
name|bfd_fffalse
block|,
name|bfd_tttrue
block|}
name|boolean
typedef|;
endif|#
directive|endif
comment|/* Support for different sizes of target format ints and addresses.    If the type `long' is at least 64 bits, BFD_HOST_64BIT_LONG will be    set to 1 above.  Otherwise, if gcc is being used, this code will    use gcc's "long long" type.  Otherwise, BFD_HOST_64_BIT must be    defined above.  */
ifndef|#
directive|ifndef
name|BFD_HOST_64_BIT
if|#
directive|if
name|BFD_HOST_64BIT_LONG
define|#
directive|define
name|BFD_HOST_64_BIT
value|long
define|#
directive|define
name|BFD_HOST_U_64_BIT
value|unsigned long
else|#
directive|else
ifdef|#
directive|ifdef
name|__GNUC__
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
define|#
directive|define
name|BFD_HOST_64_BIT
value|long long
define|#
directive|define
name|BFD_HOST_U_64_BIT
value|unsigned long long
endif|#
directive|endif
comment|/* __GNUC__>= 2 */
endif|#
directive|endif
comment|/* ! defined (__GNUC__) */
endif|#
directive|endif
comment|/* ! BFD_HOST_64BIT_LONG */
endif|#
directive|endif
comment|/* ! defined (BFD_HOST_64_BIT) */
ifdef|#
directive|ifdef
name|BFD64
ifndef|#
directive|ifndef
name|BFD_HOST_64_BIT
error|#
directive|error
error|No 64 bit integer type available
endif|#
directive|endif
comment|/* ! defined (BFD_HOST_64_BIT) */
typedef|typedef
name|BFD_HOST_U_64_BIT
name|bfd_vma
typedef|;
typedef|typedef
name|BFD_HOST_64_BIT
name|bfd_signed_vma
typedef|;
typedef|typedef
name|BFD_HOST_U_64_BIT
name|bfd_size_type
typedef|;
typedef|typedef
name|BFD_HOST_U_64_BIT
name|symvalue
typedef|;
ifndef|#
directive|ifndef
name|fprintf_vma
if|#
directive|if
name|BFD_HOST_64BIT_LONG
define|#
directive|define
name|sprintf_vma
parameter_list|(
name|s
parameter_list|,
name|x
parameter_list|)
value|sprintf (s, "%016lx", x)
define|#
directive|define
name|fprintf_vma
parameter_list|(
name|f
parameter_list|,
name|x
parameter_list|)
value|fprintf (f, "%016lx", x)
else|#
directive|else
define|#
directive|define
name|_bfd_int64_low
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) (((x)& 0xffffffff)))
define|#
directive|define
name|_bfd_int64_high
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) (((x)>> 32)& 0xffffffff))
define|#
directive|define
name|fprintf_vma
parameter_list|(
name|s
parameter_list|,
name|x
parameter_list|)
define|\
value|fprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
define|#
directive|define
name|sprintf_vma
parameter_list|(
name|s
parameter_list|,
name|x
parameter_list|)
define|\
value|sprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
comment|/* not BFD64  */
comment|/* Represent a target address.  Also used as a generic unsigned type    which is guaranteed to be big enough to hold any arithmetic types    we need to deal with.  */
typedef|typedef
name|unsigned
name|long
name|bfd_vma
typedef|;
comment|/* A generic signed type which is guaranteed to be big enough to hold any    arithmetic types we need to deal with.  Can be assumed to be compatible    with bfd_vma in the same way that signed and unsigned ints are compatible    (as parameters, in assignment, etc).  */
typedef|typedef
name|long
name|bfd_signed_vma
typedef|;
typedef|typedef
name|unsigned
name|long
name|symvalue
typedef|;
typedef|typedef
name|unsigned
name|long
name|bfd_size_type
typedef|;
comment|/* Print a bfd_vma x on stream s.  */
define|#
directive|define
name|fprintf_vma
parameter_list|(
name|s
parameter_list|,
name|x
parameter_list|)
value|fprintf (s, "%08lx", x)
define|#
directive|define
name|sprintf_vma
parameter_list|(
name|s
parameter_list|,
name|x
parameter_list|)
value|sprintf (s, "%08lx", x)
endif|#
directive|endif
comment|/* not BFD64  */
comment|/* A pointer to a position in a file.  */
comment|/* FIXME:  This should be using off_t from<sys/types.h>.    For now, try to avoid breaking stuff by not including<sys/types.h> here.    This will break on systems with 64-bit file offsets (e.g. 4.4BSD).    Probably the best long-term answer is to avoid using file_ptr AND off_t    in this header file, and to handle this in the BFD implementation    rather than in its interface.  */
comment|/* typedef off_t	file_ptr; */
typedef|typedef
name|bfd_signed_vma
name|file_ptr
typedef|;
typedef|typedef
name|bfd_vma
name|ufile_ptr
typedef|;
specifier|extern
name|void
name|bfd_sprintf_vma
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bfd_fprintf_vma
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|printf_vma
parameter_list|(
name|x
parameter_list|)
value|fprintf_vma(stdout,x)
define|#
directive|define
name|bfd_printf_vma
parameter_list|(
name|abfd
parameter_list|,
name|x
parameter_list|)
value|bfd_fprintf_vma (abfd,stdout,x)
typedef|typedef
name|unsigned
name|int
name|flagword
typedef|;
comment|/* 32 bits of flags */
typedef|typedef
name|unsigned
name|char
name|bfd_byte
typedef|;
comment|/* File formats.  */
typedef|typedef
enum|enum
name|bfd_format
block|{
name|bfd_unknown
init|=
literal|0
block|,
comment|/* File format is unknown.  */
name|bfd_object
block|,
comment|/* Linker/assember/compiler output.  */
name|bfd_archive
block|,
comment|/* Object archive file.  */
name|bfd_core
block|,
comment|/* Core dump.  */
name|bfd_type_end
comment|/* Marks the end; don't use it!  */
block|}
name|bfd_format
typedef|;
comment|/* Values that may appear in the flags field of a BFD.  These also    appear in the object_flags field of the bfd_target structure, where    they indicate the set of flags used by that backend (not all flags    are meaningful for all object file formats) (FIXME: at the moment,    the object_flags values have mostly just been copied from backend    to another, and are not necessarily correct).  */
comment|/* No flags.  */
define|#
directive|define
name|BFD_NO_FLAGS
value|0x00
comment|/* BFD contains relocation entries.  */
define|#
directive|define
name|HAS_RELOC
value|0x01
comment|/* BFD is directly executable.  */
define|#
directive|define
name|EXEC_P
value|0x02
comment|/* BFD has line number information (basically used for F_LNNO in a    COFF header).  */
define|#
directive|define
name|HAS_LINENO
value|0x04
comment|/* BFD has debugging information.  */
define|#
directive|define
name|HAS_DEBUG
value|0x08
comment|/* BFD has symbols.  */
define|#
directive|define
name|HAS_SYMS
value|0x10
comment|/* BFD has local symbols (basically used for F_LSYMS in a COFF    header).  */
define|#
directive|define
name|HAS_LOCALS
value|0x20
comment|/* BFD is a dynamic object.  */
define|#
directive|define
name|DYNAMIC
value|0x40
comment|/* Text section is write protected (if D_PAGED is not set, this is    like an a.out NMAGIC file) (the linker sets this by default, but    clears it for -r or -N).  */
define|#
directive|define
name|WP_TEXT
value|0x80
comment|/* BFD is dynamically paged (this is like an a.out ZMAGIC file) (the    linker sets this by default, but clears it for -r or -n or -N).  */
define|#
directive|define
name|D_PAGED
value|0x100
comment|/* BFD is relaxable (this means that bfd_relax_section may be able to    do something) (sometimes bfd_relax_section can do something even if    this is not set).  */
define|#
directive|define
name|BFD_IS_RELAXABLE
value|0x200
comment|/* This may be set before writing out a BFD to request using a    traditional format.  For example, this is used to request that when    writing out an a.out object the symbols not be hashed to eliminate    duplicates.  */
define|#
directive|define
name|BFD_TRADITIONAL_FORMAT
value|0x400
comment|/* This flag indicates that the BFD contents are actually cached in    memory.  If this is set, iostream points to a bfd_in_memory struct.  */
define|#
directive|define
name|BFD_IN_MEMORY
value|0x800
comment|/* Symbols and relocation.  */
comment|/* A count of carsyms (canonical archive symbols).  */
typedef|typedef
name|unsigned
name|long
name|symindex
typedef|;
comment|/* How to perform a relocation.  */
typedef|typedef
specifier|const
name|struct
name|reloc_howto_struct
name|reloc_howto_type
typedef|;
define|#
directive|define
name|BFD_NO_MORE_SYMBOLS
value|((symindex) ~0)
comment|/* General purpose part of a symbol X;    target specific parts are in libcoff.h, libaout.h, etc.  */
define|#
directive|define
name|bfd_get_section
parameter_list|(
name|x
parameter_list|)
value|((x)->section)
define|#
directive|define
name|bfd_get_output_section
parameter_list|(
name|x
parameter_list|)
value|((x)->section->output_section)
define|#
directive|define
name|bfd_set_section
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)->section) = (y)
define|#
directive|define
name|bfd_asymbol_base
parameter_list|(
name|x
parameter_list|)
value|((x)->section->vma)
define|#
directive|define
name|bfd_asymbol_value
parameter_list|(
name|x
parameter_list|)
value|(bfd_asymbol_base(x) + (x)->value)
define|#
directive|define
name|bfd_asymbol_name
parameter_list|(
name|x
parameter_list|)
value|((x)->name)
comment|/*Perhaps future: #define bfd_asymbol_bfd(x) ((x)->section->owner)*/
define|#
directive|define
name|bfd_asymbol_bfd
parameter_list|(
name|x
parameter_list|)
value|((x)->the_bfd)
define|#
directive|define
name|bfd_asymbol_flavour
parameter_list|(
name|x
parameter_list|)
value|(bfd_asymbol_bfd(x)->xvec->flavour)
comment|/* A canonical archive symbol.  */
comment|/* This is a type pun with struct ranlib on purpose!  */
typedef|typedef
struct|struct
name|carsym
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|file_ptr
name|file_offset
decl_stmt|;
comment|/* Look here to find the file.  */
block|}
name|carsym
typedef|;
comment|/* To make these you call a carsymogen.  */
comment|/* Used in generating armaps (archive tables of contents).    Perhaps just a forward definition would do?  */
struct|struct
name|orl
comment|/* Output ranlib.  */
block|{
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
comment|/* Symbol name.  */
union|union
block|{
name|file_ptr
name|pos
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|}
name|u
union|;
comment|/* bfd* or file position.  */
name|int
name|namidx
decl_stmt|;
comment|/* Index into string table.  */
block|}
struct|;
comment|/* Linenumber stuff.  */
typedef|typedef
struct|struct
name|lineno_cache_entry
block|{
name|unsigned
name|int
name|line_number
decl_stmt|;
comment|/* Linenumber from start of function.  */
union|union
block|{
name|struct
name|symbol_cache_entry
modifier|*
name|sym
decl_stmt|;
comment|/* Function name.  */
name|bfd_vma
name|offset
decl_stmt|;
comment|/* Offset into section.  */
block|}
name|u
union|;
block|}
name|alent
typedef|;
comment|/* Object and core file sections.  */
define|#
directive|define
name|align_power
parameter_list|(
name|addr
parameter_list|,
name|align
parameter_list|)
define|\
value|( ((addr) + ((1<<(align))-1))& (-1<< (align)))
typedef|typedef
name|struct
name|sec
modifier|*
name|sec_ptr
typedef|;
define|#
directive|define
name|bfd_get_section_name
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|((ptr)->name + 0)
define|#
directive|define
name|bfd_get_section_vma
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|((ptr)->vma + 0)
define|#
directive|define
name|bfd_get_section_alignment
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|((ptr)->alignment_power + 0)
define|#
directive|define
name|bfd_section_name
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|((ptr)->name)
define|#
directive|define
name|bfd_section_size
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|(bfd_get_section_size_before_reloc(ptr))
define|#
directive|define
name|bfd_section_vma
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|((ptr)->vma)
define|#
directive|define
name|bfd_section_lma
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|((ptr)->lma)
define|#
directive|define
name|bfd_section_alignment
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|((ptr)->alignment_power)
define|#
directive|define
name|bfd_get_section_flags
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|((ptr)->flags + 0)
define|#
directive|define
name|bfd_get_section_userdata
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|)
value|((ptr)->userdata)
define|#
directive|define
name|bfd_is_com_section
parameter_list|(
name|ptr
parameter_list|)
value|(((ptr)->flags& SEC_IS_COMMON) != 0)
define|#
directive|define
name|bfd_set_section_vma
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|,
name|val
parameter_list|)
value|(((ptr)->vma = (ptr)->lma= (val)), ((ptr)->user_set_vma = (boolean)true), true)
define|#
directive|define
name|bfd_set_section_alignment
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|,
name|val
parameter_list|)
value|(((ptr)->alignment_power = (val)),true)
define|#
directive|define
name|bfd_set_section_userdata
parameter_list|(
name|bfd
parameter_list|,
name|ptr
parameter_list|,
name|val
parameter_list|)
value|(((ptr)->userdata = (val)),true)
typedef|typedef
name|struct
name|stat
name|stat_type
typedef|;
typedef|typedef
enum|enum
name|bfd_print_symbol
block|{
name|bfd_print_symbol_name
block|,
name|bfd_print_symbol_more
block|,
name|bfd_print_symbol_all
block|}
name|bfd_print_symbol_type
typedef|;
comment|/* Information about a symbol that nm needs.  */
typedef|typedef
struct|struct
name|_symbol_info
block|{
name|symvalue
name|value
decl_stmt|;
name|char
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Symbol name.  */
name|unsigned
name|char
name|stab_type
decl_stmt|;
comment|/* Stab type.  */
name|char
name|stab_other
decl_stmt|;
comment|/* Stab other.  */
name|short
name|stab_desc
decl_stmt|;
comment|/* Stab desc.  */
specifier|const
name|char
modifier|*
name|stab_name
decl_stmt|;
comment|/* String for stab type.  */
block|}
name|symbol_info
typedef|;
comment|/* Get the name of a stabs type code.  */
specifier|extern
specifier|const
name|char
modifier|*
name|bfd_get_stab_name
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Hash table routines.  There is no way to free up a hash table.  */
comment|/* An element in the hash table.  Most uses will actually use a larger    structure, and an instance of this will be the first field.  */
struct|struct
name|bfd_hash_entry
block|{
comment|/* Next entry for this hash code.  */
name|struct
name|bfd_hash_entry
modifier|*
name|next
decl_stmt|;
comment|/* String being hashed.  */
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Hash code.  This is the full hash code, not the index into the      table.  */
name|unsigned
name|long
name|hash
decl_stmt|;
block|}
struct|;
comment|/* A hash table.  */
struct|struct
name|bfd_hash_table
block|{
comment|/* The hash array.  */
name|struct
name|bfd_hash_entry
modifier|*
modifier|*
name|table
decl_stmt|;
comment|/* The number of slots in the hash table.  */
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* A function used to create new elements in the hash table.  The      first entry is itself a pointer to an element.  When this      function is first invoked, this pointer will be NULL.  However,      having the pointer permits a hierarchy of method functions to be      built each of which calls the function in the superclass.  Thus      each function should be written to allocate a new block of memory      only if the argument is NULL.  */
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* An objalloc for this hash table.  This is a struct objalloc *,      but we use PTR to avoid requiring the inclusion of objalloc.h.  */
name|PTR
name|memory
decl_stmt|;
block|}
struct|;
comment|/* Initialize a hash table.  */
specifier|extern
name|boolean
name|bfd_hash_table_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
comment|/* Initialize a hash table specifying a size.  */
specifier|extern
name|boolean
name|bfd_hash_table_init_n
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|,
name|unsigned
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
comment|/* Free up a hash table.  */
specifier|extern
name|void
name|bfd_hash_table_free
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Look up a string in a hash table.  If CREATE is true, a new entry    will be created for this string if one does not already exist.  The    COPY argument must be true if this routine should copy the string    into newly allocated memory when adding an entry.  */
specifier|extern
name|struct
name|bfd_hash_entry
modifier|*
name|bfd_hash_lookup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
name|create
operator|,
name|boolean
name|copy
operator|)
argument_list|)
decl_stmt|;
comment|/* Replace an entry in a hash table.  */
specifier|extern
name|void
name|bfd_hash_replace
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|,
expr|struct
name|bfd_hash_entry
operator|*
name|old
operator|,
expr|struct
name|bfd_hash_entry
operator|*
name|nw
operator|)
argument_list|)
decl_stmt|;
comment|/* Base method for creating a hash table entry.  */
specifier|extern
name|struct
name|bfd_hash_entry
modifier|*
name|bfd_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Grab some space for a hash table entry.  */
specifier|extern
name|PTR
name|bfd_hash_allocate
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Traverse a hash table in a random order, calling a function on each    element.  If the function returns false, the traversal stops.  The    INFO argument is passed to the function.  */
specifier|extern
name|void
name|bfd_hash_traverse
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|,
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
name|PTR
argument_list|)
operator|,
name|PTR
name|info
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|COFF_SWAP_TABLE
value|(PTR)&bfd_coff_std_swap_table
comment|/* User program access to BFD facilities.  */
comment|/* Direct I/O routines, for programs which know more about the object    file than BFD does.  Use higher level routines if possible.  */
specifier|extern
name|bfd_size_type
name|bfd_bread
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_size_type
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|bfd_size_type
name|bfd_bwrite
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
name|bfd_size_type
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|bfd_seek
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|ufile_ptr
name|bfd_tell
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|bfd_flush
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|bfd_stat
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Deprecated old routines.  */
if|#
directive|if
name|__GNUC__
define|#
directive|define
name|bfd_read
parameter_list|(
name|BUF
parameter_list|,
name|ELTSIZE
parameter_list|,
name|NITEMS
parameter_list|,
name|ABFD
parameter_list|)
define|\
value|(warn_deprecated ("bfd_read", __FILE__, __LINE__, __FUNCTION__),	\    bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
define|#
directive|define
name|bfd_write
parameter_list|(
name|BUF
parameter_list|,
name|ELTSIZE
parameter_list|,
name|NITEMS
parameter_list|,
name|ABFD
parameter_list|)
define|\
value|(warn_deprecated ("bfd_write", __FILE__, __LINE__, __FUNCTION__),	\    bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
else|#
directive|else
define|#
directive|define
name|bfd_read
parameter_list|(
name|BUF
parameter_list|,
name|ELTSIZE
parameter_list|,
name|NITEMS
parameter_list|,
name|ABFD
parameter_list|)
define|\
value|(warn_deprecated ("bfd_read", (const char *) 0, 0, (const char *) 0), \    bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
define|#
directive|define
name|bfd_write
parameter_list|(
name|BUF
parameter_list|,
name|ELTSIZE
parameter_list|,
name|NITEMS
parameter_list|,
name|ABFD
parameter_list|)
define|\
value|(warn_deprecated ("bfd_write", (const char *) 0, 0, (const char *) 0),\    bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
endif|#
directive|endif
specifier|extern
name|void
name|warn_deprecated
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Cast from const char * to char * so that caller can assign to    a char * without a warning.  */
define|#
directive|define
name|bfd_get_filename
parameter_list|(
name|abfd
parameter_list|)
value|((char *) (abfd)->filename)
define|#
directive|define
name|bfd_get_cacheable
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->cacheable)
define|#
directive|define
name|bfd_get_format
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->format)
define|#
directive|define
name|bfd_get_target
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->name)
define|#
directive|define
name|bfd_get_flavour
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->flavour)
define|#
directive|define
name|bfd_family_coff
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(bfd_get_flavour (abfd) == bfd_target_coff_flavour || \    bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
define|#
directive|define
name|bfd_big_endian
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
define|#
directive|define
name|bfd_little_endian
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
define|#
directive|define
name|bfd_header_big_endian
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
define|#
directive|define
name|bfd_header_little_endian
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
define|#
directive|define
name|bfd_get_file_flags
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->flags)
define|#
directive|define
name|bfd_applicable_file_flags
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->object_flags)
define|#
directive|define
name|bfd_applicable_section_flags
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->section_flags)
define|#
directive|define
name|bfd_my_archive
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->my_archive)
define|#
directive|define
name|bfd_has_map
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->has_armap)
define|#
directive|define
name|bfd_valid_reloc_types
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->valid_reloc_types)
define|#
directive|define
name|bfd_usrdata
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->usrdata)
define|#
directive|define
name|bfd_get_start_address
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->start_address)
define|#
directive|define
name|bfd_get_symcount
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->symcount)
define|#
directive|define
name|bfd_get_outsymbols
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->outsymbols)
define|#
directive|define
name|bfd_count_sections
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->section_count)
define|#
directive|define
name|bfd_get_symbol_leading_char
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->symbol_leading_char)
define|#
directive|define
name|bfd_set_cacheable
parameter_list|(
name|abfd
parameter_list|,
name|bool
parameter_list|)
value|(((abfd)->cacheable = (boolean) (bool)), true)
specifier|extern
name|boolean
name|bfd_cache_close
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
comment|/* NB: This declaration should match the autogenerated one in libbfd.h.  */
specifier|extern
name|boolean
name|bfd_record_phdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|long
operator|,
name|boolean
operator|,
name|flagword
operator|,
name|boolean
operator|,
name|bfd_vma
operator|,
name|boolean
operator|,
name|boolean
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|sec
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Byte swapping routines.  */
name|bfd_vma
name|bfd_getb64
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_vma
name|bfd_getl64
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|bfd_getb_signed_64
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|bfd_getl_signed_64
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_vma
name|bfd_getb32
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_vma
name|bfd_getl32
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|bfd_getb_signed_32
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|bfd_getl_signed_32
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_vma
name|bfd_getb16
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_vma
name|bfd_getl16
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|bfd_getb_signed_16
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|bfd_getl_signed_16
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|void
name|bfd_putb64
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|void
name|bfd_putl64
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|void
name|bfd_putb32
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|void
name|bfd_putl32
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|void
name|bfd_putb16
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|void
name|bfd_putl16
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Byte swapping routines which take size and endiannes as arguments.  */
name|bfd_vma
name|bfd_get_bits
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|,
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
name|void
name|bfd_put_bits
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|bfd_byte
operator|*
operator|,
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
comment|/* Externally visible ECOFF routines.  */
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALMOST_STDC
argument_list|)
struct_decl|struct
name|ecoff_debug_info
struct_decl|;
struct_decl|struct
name|ecoff_debug_swap
struct_decl|;
struct_decl|struct
name|ecoff_extr
struct_decl|;
struct_decl|struct
name|symbol_cache_entry
struct_decl|;
struct_decl|struct
name|bfd_link_info
struct_decl|;
struct_decl|struct
name|bfd_link_hash_entry
struct_decl|;
struct_decl|struct
name|bfd_elf_version_tree
struct_decl|;
endif|#
directive|endif
specifier|extern
name|bfd_vma
name|bfd_ecoff_get_gp_value
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_ecoff_set_gp_value
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_vma
name|gp_value
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_ecoff_set_regmasks
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|unsigned
name|long
name|gprmask
operator|,
name|unsigned
name|long
name|fprmask
operator|,
name|unsigned
name|long
operator|*
name|cprmask
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|PTR
name|bfd_ecoff_debug_init
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|output_debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|output_swap
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bfd_ecoff_debug_free
name|PARAMS
argument_list|(
operator|(
name|PTR
name|handle
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|output_debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|output_swap
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_ecoff_debug_accumulate
name|PARAMS
argument_list|(
operator|(
name|PTR
name|handle
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|output_debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|output_swap
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|input_debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|input_swap
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_ecoff_debug_accumulate_other
name|PARAMS
argument_list|(
operator|(
name|PTR
name|handle
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|output_debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|output_swap
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_ecoff_debug_externals
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|swap
operator|,
name|boolean
name|relocateable
operator|,
name|boolean
argument_list|(
operator|*
name|get_extr
argument_list|)
argument_list|(
expr|struct
name|symbol_cache_entry
operator|*
argument_list|,
expr|struct
name|ecoff_extr
operator|*
argument_list|)
operator|,
name|void
argument_list|(
operator|*
name|set_index
argument_list|)
argument_list|(
expr|struct
name|symbol_cache_entry
operator|*
argument_list|,
name|bfd_size_type
argument_list|)
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_ecoff_debug_one_external
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|swap
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
expr|struct
name|ecoff_extr
operator|*
name|esym
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|bfd_size_type
name|bfd_ecoff_debug_size
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|swap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_ecoff_write_debug
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|swap
operator|,
name|file_ptr
name|where
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_ecoff_write_accumulated_debug
name|PARAMS
argument_list|(
operator|(
name|PTR
name|handle
operator|,
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|swap
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|file_ptr
name|where
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_mips_ecoff_create_embedded_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Externally visible ELF routines.  */
struct|struct
name|bfd_link_needed_list
block|{
name|struct
name|bfd_link_needed_list
modifier|*
name|next
decl_stmt|;
name|bfd
modifier|*
name|by
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
specifier|extern
name|boolean
name|bfd_elf32_record_link_assignment
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_elf64_record_link_assignment
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|struct
name|bfd_link_needed_list
modifier|*
name|bfd_elf_get_needed_list
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_elf_get_bfd_needed_list
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_needed_list
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_elf32_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|*
operator|,
expr|struct
name|bfd_elf_version_tree
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_elf64_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|*
operator|,
expr|struct
name|bfd_elf_version_tree
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bfd_elf_set_dt_needed_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bfd_elf_set_dt_needed_soname
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
specifier|const
name|char
modifier|*
name|bfd_elf_get_dt_soname
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|struct
name|bfd_link_needed_list
modifier|*
name|bfd_elf_get_runpath_list
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_elf32_discard_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_elf64_discard_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Return an upper bound on the number of bytes required to store a    copy of ABFD's program header table entries.  Return -1 if an error    occurs; bfd_get_error will return an appropriate code.  */
specifier|extern
name|long
name|bfd_get_elf_phdr_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
comment|/* Copy ABFD's program header table entries to *PHDRS.  The entries    will be stored as an array of Elf_Internal_Phdr structures, as    defined in include/elf/internal.h.  To find out how large the    buffer needs to be, call bfd_get_elf_phdr_upper_bound.     Return the number of program header table entries read, or -1 if an    error occurs; bfd_get_error will return an appropriate code.  */
specifier|extern
name|int
name|bfd_get_elf_phdrs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|void
operator|*
name|phdrs
operator|)
argument_list|)
decl_stmt|;
comment|/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
specifier|extern
name|int
name|bfd_get_arch_size
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Return true if address "naturally" sign extends, or -1 if not elf.  */
specifier|extern
name|int
name|bfd_get_sign_extend_vma
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_m68k_elf32_create_embedded_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_mips_elf32_create_embedded_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* SunOS shared library support routines for the linker.  */
specifier|extern
name|struct
name|bfd_link_needed_list
modifier|*
name|bfd_sunos_get_needed_list
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_sunos_record_link_assignment
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_sunos_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Linux shared library support routines for the linker.  */
specifier|extern
name|boolean
name|bfd_i386linux_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_m68klinux_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_sparclinux_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* mmap hacks */
struct_decl|struct
name|_bfd_window_internal
struct_decl|;
typedef|typedef
name|struct
name|_bfd_window_internal
name|bfd_window_internal
typedef|;
typedef|typedef
struct|struct
name|_bfd_window
block|{
comment|/* What the user asked for.  */
name|PTR
name|data
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
comment|/* The actual window used by BFD.  Small user-requested read-only      regions sharing a page may share a single window into the object      file.  Read-write versions shouldn't until I've fixed things to      keep track of which portions have been claimed by the      application; don't want to give the same region back when the      application wants two writable copies!  */
name|struct
name|_bfd_window_internal
modifier|*
name|i
decl_stmt|;
block|}
name|bfd_window
typedef|;
specifier|extern
name|void
name|bfd_init_window
name|PARAMS
argument_list|(
operator|(
name|bfd_window
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bfd_free_window
name|PARAMS
argument_list|(
operator|(
name|bfd_window
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_get_file_window
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|,
name|bfd_window
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
comment|/* XCOFF support routines for the linker.  */
specifier|extern
name|boolean
name|bfd_xcoff_link_record_set
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_hash_entry
operator|*
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_xcoff_import_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_hash_entry
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_xcoff_export_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_xcoff_link_count_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_xcoff_record_link_assignment
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_xcoff_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|boolean
operator|,
name|int
operator|,
name|boolean
operator|,
name|boolean
operator|,
expr|struct
name|sec
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_xcoff_link_generate_rtinit
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Externally visible COFF routines.  */
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALMOST_STDC
argument_list|)
struct_decl|struct
name|internal_syment
struct_decl|;
union_decl|union
name|internal_auxent
union_decl|;
endif|#
directive|endif
specifier|extern
name|boolean
name|bfd_coff_get_syment
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|symbol_cache_entry
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_coff_get_auxent
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|symbol_cache_entry
operator|*
operator|,
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_coff_set_symbol_class
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|symbol_cache_entry
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_m68k_coff_create_embedded_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* ARM Interworking support.  Called from linker.  */
specifier|extern
name|boolean
name|bfd_arm_allocate_interworking_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_arm_process_before_allocation
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_arm_get_bfd_for_interworking
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* PE ARM Interworking support.  Called from linker.  */
specifier|extern
name|boolean
name|bfd_arm_pe_allocate_interworking_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_arm_pe_process_before_allocation
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_arm_pe_get_bfd_for_interworking
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* ELF ARM Interworking support.  Called from linker.  */
specifier|extern
name|boolean
name|bfd_elf32_arm_allocate_interworking_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_elf32_arm_process_before_allocation
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|boolean
name|bfd_elf32_arm_get_bfd_for_interworking
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* TI COFF load page support.  */
specifier|extern
name|void
name|bfd_ticoff_set_section_load_page
name|PARAMS
argument_list|(
operator|(
expr|struct
name|sec
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|bfd_ticoff_get_section_load_page
name|PARAMS
argument_list|(
operator|(
expr|struct
name|sec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_extern

begin_comment
comment|/* And more from the source.  */
end_comment

end_unit

