begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF 2 support.    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     Adapted from gdb/dwarf2read.c by Gavin Koch of Cygnus Solutions    (gavin@cygnus.com).     From the dwarf2read.c header:    Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,    Inc.  with support from Florida State University (under contract    with the Ada Joint Program Office), and Silicon Graphics, Inc.    Initial contribution by Brent Benson, Harris Computer Systems, Inc.,    based on Fred Fish's (Cygnus Support) implementation of DWARF 1    support in dwarfread.c  This file is part of BFD.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_comment
comment|/* The data in the .debug_line statement prologue looks like this.  */
end_comment

begin_struct
struct|struct
name|line_head
block|{
name|bfd_vma
name|total_length
decl_stmt|;
name|unsigned
name|short
name|version
decl_stmt|;
name|unsigned
name|int
name|prologue_length
decl_stmt|;
name|unsigned
name|char
name|minimum_instruction_length
decl_stmt|;
name|unsigned
name|char
name|default_is_stmt
decl_stmt|;
name|int
name|line_base
decl_stmt|;
name|unsigned
name|char
name|line_range
decl_stmt|;
name|unsigned
name|char
name|opcode_base
decl_stmt|;
name|unsigned
name|char
modifier|*
name|standard_opcode_lengths
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Attributes have a name and a value.  */
end_comment

begin_struct
struct|struct
name|attribute
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|unsigned
name|int
name|unsnd
decl_stmt|;
name|int
name|snd
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get at parts of an attribute structure.  */
end_comment

begin_define
define|#
directive|define
name|DW_STRING
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.str)
end_define

begin_define
define|#
directive|define
name|DW_UNSND
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.unsnd)
end_define

begin_define
define|#
directive|define
name|DW_BLOCK
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.blk)
end_define

begin_define
define|#
directive|define
name|DW_SND
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.snd)
end_define

begin_define
define|#
directive|define
name|DW_ADDR
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.addr)
end_define

begin_comment
comment|/* Blocks are a bunch of untyped bytes.  */
end_comment

begin_struct
struct|struct
name|dwarf_block
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dwarf2_debug
block|{
comment|/* A list of all previously read comp_units.  */
name|struct
name|comp_unit
modifier|*
name|all_comp_units
decl_stmt|;
comment|/* The next unread compilation unit within the .debug_info section.      Zero indicates that the .debug_info section has not been loaded      into a buffer yet.  */
name|char
modifier|*
name|info_ptr
decl_stmt|;
comment|/* Pointer to the end of the .debug_info section memory buffer.  */
name|char
modifier|*
name|info_ptr_end
decl_stmt|;
comment|/* Pointer to the section and address of the beginning of the      section.  */
name|asection
modifier|*
name|sec
decl_stmt|;
name|char
modifier|*
name|sec_info_ptr
decl_stmt|;
comment|/* Pointer to the symbol table.  */
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
comment|/* Pointer to the .debug_abbrev section loaded into memory.  */
name|char
modifier|*
name|dwarf_abbrev_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_abbrev section.  */
name|unsigned
name|long
name|dwarf_abbrev_size
decl_stmt|;
comment|/* Buffer for decode_line_info.  */
name|char
modifier|*
name|dwarf_line_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_line section.  */
name|unsigned
name|long
name|dwarf_line_size
decl_stmt|;
comment|/* Pointer to the .debug_str section loaded into memory.  */
name|char
modifier|*
name|dwarf_str_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_str section.  */
name|unsigned
name|long
name|dwarf_str_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arange
block|{
name|struct
name|arange
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A minimal decoding of DWARF2 compilation units.  We only decode    what's needed to get to the line number information.  */
end_comment

begin_struct
struct|struct
name|comp_unit
block|{
comment|/* Chain the previously read compilation units.  */
name|struct
name|comp_unit
modifier|*
name|next_unit
decl_stmt|;
comment|/* Keep the bdf convenient (for memory allocation).  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* The lowest and higest addresses contained in this compilation      unit as specified in the compilation unit header.  */
name|struct
name|arange
name|arange
decl_stmt|;
comment|/* The DW_AT_name attribute (for error messages).  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The abbrev hash table.  */
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
comment|/* Note that an error was found by comp_unit_find_nearest_line.  */
name|int
name|error
decl_stmt|;
comment|/* The DW_AT_comp_dir attribute.  */
name|char
modifier|*
name|comp_dir
decl_stmt|;
comment|/* True if there is a line number table associated with this comp. unit.  */
name|int
name|stmtlist
decl_stmt|;
comment|/* The offset into .debug_line of the line number table.  */
name|unsigned
name|long
name|line_offset
decl_stmt|;
comment|/* Pointer to the first child die for the comp unit.  */
name|char
modifier|*
name|first_child_die_ptr
decl_stmt|;
comment|/* The end of the comp unit.  */
name|char
modifier|*
name|end_ptr
decl_stmt|;
comment|/* The decoded line number, NULL if not yet decoded.  */
name|struct
name|line_info_table
modifier|*
name|line_table
decl_stmt|;
comment|/* A list of the functions found in this comp. unit.  */
name|struct
name|funcinfo
modifier|*
name|function_table
decl_stmt|;
comment|/* Pointer to dwarf2_debug structure.  */
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
comment|/* Address size for this unit - from unit header.  */
name|unsigned
name|char
name|addr_size
decl_stmt|;
comment|/* Offset size for this unit - from unit header.  */
name|unsigned
name|char
name|offset_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This data structure holds the information of an abbrev.  */
end_comment

begin_struct
struct|struct
name|abbrev_info
block|{
name|unsigned
name|int
name|number
decl_stmt|;
comment|/* Number identifying abbrev.  */
name|enum
name|dwarf_tag
name|tag
decl_stmt|;
comment|/* DWARF tag.  */
name|int
name|has_children
decl_stmt|;
comment|/* Boolean.  */
name|unsigned
name|int
name|num_attrs
decl_stmt|;
comment|/* Number of attributes.  */
name|struct
name|attr_abbrev
modifier|*
name|attrs
decl_stmt|;
comment|/* An array of attribute descriptions.  */
name|struct
name|abbrev_info
modifier|*
name|next
decl_stmt|;
comment|/* Next in chain.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|attr_abbrev
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|ABBREV_HASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|ABBREV_HASH_SIZE
value|121
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_ALLOC_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|ATTR_ALLOC_CHUNK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_1_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_1_signed_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_2_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_4_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|read_8_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_n_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_string
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_indirect_string
name|PARAMS
argument_list|(
operator|(
expr|struct
name|comp_unit
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_unsigned_leb128
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_signed_leb128
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|read_address
name|PARAMS
argument_list|(
operator|(
expr|struct
name|comp_unit
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|abbrev_info
modifier|*
name|lookup_abbrev
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
expr|struct
name|abbrev_info
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|abbrev_info
modifier|*
modifier|*
name|read_abbrevs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|dwarf2_debug
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_attribute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|attribute
operator|*
operator|,
expr|struct
name|attr_abbrev
operator|*
operator|,
expr|struct
name|comp_unit
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_attribute_value
name|PARAMS
argument_list|(
operator|(
expr|struct
name|attribute
operator|*
operator|,
name|unsigned
operator|,
expr|struct
name|comp_unit
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_line_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|line_info_table
operator|*
operator|,
name|bfd_vma
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|concat_filename
name|PARAMS
argument_list|(
operator|(
expr|struct
name|line_info_table
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arange_add
name|PARAMS
argument_list|(
operator|(
expr|struct
name|comp_unit
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|line_info_table
modifier|*
name|decode_line_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|comp_unit
operator|*
operator|,
expr|struct
name|dwarf2_debug
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|lookup_address_in_line_info_table
name|PARAMS
argument_list|(
operator|(
expr|struct
name|line_info_table
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|lookup_address_in_function_table
name|PARAMS
argument_list|(
operator|(
expr|struct
name|funcinfo
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|scan_unit_for_functions
name|PARAMS
argument_list|(
operator|(
expr|struct
name|comp_unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|find_rela_addend
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_size_type
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|comp_unit
modifier|*
name|parse_comp_unit
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|dwarf2_debug
operator|*
operator|,
name|bfd_vma
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|comp_unit_contains_address
name|PARAMS
argument_list|(
operator|(
expr|struct
name|comp_unit
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|comp_unit_find_nearest_line
name|PARAMS
argument_list|(
operator|(
expr|struct
name|comp_unit
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
expr|struct
name|dwarf2_debug
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|find_debug_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VERBATIM    The following function up to the END VERBATIM mark are    copied directly from dwarf2read.c.  */
end_comment

begin_comment
comment|/* Read dwarf information from a buffer.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|read_1_byte
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_1_signed_byte
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_signed_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_2_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is not used.  */
end_comment

begin_endif
unit|static int read_2_signed_bytes (abfd, buf)      bfd *abfd;      char *buf; {   return bfd_get_signed_16 (abfd, (bfd_byte *) buf); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|int
name|read_4_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is not used.  */
end_comment

begin_endif
unit|static int read_4_signed_bytes (abfd, buf)      bfd *abfd;      char *buf; {   return bfd_get_signed_32 (abfd, (bfd_byte *) buf); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bfd_vma
name|read_8_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_n_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If the size of a host char is 8 bits, we can return a pointer      to the buffer, otherwise we have to copy the data to a buffer      allocated on the temporary obstack.  */
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_string
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|bytes_read_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
decl_stmt|;
block|{
comment|/* Return a pointer to the embedded string.  */
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|bytes_read_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read_ptr
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_indirect_string
parameter_list|(
name|unit
parameter_list|,
name|buf
parameter_list|,
name|bytes_read_ptr
parameter_list|)
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
decl_stmt|;
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|struct
name|dwarf2_debug
modifier|*
name|stash
init|=
name|unit
operator|->
name|stash
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|offset_size
operator|==
literal|4
condition|)
name|offset
operator|=
name|read_4_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|read_8_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
name|unit
operator|->
name|offset_size
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_str_buffer
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_str"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_str section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|stash
operator|->
name|dwarf_str_size
operator|=
name|msec
operator|->
name|_raw_size
expr_stmt|;
name|stash
operator|->
name|dwarf_str_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|msec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_abbrev_buffer
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|dwarf_str_buffer
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|msec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|offset
operator|>=
name|stash
operator|->
name|dwarf_str_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: DW_FORM_strp offset (%u) greater than or equal to .debug_str size (%u)."
argument_list|)
argument_list|,
name|offset
argument_list|,
name|stash
operator|->
name|dwarf_str_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buf
operator|=
name|stash
operator|->
name|dwarf_str_buffer
operator|+
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_unsigned_leb128
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|bytes_read_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
decl_stmt|;
block|{
name|unsigned
name|int
name|result
decl_stmt|;
name|unsigned
name|int
name|num_read
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_signed_leb128
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|bytes_read_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|num_read
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
if|if
condition|(
operator|(
name|shift
operator|<
literal|32
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
condition|)
name|result
operator||=
operator|-
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* END VERBATIM */
end_comment

begin_function
specifier|static
name|bfd_vma
name|read_address
parameter_list|(
name|unit
parameter_list|,
name|buf
parameter_list|)
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
switch|switch
condition|(
name|unit
operator|->
name|addr_size
condition|)
block|{
case|case
literal|8
case|:
return|return
name|bfd_get_64
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|bfd_get_32
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|bfd_get_16
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lookup an abbrev_info structure in the abbrev hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
name|lookup_abbrev
parameter_list|(
name|number
parameter_list|,
name|abbrevs
parameter_list|)
name|unsigned
name|int
name|number
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
block|{
name|unsigned
name|int
name|hash_number
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|hash_number
operator|=
name|number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|abbrev
operator|=
name|abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
while|while
condition|(
name|abbrev
condition|)
block|{
if|if
condition|(
name|abbrev
operator|->
name|number
operator|==
name|number
condition|)
return|return
name|abbrev
return|;
else|else
name|abbrev
operator|=
name|abbrev
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* In DWARF version 2, the description of the debugging information is    stored in a separate .debug_abbrev section.  Before we read any    dies from a section we read in all abbreviations and install them    in a hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
modifier|*
name|read_abbrevs
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|,
name|stash
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
block|{
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
name|char
modifier|*
name|abbrev_ptr
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|cur_abbrev
decl_stmt|;
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|abbrev_name
decl_stmt|;
name|unsigned
name|int
name|abbrev_form
decl_stmt|,
name|hash_number
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_abbrev_buffer
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_abbrev"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_abbrev section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|stash
operator|->
name|dwarf_abbrev_size
operator|=
name|msec
operator|->
name|_raw_size
expr_stmt|;
name|stash
operator|->
name|dwarf_abbrev_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|msec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_abbrev_buffer
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|dwarf_abbrev_buffer
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|msec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|offset
operator|>=
name|stash
operator|->
name|dwarf_abbrev_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Abbrev offset (%u) greater than or equal to .debug_abbrev size (%u)."
argument_list|)
argument_list|,
name|offset
argument_list|,
name|stash
operator|->
name|dwarf_abbrev_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
operator|*
argument_list|)
operator|*
name|ABBREV_HASH_SIZE
expr_stmt|;
name|abbrevs
operator|=
operator|(
expr|struct
name|abbrev_info
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|=
name|stash
operator|->
name|dwarf_abbrev_buffer
operator|+
name|offset
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Loop until we reach an abbrev number of 0.  */
while|while
condition|(
name|abbrev_number
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
argument_list|)
expr_stmt|;
name|cur_abbrev
operator|=
operator|(
expr|struct
name|abbrev_info
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
comment|/* Read in abbrev header.  */
name|cur_abbrev
operator|->
name|number
operator|=
name|abbrev_number
expr_stmt|;
name|cur_abbrev
operator|->
name|tag
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|cur_abbrev
operator|->
name|has_children
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* Now read in declarations.  */
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
while|while
condition|(
name|abbrev_name
condition|)
block|{
if|if
condition|(
operator|(
name|cur_abbrev
operator|->
name|num_attrs
operator|%
name|ATTR_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|amt
operator|=
name|cur_abbrev
operator|->
name|num_attrs
operator|+
name|ATTR_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|attr_abbrev
argument_list|)
expr_stmt|;
name|cur_abbrev
operator|->
name|attrs
operator|=
operator|(
operator|(
expr|struct
name|attr_abbrev
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|cur_abbrev
operator|->
name|attrs
argument_list|,
name|amt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_abbrev
operator|->
name|attrs
condition|)
return|return
literal|0
return|;
block|}
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
index|]
operator|.
name|name
operator|=
name|abbrev_name
expr_stmt|;
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
operator|++
index|]
operator|.
name|form
operator|=
name|abbrev_form
expr_stmt|;
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
block|}
name|hash_number
operator|=
name|abbrev_number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|cur_abbrev
operator|->
name|next
operator|=
name|abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
name|abbrevs
index|[
name|hash_number
index|]
operator|=
name|cur_abbrev
expr_stmt|;
comment|/* Get next abbreviation.          Under Irix6 the abbreviations for a compilation unit are not 	 always properly terminated with an abbrev number of 0. 	 Exit loop if we encounter an abbreviation which we have 	 already read (which means we are about to read the abbreviations 	 for the next compile unit) or if the end of the abbreviation 	 table is reached.  */
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|abbrev_ptr
operator|-
name|stash
operator|->
name|dwarf_abbrev_buffer
argument_list|)
operator|>=
name|stash
operator|->
name|dwarf_abbrev_size
condition|)
break|break;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|abbrevs
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
return|return
name|abbrevs
return|;
block|}
end_function

begin_comment
comment|/* Read an attribute value described by an attribute form.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_attribute_value
parameter_list|(
name|attr
parameter_list|,
name|form
parameter_list|,
name|unit
parameter_list|,
name|info_ptr
parameter_list|)
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|unsigned
name|form
decl_stmt|;
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|char
modifier|*
name|info_ptr
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|attr
operator|->
name|form
operator|=
name|form
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
comment|/* FIXME: DWARF3 draft sais DW_FORM_ref_addr is offset_size.  */
case|case
name|DW_FORM_ref_addr
case|:
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
operator|=
name|read_address
argument_list|(
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|unit
operator|->
name|addr_size
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
operator|(
expr|struct
name|dwarf_block
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block4
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
operator|(
expr|struct
name|dwarf_block
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data2
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_data4
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_data8
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
name|DW_STRING
argument_list|(
name|attr
argument_list|)
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_strp
case|:
name|DW_STRING
argument_list|(
name|attr
argument_list|)
operator|=
name|read_indirect_string
argument_list|(
name|unit
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_block
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
operator|(
expr|struct
name|dwarf_block
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block1
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
operator|(
expr|struct
name|dwarf_block
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data1
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_sdata
case|:
name|DW_SND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_udata
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref2
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref4
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref8
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref_udata
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_indirect
case|:
name|form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|info_ptr
operator|=
name|read_attribute_value
argument_list|(
name|attr
argument_list|,
name|form
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Invalid or unhandled FORM value: %d."
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read an attribute described by an abbreviated attribute.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_attribute
parameter_list|(
name|attr
parameter_list|,
name|abbrev
parameter_list|,
name|unit
parameter_list|,
name|info_ptr
parameter_list|)
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_abbrev
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|char
modifier|*
name|info_ptr
decl_stmt|;
block|{
name|attr
operator|->
name|name
operator|=
name|abbrev
operator|->
name|name
expr_stmt|;
name|info_ptr
operator|=
name|read_attribute_value
argument_list|(
name|attr
argument_list|,
name|abbrev
operator|->
name|form
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Source line information table routines.  */
end_comment

begin_define
define|#
directive|define
name|FILE_ALLOC_CHUNK
value|5
end_define

begin_define
define|#
directive|define
name|DIR_ALLOC_CHUNK
value|5
end_define

begin_struct
struct|struct
name|line_info
block|{
name|struct
name|line_info
modifier|*
name|prev_line
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|int
name|end_sequence
decl_stmt|;
comment|/* End of (sequential) code sequence.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fileinfo
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|dir
decl_stmt|;
name|unsigned
name|int
name|time
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|line_info_table
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|num_files
decl_stmt|;
name|unsigned
name|int
name|num_dirs
decl_stmt|;
name|char
modifier|*
name|comp_dir
decl_stmt|;
name|char
modifier|*
modifier|*
name|dirs
decl_stmt|;
name|struct
name|fileinfo
modifier|*
name|files
decl_stmt|;
name|struct
name|line_info
modifier|*
name|last_line
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|add_line_info
parameter_list|(
name|table
parameter_list|,
name|address
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|,
name|column
parameter_list|,
name|end_sequence
parameter_list|)
name|struct
name|line_info_table
modifier|*
name|table
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|int
name|end_sequence
decl_stmt|;
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|line_info
argument_list|)
decl_stmt|;
name|struct
name|line_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|line_info
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|table
operator|->
name|abfd
argument_list|,
name|amt
argument_list|)
decl_stmt|;
name|info
operator|->
name|prev_line
operator|=
name|table
operator|->
name|last_line
expr_stmt|;
name|table
operator|->
name|last_line
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|info
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|info
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|info
operator|->
name|column
operator|=
name|column
expr_stmt|;
name|info
operator|->
name|end_sequence
operator|=
name|end_sequence
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|concat_filename
parameter_list|(
name|table
parameter_list|,
name|file
parameter_list|)
name|struct
name|line_info_table
modifier|*
name|table
decl_stmt|;
name|unsigned
name|int
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|file
operator|-
literal|1
operator|>=
name|table
operator|->
name|num_files
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: mangled line number section (bad file number)."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"<unknown>"
return|;
block|}
name|filename
operator|=
name|table
operator|->
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|filename
argument_list|)
condition|)
return|return
name|filename
return|;
else|else
block|{
name|char
modifier|*
name|dirname
init|=
operator|(
name|table
operator|->
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
condition|?
name|table
operator|->
name|dirs
index|[
name|table
operator|->
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
operator|-
literal|1
index|]
else|:
name|table
operator|->
name|comp_dir
operator|)
decl_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|concat
argument_list|(
name|dirname
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arange_add
parameter_list|(
name|unit
parameter_list|,
name|low_pc
parameter_list|,
name|high_pc
parameter_list|)
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|bfd_vma
name|low_pc
decl_stmt|;
name|bfd_vma
name|high_pc
decl_stmt|;
block|{
name|struct
name|arange
modifier|*
name|arange
decl_stmt|;
comment|/* First see if we can cheaply extend an existing range.  */
name|arange
operator|=
operator|&
name|unit
operator|->
name|arange
expr_stmt|;
do|do
block|{
if|if
condition|(
name|low_pc
operator|==
name|arange
operator|->
name|high
condition|)
block|{
name|arange
operator|->
name|high
operator|=
name|high_pc
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|high_pc
operator|==
name|arange
operator|->
name|low
condition|)
block|{
name|arange
operator|->
name|low
operator|=
name|low_pc
expr_stmt|;
return|return;
block|}
name|arange
operator|=
name|arange
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|arange
condition|)
do|;
if|if
condition|(
name|unit
operator|->
name|arange
operator|.
name|high
operator|==
literal|0
condition|)
block|{
comment|/* This is the first address range: store it in unit->arange.  */
name|unit
operator|->
name|arange
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|unit
operator|->
name|arange
operator|.
name|low
operator|=
name|low_pc
expr_stmt|;
name|unit
operator|->
name|arange
operator|.
name|high
operator|=
name|high_pc
expr_stmt|;
return|return;
block|}
comment|/* Need to allocate a new arange and insert it into the arange list.  */
name|arange
operator|=
name|bfd_zalloc
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|arange
argument_list|)
argument_list|)
expr_stmt|;
name|arange
operator|->
name|low
operator|=
name|low_pc
expr_stmt|;
name|arange
operator|->
name|high
operator|=
name|high_pc
expr_stmt|;
name|arange
operator|->
name|next
operator|=
name|unit
operator|->
name|arange
operator|.
name|next
expr_stmt|;
name|unit
operator|->
name|arange
operator|.
name|next
operator|=
name|arange
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode the line number information for UNIT.  */
end_comment

begin_function
specifier|static
name|struct
name|line_info_table
modifier|*
name|decode_line_info
parameter_list|(
name|unit
parameter_list|,
name|stash
parameter_list|)
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|struct
name|line_info_table
modifier|*
name|table
decl_stmt|;
name|char
modifier|*
name|line_ptr
decl_stmt|;
name|char
modifier|*
name|line_end
decl_stmt|;
name|struct
name|line_head
name|lh
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|bytes_read
decl_stmt|,
name|offset_size
decl_stmt|;
name|char
modifier|*
name|cur_file
decl_stmt|,
modifier|*
name|cur_dir
decl_stmt|;
name|unsigned
name|char
name|op_code
decl_stmt|,
name|extended_op
decl_stmt|,
name|adj_opcode
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_line_buffer
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_line"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_line section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|stash
operator|->
name|dwarf_line_size
operator|=
name|msec
operator|->
name|_raw_size
expr_stmt|;
name|stash
operator|->
name|dwarf_line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|msec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_line_buffer
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|dwarf_line_buffer
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|msec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* FIXME: We ought to apply the relocs against this section before 	 we process it...  */
block|}
comment|/* Since we are using un-relocated data, it is possible to get a bad value      for the line_offset.  Validate it here so that we won't get a segfault      below.  */
if|if
condition|(
name|unit
operator|->
name|line_offset
operator|>=
name|stash
operator|->
name|dwarf_line_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Line offset (%u) greater than or equal to .debug_line size (%u)."
argument_list|)
argument_list|,
name|unit
operator|->
name|line_offset
argument_list|,
name|stash
operator|->
name|dwarf_line_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|line_info_table
argument_list|)
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|line_info_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|table
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|table
operator|->
name|comp_dir
operator|=
name|unit
operator|->
name|comp_dir
expr_stmt|;
name|table
operator|->
name|num_files
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|files
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|num_dirs
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|dirs
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|files
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|last_line
operator|=
name|NULL
expr_stmt|;
name|line_ptr
operator|=
name|stash
operator|->
name|dwarf_line_buffer
operator|+
name|unit
operator|->
name|line_offset
expr_stmt|;
comment|/* Read in the prologue.  */
name|lh
operator|.
name|total_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|4
expr_stmt|;
name|offset_size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|lh
operator|.
name|total_length
operator|==
literal|0xffffffff
condition|)
block|{
name|lh
operator|.
name|total_length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|8
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
block|}
name|line_end
operator|=
name|line_ptr
operator|+
name|lh
operator|.
name|total_length
expr_stmt|;
name|lh
operator|.
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|offset_size
operator|==
literal|4
condition|)
name|lh
operator|.
name|prologue_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
else|else
name|lh
operator|.
name|prologue_length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|offset_size
expr_stmt|;
name|lh
operator|.
name|minimum_instruction_length
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|default_is_stmt
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|line_base
operator|=
name|read_1_signed_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|line_range
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|opcode_base
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|amt
operator|=
name|lh
operator|.
name|opcode_base
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
expr_stmt|;
name|lh
operator|.
name|standard_opcode_lengths
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|lh
operator|.
name|standard_opcode_lengths
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lh
operator|.
name|opcode_base
condition|;
operator|++
name|i
control|)
block|{
name|lh
operator|.
name|standard_opcode_lengths
index|[
name|i
index|]
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Read directory table.  */
while|while
condition|(
operator|(
name|cur_dir
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|table
operator|->
name|num_dirs
operator|%
name|DIR_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|amt
operator|=
name|table
operator|->
name|num_dirs
operator|+
name|DIR_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|table
operator|->
name|dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|table
operator|->
name|dirs
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|dirs
condition|)
return|return
literal|0
return|;
block|}
name|table
operator|->
name|dirs
index|[
name|table
operator|->
name|num_dirs
operator|++
index|]
operator|=
name|cur_dir
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Read file name table.  */
while|while
condition|(
operator|(
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|table
operator|->
name|num_files
operator|%
name|FILE_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|amt
operator|=
name|table
operator|->
name|num_files
operator|+
name|FILE_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|fileinfo
argument_list|)
expr_stmt|;
name|table
operator|->
name|files
operator|=
operator|(
expr|struct
name|fileinfo
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|table
operator|->
name|files
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|files
condition|)
return|return
literal|0
return|;
block|}
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|name
operator|=
name|cur_file
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|dir
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|num_files
operator|++
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Read the statement sequences until there's nothing left.  */
while|while
condition|(
name|line_ptr
operator|<
name|line_end
condition|)
block|{
comment|/* State machine registers.  */
name|bfd_vma
name|address
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|concat_filename
argument_list|(
name|table
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|line
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|column
init|=
literal|0
decl_stmt|;
name|int
name|is_stmt
init|=
name|lh
operator|.
name|default_is_stmt
decl_stmt|;
name|int
name|basic_block
init|=
literal|0
decl_stmt|;
name|int
name|end_sequence
init|=
literal|0
decl_stmt|,
name|need_low_pc
init|=
literal|1
decl_stmt|;
name|bfd_vma
name|low_pc
init|=
literal|0
decl_stmt|;
comment|/* Decode the table.  */
while|while
condition|(
operator|!
name|end_sequence
condition|)
block|{
name|op_code
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|op_code
operator|>=
name|lh
operator|.
name|opcode_base
condition|)
block|{
comment|/* Special operand.  */
name|adj_opcode
operator|=
name|op_code
operator|-
name|lh
operator|.
name|opcode_base
expr_stmt|;
name|address
operator|+=
operator|(
name|adj_opcode
operator|/
name|lh
operator|.
name|line_range
operator|)
operator|*
name|lh
operator|.
name|minimum_instruction_length
expr_stmt|;
name|line
operator|+=
name|lh
operator|.
name|line_base
operator|+
operator|(
name|adj_opcode
operator|%
name|lh
operator|.
name|line_range
operator|)
expr_stmt|;
comment|/* Append row to matrix using current values.  */
name|add_line_info
argument_list|(
name|table
argument_list|,
name|address
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|basic_block
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_low_pc
condition|)
block|{
name|need_low_pc
operator|=
literal|0
expr_stmt|;
name|low_pc
operator|=
name|address
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|DW_LNS_extended_op
case|:
name|line_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* Ignore length.  */
name|extended_op
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|extended_op
condition|)
block|{
case|case
name|DW_LNE_end_sequence
case|:
name|end_sequence
operator|=
literal|1
expr_stmt|;
name|add_line_info
argument_list|(
name|table
argument_list|,
name|address
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
name|end_sequence
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_low_pc
condition|)
block|{
name|need_low_pc
operator|=
literal|0
expr_stmt|;
name|low_pc
operator|=
name|address
expr_stmt|;
block|}
name|arange_add
argument_list|(
name|unit
argument_list|,
name|low_pc
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNE_set_address
case|:
name|address
operator|=
name|read_address
argument_list|(
name|unit
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|unit
operator|->
name|addr_size
expr_stmt|;
break|break;
case|case
name|DW_LNE_define_file
case|:
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|table
operator|->
name|num_files
operator|%
name|FILE_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|amt
operator|=
name|table
operator|->
name|num_files
operator|+
name|FILE_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|fileinfo
argument_list|)
expr_stmt|;
name|table
operator|->
name|files
operator|=
operator|(
expr|struct
name|fileinfo
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|table
operator|->
name|files
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|files
condition|)
return|return
literal|0
return|;
block|}
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|name
operator|=
name|cur_file
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|dir
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|num_files
operator|++
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: mangled line number section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|DW_LNS_copy
case|:
name|add_line_info
argument_list|(
name|table
argument_list|,
name|address
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|basic_block
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|need_low_pc
condition|)
block|{
name|need_low_pc
operator|=
literal|0
expr_stmt|;
name|low_pc
operator|=
name|address
expr_stmt|;
block|}
break|break;
case|case
name|DW_LNS_advance_pc
case|:
name|address
operator|+=
name|lh
operator|.
name|minimum_instruction_length
operator|*
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_line
case|:
name|line
operator|+=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_file
case|:
block|{
name|unsigned
name|int
name|file
decl_stmt|;
comment|/* The file and directory tables are 0 based, the references 		   are 1 based.  */
name|file
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|filename
operator|=
name|concat_filename
argument_list|(
name|table
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DW_LNS_set_column
case|:
name|column
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_negate_stmt
case|:
name|is_stmt
operator|=
operator|(
operator|!
name|is_stmt
operator|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_basic_block
case|:
name|basic_block
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_LNS_const_add_pc
case|:
name|address
operator|+=
name|lh
operator|.
name|minimum_instruction_length
operator|*
operator|(
operator|(
literal|255
operator|-
name|lh
operator|.
name|opcode_base
operator|)
operator|/
name|lh
operator|.
name|line_range
operator|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|address
operator|+=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
block|{
comment|/* Unknown standard opcode, ignore it.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lh
operator|.
name|standard_opcode_lengths
index|[
name|op_code
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/* If ADDR is within TABLE set the output parameters and return true,    otherwise return false.  The output parameters, FILENAME_PTR and    LINENUMBER_PTR, are pointers to the objects to be filled in.  */
end_comment

begin_function
specifier|static
name|boolean
name|lookup_address_in_line_info_table
parameter_list|(
name|table
parameter_list|,
name|addr
parameter_list|,
name|filename_ptr
parameter_list|,
name|linenumber_ptr
parameter_list|)
name|struct
name|line_info_table
modifier|*
name|table
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|linenumber_ptr
decl_stmt|;
block|{
name|struct
name|line_info
modifier|*
name|next_line
init|=
name|table
operator|->
name|last_line
decl_stmt|;
name|struct
name|line_info
modifier|*
name|each_line
decl_stmt|;
if|if
condition|(
operator|!
name|next_line
condition|)
return|return
name|false
return|;
name|each_line
operator|=
name|next_line
operator|->
name|prev_line
expr_stmt|;
while|while
condition|(
name|each_line
operator|&&
name|next_line
condition|)
block|{
if|if
condition|(
operator|!
name|each_line
operator|->
name|end_sequence
operator|&&
name|addr
operator|>=
name|each_line
operator|->
name|address
operator|&&
name|addr
operator|<
name|next_line
operator|->
name|address
condition|)
block|{
operator|*
name|filename_ptr
operator|=
name|each_line
operator|->
name|filename
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|each_line
operator|->
name|line
expr_stmt|;
return|return
name|true
return|;
block|}
name|next_line
operator|=
name|each_line
expr_stmt|;
name|each_line
operator|=
name|each_line
operator|->
name|prev_line
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Function table functions.  */
end_comment

begin_struct
struct|struct
name|funcinfo
block|{
name|struct
name|funcinfo
modifier|*
name|prev_func
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If ADDR is within TABLE, set FUNCTIONNAME_PTR, and return true.  */
end_comment

begin_function
specifier|static
name|boolean
name|lookup_address_in_function_table
parameter_list|(
name|table
parameter_list|,
name|addr
parameter_list|,
name|functionname_ptr
parameter_list|)
name|struct
name|funcinfo
modifier|*
name|table
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
block|{
name|struct
name|funcinfo
modifier|*
name|each_func
decl_stmt|;
for|for
control|(
name|each_func
operator|=
name|table
init|;
name|each_func
condition|;
name|each_func
operator|=
name|each_func
operator|->
name|prev_func
control|)
block|{
if|if
condition|(
name|addr
operator|>=
name|each_func
operator|->
name|low
operator|&&
name|addr
operator|<
name|each_func
operator|->
name|high
condition|)
block|{
operator|*
name|functionname_ptr
operator|=
name|each_func
operator|->
name|name
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* DWARF2 Compilation unit functions.  */
end_comment

begin_comment
comment|/* Scan over each die in a comp. unit looking for functions to add    to the function table.  */
end_comment

begin_function
specifier|static
name|boolean
name|scan_unit_for_functions
parameter_list|(
name|unit
parameter_list|)
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|char
modifier|*
name|info_ptr
init|=
name|unit
operator|->
name|first_child_die_ptr
decl_stmt|;
name|int
name|nesting_level
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|nesting_level
condition|)
block|{
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|attribute
name|attr
decl_stmt|;
name|struct
name|funcinfo
modifier|*
name|func
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
block|{
name|nesting_level
operator|--
expr_stmt|;
continue|continue;
block|}
name|abbrev
operator|=
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|unit
operator|->
name|abbrevs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Could not find abbrev number %d."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|abbrev
operator|->
name|tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|funcinfo
argument_list|)
decl_stmt|;
name|func
operator|=
operator|(
expr|struct
name|funcinfo
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|func
operator|->
name|prev_func
operator|=
name|unit
operator|->
name|function_table
expr_stmt|;
name|unit
operator|->
name|function_table
operator|=
name|func
expr_stmt|;
block|}
else|else
name|func
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_name
case|:
name|name
operator|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
comment|/* Prefer DW_AT_MIPS_linkage_name over DW_AT_name.  */
if|if
condition|(
name|func
operator|->
name|name
operator|==
name|NULL
condition|)
name|func
operator|->
name|name
operator|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_MIPS_linkage_name
case|:
name|func
operator|->
name|name
operator|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_low_pc
case|:
name|func
operator|->
name|low
operator|=
name|DW_ADDR
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|func
operator|->
name|high
operator|=
name|DW_ADDR
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_name
case|:
name|name
operator|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|abbrev
operator|->
name|has_children
condition|)
name|nesting_level
operator|++
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Look for a RELA relocation to be applied on OFFSET of section SEC,    and return the addend if such a relocation is found.  Since this is    only used to find relocations referring to the .debug_abbrev    section, we make sure the relocation refers to this section, but    this is not strictly necessary, and it can probably be safely    removed if needed.  However, it is important to note that this    function only returns the addend, it doesn't serve the purpose of    applying a generic relocation.     If no suitable relocation is found, or if it is not a real RELA    relocation, this function returns 0.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|find_rela_addend
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|offset
parameter_list|,
name|syms
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_size_type
name|offset
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
block|{
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_count
decl_stmt|,
name|relc
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocs
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|relocs
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|relc
operator|=
literal|0
init|;
name|relc
operator|<
name|reloc_count
condition|;
name|relc
operator|++
control|)
if|if
condition|(
name|relocs
index|[
name|relc
index|]
operator|->
name|address
operator|==
name|offset
operator|&&
operator|(
operator|*
name|relocs
index|[
name|relc
index|]
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|&&
name|strcmp
argument_list|(
operator|(
operator|*
name|relocs
index|[
name|relc
index|]
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|name
argument_list|,
literal|".debug_abbrev"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|addend
init|=
operator|(
name|relocs
index|[
name|relc
index|]
operator|->
name|howto
operator|->
name|partial_inplace
condition|?
literal|0
else|:
name|relocs
index|[
name|relc
index|]
operator|->
name|addend
operator|)
decl_stmt|;
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
return|return
name|addend
return|;
block|}
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse a DWARF2 compilation unit starting at INFO_PTR.  This    includes the compilation unit header that proceeds the DIE's, but    does not include the length field that preceeds each compilation    unit header.  END_PTR points one past the end of this comp unit.    OFFSET_SIZE is the size of DWARF2 offsets (either 4 or 8 bytes).     This routine does not read the whole compilation unit; only enough    to get to the line number information for the compilation unit.  */
end_comment

begin_function
specifier|static
name|struct
name|comp_unit
modifier|*
name|parse_comp_unit
parameter_list|(
name|abfd
parameter_list|,
name|stash
parameter_list|,
name|unit_length
parameter_list|,
name|offset_size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
name|bfd_vma
name|unit_length
decl_stmt|;
name|unsigned
name|int
name|offset_size
decl_stmt|;
block|{
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|unsigned
name|short
name|version
decl_stmt|;
name|unsigned
name|int
name|abbrev_offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|addr_size
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|attribute
name|attr
decl_stmt|;
name|char
modifier|*
name|info_ptr
init|=
name|stash
operator|->
name|info_ptr
decl_stmt|;
name|char
modifier|*
name|end_ptr
init|=
name|info_ptr
operator|+
name|unit_length
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|bfd_size_type
name|off
decl_stmt|;
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|offset_size
operator|==
literal|4
operator|||
name|offset_size
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_size
operator|==
literal|4
condition|)
name|abbrev_offset
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
else|else
name|abbrev_offset
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* The abbrev offset is generally a relocation pointing to      .debug_abbrev+offset.  On RELA targets, we have to find the      relocation and extract the addend to obtain the actual      abbrev_offset, so do it here.  */
name|off
operator|=
name|info_ptr
operator|-
name|stash
operator|->
name|sec_info_ptr
expr_stmt|;
name|abbrev_offset
operator|+=
name|find_rela_addend
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|sec
argument_list|,
name|off
argument_list|,
name|stash
operator|->
name|syms
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|offset_size
expr_stmt|;
name|addr_size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|2
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: found dwarf version '%hu', this reader only handles version 2 information."
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|addr_size
operator|>
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: found address size '%u', this reader can not handle sizes greater than '%u'."
argument_list|)
argument_list|,
name|addr_size
argument_list|,
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|addr_size
operator|!=
literal|2
operator|&&
name|addr_size
operator|!=
literal|4
operator|&&
name|addr_size
operator|!=
literal|8
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Dwarf Error: found address size '%u', this reader can only handle address sizes '2', '4' and '8'."
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Read the abbrevs for this compilation unit into a table.  */
name|abbrevs
operator|=
name|read_abbrevs
argument_list|(
name|abfd
argument_list|,
name|abbrev_offset
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrevs
condition|)
return|return
literal|0
return|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Bad abbrev number: %d."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|abbrev
operator|=
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|abbrevs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Could not find abbrev number %d."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|comp_unit
argument_list|)
expr_stmt|;
name|unit
operator|=
operator|(
expr|struct
name|comp_unit
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|unit
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|unit
operator|->
name|addr_size
operator|=
name|addr_size
expr_stmt|;
name|unit
operator|->
name|offset_size
operator|=
name|offset_size
expr_stmt|;
name|unit
operator|->
name|abbrevs
operator|=
name|abbrevs
expr_stmt|;
name|unit
operator|->
name|end_ptr
operator|=
name|end_ptr
expr_stmt|;
name|unit
operator|->
name|stash
operator|=
name|stash
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* Store the data if it is of an attribute we want to keep in a 	 partial symbol table.  */
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_stmt_list
case|:
name|unit
operator|->
name|stmtlist
operator|=
literal|1
expr_stmt|;
name|unit
operator|->
name|line_offset
operator|=
name|DW_UNSND
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_name
case|:
name|unit
operator|->
name|name
operator|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_low_pc
case|:
name|unit
operator|->
name|arange
operator|.
name|low
operator|=
name|DW_ADDR
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|unit
operator|->
name|arange
operator|.
name|high
operator|=
name|DW_ADDR
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_comp_dir
case|:
block|{
name|char
modifier|*
name|comp_dir
init|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp_dir
condition|)
block|{
comment|/* Irix 6.2 native cc prepends<machine>.: to the compilation 		   directory, get rid of it.  */
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|comp_dir
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|&&
name|cp
operator|!=
name|comp_dir
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|comp_dir
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
name|unit
operator|->
name|comp_dir
operator|=
name|comp_dir
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
name|unit
operator|->
name|first_child_die_ptr
operator|=
name|info_ptr
expr_stmt|;
return|return
name|unit
return|;
block|}
end_function

begin_comment
comment|/* Return true if UNIT contains the address given by ADDR.  */
end_comment

begin_function
specifier|static
name|boolean
name|comp_unit_contains_address
parameter_list|(
name|unit
parameter_list|,
name|addr
parameter_list|)
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|arange
modifier|*
name|arange
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|error
condition|)
return|return
literal|0
return|;
name|arange
operator|=
operator|&
name|unit
operator|->
name|arange
expr_stmt|;
do|do
block|{
if|if
condition|(
name|addr
operator|>=
name|arange
operator|->
name|low
operator|&&
name|addr
operator|<
name|arange
operator|->
name|high
condition|)
return|return
literal|1
return|;
name|arange
operator|=
name|arange
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|arange
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If UNIT contains ADDR, set the output parameters to the values for    the line containing ADDR.  The output parameters, FILENAME_PTR,    FUNCTIONNAME_PTR, and LINENUMBER_PTR, are pointers to the objects    to be filled in.     Return true of UNIT contains ADDR, and no errors were encountered;    false otherwise.  */
end_comment

begin_function
specifier|static
name|boolean
name|comp_unit_find_nearest_line
parameter_list|(
name|unit
parameter_list|,
name|addr
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|linenumber_ptr
parameter_list|,
name|stash
parameter_list|)
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|linenumber_ptr
decl_stmt|;
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
block|{
name|boolean
name|line_p
decl_stmt|;
name|boolean
name|func_p
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|error
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|unit
operator|->
name|line_table
condition|)
block|{
if|if
condition|(
operator|!
name|unit
operator|->
name|stmtlist
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
name|unit
operator|->
name|line_table
operator|=
name|decode_line_info
argument_list|(
name|unit
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unit
operator|->
name|line_table
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|unit
operator|->
name|first_child_die_ptr
operator|<
name|unit
operator|->
name|end_ptr
operator|&&
operator|!
name|scan_unit_for_functions
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|line_p
operator|=
name|lookup_address_in_line_info_table
argument_list|(
name|unit
operator|->
name|line_table
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|linenumber_ptr
argument_list|)
expr_stmt|;
name|func_p
operator|=
name|lookup_address_in_function_table
argument_list|(
name|unit
operator|->
name|function_table
argument_list|,
name|addr
argument_list|,
name|functionname_ptr
argument_list|)
expr_stmt|;
return|return
name|line_p
operator|||
name|func_p
return|;
block|}
end_function

begin_comment
comment|/* Locate a section in a BFD containing debugging info.  The search starts from the    section after AFTER_SEC, or from the first section in the BFD if AFTER_SEC is    NULL.  The search works by examining the names of the sections.  There are two    permissiable names.  The first is .debug_info.  This is the standard DWARF2 name.    The second is a prefix .gnu.linkonce.wi.  This is a variation on the .debug_info    section which has a checksum describing the contents appended onto the name.  This    allows the linker to identify and discard duplicate debugging sections for    different compilation units.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_DEBUG_INFO
value|".debug_info"
end_define

begin_define
define|#
directive|define
name|GNU_LINKONCE_INFO
value|".gnu.linkonce.wi."
end_define

begin_function
specifier|static
name|asection
modifier|*
name|find_debug_info
parameter_list|(
name|abfd
parameter_list|,
name|after_sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|after_sec
decl_stmt|;
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|after_sec
condition|)
name|msec
operator|=
name|after_sec
operator|->
name|next
expr_stmt|;
else|else
name|msec
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|msec
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|msec
operator|->
name|name
argument_list|,
name|DWARF2_DEBUG_INFO
argument_list|)
operator|==
literal|0
condition|)
return|return
name|msec
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|msec
operator|->
name|name
argument_list|,
name|GNU_LINKONCE_INFO
argument_list|,
name|strlen
argument_list|(
name|GNU_LINKONCE_INFO
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|msec
return|;
name|msec
operator|=
name|msec
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The DWARF2 version of find_nearest line.  Return true if the line    is found without error.  ADDR_SIZE is the number of bytes in the    initial .debug_info length field and in the abbreviation offset.    You may use zero to indicate that the default value should be    used.  */
end_comment

begin_function
name|boolean
name|_bfd_dwarf2_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|linenumber_ptr
parameter_list|,
name|addr_size
parameter_list|,
name|pinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|linenumber_ptr
decl_stmt|;
name|unsigned
name|int
name|addr_size
decl_stmt|;
name|PTR
modifier|*
name|pinfo
decl_stmt|;
block|{
comment|/* Read each compilation unit from the section .debug_info, and check      to see if it contains the address we are searching for.  If yes,      lookup the address, and return the line number info.  If no, go      on to the next compilation unit.       We keep a list of all the previously read compilation units, and      a pointer to the next un-read compilation unit.  Check the      previously read units before reading more.  */
name|struct
name|dwarf2_debug
modifier|*
name|stash
init|=
operator|(
expr|struct
name|dwarf2_debug
operator|*
operator|)
operator|*
name|pinfo
decl_stmt|;
comment|/* What address are we looking for?  */
name|bfd_vma
name|addr
init|=
name|offset
operator|+
name|section
operator|->
name|vma
decl_stmt|;
name|struct
name|comp_unit
modifier|*
name|each
decl_stmt|;
operator|*
name|filename_ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
literal|0
expr_stmt|;
comment|/* The DWARF2 spec says that the initial length field, and the      offset of the abbreviation table, should both be 4-byte values.      However, some compilers do things differently.  */
if|if
condition|(
name|addr_size
operator|==
literal|0
condition|)
name|addr_size
operator|=
literal|4
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|addr_size
operator|==
literal|4
operator|||
name|addr_size
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
block|{
name|bfd_size_type
name|total_size
decl_stmt|;
name|asection
modifier|*
name|msec
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_debug
argument_list|)
decl_stmt|;
name|stash
operator|=
operator|(
expr|struct
name|dwarf2_debug
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
return|return
name|false
return|;
operator|*
name|pinfo
operator|=
operator|(
name|PTR
operator|)
name|stash
expr_stmt|;
name|msec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
comment|/* No dwarf2 info.  Note that at this point the stash 	   has been allocated, but contains zeros, this lets 	   future calls to this function fail quicker.  */
return|return
name|false
return|;
comment|/* There can be more than one DWARF2 info section in a BFD these days.          Read them all in and produce one large stash.  We do this in two 	 passes - in the first pass we just accumulate the section sizes. 	 In the second pass we read in the section's contents.  The allows 	 us to avoid reallocing the data as we add sections to the stash.  */
for|for
control|(
name|total_size
operator|=
literal|0
init|;
name|msec
condition|;
name|msec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|)
control|)
name|total_size
operator|+=
name|msec
operator|->
name|_raw_size
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stash
operator|->
name|info_ptr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|stash
operator|->
name|info_ptr_end
operator|=
name|stash
operator|->
name|info_ptr
expr_stmt|;
for|for
control|(
name|msec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
init|;
name|msec
condition|;
name|msec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|)
control|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|start
decl_stmt|;
name|size
operator|=
name|msec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
continue|continue;
name|start
operator|=
name|stash
operator|->
name|info_ptr_end
operator|-
name|stash
operator|->
name|info_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|info_ptr
operator|+
name|start
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
continue|continue;
name|stash
operator|->
name|info_ptr_end
operator|=
name|stash
operator|->
name|info_ptr
operator|+
name|start
operator|+
name|size
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|stash
operator|->
name|info_ptr_end
operator|==
name|stash
operator|->
name|info_ptr
operator|+
name|total_size
argument_list|)
expr_stmt|;
name|stash
operator|->
name|sec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stash
operator|->
name|sec_info_ptr
operator|=
name|stash
operator|->
name|info_ptr
expr_stmt|;
name|stash
operator|->
name|syms
operator|=
name|symbols
expr_stmt|;
block|}
comment|/* FIXME: There is a problem with the contents of the      .debug_info section.  The 'low' and 'high' addresses of the      comp_units are computed by relocs against symbols in the      .text segment.  We need these addresses in order to determine      the nearest line number, and so we have to resolve the      relocs.  There is a similar problem when the .debug_line      section is processed as well (e.g., there may be relocs      against the operand of the DW_LNE_set_address operator).       Unfortunately getting hold of the reloc information is hard...       For now, this means that disassembling object files (as      opposed to fully executables) does not always work as well as      we would like.  */
comment|/* A null info_ptr indicates that there is no dwarf2 info      (or that an error occured while setting up the stash).  */
if|if
condition|(
operator|!
name|stash
operator|->
name|info_ptr
condition|)
return|return
name|false
return|;
comment|/* Check the previously read comp. units first.  */
for|for
control|(
name|each
operator|=
name|stash
operator|->
name|all_comp_units
init|;
name|each
condition|;
name|each
operator|=
name|each
operator|->
name|next_unit
control|)
if|if
condition|(
name|comp_unit_contains_address
argument_list|(
name|each
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|comp_unit_find_nearest_line
argument_list|(
name|each
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
return|;
comment|/* Read each remaining comp. units checking each as they are read.  */
while|while
condition|(
name|stash
operator|->
name|info_ptr
operator|<
name|stash
operator|->
name|info_ptr_end
condition|)
block|{
name|bfd_vma
name|length
decl_stmt|;
name|boolean
name|found
decl_stmt|;
name|unsigned
name|int
name|offset_size
init|=
name|addr_size
decl_stmt|;
if|if
condition|(
name|addr_size
operator|==
literal|4
condition|)
block|{
name|length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|offset_size
operator|=
literal|8
expr_stmt|;
name|length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|info_ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
literal|8
expr_stmt|;
block|}
block|}
else|else
name|length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|info_ptr
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
name|addr_size
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|each
operator|=
name|parse_comp_unit
argument_list|(
name|abfd
argument_list|,
name|stash
argument_list|,
name|length
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
name|length
expr_stmt|;
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|stash
operator|->
name|info_ptr
operator|-
name|stash
operator|->
name|sec_info_ptr
argument_list|)
operator|==
name|stash
operator|->
name|sec
operator|->
name|_raw_size
condition|)
block|{
name|stash
operator|->
name|sec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|sec
argument_list|)
expr_stmt|;
name|stash
operator|->
name|sec_info_ptr
operator|=
name|stash
operator|->
name|info_ptr
expr_stmt|;
block|}
if|if
condition|(
name|each
condition|)
block|{
name|each
operator|->
name|next_unit
operator|=
name|stash
operator|->
name|all_comp_units
expr_stmt|;
name|stash
operator|->
name|all_comp_units
operator|=
name|each
expr_stmt|;
comment|/* DW_AT_low_pc and DW_AT_high_pc are optional for 		 compilation units.  If we don't have them (i.e., 		 unit->high == 0), we need to consult the line info 		 table to see if a compilation unit contains the given 		 address.  */
if|if
condition|(
name|each
operator|->
name|arange
operator|.
name|high
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|comp_unit_contains_address
argument_list|(
name|each
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|comp_unit_find_nearest_line
argument_list|(
name|each
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
return|;
block|}
else|else
block|{
name|found
operator|=
name|comp_unit_find_nearest_line
argument_list|(
name|each
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
name|true
return|;
block|}
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_function

end_unit

