begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A.out "format 1" file handling code for BFD.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,    2001, 2002, 2003    Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/sun4.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_comment
comment|/* This is needed to reject a NewsOS file, e.g. in    gdb/testsuite/gdb.t10/crossload.exp.<kingdon@cygnus.com>    I needed to add M_UNKNOWN to recognize a 68000 object, so this will    probably no longer reject a NewsOS object.<ian@cygnus.com>.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MACHTYPE_OK
end_ifndef

begin_define
define|#
directive|define
name|MACHTYPE_OK
parameter_list|(
name|mtype
parameter_list|)
define|\
value|(((mtype) == M_SPARC&& bfd_lookup_arch (bfd_arch_sparc, 0) != NULL) \    || (((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020) \&& bfd_lookup_arch (bfd_arch_m68k, 0) != NULL))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The file @code{aoutf1.h} contains the code for BFD's a.out back end. Control over the generated back end is given by these two preprocessor names: @table @code @item ARCH_SIZE This value should be either 32 or 64, depending upon the size of an int in the target format. It changes the sizes of the structs which perform the memory/disk mapping of structures.  The 64 bit backend may only be used if the host compiler supports 64 ints (eg long long with gcc), by defining the name @code{BFD_HOST_64_BIT} in @code{bfd.h}. With this name defined, @emph{all} bfd operations are performed with 64bit arithmetic, not just those to a 64bit target.  @item TARGETNAME The name put into the target vector. @item @end table  */
end_comment

begin_comment
comment|/*SUPPRESS558*/
end_comment

begin_comment
comment|/*SUPPRESS529*/
end_comment

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|sunos_set_arch_mach
value|sunos_64_set_arch_mach
end_define

begin_define
define|#
directive|define
name|sunos_write_object_contents
value|aout_64_sunos4_write_object_contents
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sunos_set_arch_mach
value|sunos_32_set_arch_mach
end_define

begin_define
define|#
directive|define
name|sunos_write_object_contents
value|aout_32_sunos4_write_object_contents
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sunos_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sunos_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|machine_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|choose_reloc_size
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sunos_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|sunos4_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sunos4_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sunos4_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sunos4_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sunos4_set_sizes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Merge backend data into the output file.    This is necessary on sparclet-aout where we want the resultant machine    number to be M_SPARCLET if any input file is M_SPARCLET.  */
end_comment

begin_define
define|#
directive|define
name|MY_bfd_merge_private_bfd_data
value|sunos_merge_private_bfd_data
end_define

begin_function
specifier|static
name|bfd_boolean
name|sunos_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|,
decl|*
name|obfd
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_aout_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_aout_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_arch_sparc
condition|)
block|{
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
operator|<
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
condition|)
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_arch_sparc
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/* This is either sunos_32_set_arch_mach or sunos_64_set_arch_mach,    depending upon ARCH_SIZE.  */
end_comment

begin_function
specifier|static
name|void
name|sunos_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|machtype
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|machine_type
name|machtype
decl_stmt|;
block|{
comment|/* Determine the architecture and machine type of the object file.  */
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
switch|switch
condition|(
name|machtype
condition|)
block|{
case|case
name|M_UNKNOWN
case|:
comment|/* Some Sun3s make magic numbers without cpu types in them, so 	 we'll default to the 68000.  */
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
name|bfd_mach_m68000
expr_stmt|;
break|break;
case|case
name|M_68010
case|:
case|case
name|M_HP200
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
name|bfd_mach_m68010
expr_stmt|;
break|break;
case|case
name|M_68020
case|:
case|case
name|M_HP300
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
name|bfd_mach_m68020
expr_stmt|;
break|break;
case|case
name|M_SPARC
case|:
name|arch
operator|=
name|bfd_arch_sparc
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|M_SPARCLET
case|:
name|arch
operator|=
name|bfd_arch_sparc
expr_stmt|;
name|machine
operator|=
name|bfd_mach_sparc_sparclet
expr_stmt|;
break|break;
case|case
name|M_SPARCLITE_LE
case|:
name|arch
operator|=
name|bfd_arch_sparc
expr_stmt|;
name|machine
operator|=
name|bfd_mach_sparc_sparclite_le
expr_stmt|;
break|break;
case|case
name|M_386
case|:
case|case
name|M_386_DYNIX
case|:
name|arch
operator|=
name|bfd_arch_i386
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|M_29K
case|:
name|arch
operator|=
name|bfd_arch_a29k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|M_HPUX
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SET_ARCH_MACH
parameter_list|(
name|ABFD
parameter_list|,
name|EXEC
parameter_list|)
define|\
value|NAME(sunos,set_arch_mach) (ABFD, N_MACHTYPE (EXEC)); \   choose_reloc_size(ABFD);
end_define

begin_comment
comment|/* Determine the size of a relocation entry, based on the architecture */
end_comment

begin_function
specifier|static
name|void
name|choose_reloc_size
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
case|case
name|bfd_arch_a29k
case|:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_EXT_SIZE
expr_stmt|;
break|break;
default|default:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Write an object file in SunOS format.  Section contents have    already been written.  We write the file header, symbols, and    relocation.  The real name of this function is either    aout_64_sunos4_write_object_contents or    aout_32_sunos4_write_object_contents, depending upon ARCH_SIZE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Magic number, maestro, please!  */
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_m68k
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_m68000
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68010
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_68010
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|bfd_mach_m68020
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_68020
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_sparc
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_sparc_sparclet
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_SPARCLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_mach_sparc_sparclite_le
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_SPARCLITE_LE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_SPARC
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_i386
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_386
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_a29k
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_29K
argument_list|)
expr_stmt|;
break|break;
default|default:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_UNKNOWN
argument_list|)
expr_stmt|;
block|}
name|choose_reloc_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|N_SET_FLAGS
argument_list|(
operator|*
name|execp
argument_list|,
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_hdr_flags
argument_list|)
expr_stmt|;
name|N_SET_DYNAMIC
argument_list|(
operator|*
name|execp
argument_list|,
call|(
name|long
call|)
argument_list|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|DYNAMIC
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_HEADERS
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* core files */
end_comment

begin_define
define|#
directive|define
name|CORE_MAGIC
value|0x080456
end_define

begin_define
define|#
directive|define
name|CORE_NAMELEN
value|16
end_define

begin_comment
comment|/* The core structure is taken from the Sun documentation.   Unfortunately, they don't document the FPA structure, or at least I   can't find it easily.  Fortunately the core header contains its own   length.  So this shouldn't cause problems, except for c_ucode, which   so far we don't use but is easy to find with a little arithmetic.  */
end_comment

begin_comment
comment|/* But the reg structure can be gotten from the SPARC processor handbook.   This really should be in a GNU include file though so that gdb can use   the same info.  */
end_comment

begin_struct
struct|struct
name|regs
block|{
name|int
name|r_psr
decl_stmt|;
name|int
name|r_pc
decl_stmt|;
name|int
name|r_npc
decl_stmt|;
name|int
name|r_y
decl_stmt|;
name|int
name|r_g1
decl_stmt|;
name|int
name|r_g2
decl_stmt|;
name|int
name|r_g3
decl_stmt|;
name|int
name|r_g4
decl_stmt|;
name|int
name|r_g5
decl_stmt|;
name|int
name|r_g6
decl_stmt|;
name|int
name|r_g7
decl_stmt|;
name|int
name|r_o0
decl_stmt|;
name|int
name|r_o1
decl_stmt|;
name|int
name|r_o2
decl_stmt|;
name|int
name|r_o3
decl_stmt|;
name|int
name|r_o4
decl_stmt|;
name|int
name|r_o5
decl_stmt|;
name|int
name|r_o6
decl_stmt|;
name|int
name|r_o7
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Taken from Sun documentation: */
end_comment

begin_comment
comment|/* FIXME:  It's worse than we expect.  This struct contains TWO substructs   neither of whose size we know, WITH STUFF IN BETWEEN THEM!  We can't   even portably access the stuff in between!  */
end_comment

begin_struct
struct|struct
name|external_sparc_core
block|{
name|int
name|c_magic
decl_stmt|;
comment|/* Corefile magic number */
name|int
name|c_len
decl_stmt|;
comment|/* Sizeof (struct core) */
define|#
directive|define
name|SPARC_CORE_LEN
value|432
name|int
name|c_regs
index|[
literal|19
index|]
decl_stmt|;
comment|/* General purpose registers -- MACHDEP SIZE */
name|struct
name|external_exec
name|c_aouthdr
decl_stmt|;
comment|/* A.out header */
name|int
name|c_signo
decl_stmt|;
comment|/* Killing signal, if any */
name|int
name|c_tsize
decl_stmt|;
comment|/* Text size (bytes) */
name|int
name|c_dsize
decl_stmt|;
comment|/* Data size (bytes) */
name|int
name|c_ssize
decl_stmt|;
comment|/* Stack size (bytes) */
name|char
name|c_cmdname
index|[
name|CORE_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Command name */
name|double
name|fp_stuff
index|[
literal|1
index|]
decl_stmt|;
comment|/* external FPU state (size unknown by us) */
comment|/* The type "double" is critical here, for alignment.     SunOS declares a struct here, but the struct's alignment       is double since it contains doubles.  */
name|int
name|c_ucode
decl_stmt|;
comment|/* Exception no. from u_code */
comment|/* (this member is not accessible by name since we don't     portably know the size of fp_stuff.) */
block|}
struct|;
end_struct

begin_comment
comment|/* Core files generated by the BCP (the part of Solaris which allows    it to run SunOS4 a.out files).  */
end_comment

begin_struct
struct|struct
name|external_solaris_bcp_core
block|{
name|int
name|c_magic
decl_stmt|;
comment|/* Corefile magic number */
name|int
name|c_len
decl_stmt|;
comment|/* Sizeof (struct core) */
define|#
directive|define
name|SOLARIS_BCP_CORE_LEN
value|456
name|int
name|c_regs
index|[
literal|19
index|]
decl_stmt|;
comment|/* General purpose registers -- MACHDEP SIZE */
name|int
name|c_exdata_vp
decl_stmt|;
comment|/* exdata structure */
name|int
name|c_exdata_tsize
decl_stmt|;
name|int
name|c_exdata_dsize
decl_stmt|;
name|int
name|c_exdata_bsize
decl_stmt|;
name|int
name|c_exdata_lsize
decl_stmt|;
name|int
name|c_exdata_nshlibs
decl_stmt|;
name|short
name|c_exdata_mach
decl_stmt|;
name|short
name|c_exdata_mag
decl_stmt|;
name|int
name|c_exdata_toffset
decl_stmt|;
name|int
name|c_exdata_doffset
decl_stmt|;
name|int
name|c_exdata_loffset
decl_stmt|;
name|int
name|c_exdata_txtorg
decl_stmt|;
name|int
name|c_exdata_datorg
decl_stmt|;
name|int
name|c_exdata_entloc
decl_stmt|;
name|int
name|c_signo
decl_stmt|;
comment|/* Killing signal, if any */
name|int
name|c_tsize
decl_stmt|;
comment|/* Text size (bytes) */
name|int
name|c_dsize
decl_stmt|;
comment|/* Data size (bytes) */
name|int
name|c_ssize
decl_stmt|;
comment|/* Stack size (bytes) */
name|char
name|c_cmdname
index|[
name|CORE_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Command name */
name|double
name|fp_stuff
index|[
literal|1
index|]
decl_stmt|;
comment|/* external FPU state (size unknown by us) */
comment|/* The type "double" is critical here, for alignment.     SunOS declares a struct here, but the struct's alignment       is double since it contains doubles.  */
name|int
name|c_ucode
decl_stmt|;
comment|/* Exception no. from u_code */
comment|/* (this member is not accessible by name since we don't     portably know the size of fp_stuff.) */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|external_sun3_core
block|{
name|int
name|c_magic
decl_stmt|;
comment|/* Corefile magic number */
name|int
name|c_len
decl_stmt|;
comment|/* Sizeof (struct core) */
define|#
directive|define
name|SUN3_CORE_LEN
value|826
comment|/* As of SunOS 4.1.1 */
name|int
name|c_regs
index|[
literal|18
index|]
decl_stmt|;
comment|/* General purpose registers -- MACHDEP SIZE */
name|struct
name|external_exec
name|c_aouthdr
decl_stmt|;
comment|/* A.out header */
name|int
name|c_signo
decl_stmt|;
comment|/* Killing signal, if any */
name|int
name|c_tsize
decl_stmt|;
comment|/* Text size (bytes) */
name|int
name|c_dsize
decl_stmt|;
comment|/* Data size (bytes) */
name|int
name|c_ssize
decl_stmt|;
comment|/* Stack size (bytes) */
name|char
name|c_cmdname
index|[
name|CORE_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Command name */
name|double
name|fp_stuff
index|[
literal|1
index|]
decl_stmt|;
comment|/* external FPU state (size unknown by us) */
comment|/* The type "double" is critical here, for alignment.     SunOS declares a struct here, but the struct's alignment       is double since it contains doubles.  */
name|int
name|c_ucode
decl_stmt|;
comment|/* Exception no. from u_code */
comment|/* (this member is not accessible by name since we don't     portably know the size of fp_stuff.) */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|internal_sunos_core
block|{
name|int
name|c_magic
decl_stmt|;
comment|/* Corefile magic number */
name|int
name|c_len
decl_stmt|;
comment|/* Sizeof (struct core) */
name|long
name|c_regs_pos
decl_stmt|;
comment|/* file offset of General purpose registers */
name|int
name|c_regs_size
decl_stmt|;
comment|/* size of General purpose registers */
name|struct
name|internal_exec
name|c_aouthdr
decl_stmt|;
comment|/* A.out header */
name|int
name|c_signo
decl_stmt|;
comment|/* Killing signal, if any */
name|int
name|c_tsize
decl_stmt|;
comment|/* Text size (bytes) */
name|int
name|c_dsize
decl_stmt|;
comment|/* Data size (bytes) */
name|bfd_vma
name|c_data_addr
decl_stmt|;
comment|/* Data start (address) */
name|int
name|c_ssize
decl_stmt|;
comment|/* Stack size (bytes) */
name|bfd_vma
name|c_stacktop
decl_stmt|;
comment|/* Stack top (address) */
name|char
name|c_cmdname
index|[
name|CORE_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Command name */
name|long
name|fp_stuff_pos
decl_stmt|;
comment|/* file offset of external FPU state (regs) */
name|int
name|fp_stuff_size
decl_stmt|;
comment|/* Size of it */
name|int
name|c_ucode
decl_stmt|;
comment|/* Exception no. from u_code */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|swapcore_sun3
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|internal_sunos_core
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swapcore_sparc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|internal_sunos_core
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swapcore_solaris_bcp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|internal_sunos_core
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* byte-swap in the Sun-3 core structure */
end_comment

begin_function
specifier|static
name|void
name|swapcore_sun3
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|,
name|intcore
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|ext
decl_stmt|;
name|struct
name|internal_sunos_core
modifier|*
name|intcore
decl_stmt|;
block|{
name|struct
name|external_sun3_core
modifier|*
name|extcore
init|=
operator|(
expr|struct
name|external_sun3_core
operator|*
operator|)
name|ext
decl_stmt|;
name|intcore
operator|->
name|c_magic
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_magic
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_len
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_len
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sun3_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|c_regs
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_size
operator|=
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_regs
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
name|aout_64_swap_exec_header_in
else|#
directive|else
name|aout_32_swap_exec_header_in
endif|#
directive|endif
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_aouthdr
argument_list|,
operator|&
name|intcore
operator|->
name|c_aouthdr
argument_list|)
decl_stmt|;
name|intcore
operator|->
name|c_signo
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_signo
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_tsize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_tsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_dsize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_dsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_data_addr
operator|=
name|N_DATADDR
argument_list|(
name|intcore
operator|->
name|c_aouthdr
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_ssize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_ssize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|,
name|extcore
operator|->
name|c_cmdname
argument_list|,
sizeof|sizeof
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|)
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|fp_stuff_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sun3_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* FP stuff takes up whole rest of struct, except c_ucode.  */
name|intcore
operator|->
name|fp_stuff_size
operator|=
name|intcore
operator|->
name|c_len
operator|-
operator|(
sizeof|sizeof
name|extcore
operator|->
name|c_ucode
operator|)
operator|-
call|(
name|file_ptr
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sun3_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* Ucode is the last thing in the struct -- just before the end */
name|intcore
operator|->
name|c_ucode
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|intcore
operator|->
name|c_len
operator|-
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_ucode
argument_list|)
operator|+
operator|(
name|unsigned
name|char
operator|*
operator|)
name|extcore
operator|)
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_stacktop
operator|=
literal|0x0E000000
expr_stmt|;
comment|/* By experimentation */
block|}
end_function

begin_comment
comment|/* byte-swap in the Sparc core structure */
end_comment

begin_function
specifier|static
name|void
name|swapcore_sparc
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|,
name|intcore
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|ext
decl_stmt|;
name|struct
name|internal_sunos_core
modifier|*
name|intcore
decl_stmt|;
block|{
name|struct
name|external_sparc_core
modifier|*
name|extcore
init|=
operator|(
expr|struct
name|external_sparc_core
operator|*
operator|)
name|ext
decl_stmt|;
name|intcore
operator|->
name|c_magic
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_magic
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_len
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_len
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sparc_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|c_regs
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_size
operator|=
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_regs
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
name|aout_64_swap_exec_header_in
else|#
directive|else
name|aout_32_swap_exec_header_in
endif|#
directive|endif
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_aouthdr
argument_list|,
operator|&
name|intcore
operator|->
name|c_aouthdr
argument_list|)
decl_stmt|;
name|intcore
operator|->
name|c_signo
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_signo
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_tsize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_tsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_dsize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_dsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_data_addr
operator|=
name|N_DATADDR
argument_list|(
name|intcore
operator|->
name|c_aouthdr
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_ssize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_ssize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|,
name|extcore
operator|->
name|c_cmdname
argument_list|,
sizeof|sizeof
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|)
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|fp_stuff_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sparc_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* FP stuff takes up whole rest of struct, except c_ucode.  */
name|intcore
operator|->
name|fp_stuff_size
operator|=
name|intcore
operator|->
name|c_len
operator|-
operator|(
sizeof|sizeof
name|extcore
operator|->
name|c_ucode
operator|)
operator|-
call|(
name|file_ptr
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sparc_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* Ucode is the last thing in the struct -- just before the end */
name|intcore
operator|->
name|c_ucode
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|intcore
operator|->
name|c_len
operator|-
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_ucode
argument_list|)
operator|+
operator|(
name|unsigned
name|char
operator|*
operator|)
name|extcore
operator|)
argument_list|)
expr_stmt|;
comment|/* Supposedly the user stack grows downward from the bottom of kernel memory.      Presuming that this remains true, this definition will work.  */
comment|/* Now sun has provided us with another challenge.  The value is different      for sparc2 and sparc10 (both running SunOS 4.1.3).  We pick one or      the other based on the current value of the stack pointer.  This      loses (a) if the stack pointer has been clobbered, or (b) if the stack      is larger than 128 megabytes.       It's times like these you're glad they're switching to ELF.       Note that using include files or nlist on /vmunix would be wrong,      because we want the value for this core file, no matter what kind of      machine we were compiled on or are running on.  */
define|#
directive|define
name|SPARC_USRSTACK_SPARC2
value|((bfd_vma)0xf8000000)
define|#
directive|define
name|SPARC_USRSTACK_SPARC10
value|((bfd_vma)0xf0000000)
block|{
name|bfd_vma
name|sp
init|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|regs
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_regs
index|[
literal|0
index|]
operator|)
operator|->
name|r_o6
argument_list|)
decl_stmt|;
if|if
condition|(
name|sp
operator|<
name|SPARC_USRSTACK_SPARC10
condition|)
name|intcore
operator|->
name|c_stacktop
operator|=
name|SPARC_USRSTACK_SPARC10
expr_stmt|;
else|else
name|intcore
operator|->
name|c_stacktop
operator|=
name|SPARC_USRSTACK_SPARC2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* byte-swap in the Solaris BCP core structure */
end_comment

begin_function
specifier|static
name|void
name|swapcore_solaris_bcp
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|,
name|intcore
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|ext
decl_stmt|;
name|struct
name|internal_sunos_core
modifier|*
name|intcore
decl_stmt|;
block|{
name|struct
name|external_solaris_bcp_core
modifier|*
name|extcore
init|=
operator|(
expr|struct
name|external_solaris_bcp_core
operator|*
operator|)
name|ext
decl_stmt|;
name|intcore
operator|->
name|c_magic
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_magic
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_len
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_len
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_solaris_bcp_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|c_regs
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_size
operator|=
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_regs
argument_list|)
expr_stmt|;
comment|/* The Solaris BCP exdata structure does not contain an a_syms field,      so we are unable to synthesize an internal exec header.      Luckily we are able to figure out the start address of the data section,      which is the only thing needed from the internal exec header,      from the exdata structure.       As of Solaris 2.3, BCP core files for statically linked executables      are buggy. The exdata structure is not properly filled in, and      the data section is written from address zero instead of the data      start address.  */
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|intcore
operator|->
name|c_aouthdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_data_addr
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_exdata_datorg
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_signo
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_signo
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_tsize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_tsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_dsize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_dsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_ssize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_ssize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|,
name|extcore
operator|->
name|c_cmdname
argument_list|,
sizeof|sizeof
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|)
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|fp_stuff_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_solaris_bcp_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* FP stuff takes up whole rest of struct, except c_ucode.  */
name|intcore
operator|->
name|fp_stuff_size
operator|=
name|intcore
operator|->
name|c_len
operator|-
operator|(
sizeof|sizeof
name|extcore
operator|->
name|c_ucode
operator|)
operator|-
call|(
name|file_ptr
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_solaris_bcp_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* Ucode is the last thing in the struct -- just before the end */
name|intcore
operator|->
name|c_ucode
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|intcore
operator|->
name|c_len
operator|-
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_ucode
argument_list|)
operator|+
operator|(
name|unsigned
name|char
operator|*
operator|)
name|extcore
operator|)
argument_list|)
expr_stmt|;
comment|/* Supposedly the user stack grows downward from the bottom of kernel memory.      Presuming that this remains true, this definition will work.  */
comment|/* Now sun has provided us with another challenge.  The value is different      for sparc2 and sparc10 (both running SunOS 4.1.3).  We pick one or      the other based on the current value of the stack pointer.  This      loses (a) if the stack pointer has been clobbered, or (b) if the stack      is larger than 128 megabytes.       It's times like these you're glad they're switching to ELF.       Note that using include files or nlist on /vmunix would be wrong,      because we want the value for this core file, no matter what kind of      machine we were compiled on or are running on.  */
define|#
directive|define
name|SPARC_USRSTACK_SPARC2
value|((bfd_vma)0xf8000000)
define|#
directive|define
name|SPARC_USRSTACK_SPARC10
value|((bfd_vma)0xf0000000)
block|{
name|bfd_vma
name|sp
init|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|regs
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_regs
index|[
literal|0
index|]
operator|)
operator|->
name|r_o6
argument_list|)
decl_stmt|;
if|if
condition|(
name|sp
operator|<
name|SPARC_USRSTACK_SPARC10
condition|)
name|intcore
operator|->
name|c_stacktop
operator|=
name|SPARC_USRSTACK_SPARC10
expr_stmt|;
else|else
name|intcore
operator|->
name|c_stacktop
operator|=
name|SPARC_USRSTACK_SPARC2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* need this cast because ptr is really void * */
end_comment

begin_define
define|#
directive|define
name|core_hdr
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->tdata.sun_core_data)
end_define

begin_define
define|#
directive|define
name|core_datasec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->data_section)
end_define

begin_define
define|#
directive|define
name|core_stacksec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->stack_section)
end_define

begin_define
define|#
directive|define
name|core_regsec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->reg_section)
end_define

begin_define
define|#
directive|define
name|core_reg2sec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->reg2_section)
end_define

begin_comment
comment|/* These are stored in the bfd's tdata */
end_comment

begin_struct
struct|struct
name|sun_core_struct
block|{
name|struct
name|internal_sunos_core
modifier|*
name|hdr
decl_stmt|;
comment|/* core file header */
name|asection
modifier|*
name|data_section
decl_stmt|;
name|asection
modifier|*
name|stack_section
decl_stmt|;
name|asection
modifier|*
name|reg_section
decl_stmt|;
name|asection
modifier|*
name|reg2_section
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|sunos4_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|char
name|longbuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Raw bytes of various header fields */
name|bfd_size_type
name|core_size
decl_stmt|,
name|amt
decl_stmt|;
name|unsigned
name|long
name|core_mag
decl_stmt|;
name|struct
name|internal_sunos_core
modifier|*
name|core
decl_stmt|;
name|char
modifier|*
name|extcore
decl_stmt|;
struct|struct
name|mergem
block|{
name|struct
name|sun_core_struct
name|suncoredata
decl_stmt|;
name|struct
name|internal_sunos_core
name|internal_sunos_core
decl_stmt|;
name|char
name|external_core
index|[
literal|1
index|]
decl_stmt|;
block|}
modifier|*
name|mergem
struct|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|longbuf
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|longbuf
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|longbuf
argument_list|)
condition|)
return|return
literal|0
return|;
name|core_mag
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|longbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_mag
operator|!=
name|CORE_MAGIC
condition|)
return|return
literal|0
return|;
comment|/* SunOS core headers can vary in length; second word is size; */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|longbuf
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|longbuf
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|longbuf
argument_list|)
condition|)
return|return
literal|0
return|;
name|core_size
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|longbuf
argument_list|)
expr_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|core_size
operator|>
literal|20000
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|amt
operator|=
name|core_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mergem
argument_list|)
expr_stmt|;
name|mergem
operator|=
operator|(
expr|struct
name|mergem
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergem
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|extcore
operator|=
name|mergem
operator|->
name|external_core
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|extcore
argument_list|,
name|core_size
argument_list|,
name|abfd
argument_list|)
operator|)
operator|!=
name|core_size
condition|)
block|{
name|loser
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mergem
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|NULL
expr_stmt|;
name|bfd_section_list_clear
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Validate that it's a core file we know how to handle, due to sun      botching the positioning of registers and other fields in a machine      dependent way.  */
name|core
operator|=
operator|&
name|mergem
operator|->
name|internal_sunos_core
expr_stmt|;
switch|switch
condition|(
name|core_size
condition|)
block|{
case|case
name|SPARC_CORE_LEN
case|:
name|swapcore_sparc
argument_list|(
name|abfd
argument_list|,
name|extcore
argument_list|,
name|core
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUN3_CORE_LEN
case|:
name|swapcore_sun3
argument_list|(
name|abfd
argument_list|,
name|extcore
argument_list|,
name|core
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOLARIS_BCP_CORE_LEN
case|:
name|swapcore_solaris_bcp
argument_list|(
name|abfd
argument_list|,
name|extcore
argument_list|,
name|core
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
comment|/* FIXME */
goto|goto
name|loser
goto|;
block|}
name|abfd
operator|->
name|tdata
operator|.
name|sun_core_data
operator|=
operator|&
name|mergem
operator|->
name|suncoredata
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|sun_core_data
operator|->
name|hdr
operator|=
name|core
expr_stmt|;
comment|/* Create the sections.  */
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".stack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
comment|/* bfd_release frees everything allocated after it's arg.  */
goto|goto
name|loser
goto|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|loser
goto|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|loser
goto|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".reg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|loser
goto|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|core
operator|->
name|c_ssize
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|core
operator|->
name|c_dsize
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|core
operator|->
name|c_regs_size
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|core
operator|->
name|fp_stuff_size
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
operator|(
name|core
operator|->
name|c_stacktop
operator|-
name|core
operator|->
name|c_ssize
operator|)
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|core
operator|->
name|c_data_addr
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|core
operator|->
name|c_len
operator|+
name|core
operator|->
name|c_dsize
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|core
operator|->
name|c_len
expr_stmt|;
comment|/* We'll access the regs afresh in the core file, like any section: */
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|->
name|c_regs_pos
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|->
name|fp_stuff_pos
expr_stmt|;
comment|/* Align to word at least */
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sunos4_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdr
operator|->
name|c_cmdname
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sunos4_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdr
operator|->
name|c_signo
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sunos4_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
block|{
if|if
condition|(
name|core_bfd
operator|->
name|xvec
operator|!=
name|exec_bfd
operator|->
name|xvec
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Solaris core files do not include an aouthdr.  */
if|if
condition|(
operator|(
name|core_hdr
argument_list|(
name|core_bfd
argument_list|)
operator|->
name|hdr
operator|)
operator|->
name|c_len
operator|==
name|SOLARIS_BCP_CORE_LEN
condition|)
return|return
name|TRUE
return|;
return|return
operator|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
name|core_hdr
argument_list|(
name|core_bfd
argument_list|)
operator|->
name|hdr
operator|)
operator|->
name|c_aouthdr
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|exec_hdr
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MY_set_sizes
value|sunos4_set_sizes
end_define

begin_function
specifier|static
name|bfd_boolean
name|sunos4_set_sizes
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|bfd_arch_sparc
case|:
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|0x2000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|0x2000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|bfd_arch_m68k
case|:
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|0x2000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|0x20000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* We default to setting the toolversion field to 1, as is required by    SunOS.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_exec_hdr_flags
end_ifndef

begin_define
define|#
directive|define
name|MY_exec_hdr_flags
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_entry_is_text_address
end_ifndef

begin_define
define|#
directive|define
name|MY_entry_is_text_address
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_add_dynamic_symbols
end_ifndef

begin_define
define|#
directive|define
name|MY_add_dynamic_symbols
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_add_one_symbol
end_ifndef

begin_define
define|#
directive|define
name|MY_add_one_symbol
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_link_dynamic_object
end_ifndef

begin_define
define|#
directive|define
name|MY_link_dynamic_object
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_write_dynamic_symbol
end_ifndef

begin_define
define|#
directive|define
name|MY_write_dynamic_symbol
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_check_dynamic_reloc
end_ifndef

begin_define
define|#
directive|define
name|MY_check_dynamic_reloc
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MY_finish_dynamic_link
end_ifndef

begin_define
define|#
directive|define
name|MY_finish_dynamic_link
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|aout_backend_data
name|sunos4_aout_backend
init|=
block|{
literal|0
block|,
comment|/* zmagic files are not contiguous */
literal|1
block|,
comment|/* text includes header */
name|MY_entry_is_text_address
block|,
name|MY_exec_hdr_flags
block|,
literal|0
block|,
comment|/* default text vma */
name|sunos4_set_sizes
block|,
literal|0
block|,
comment|/* header is counted in zmagic text */
name|MY_add_dynamic_symbols
block|,
name|MY_add_one_symbol
block|,
name|MY_link_dynamic_object
block|,
name|MY_write_dynamic_symbol
block|,
name|MY_check_dynamic_reloc
block|,
name|MY_finish_dynamic_link
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|MY_core_file_failing_command
value|sunos4_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|MY_core_file_failing_signal
value|sunos4_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|MY_core_file_matches_executable_p
value|sunos4_core_file_matches_executable_p
end_define

begin_define
define|#
directive|define
name|MY_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|MY_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|MY_bfd_debug_info_accumulate
define|\
value|(void (*) PARAMS ((bfd *, struct bfd_section *))) bfd_void
end_define

begin_define
define|#
directive|define
name|MY_core_file_p
value|sunos4_core_file_p
end_define

begin_define
define|#
directive|define
name|MY_write_object_contents
value|NAME(aout,sunos4_write_object_contents)
end_define

begin_define
define|#
directive|define
name|MY_backend_data
value|&sunos4_aout_backend
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_IS_LITTLE_ENDIAN_P
end_ifndef

begin_define
define|#
directive|define
name|TARGET_IS_BIG_ENDIAN_P
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"aout-target.h"
end_include

end_unit

