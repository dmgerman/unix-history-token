begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for the generic parts of COFF, for BFD.    Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Most of this hacked by  Steve Chamberlain, sac@cygnus.com.    Split out of coffcode.h by Ian Taylor, ian@cygnus.com.  */
end_comment

begin_comment
comment|/* This file contains COFF code that is not dependent on any    particular COFF target.  There is only one version of this file in    libbfd.a, so no target specific code may be put in here.  Or, to    put it another way,     ********** DO NOT PUT TARGET SPECIFIC CODE IN THIS FILE **********     If you need to add some target specific behaviour, add a new hook    function to bfd_coff_backend_data.     Some of these functions are also called by the ECOFF routines.    Those functions may not use any COFF specific information, such as    coff_data (abfd).  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|coff_fix_symbol_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|bfd_size_type
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_size_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_write_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|bfd_size_type
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_size_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_write_alien_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|bfd_size_type
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_size_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_write_native_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|coff_symbol_type
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|bfd_size_type
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_size_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_pointerize_aux
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|unsigned
name|int
operator|,
name|combined_entry_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|make_a_section_from_file
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_scnhdr
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|coff_real_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
operator|,
expr|struct
name|internal_filehdr
operator|*
operator|,
expr|struct
name|internal_aouthdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_symbol_value
name|PARAMS
argument_list|(
operator|(
name|coff_symbol_type
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_debug_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|copy_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STRING_SIZE_SIZE
value|(4)
end_define

begin_comment
comment|/* Take a section header read from a coff file (in HOST byte order),    and make a BFD "section" out of it.  This is used by ECOFF.  */
end_comment

begin_function
specifier|static
name|boolean
name|make_a_section_from_file
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|target_index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_scnhdr
modifier|*
name|hdr
decl_stmt|;
name|unsigned
name|int
name|target_index
decl_stmt|;
block|{
name|asection
modifier|*
name|return_section
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* Handle long section names as in PE.  */
if|if
condition|(
name|bfd_coff_long_section_names
argument_list|(
name|abfd
argument_list|)
operator|&&
name|hdr
operator|->
name|s_name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
name|buf
index|[
name|SCNNMLEN
index|]
decl_stmt|;
name|long
name|strindex
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|strings
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|hdr
operator|->
name|s_name
operator|+
literal|1
argument_list|,
name|SCNNMLEN
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|SCNNMLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strindex
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
name|strindex
operator|>=
literal|0
condition|)
block|{
name|strings
operator|=
name|_bfd_coff_read_string_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* FIXME: For extra safety, we should make sure that              strindex does not run us past the end, but right now we              don't know the length of the string table.  */
name|strings
operator|+=
name|strindex
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|strings
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|strings
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Assorted wastage to null-terminate the name, thanks AT&T! */
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|s_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strncpy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
operator|->
name|s_name
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
name|name
index|[
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|s_name
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|return_section
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_section
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|return_section
operator|->
name|vma
operator|=
name|hdr
operator|->
name|s_vaddr
expr_stmt|;
name|return_section
operator|->
name|lma
operator|=
name|hdr
operator|->
name|s_paddr
expr_stmt|;
name|return_section
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|s_size
expr_stmt|;
name|return_section
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|s_scnptr
expr_stmt|;
name|return_section
operator|->
name|rel_filepos
operator|=
name|hdr
operator|->
name|s_relptr
expr_stmt|;
name|return_section
operator|->
name|reloc_count
operator|=
name|hdr
operator|->
name|s_nreloc
expr_stmt|;
name|bfd_coff_set_alignment_hook
argument_list|(
name|abfd
argument_list|,
name|return_section
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|return_section
operator|->
name|line_filepos
operator|=
name|hdr
operator|->
name|s_lnnoptr
expr_stmt|;
name|return_section
operator|->
name|lineno_count
operator|=
name|hdr
operator|->
name|s_nlnno
expr_stmt|;
name|return_section
operator|->
name|userdata
operator|=
name|NULL
expr_stmt|;
name|return_section
operator|->
name|next
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|return_section
operator|->
name|flags
operator|=
name|bfd_coff_styp_to_sec_flags_hook
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|return_section
operator|->
name|target_index
operator|=
name|target_index
expr_stmt|;
comment|/* At least on i386-coff, the line number count for a shared library      section must be ignored.  */
if|if
condition|(
operator|(
name|return_section
operator|->
name|flags
operator|&
name|SEC_COFF_SHARED_LIBRARY
operator|)
operator|!=
literal|0
condition|)
name|return_section
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|s_nreloc
operator|!=
literal|0
condition|)
name|return_section
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
comment|/* FIXME: should this check 'hdr->s_size> 0' */
if|if
condition|(
name|hdr
operator|->
name|s_scnptr
operator|!=
literal|0
condition|)
name|return_section
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read in a COFF object and make it into a BFD.  This is used by    ECOFF as well.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|coff_real_object_p
parameter_list|(
name|abfd
parameter_list|,
name|nscns
parameter_list|,
name|internal_f
parameter_list|,
name|internal_a
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|nscns
decl_stmt|;
name|struct
name|internal_filehdr
modifier|*
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
modifier|*
name|internal_a
decl_stmt|;
block|{
name|flagword
name|oflags
init|=
name|abfd
operator|->
name|flags
decl_stmt|;
name|bfd_vma
name|ostart
init|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|PTR
name|tdata
decl_stmt|;
name|size_t
name|readsize
decl_stmt|;
comment|/* length of file_info */
name|unsigned
name|int
name|scnhsz
decl_stmt|;
name|char
modifier|*
name|external_sections
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_RELFLG
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
if|if
condition|(
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_EXEC
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_LNNO
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_LSYMS
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LOCALS
expr_stmt|;
comment|/* FIXME: How can we set D_PAGED correctly?  */
if|if
condition|(
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_EXEC
operator|)
operator|!=
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_f
operator|->
name|f_nsyms
expr_stmt|;
if|if
condition|(
name|internal_f
operator|->
name|f_nsyms
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
if|if
condition|(
name|internal_a
operator|!=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|NULL
condition|)
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_a
operator|->
name|entry
expr_stmt|;
else|else
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Set up the tdata area.  ECOFF uses its own routine, and overrides      abfd->flags.  */
name|tdata
operator|=
name|bfd_coff_mkobject_hook
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|internal_f
argument_list|,
operator|(
name|PTR
operator|)
name|internal_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|scnhsz
operator|=
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|readsize
operator|=
name|nscns
operator|*
name|scnhsz
expr_stmt|;
name|external_sections
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|readsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|external_sections
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|external_sections
argument_list|,
literal|1
argument_list|,
name|readsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|readsize
condition|)
goto|goto
name|fail
goto|;
comment|/* Now copy data as required; construct all asections etc */
if|if
condition|(
name|nscns
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nscns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|internal_scnhdr
name|tmp
decl_stmt|;
name|bfd_coff_swap_scnhdr_in
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|external_sections
operator|+
name|i
operator|*
name|scnhsz
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_a_section_from_file
argument_list|(
name|abfd
argument_list|,
operator|&
name|tmp
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
comment|/*  make_abs_section (abfd); */
if|if
condition|(
name|bfd_coff_set_arch_mach_hook
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|internal_f
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|fail
goto|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|fail
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|flags
operator|=
name|oflags
expr_stmt|;
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|ostart
expr_stmt|;
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Turn a COFF file into a BFD, but fail with bfd_error_wrong_format if it is    not a COFF file.  This is also used by ECOFF.  */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|coff_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|int
name|filhsz
decl_stmt|;
name|unsigned
name|int
name|aoutsz
decl_stmt|;
name|int
name|nscns
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
name|internal_a
decl_stmt|;
comment|/* figure out how much to read */
name|filhsz
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|aoutsz
operator|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|filehdr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|filhsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|filehdr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|filehdr
argument_list|,
literal|1
argument_list|,
name|filhsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|filhsz
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bfd_coff_swap_filehdr_in
argument_list|(
name|abfd
argument_list|,
name|filehdr
argument_list|,
operator|&
name|internal_f
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|filehdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_coff_bad_format_hook
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_f
argument_list|)
operator|==
name|false
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nscns
operator|=
name|internal_f
operator|.
name|f_nscns
expr_stmt|;
if|if
condition|(
name|internal_f
operator|.
name|f_opthdr
condition|)
block|{
name|PTR
name|opthdr
decl_stmt|;
name|opthdr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|aoutsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|opthdr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
empty_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|opthdr
argument_list|,
literal|1
argument_list|,
name|aoutsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|aoutsz
condition|)
block|{
return|return
literal|0
return|;
block|}
name|bfd_coff_swap_aouthdr_in
argument_list|(
name|abfd
argument_list|,
name|opthdr
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|)
expr_stmt|;
block|}
comment|/* Seek past the opt hdr stuff */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|internal_f
operator|.
name|f_opthdr
operator|+
name|filhsz
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|coff_real_object_p
argument_list|(
name|abfd
argument_list|,
name|nscns
argument_list|,
operator|&
name|internal_f
argument_list|,
operator|(
name|internal_f
operator|.
name|f_opthdr
operator|!=
literal|0
condition|?
operator|&
name|internal_a
else|:
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|NULL
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the BFD section from a COFF symbol section number.  */
end_comment

begin_function
name|asection
modifier|*
name|coff_section_from_bfd_index
parameter_list|(
name|abfd
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|index
decl_stmt|;
block|{
name|struct
name|sec
modifier|*
name|answer
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
if|if
condition|(
name|index
operator|==
name|N_ABS
condition|)
return|return
name|bfd_abs_section_ptr
return|;
if|if
condition|(
name|index
operator|==
name|N_UNDEF
condition|)
return|return
name|bfd_und_section_ptr
return|;
if|if
condition|(
name|index
operator|==
name|N_DEBUG
condition|)
return|return
name|bfd_abs_section_ptr
return|;
while|while
condition|(
name|answer
condition|)
block|{
if|if
condition|(
name|answer
operator|->
name|target_index
operator|==
name|index
condition|)
return|return
name|answer
return|;
name|answer
operator|=
name|answer
operator|->
name|next
expr_stmt|;
block|}
comment|/* We should not reach this point, but the SCO 3.2v4 /lib/libc_s.a      has a bad symbol table in biglitpow.o.  */
return|return
name|bfd_und_section_ptr
return|;
block|}
end_function

begin_comment
comment|/* Get the upper bound of a COFF symbol table.  */
end_comment

begin_function
name|long
name|coff_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|bfd_coff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|coff_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize a COFF symbol table.  */
end_comment

begin_function
name|long
name|coff_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|unsigned
name|int
name|counter
decl_stmt|;
name|coff_symbol_type
modifier|*
name|symbase
decl_stmt|;
name|coff_symbol_type
modifier|*
modifier|*
name|location
init|=
operator|(
name|coff_symbol_type
operator|*
operator|*
operator|)
name|alocation
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_coff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|symbase
operator|=
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|counter
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|counter
operator|--
operator|>
literal|0
condition|)
operator|*
name|location
operator|++
operator|=
name|symbase
operator|++
expr_stmt|;
operator|*
name|location
operator|=
name|NULL
expr_stmt|;
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the name of a symbol.  The caller must pass in a buffer of size>= SYMNMLEN + 1.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_bfd_coff_internal_syment_name
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
comment|/* FIXME: It's not clear this will work correctly if sizeof      (_n_zeroes) != 4.  */
if|if
condition|(
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|!=
literal|0
operator|||
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|sym
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|buf
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|strings
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|>=
name|STRING_SIZE_SIZE
argument_list|)
expr_stmt|;
name|strings
operator|=
name|obj_coff_strings
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
condition|)
block|{
name|strings
operator|=
name|_bfd_coff_read_string_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|strings
operator|+
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read in and swap the relocs.  This returns a buffer holding the    relocs for section SEC in file ABFD.  If CACHE is true and    INTERNAL_RELOCS is NULL, the relocs read in will be saved in case    the function is called again.  If EXTERNAL_RELOCS is not NULL, it    is a buffer large enough to hold the unswapped relocs.  If    INTERNAL_RELOCS is not NULL, it is a buffer large enough to hold    the swapped relocs.  If REQUIRE_INTERNAL is true, then the return    value must be INTERNAL_RELOCS.  The function returns NULL on error.  */
end_comment

begin_function
name|struct
name|internal_reloc
modifier|*
name|_bfd_coff_read_internal_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|cache
parameter_list|,
name|external_relocs
parameter_list|,
name|require_internal
parameter_list|,
name|internal_relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|boolean
name|cache
decl_stmt|;
name|bfd_byte
modifier|*
name|external_relocs
decl_stmt|;
name|boolean
name|require_internal
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
block|{
name|bfd_size_type
name|relsz
decl_stmt|;
name|bfd_byte
modifier|*
name|free_external
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|free_internal
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|erel
decl_stmt|;
name|bfd_byte
modifier|*
name|erel_end
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|require_internal
condition|)
return|return
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
return|;
name|memcpy
argument_list|(
name|internal_relocs
argument_list|,
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
argument_list|,
name|sec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|internal_relocs
return|;
block|}
name|relsz
operator|=
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
name|NULL
condition|)
block|{
name|free_external
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|reloc_count
operator|*
name|relsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_external
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|reloc_count
operator|>
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|external_relocs
operator|=
name|free_external
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|external_relocs
argument_list|,
name|relsz
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|relsz
operator|*
name|sec
operator|->
name|reloc_count
operator|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
block|{
name|free_internal
operator|=
operator|(
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|free_internal
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|reloc_count
operator|>
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|internal_relocs
operator|=
name|free_internal
expr_stmt|;
block|}
comment|/* Swap in the relocs.  */
name|erel
operator|=
name|external_relocs
expr_stmt|;
name|erel_end
operator|=
name|erel
operator|+
name|relsz
operator|*
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|irel
operator|=
name|internal_relocs
expr_stmt|;
for|for
control|(
init|;
name|erel
operator|<
name|erel_end
condition|;
name|erel
operator|+=
name|relsz
operator|,
name|irel
operator|++
control|)
name|bfd_coff_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|erel
argument_list|,
operator|(
name|PTR
operator|)
name|irel
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_external
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|free_external
argument_list|)
expr_stmt|;
name|free_external
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|&&
name|free_internal
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|free_internal
expr_stmt|;
block|}
return|return
name|internal_relocs
return|;
name|error_return
label|:
if|if
condition|(
name|free_external
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_external
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_internal
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_internal
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set lineno_count for the output sections of a COFF file.  */
end_comment

begin_function
name|int
name|coff_count_linenumbers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|int
name|limit
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
block|{
comment|/* This may be from the backend linker, in which case the          lineno_count in the sections is correct.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|total
operator|+=
name|s
operator|->
name|lineno_count
expr_stmt|;
return|return
name|total
return|;
block|}
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|lineno_count
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|asymbol
modifier|*
name|q_maybe
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
name|q_maybe
argument_list|)
operator|==
name|bfd_target_coff_flavour
condition|)
block|{
name|coff_symbol_type
modifier|*
name|q
init|=
name|coffsymbol
argument_list|(
name|q_maybe
argument_list|)
decl_stmt|;
comment|/* The AIX 4.1 compiler can sometimes generate line numbers              attached to debugging symbols.  We try to simply ignore              those here.  */
if|if
condition|(
name|q
operator|->
name|lineno
operator|!=
name|NULL
operator|&&
name|q
operator|->
name|symbol
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
condition|)
block|{
comment|/* This symbol has line numbers.  Increment the owning 	         section's linenumber count.  */
name|alent
modifier|*
name|l
init|=
name|q
operator|->
name|lineno
decl_stmt|;
operator|++
name|q
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|lineno_count
expr_stmt|;
operator|++
name|total
expr_stmt|;
operator|++
name|l
expr_stmt|;
while|while
condition|(
name|l
operator|->
name|line_number
operator|!=
literal|0
condition|)
block|{
operator|++
name|total
expr_stmt|;
operator|++
name|q
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|lineno_count
expr_stmt|;
operator|++
name|l
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|total
return|;
block|}
end_function

begin_comment
comment|/* Takes a bfd and a symbol, returns a pointer to the coff specific    area of the symbol if there is one.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|coff_symbol_type
modifier|*
name|coff_symbol_from
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
name|symbol
argument_list|)
operator|!=
name|bfd_target_coff_flavour
condition|)
return|return
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
name|bfd_asymbol_bfd
argument_list|(
name|symbol
argument_list|)
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|==
operator|(
name|coff_data_type
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
return|;
return|return
operator|(
name|coff_symbol_type
operator|*
operator|)
name|symbol
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fixup_symbol_value
parameter_list|(
name|coff_symbol_ptr
parameter_list|,
name|syment
parameter_list|)
name|coff_symbol_type
modifier|*
name|coff_symbol_ptr
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syment
decl_stmt|;
block|{
comment|/* Normalize the symbol flags */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
block|{
comment|/* a common symbol is undefined with a value */
name|syment
operator|->
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
block|{
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
block|{
name|syment
operator|->
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
condition|)
block|{
name|syment
operator|->
name|n_scnum
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
operator|+
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
operator|+
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This can happen, but I don't know why yet (steve@cygnus.com) */
name|syment
operator|->
name|n_scnum
operator|=
name|N_ABS
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Run through all the symbols in the symbol table and work out what    their indexes into the symbol table will be when output.     Coff requires that each C_FILE symbol points to the next one in the    chain, and that the last one points to the first external symbol. We    do that here too.  */
end_comment

begin_function
name|boolean
name|coff_renumber_symbols
parameter_list|(
name|bfd_ptr
parameter_list|,
name|first_undef
parameter_list|)
name|bfd
modifier|*
name|bfd_ptr
decl_stmt|;
name|int
modifier|*
name|first_undef
decl_stmt|;
block|{
name|unsigned
name|int
name|symbol_count
init|=
name|bfd_get_symcount
argument_list|(
name|bfd_ptr
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_ptr_ptr
init|=
name|bfd_ptr
operator|->
name|outsymbols
decl_stmt|;
name|unsigned
name|int
name|native_index
init|=
literal|0
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|last_file
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|NULL
decl_stmt|;
name|unsigned
name|int
name|symbol_index
decl_stmt|;
comment|/* COFF demands that undefined symbols come after all other symbols.      Since we don't need to impose this extra knowledge on all our      client programs, deal with that here.  Sort the symbol table;      just move the undefined symbols to the end, leaving the rest      alone.  The O'Reilly book says that defined global symbols come      at the end before the undefined symbols, so we do that here as      well.  */
comment|/* @@ Do we have some condition we could test for, so we don't always      have to do this?  I don't think relocatability is quite right, but      I'm not certain.  [raeburn:19920508.1711EST]  */
block|{
name|asymbol
modifier|*
modifier|*
name|newsyms
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|newsyms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|bfd_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|*
operator|(
name|symbol_count
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsyms
condition|)
return|return
name|false
return|;
name|bfd_ptr
operator|->
name|outsymbols
operator|=
name|newsyms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BSF_NOT_AT_END
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|!
name|bfd_is_und_section
argument_list|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|section
argument_list|)
operator|&&
operator|(
operator|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_FUNCTION
operator|)
operator|)
operator|!=
name|BSF_GLOBAL
operator|)
operator|)
condition|)
operator|*
name|newsyms
operator|++
operator|=
name|symbol_ptr_ptr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BSF_NOT_AT_END
operator|)
operator|==
literal|0
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|bfd_is_com_section
argument_list|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|section
argument_list|)
operator|||
operator|(
operator|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_FUNCTION
operator|)
operator|)
operator|==
name|BSF_GLOBAL
operator|)
operator|)
condition|)
operator|*
name|newsyms
operator|++
operator|=
name|symbol_ptr_ptr
index|[
name|i
index|]
expr_stmt|;
operator|*
name|first_undef
operator|=
name|newsyms
operator|-
name|bfd_ptr
operator|->
name|outsymbols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BSF_NOT_AT_END
operator|)
operator|==
literal|0
operator|&&
name|bfd_is_und_section
argument_list|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|section
argument_list|)
condition|)
operator|*
name|newsyms
operator|++
operator|=
name|symbol_ptr_ptr
index|[
name|i
index|]
expr_stmt|;
operator|*
name|newsyms
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
expr_stmt|;
name|symbol_ptr_ptr
operator|=
name|bfd_ptr
operator|->
name|outsymbols
expr_stmt|;
block|}
for|for
control|(
name|symbol_index
operator|=
literal|0
init|;
name|symbol_index
operator|<
name|symbol_count
condition|;
name|symbol_index
operator|++
control|)
block|{
name|coff_symbol_type
modifier|*
name|coff_symbol_ptr
init|=
name|coff_symbol_from
argument_list|(
name|bfd_ptr
argument_list|,
name|symbol_ptr_ptr
index|[
name|symbol_index
index|]
argument_list|)
decl_stmt|;
name|symbol_ptr_ptr
index|[
name|symbol_index
index|]
operator|->
name|udata
operator|.
name|i
operator|=
name|symbol_index
expr_stmt|;
if|if
condition|(
name|coff_symbol_ptr
operator|&&
name|coff_symbol_ptr
operator|->
name|native
condition|)
block|{
name|combined_entry_type
modifier|*
name|s
init|=
name|coff_symbol_ptr
operator|->
name|native
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
if|if
condition|(
name|last_file
operator|!=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|NULL
condition|)
name|last_file
operator|->
name|n_value
operator|=
name|native_index
expr_stmt|;
name|last_file
operator|=
operator|&
operator|(
name|s
operator|->
name|u
operator|.
name|syment
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Modify the symbol values according to their section and 	         type */
name|fixup_symbol_value
argument_list|(
name|coff_symbol_ptr
argument_list|,
operator|&
operator|(
name|s
operator|->
name|u
operator|.
name|syment
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|native_index
operator|++
expr_stmt|;
block|}
else|else
block|{
name|native_index
operator|++
expr_stmt|;
block|}
block|}
name|obj_conv_table_size
argument_list|(
name|bfd_ptr
argument_list|)
operator|=
name|native_index
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Run thorough the symbol table again, and fix it so that all    pointers to entries are changed to the entries' index in the output    symbol table.  */
end_comment

begin_function
name|void
name|coff_mangle_symbols
parameter_list|(
name|bfd_ptr
parameter_list|)
name|bfd
modifier|*
name|bfd_ptr
decl_stmt|;
block|{
name|unsigned
name|int
name|symbol_count
init|=
name|bfd_get_symcount
argument_list|(
name|bfd_ptr
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_ptr_ptr
init|=
name|bfd_ptr
operator|->
name|outsymbols
decl_stmt|;
name|unsigned
name|int
name|symbol_index
decl_stmt|;
for|for
control|(
name|symbol_index
operator|=
literal|0
init|;
name|symbol_index
operator|<
name|symbol_count
condition|;
name|symbol_index
operator|++
control|)
block|{
name|coff_symbol_type
modifier|*
name|coff_symbol_ptr
init|=
name|coff_symbol_from
argument_list|(
name|bfd_ptr
argument_list|,
name|symbol_ptr_ptr
index|[
name|symbol_index
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|coff_symbol_ptr
operator|&&
name|coff_symbol_ptr
operator|->
name|native
condition|)
block|{
name|int
name|i
decl_stmt|;
name|combined_entry_type
modifier|*
name|s
init|=
name|coff_symbol_ptr
operator|->
name|native
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|fix_value
condition|)
block|{
comment|/* FIXME: We should use a union here.  */
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
operator|(
operator|(
name|combined_entry_type
operator|*
operator|)
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
operator|->
name|offset
expr_stmt|;
name|s
operator|->
name|fix_value
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|fix_line
condition|)
block|{
comment|/* The value is the offset into the line number entries                  for the symbol's section.  On output, the symbol's                  section should be N_DEBUG.  */
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
operator|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|line_filepos
operator|+
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|*
name|bfd_coff_linesz
argument_list|(
name|bfd_ptr
argument_list|)
operator|)
expr_stmt|;
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|bfd_ptr
argument_list|,
name|N_DEBUG
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|flags
operator|&
name|BSF_DEBUGGING
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|i
operator|++
control|)
block|{
name|combined_entry_type
modifier|*
name|a
init|=
name|s
operator|+
name|i
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|fix_tag
condition|)
block|{
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|->
name|offset
expr_stmt|;
name|a
operator|->
name|fix_tag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|fix_end
condition|)
block|{
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|->
name|offset
expr_stmt|;
name|a
operator|->
name|fix_end
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|fix_scnlen
condition|)
block|{
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|p
operator|->
name|offset
expr_stmt|;
name|a
operator|->
name|fix_scnlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|coff_fix_symbol_name
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|native
parameter_list|,
name|string_size_p
parameter_list|,
name|debug_string_section_p
parameter_list|,
name|debug_string_size_p
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|combined_entry_type
modifier|*
name|native
decl_stmt|;
name|bfd_size_type
modifier|*
name|string_size_p
decl_stmt|;
name|asection
modifier|*
modifier|*
name|debug_string_section_p
decl_stmt|;
name|bfd_size_type
modifier|*
name|debug_string_size_p
decl_stmt|;
block|{
name|unsigned
name|int
name|name_length
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|auxent
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|symbol
operator|->
name|name
operator|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* coff symbols always have names, so we'll make one up */
name|symbol
operator|->
name|name
operator|=
literal|"strange"
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|symbol
operator|->
name|name
expr_stmt|;
block|}
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
operator|&&
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|>
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
literal|".file"
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|auxent
operator|=
operator|&
operator|(
name|native
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
expr_stmt|;
if|if
condition|(
name|bfd_coff_long_filenames
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|name_length
operator|<=
name|FILNMLEN
condition|)
block|{
name|strncpy
argument_list|(
name|auxent
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|name
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|auxent
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
operator|*
name|string_size_p
operator|+
name|STRING_SIZE_SIZE
expr_stmt|;
name|auxent
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|=
literal|0
expr_stmt|;
operator|*
name|string_size_p
operator|+=
name|name_length
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|strncpy
argument_list|(
name|auxent
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|name
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|>
name|FILNMLEN
condition|)
block|{
name|name
index|[
name|FILNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|name_length
operator|<=
name|SYMNMLEN
condition|)
block|{
comment|/* This name will fit into the symbol neatly */
name|strncpy
argument_list|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bfd_coff_symname_in_debug
argument_list|(
name|abfd
argument_list|,
operator|&
name|native
operator|->
name|u
operator|.
name|syment
argument_list|)
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
operator|*
name|string_size_p
operator|+
name|STRING_SIZE_SIZE
operator|)
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
operator|*
name|string_size_p
operator|+=
name|name_length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|long
name|filepos
decl_stmt|;
name|bfd_byte
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* This name should be written into the .debug section.  For 	     some reason each name is preceded by a two byte length 	     and also followed by a null byte.  FIXME: We assume that 	     the .debug section has already been created, and that it 	     is large enough.  */
if|if
condition|(
operator|*
name|debug_string_section_p
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
operator|*
name|debug_string_section_p
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
name|filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|name_length
operator|+
literal|1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
operator|*
name|debug_string_section_p
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
operator|*
name|debug_string_size_p
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|2
argument_list|)
operator|||
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
operator|*
name|debug_string_section_p
argument_list|,
operator|(
name|PTR
operator|)
name|symbol
operator|->
name|name
argument_list|,
operator|(
operator|(
name|file_ptr
operator|)
operator|*
name|debug_string_size_p
operator|+
literal|2
operator|)
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|name_length
operator|+
literal|1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|*
name|debug_string_size_p
operator|+
literal|2
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
operator|*
name|debug_string_size_p
operator|+=
name|name_length
operator|+
literal|3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We need to keep track of the symbol index so that when we write out    the relocs we can get the index for a symbol.  This method is a    hack.  FIXME.  */
end_comment

begin_define
define|#
directive|define
name|set_index
parameter_list|(
name|symbol
parameter_list|,
name|idx
parameter_list|)
value|((symbol)->udata.i = (idx))
end_define

begin_comment
comment|/* Write a symbol out to a COFF file.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_write_symbol
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|native
parameter_list|,
name|written
parameter_list|,
name|string_size_p
parameter_list|,
name|debug_string_section_p
parameter_list|,
name|debug_string_size_p
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|combined_entry_type
modifier|*
name|native
decl_stmt|;
name|unsigned
name|int
modifier|*
name|written
decl_stmt|;
name|bfd_size_type
modifier|*
name|string_size_p
decl_stmt|;
name|asection
modifier|*
modifier|*
name|debug_string_section_p
decl_stmt|;
name|bfd_size_type
modifier|*
name|debug_string_size_p
decl_stmt|;
block|{
name|unsigned
name|int
name|numaux
init|=
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
decl_stmt|;
name|int
name|type
init|=
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
decl_stmt|;
name|int
name|class
init|=
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
decl_stmt|;
name|PTR
name|buf
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
name|symbol
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|&&
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_DEBUG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_ABS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
block|}
else|else
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
name|coff_fix_symbol_name
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|native
argument_list|,
name|string_size_p
argument_list|,
name|debug_string_section_p
argument_list|,
name|debug_string_size_p
argument_list|)
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|buf
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symesz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|false
return|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|native
operator|->
name|u
operator|.
name|syment
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|symesz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symesz
condition|)
return|return
name|false
return|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|auxesz
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|auxesz
operator|=
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|buf
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|auxesz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|false
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|j
operator|++
control|)
block|{
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
operator|(
name|native
operator|+
name|j
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|j
argument_list|,
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|auxesz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|auxesz
condition|)
return|return
name|false
return|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Store the index for use when we write out the relocs.  */
name|set_index
argument_list|(
name|symbol
argument_list|,
operator|*
name|written
argument_list|)
expr_stmt|;
operator|*
name|written
operator|+=
name|numaux
operator|+
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out a symbol to a COFF file that does not come from a COFF    file originally.  This symbol may have been created by the linker,    or we may be linking a non COFF file to a COFF file.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_write_alien_symbol
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|written
parameter_list|,
name|string_size_p
parameter_list|,
name|debug_string_section_p
parameter_list|,
name|debug_string_size_p
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|unsigned
name|int
modifier|*
name|written
decl_stmt|;
name|bfd_size_type
modifier|*
name|string_size_p
decl_stmt|;
name|asection
modifier|*
modifier|*
name|debug_string_section_p
decl_stmt|;
name|bfd_size_type
modifier|*
name|debug_string_size_p
decl_stmt|;
block|{
name|combined_entry_type
modifier|*
name|native
decl_stmt|;
name|combined_entry_type
name|dummy
decl_stmt|;
name|native
operator|=
operator|&
name|dummy
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|=
name|T_NULL
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
block|{
comment|/* There isn't much point to writing out a debugging symbol          unless we are prepared to convert it into COFF debugging          format.  So, we just ignore them.  We must clobber the symbol          name to keep it from being put in the string table.  */
name|symbol
operator|->
name|name
operator|=
literal|""
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
operator|(
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Copy the any flags from the the file header into the symbol.          FIXME: Why?  */
block|{
name|coff_symbol_type
modifier|*
name|c
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
condition|)
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
operator|=
name|bfd_asymbol_bfd
argument_list|(
operator|&
name|c
operator|->
name|symbol
argument_list|)
operator|->
name|flags
expr_stmt|;
block|}
block|}
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
else|else
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|=
literal|0
expr_stmt|;
return|return
name|coff_write_symbol
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|native
argument_list|,
name|written
argument_list|,
name|string_size_p
argument_list|,
name|debug_string_section_p
argument_list|,
name|debug_string_size_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write a native symbol to a COFF file.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_write_native_symbol
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|written
parameter_list|,
name|string_size_p
parameter_list|,
name|debug_string_section_p
parameter_list|,
name|debug_string_size_p
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|coff_symbol_type
modifier|*
name|symbol
decl_stmt|;
name|unsigned
name|int
modifier|*
name|written
decl_stmt|;
name|bfd_size_type
modifier|*
name|string_size_p
decl_stmt|;
name|asection
modifier|*
modifier|*
name|debug_string_section_p
decl_stmt|;
name|bfd_size_type
modifier|*
name|debug_string_size_p
decl_stmt|;
block|{
name|combined_entry_type
modifier|*
name|native
init|=
name|symbol
operator|->
name|native
decl_stmt|;
name|alent
modifier|*
name|lineno
init|=
name|symbol
operator|->
name|lineno
decl_stmt|;
comment|/* If this symbol has an associated line number, we must store the      symbol index in the line number field.  We also tag the auxent to      point to the right place in the lineno table.  */
if|if
condition|(
name|lineno
operator|&&
operator|!
name|symbol
operator|->
name|done_lineno
operator|&&
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|lineno
index|[
name|count
index|]
operator|.
name|u
operator|.
name|offset
operator|=
operator|*
name|written
expr_stmt|;
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
name|union
name|internal_auxent
modifier|*
name|a
init|=
operator|&
operator|(
operator|(
name|native
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
decl_stmt|;
name|a
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|moving_line_filepos
expr_stmt|;
block|}
comment|/* Count and relocate all other linenumbers.  */
name|count
operator|++
expr_stmt|;
while|while
condition|(
name|lineno
index|[
name|count
index|]
operator|.
name|line_number
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 13 april 92. sac  	     I've been told this, but still need proof:> The second bug is also in `bfd/coffcode.h'.  This bug> causes the linker to screw up the pc-relocations for> all the line numbers in COFF code.  This bug isn't only> specific to A29K implementations, but affects all> systems using COFF format binaries.  Note that in COFF> object files, the line number core offsets output by> the assembler are relative to the start of each> procedure, not to the start of the .text section.  This> patch relocates the line numbers relative to the> `native->u.syment.n_value' instead of the section> virtual address.> modular!olson@cs.arizona.edu (Jon Olson) 	   */
block|lineno[count].u.offset += native->u.syment.n_value;
else|#
directive|else
name|lineno
index|[
name|count
index|]
operator|.
name|u
operator|.
name|offset
operator|+=
operator|(
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|++
expr_stmt|;
block|}
name|symbol
operator|->
name|done_lineno
operator|=
name|true
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|moving_line_filepos
operator|+=
name|count
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
return|return
name|coff_write_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
name|symbol
operator|->
name|symbol
operator|)
argument_list|,
name|native
argument_list|,
name|written
argument_list|,
name|string_size_p
argument_list|,
name|debug_string_section_p
argument_list|,
name|debug_string_size_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the COFF symbols.  */
end_comment

begin_function
name|boolean
name|coff_write_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_size_type
name|string_size
decl_stmt|;
name|asection
modifier|*
name|debug_string_section
decl_stmt|;
name|bfd_size_type
name|debug_string_size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|limit
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|written
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
name|string_size
operator|=
literal|0
expr_stmt|;
name|debug_string_section
operator|=
name|NULL
expr_stmt|;
name|debug_string_size
operator|=
literal|0
expr_stmt|;
comment|/* If this target supports long section names, they must be put into      the string table.  This is supported by PE.  This code must      handle section names just as they are handled in      coff_write_object_contents.  */
if|if
condition|(
name|bfd_coff_long_section_names
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SCNNMLEN
condition|)
name|string_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Seek to the right place */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Output all the symbols we have */
name|written
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|asymbol
modifier|*
name|symbol
init|=
operator|*
name|p
decl_stmt|;
name|coff_symbol_type
modifier|*
name|c_symbol
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|c_symbol
operator|==
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
operator|||
name|c_symbol
operator|->
name|native
operator|==
operator|(
name|combined_entry_type
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|coff_write_alien_symbol
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
operator|&
name|written
argument_list|,
operator|&
name|string_size
argument_list|,
operator|&
name|debug_string_section
argument_list|,
operator|&
name|debug_string_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|coff_write_native_symbol
argument_list|(
name|abfd
argument_list|,
name|c_symbol
argument_list|,
operator|&
name|written
argument_list|,
operator|&
name|string_size
argument_list|,
operator|&
name|debug_string_section
argument_list|,
operator|&
name|debug_string_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|=
name|written
expr_stmt|;
comment|/* Now write out strings */
if|if
condition|(
name|string_size
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|string_size
operator|+
name|STRING_SIZE_SIZE
decl_stmt|;
name|bfd_byte
name|buffer
index|[
name|STRING_SIZE_SIZE
index|]
decl_stmt|;
if|#
directive|if
name|STRING_SIZE_SIZE
operator|==
literal|4
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Change bfd_h_put_32
endif|#
directive|endif
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Handle long section names.  This code must handle section 	 names just as they are handled in coff_write_object_contents.  */
if|if
condition|(
name|bfd_coff_long_section_names
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SCNNMLEN
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|1
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
operator|+
literal|1
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|asymbol
modifier|*
name|q
init|=
operator|*
name|p
decl_stmt|;
name|size_t
name|name_length
init|=
name|strlen
argument_list|(
name|q
operator|->
name|name
argument_list|)
decl_stmt|;
name|coff_symbol_type
modifier|*
name|c_symbol
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|size_t
name|maxlen
decl_stmt|;
comment|/* Figure out whether the symbol name should go in the string 	     table.  Symbol names that are short enough are stored 	     directly in the syment structure.  File names permit a 	     different, longer, length in the syment structure.  On 	     XCOFF, some symbol names are stored in the .debug section 	     rather than in the string table.  */
if|if
condition|(
name|c_symbol
operator|==
name|NULL
operator|||
name|c_symbol
operator|->
name|native
operator|==
name|NULL
condition|)
block|{
comment|/* This is not a COFF symbol, so it certainly is not a 	         file name, nor does it go in the .debug section.  */
name|maxlen
operator|=
name|SYMNMLEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_coff_symname_in_debug
argument_list|(
name|abfd
argument_list|,
operator|&
name|c_symbol
operator|->
name|native
operator|->
name|u
operator|.
name|syment
argument_list|)
condition|)
block|{
comment|/* This symbol name is in the XCOFF .debug section. 	         Don't write it into the string table.  */
name|maxlen
operator|=
name|name_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_symbol
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
operator|&&
name|c_symbol
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|>
literal|0
condition|)
name|maxlen
operator|=
name|FILNMLEN
expr_stmt|;
else|else
name|maxlen
operator|=
name|SYMNMLEN
expr_stmt|;
if|if
condition|(
name|name_length
operator|>
name|maxlen
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|q
operator|->
name|name
argument_list|)
argument_list|,
literal|1
argument_list|,
name|name_length
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|name_length
operator|+
literal|1
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* We would normally not write anything here, but we'll write          out 4 so that any stupid coff reader which tries to read the          string table even when there isn't one won't croak.  */
name|unsigned
name|int
name|size
init|=
name|STRING_SIZE_SIZE
decl_stmt|;
name|bfd_byte
name|buffer
index|[
name|STRING_SIZE_SIZE
index|]
decl_stmt|;
if|#
directive|if
name|STRING_SIZE_SIZE
operator|==
literal|4
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Change bfd_h_put_32
endif|#
directive|endif
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
name|STRING_SIZE_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|STRING_SIZE_SIZE
condition|)
return|return
name|false
return|;
block|}
comment|/* Make sure the .debug section was created to be the correct size.      We should create it ourselves on the fly, but we don't because      BFD won't let us write to any section until we know how large all      the sections are.  We could still do it by making another pass      over the symbols.  FIXME.  */
name|BFD_ASSERT
argument_list|(
name|debug_string_size
operator|==
literal|0
operator|||
operator|(
name|debug_string_section
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|BFD_ALIGN
argument_list|(
name|debug_string_size
argument_list|,
literal|1
operator|<<
name|debug_string_section
operator|->
name|alignment_power
argument_list|)
operator|==
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|debug_string_section
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|coff_write_linenumbers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|linesz
decl_stmt|;
name|PTR
name|buff
decl_stmt|;
name|linesz
operator|=
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|buff
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|linesz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buff
condition|)
return|return
name|false
return|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|lineno_count
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|q
init|=
name|abfd
operator|->
name|outsymbols
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|line_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Find all the linenumbers in this section */
while|while
condition|(
operator|*
name|q
condition|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|->
name|output_section
operator|==
name|s
condition|)
block|{
name|alent
modifier|*
name|l
init|=
name|BFD_SEND
argument_list|(
name|bfd_asymbol_bfd
argument_list|(
name|p
argument_list|)
argument_list|,
name|_get_lineno
argument_list|,
operator|(
name|bfd_asymbol_bfd
argument_list|(
name|p
argument_list|)
expr|,
name|p
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
condition|)
block|{
comment|/* Found a linenumber entry, output */
name|struct
name|internal_lineno
name|out
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|l_lnno
operator|=
literal|0
expr_stmt|;
name|out
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
name|l
operator|->
name|u
operator|.
name|offset
expr_stmt|;
name|bfd_coff_swap_lineno_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|out
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|linesz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|linesz
condition|)
return|return
name|false
return|;
name|l
operator|++
expr_stmt|;
while|while
condition|(
name|l
operator|->
name|line_number
condition|)
block|{
name|out
operator|.
name|l_lnno
operator|=
name|l
operator|->
name|line_number
expr_stmt|;
name|out
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
name|l
operator|->
name|u
operator|.
name|offset
expr_stmt|;
name|bfd_coff_swap_lineno_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|out
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|linesz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|linesz
condition|)
return|return
name|false
return|;
name|l
operator|++
expr_stmt|;
block|}
block|}
block|}
name|q
operator|++
expr_stmt|;
block|}
block|}
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
name|alent
modifier|*
name|coff_get_lineno
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
return|return
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is only called from coff_add_missing_symbols, which has been    disabled.  */
end_comment

begin_comment
unit|asymbol * coff_section_symbol (abfd, name)      bfd *abfd;      char *name; {   asection *sec = bfd_make_section_old_way (abfd, name);   asymbol *sym;   combined_entry_type *csym;    sym = sec->symbol;   csym = coff_symbol_from (abfd, sym)->native;
comment|/* Make sure back-end COFF stuff is there.  */
end_comment

begin_comment
unit|if (csym == 0)     {       struct foo 	{ 	  coff_symbol_type sym;
comment|/* @@FIXME This shouldn't use a fixed size!!  */
end_comment

begin_comment
unit|combined_entry_type e[10]; 	};       struct foo *f;       f = (struct foo *) bfd_alloc (abfd, sizeof (*f));       if (!f) 	{ 	  bfd_set_error (bfd_error_no_error); 	  return NULL; 	}       memset ((char *) f, 0, sizeof (*f));       coff_symbol_from (abfd, sym)->native = csym = f->e;     }   csym[0].u.syment.n_sclass = C_STAT;   csym[0].u.syment.n_numaux = 1;
comment|/*  SF_SET_STATICS (sym);       @@ ??? */
end_comment

begin_endif
unit|csym[1].u.auxent.x_scn.x_scnlen = sec->_raw_size;   csym[1].u.auxent.x_scn.x_nreloc = sec->reloc_count;   csym[1].u.auxent.x_scn.x_nlinno = sec->lineno_count;    if (sec->output_section == NULL)     {       sec->output_section = sec;       sec->output_offset = 0;     }    return sym; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* This function transforms the offsets into the symbol table into    pointers to syments.  */
end_comment

begin_function
specifier|static
name|void
name|coff_pointerize_aux
parameter_list|(
name|abfd
parameter_list|,
name|table_base
parameter_list|,
name|symbol
parameter_list|,
name|indaux
parameter_list|,
name|auxent
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|combined_entry_type
modifier|*
name|table_base
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol
decl_stmt|;
name|unsigned
name|int
name|indaux
decl_stmt|;
name|combined_entry_type
modifier|*
name|auxent
decl_stmt|;
block|{
name|int
name|type
init|=
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
decl_stmt|;
name|int
name|class
init|=
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
decl_stmt|;
if|if
condition|(
name|coff_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|_bfd_coff_pointerize_aux_hook
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|coff_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|_bfd_coff_pointerize_aux_hook
operator|)
operator|(
name|abfd
operator|,
name|table_base
operator|,
name|symbol
operator|,
name|indaux
operator|,
name|auxent
operator|)
condition|)
return|return;
block|}
comment|/* Don't bother if this is a file or a section */
if|if
condition|(
name|class
operator|==
name|C_STAT
operator|&&
name|type
operator|==
name|T_NULL
condition|)
return|return;
if|if
condition|(
name|class
operator|==
name|C_FILE
condition|)
return|return;
comment|/* Otherwise patch up */
define|#
directive|define
name|N_TMASK
value|coff_data (abfd)->local_n_tmask
define|#
directive|define
name|N_BTSHFT
value|coff_data (abfd)->local_n_btshft
if|if
condition|(
operator|(
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
operator|||
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|)
operator|&&
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|>
literal|0
condition|)
block|{
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|=
name|table_base
operator|+
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
expr_stmt|;
name|auxent
operator|->
name|fix_end
operator|=
literal|1
expr_stmt|;
block|}
comment|/* A negative tagndx is meaningless, but the SCO 3.2v4 cc can      generate one, so we must be careful to ignore it.  */
if|if
condition|(
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|>
literal|0
condition|)
block|{
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|=
name|table_base
operator|+
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
expr_stmt|;
name|auxent
operator|->
name|fix_tag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate space for the ".debug" section, and read it.    We did not read the debug section until now, because    we didn't want to go to the trouble until someone needed it. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_debug_section
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
name|debug_section
decl_stmt|;
name|long
name|position
decl_stmt|;
name|asection
modifier|*
name|sect
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sect
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_debug_section
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|debug_section
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_section
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Seek to the beginning of the `.debug' section and read it.       Save the current position first; it is needed by our caller.      Then read debug section and reset the file pointer.  */
name|position
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|sect
operator|->
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|debug_section
argument_list|,
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
operator|)
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|position
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|debug_section
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a malloc'd copy of 'name'.  'name' may not be    \0-terminated, but will not exceed 'maxlen' characters.  The copy *will*    be \0-terminated.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|copy_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|maxlen
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|maxlen
condition|;
operator|++
name|len
control|)
block|{
if|if
condition|(
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|newname
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strncpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|newname
return|;
block|}
end_function

begin_comment
comment|/* Read in the external symbols.  */
end_comment

begin_function
name|boolean
name|_bfd_coff_get_external_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_size_type
name|symesz
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|PTR
name|syms
decl_stmt|;
if|if
condition|(
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|size
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
name|syms
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|syms
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|syms
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read in the external strings.  The strings are not loaded until    they are needed.  This is because we have no simple way of    detecting a missing string table in an archive.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_bfd_coff_read_string_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|extstrsize
index|[
name|STRING_SIZE_SIZE
index|]
decl_stmt|;
name|size_t
name|strsize
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
if|if
condition|(
name|obj_coff_strings
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|obj_coff_strings
argument_list|(
name|abfd
argument_list|)
return|;
if|if
condition|(
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|extstrsize
argument_list|,
sizeof|sizeof
name|extstrsize
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|extstrsize
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_file_truncated
condition|)
return|return
name|NULL
return|;
comment|/* There is no string table.  */
name|strsize
operator|=
name|STRING_SIZE_SIZE
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|STRING_SIZE_SIZE
operator|==
literal|4
name|strsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|extstrsize
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Change bfd_h_get_32
endif|#
directive|endif
block|}
if|if
condition|(
name|strsize
operator|<
name|STRING_SIZE_SIZE
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: bad string table size %lu"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strsize
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|strings
operator|+
name|STRING_SIZE_SIZE
argument_list|,
name|strsize
operator|-
name|STRING_SIZE_SIZE
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|strsize
operator|-
name|STRING_SIZE_SIZE
condition|)
block|{
name|free
argument_list|(
name|strings
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|obj_coff_strings
argument_list|(
name|abfd
argument_list|)
operator|=
name|strings
expr_stmt|;
return|return
name|strings
return|;
block|}
end_function

begin_comment
comment|/* Free up the external symbols and strings read from a COFF file.  */
end_comment

begin_function
name|boolean
name|_bfd_coff_free_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|obj_coff_strings
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|obj_coff_keep_strings
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|obj_coff_strings
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|obj_coff_strings
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read a symbol table into freshly bfd_allocated memory, swap it, and    knit the symbol names into a normalized form.  By normalized here I    mean that all symbols have an n_offset pointer that points to a null-    terminated string.  */
end_comment

begin_function
name|combined_entry_type
modifier|*
name|coff_get_normalized_symtab
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|combined_entry_type
modifier|*
name|internal
decl_stmt|;
name|combined_entry_type
modifier|*
name|internal_ptr
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol_ptr
decl_stmt|;
name|combined_entry_type
modifier|*
name|internal_end
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
name|char
modifier|*
name|raw_src
decl_stmt|;
name|char
modifier|*
name|raw_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|string_table
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|debug_section
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
return|;
name|size
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
expr_stmt|;
name|internal
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|internal_end
operator|=
name|internal
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
name|raw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* mark the end of the symbols */
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|raw_end
operator|=
operator|(
name|char
operator|*
operator|)
name|raw_src
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
comment|/* FIXME SOMEDAY.  A string table size of zero is very weird, but      probably possible.  If one shows up, it will probably kill us.  */
comment|/* Swap all the raw entries */
for|for
control|(
name|internal_ptr
operator|=
name|internal
init|;
name|raw_src
operator|<
name|raw_end
condition|;
name|raw_src
operator|+=
name|symesz
operator|,
name|internal_ptr
operator|++
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_src
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_ptr
operator|->
name|u
operator|.
name|syment
argument_list|)
expr_stmt|;
name|symbol_ptr
operator|=
name|internal_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|i
operator|++
control|)
block|{
name|internal_ptr
operator|++
expr_stmt|;
name|raw_src
operator|+=
name|symesz
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_src
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
name|i
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
operator|(
name|internal_ptr
operator|->
name|u
operator|.
name|auxent
operator|)
argument_list|)
expr_stmt|;
name|coff_pointerize_aux
argument_list|(
name|abfd
argument_list|,
name|internal
argument_list|,
name|symbol_ptr
argument_list|,
name|i
argument_list|,
name|internal_ptr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free the raw symbols, but not the strings (if we have them).  */
name|obj_coff_keep_strings
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_coff_free_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|internal_ptr
operator|=
name|internal
init|;
name|internal_ptr
operator|<
name|internal_end
condition|;
name|internal_ptr
operator|++
control|)
block|{
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
operator|&&
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|>
literal|0
condition|)
block|{
comment|/* make a file symbol point to the name in the auxent, since 	     the text ".file" is redundant */
if|if
condition|(
operator|(
name|internal_ptr
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
condition|)
block|{
comment|/* the filename is a long one, point into the string table */
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
block|{
name|string_table
operator|=
name|_bfd_coff_read_string_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|string_table
operator|+
operator|(
name|internal_ptr
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ordinary short filename, put into memory anyway */
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
name|long
operator|)
name|copy_name
argument_list|(
name|abfd
argument_list|,
operator|(
name|internal_ptr
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|!=
literal|0
condition|)
block|{
comment|/* This is a "short" name.  Make it long.  */
name|unsigned
name|long
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|newstring
init|=
name|NULL
decl_stmt|;
comment|/* find the length of this string without walking into memory 	         that isn't ours.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
comment|/* if end of string */
block|}
comment|/* possible lengths of this string. */
if|if
condition|(
operator|(
name|newstring
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|++
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|newstring
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newstring
argument_list|,
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
name|long
name|int
operator|)
name|newstring
expr_stmt|;
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|==
literal|0
condition|)
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
name|long
name|int
operator|)
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bfd_coff_symname_in_debug
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_ptr
operator|->
name|u
operator|.
name|syment
argument_list|)
condition|)
block|{
comment|/* Long name already.  Point symbol at the string in the                  table.  */
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
block|{
name|string_table
operator|=
name|_bfd_coff_read_string_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
call|(
name|long
name|int
call|)
argument_list|(
name|string_table
operator|+
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Long name in debug section.  Very similar.  */
if|if
condition|(
name|debug_section
operator|==
name|NULL
condition|)
name|debug_section
operator|=
name|build_debug_section
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
call|(
name|long
name|int
call|)
argument_list|(
name|debug_section
operator|+
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|)
expr_stmt|;
block|}
block|}
name|internal_ptr
operator|+=
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
block|}
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
name|internal_ptr
operator|-
name|internal
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|internal
operator|)
return|;
block|}
end_function

begin_comment
comment|/* coff_get_normalized_symtab() */
end_comment

begin_function
name|long
name|coff_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_function
name|asymbol
modifier|*
name|coff_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|coff_symbol_type
modifier|*
name|new
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|native
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|done_lineno
operator|=
name|false
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* Make a debugging symbol.  */
end_comment

begin_function
name|asymbol
modifier|*
name|coff_bfd_make_debug_symbol
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|sz
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
block|{
name|coff_symbol_type
modifier|*
name|new
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* @@ The 10 is a guess at a plausible maximum number of aux entries      (but shouldn't be a constant).  */
name|new
operator|->
name|native
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
operator|*
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|native
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|new
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|done_lineno
operator|=
name|false
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
name|void
name|coff_get_symbol_info
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
operator|!=
name|NULL
operator|&&
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
operator|->
name|fix_value
condition|)
block|{
name|combined_entry_type
modifier|*
name|psym
decl_stmt|;
name|psym
operator|=
operator|(
operator|(
name|combined_entry_type
operator|*
operator|)
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
name|ret
operator|->
name|value
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
name|psym
operator|-
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the COFF syment for a symbol.  */
end_comment

begin_function
name|boolean
name|bfd_coff_get_syment
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|psyment
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|psyment
decl_stmt|;
block|{
name|coff_symbol_type
modifier|*
name|csym
decl_stmt|;
name|csym
operator|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|csym
operator|==
name|NULL
operator|||
name|csym
operator|->
name|native
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|psyment
operator|=
name|csym
operator|->
name|native
operator|->
name|u
operator|.
name|syment
expr_stmt|;
if|if
condition|(
name|csym
operator|->
name|native
operator|->
name|fix_value
condition|)
name|psyment
operator|->
name|n_value
operator|=
operator|(
operator|(
name|combined_entry_type
operator|*
operator|)
name|psyment
operator|->
name|n_value
operator|-
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
comment|/* FIXME: We should handle fix_line here.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the COFF auxent for a symbol.  */
end_comment

begin_function
name|boolean
name|bfd_coff_get_auxent
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|indx
parameter_list|,
name|pauxent
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|pauxent
decl_stmt|;
block|{
name|coff_symbol_type
modifier|*
name|csym
decl_stmt|;
name|combined_entry_type
modifier|*
name|ent
decl_stmt|;
name|csym
operator|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|csym
operator|==
name|NULL
operator|||
name|csym
operator|->
name|native
operator|==
name|NULL
operator|||
name|indx
operator|>=
name|csym
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ent
operator|=
name|csym
operator|->
name|native
operator|+
name|indx
operator|+
literal|1
expr_stmt|;
operator|*
name|pauxent
operator|=
name|ent
operator|->
name|u
operator|.
name|auxent
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|fix_tag
condition|)
name|pauxent
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
operator|(
operator|(
name|combined_entry_type
operator|*
operator|)
name|pauxent
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|-
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|fix_end
condition|)
name|pauxent
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
operator|(
operator|(
name|combined_entry_type
operator|*
operator|)
name|pauxent
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|-
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|fix_scnlen
condition|)
name|pauxent
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
operator|(
operator|(
name|combined_entry_type
operator|*
operator|)
name|pauxent
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|p
operator|-
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Print out information about COFF symbol.  */
end_comment

begin_function
name|void
name|coff_print_symbol
parameter_list|(
name|abfd
parameter_list|,
name|filep
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filep
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"coff %s %s"
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
condition|?
literal|"n"
else|:
literal|"g"
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
condition|?
literal|"l"
else|:
literal|" "
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
if|if
condition|(
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
condition|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|int
name|aux
decl_stmt|;
name|combined_entry_type
modifier|*
name|combined
init|=
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
decl_stmt|;
name|combined_entry_type
modifier|*
name|root
init|=
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|lineno_cache_entry
modifier|*
name|l
init|=
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%3ld]"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|combined
operator|-
name|root
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|combined
operator|->
name|fix_value
condition|)
name|val
operator|=
operator|(
name|unsigned
name|long
operator|)
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
else|else
name|val
operator|=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|combined_entry_type
operator|*
operator|)
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|root
argument_list|)
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(sec %2d)(fl 0x%02x)(ty %3x)(scl %3d) (nx %d) 0x%08lx %s"
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
argument_list|,
name|val
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|aux
operator|=
literal|0
init|;
name|aux
operator|<
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|aux
operator|++
control|)
block|{
name|combined_entry_type
modifier|*
name|auxp
init|=
name|combined
operator|+
name|aux
operator|+
literal|1
decl_stmt|;
name|long
name|tagndx
decl_stmt|;
if|if
condition|(
name|auxp
operator|->
name|fix_tag
condition|)
name|tagndx
operator|=
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|-
name|root
expr_stmt|;
else|else
name|tagndx
operator|=
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_coff_print_aux
argument_list|(
name|abfd
argument_list|,
name|file
argument_list|,
name|root
argument_list|,
name|combined
argument_list|,
name|auxp
argument_list|,
name|aux
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
condition|)
block|{
case|case
name|C_FILE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"File "
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
if|if
condition|(
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|==
name|T_NULL
condition|)
comment|/* probably a section symbol? */
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"AUX scnlen 0x%lx nreloc %d nlnno %d"
argument_list|,
operator|(
name|long
operator|)
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_scnlen
argument_list|,
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_nreloc
argument_list|,
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_nlinno
argument_list|)
expr_stmt|;
if|if
condition|(
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_checksum
operator|!=
literal|0
operator|||
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_associated
operator|!=
literal|0
operator|||
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" checksum 0x%lx assoc %d comdat %d"
argument_list|,
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_checksum
argument_list|,
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_associated
argument_list|,
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through */
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"AUX lnno %d size 0x%x tagndx %ld"
argument_list|,
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|,
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|tagndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|auxp
operator|->
name|fix_end
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" endndx %ld"
argument_list|,
operator|(
call|(
name|long
call|)
argument_list|(
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|-
name|root
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|l
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%s :"
argument_list|,
name|l
operator|->
name|u
operator|.
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
while|while
condition|(
name|l
operator|->
name|line_number
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%4d : 0x%lx"
argument_list|,
name|l
operator|->
name|line_number
argument_list|,
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|l
operator|->
name|u
operator|.
name|offset
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s %s %s"
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
condition|?
literal|"n"
else|:
literal|"g"
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
condition|?
literal|"l"
else|:
literal|" "
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return whether a symbol name implies a local symbol.  In COFF,    local symbols generally start with ``.L''.  Most targets use this    function for the is_local_label_name entry point, but some may    override it.  */
end_comment

begin_function
name|boolean
name|_bfd_coff_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
return|;
block|}
end_function

begin_comment
comment|/* Provided a BFD, a section and an offset into the section, calculate    and return the name of the source file and the line nearest to the    wanted location.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|coff_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
name|boolean
name|found
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|line_base
decl_stmt|;
name|coff_data_type
modifier|*
name|cof
init|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Run through the raw syments if available */
name|combined_entry_type
modifier|*
name|p
decl_stmt|;
name|combined_entry_type
modifier|*
name|pend
decl_stmt|;
name|alent
modifier|*
name|l
decl_stmt|;
name|struct
name|coff_section_tdata
modifier|*
name|sec_data
decl_stmt|;
comment|/* Before looking through the symbol table, try to use a .stab      section to find the information.  */
if|if
condition|(
operator|!
name|_bfd_stab_section_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|found
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|line_info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|found
condition|)
return|return
name|true
return|;
operator|*
name|filename_ptr
operator|=
literal|0
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
literal|0
expr_stmt|;
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
comment|/* Don't try and find line numbers in a non coff file */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_coff_flavour
condition|)
return|return
name|false
return|;
if|if
condition|(
name|cof
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Find the first C_FILE symbol.  */
name|p
operator|=
name|cof
operator|->
name|raw_syments
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|cof
operator|->
name|raw_syment_count
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|pend
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
break|break;
name|p
operator|+=
literal|1
operator|+
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|pend
condition|)
block|{
name|bfd_vma
name|maxdiff
decl_stmt|;
comment|/* Look through the C_FILE symbols to find the best one.  */
operator|*
name|filename_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
name|maxdiff
operator|=
operator|(
name|bfd_vma
operator|)
literal|0
operator|-
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|combined_entry_type
modifier|*
name|p2
decl_stmt|;
for|for
control|(
name|p2
operator|=
name|p
operator|+
literal|1
operator|+
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
init|;
name|p2
operator|<
name|pend
condition|;
name|p2
operator|+=
literal|1
operator|+
name|p2
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
control|)
block|{
if|if
condition|(
name|p2
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|>
literal|0
operator|&&
operator|(
name|section
operator|==
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|p2
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|p2
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
name|p2
operator|=
name|pend
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p2
operator|<
name|pend
operator|&&
name|offset
operator|>=
operator|(
name|bfd_vma
operator|)
name|p2
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|&&
name|offset
operator|-
operator|(
name|bfd_vma
operator|)
name|p2
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|<
name|maxdiff
condition|)
block|{
operator|*
name|filename_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
name|maxdiff
operator|=
name|offset
operator|-
name|p2
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
block|}
comment|/* Avoid endless loops on erroneous files by ensuring that 	     we always move forward in the file.  */
if|if
condition|(
name|p
operator|-
name|cof
operator|->
name|raw_syments
operator|>=
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
condition|)
break|break;
name|p
operator|=
name|cof
operator|->
name|raw_syments
operator|+
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|pend
operator|||
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|!=
name|C_FILE
condition|)
break|break;
block|}
block|}
comment|/* Now wander though the raw linenumbers of the section */
comment|/* If we have been called on this section before, and the offset we      want is further down then we can prime the lookup loop.  */
name|sec_data
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_data
operator|!=
name|NULL
operator|&&
name|sec_data
operator|->
name|i
operator|>
literal|0
operator|&&
name|offset
operator|>=
name|sec_data
operator|->
name|offset
condition|)
block|{
name|i
operator|=
name|sec_data
operator|->
name|i
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|sec_data
operator|->
name|function
expr_stmt|;
name|line_base
operator|=
name|sec_data
operator|->
name|line_base
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|line_base
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|section
operator|->
name|lineno
operator|!=
name|NULL
condition|)
block|{
name|l
operator|=
operator|&
name|section
operator|->
name|lineno
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|section
operator|->
name|lineno_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|->
name|line_number
operator|==
literal|0
condition|)
block|{
comment|/* Get the symbol this line number points at */
name|coff_symbol_type
modifier|*
name|coff
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
operator|(
name|l
operator|->
name|u
operator|.
name|sym
operator|)
decl_stmt|;
if|if
condition|(
name|coff
operator|->
name|symbol
operator|.
name|value
operator|>
name|offset
condition|)
break|break;
operator|*
name|functionname_ptr
operator|=
name|coff
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|coff
operator|->
name|native
condition|)
block|{
name|combined_entry_type
modifier|*
name|s
init|=
name|coff
operator|->
name|native
decl_stmt|;
name|s
operator|=
name|s
operator|+
literal|1
operator|+
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
comment|/* In XCOFF a debugging symbol can follow the 		     function symbol.  */
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|==
name|N_DEBUG
condition|)
name|s
operator|=
name|s
operator|+
literal|1
operator|+
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
comment|/* S should now point to the .bf of the function.  */
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
comment|/* The linenumber is stored in the auxent.  */
name|union
name|internal_auxent
modifier|*
name|a
init|=
operator|&
operator|(
operator|(
name|s
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
decl_stmt|;
name|line_base
operator|=
name|a
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
operator|*
name|line_ptr
operator|=
name|line_base
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|l
operator|->
name|u
operator|.
name|offset
operator|+
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|>
name|offset
condition|)
break|break;
operator|*
name|line_ptr
operator|=
name|l
operator|->
name|line_number
operator|+
name|line_base
operator|-
literal|1
expr_stmt|;
block|}
name|l
operator|++
expr_stmt|;
block|}
block|}
comment|/* Cache the results for the next call.  */
if|if
condition|(
name|sec_data
operator|==
name|NULL
operator|&&
name|section
operator|->
name|owner
operator|==
name|abfd
condition|)
block|{
name|section
operator|->
name|used_by_bfd
operator|=
operator|(
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|sec_data
operator|=
operator|(
expr|struct
name|coff_section_tdata
operator|*
operator|)
name|section
operator|->
name|used_by_bfd
expr_stmt|;
block|}
if|if
condition|(
name|sec_data
operator|!=
name|NULL
condition|)
block|{
name|sec_data
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|sec_data
operator|->
name|i
operator|=
name|i
expr_stmt|;
name|sec_data
operator|->
name|function
operator|=
operator|*
name|functionname_ptr
expr_stmt|;
name|sec_data
operator|->
name|line_base
operator|=
name|line_base
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|coff_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|reloc
decl_stmt|;
block|{
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|reloc
operator|==
name|false
condition|)
block|{
name|size
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
operator|+
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|size
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

end_unit

