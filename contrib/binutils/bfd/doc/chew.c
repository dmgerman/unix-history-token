begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* chew    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001,    2002, 2003    Free Software Foundation, Inc.    Contributed by steve chamberlain @cygnus  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Yet another way of extracting documentation from source.    No, I haven't finished it yet, but I hope you people like it better    than the old way     sac     Basically, this is a sort of string forth, maybe we should call it    struth?     You define new words thus:    :<newword><oldwords> ;  */
end_comment

begin_comment
comment|/* Primitives provided by the program:     Two stacks are provided, a string stack and an integer stack.     Internal state variables: 	internal_wanted - indicates whether `-i' was passed 	internal_mode - user-settable     Commands: 	push_text 	! - pop top of integer stack for address, pop next for value; store 	@ - treat value on integer stack as the address of an integer; push 		that integer on the integer stack after popping the "address" 	hello - print "hello\n" to stdout 	stdout - put stdout marker on TOS 	stderr - put stderr marker on TOS 	print - print TOS-1 on TOS (eg: "hello\n" stdout print) 	skip_past_newline 	catstr - fn icatstr 	copy_past_newline - append input, up to and including newline into TOS 	dup - fn other_dup 	drop - discard TOS 	idrop - ditto 	remchar - delete last character from TOS 	get_stuff_in_command 	do_fancy_stuff - translate<<foo>> to @code{foo} in TOS 	bulletize - if "o" lines found, prepend @itemize @bullet to TOS 		and @item to each "o" line; append @end itemize 	courierize - put @example around . and | lines, translate {* *} { } 	exit - fn chew_exit 	swap 	outputdots - strip out lines without leading dots 	paramstuff - convert full declaration into "PARAMS" form if not already 	maybecatstr - do catstr if internal_mode == internal_wanted, discard 		value in any case 	translatecomments - turn {* and *} into comment delimiters 	kill_bogus_lines - get rid of extra newlines 	indent 	internalmode - pop from integer stack, set `internalmode' to that value 	print_stack_level - print current stack depth to stderr 	strip_trailing_newlines - go ahead, guess... 	[quoted string] - push string onto string stack 	[word starting with digit] - push atol(str) onto integer stack     A command must be all upper-case, and alone on a line.     Foo.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|DEF_SIZE
value|5000
end_define

begin_define
define|#
directive|define
name|STACK
value|50
end_define

begin_decl_stmt
name|int
name|internal_wanted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|internal_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warning
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is a string type ...  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|buffer
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|long
name|write_idx
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
block|}
name|string_type
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|static
name|void
name|init_string_with_size
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_string
parameter_list|(
name|string_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_buffer
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_string
parameter_list|(
name|string_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|addr
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
name|at
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catchar
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overwrite_string
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|string_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catbuf
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cattext
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catstr
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|string_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|init_string_with_size
parameter_list|(
name|buffer
parameter_list|,
name|size
parameter_list|)
name|string_type
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|buffer
operator|->
name|write_idx
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|buffer
operator|->
name|ptr
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_string
parameter_list|(
name|buffer
parameter_list|)
name|string_type
modifier|*
name|buffer
decl_stmt|;
block|{
name|init_string_with_size
argument_list|(
name|buffer
argument_list|,
name|DEF_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|find
parameter_list|(
name|str
parameter_list|,
name|what
parameter_list|)
name|string_type
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|what
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str
operator|->
name|write_idx
operator|&&
operator|*
name|p
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|str
operator|->
name|ptr
index|[
name|i
index|]
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|what
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|p
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_buffer
parameter_list|(
name|buffer
parameter_list|,
name|f
parameter_list|)
name|string_type
modifier|*
name|buffer
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|fwrite
argument_list|(
name|buffer
operator|->
name|ptr
argument_list|,
name|buffer
operator|->
name|write_idx
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_string
parameter_list|(
name|buffer
parameter_list|)
name|string_type
modifier|*
name|buffer
decl_stmt|;
block|{
name|free
argument_list|(
name|buffer
operator|->
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|addr
parameter_list|(
name|buffer
parameter_list|,
name|idx
parameter_list|)
name|string_type
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
block|{
return|return
name|buffer
operator|->
name|ptr
operator|+
name|idx
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|at
parameter_list|(
name|buffer
parameter_list|,
name|pos
parameter_list|)
name|string_type
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|>=
name|buffer
operator|->
name|write_idx
condition|)
return|return
literal|0
return|;
return|return
name|buffer
operator|->
name|ptr
index|[
name|pos
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|catchar
parameter_list|(
name|buffer
parameter_list|,
name|ch
parameter_list|)
name|string_type
modifier|*
name|buffer
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|buffer
operator|->
name|write_idx
operator|==
name|buffer
operator|->
name|size
condition|)
block|{
name|buffer
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|->
name|ptr
operator|=
name|realloc
argument_list|(
name|buffer
operator|->
name|ptr
argument_list|,
name|buffer
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|->
name|ptr
index|[
name|buffer
operator|->
name|write_idx
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|overwrite_string
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|string_type
modifier|*
name|dst
decl_stmt|;
name|string_type
modifier|*
name|src
decl_stmt|;
block|{
name|free
argument_list|(
name|dst
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|size
operator|=
name|src
operator|->
name|size
expr_stmt|;
name|dst
operator|->
name|write_idx
operator|=
name|src
operator|->
name|write_idx
expr_stmt|;
name|dst
operator|->
name|ptr
operator|=
name|src
operator|->
name|ptr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|catbuf
parameter_list|(
name|buffer
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|string_type
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|buffer
operator|->
name|write_idx
operator|+
name|len
operator|>=
name|buffer
operator|->
name|size
condition|)
block|{
while|while
condition|(
name|buffer
operator|->
name|write_idx
operator|+
name|len
operator|>=
name|buffer
operator|->
name|size
condition|)
name|buffer
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|->
name|ptr
operator|=
name|realloc
argument_list|(
name|buffer
operator|->
name|ptr
argument_list|,
name|buffer
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buffer
operator|->
name|ptr
operator|+
name|buffer
operator|->
name|write_idx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|write_idx
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cattext
parameter_list|(
name|buffer
parameter_list|,
name|string
parameter_list|)
name|string_type
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|catbuf
argument_list|(
name|buffer
argument_list|,
name|string
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|catstr
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|string_type
modifier|*
name|dst
decl_stmt|;
name|string_type
modifier|*
name|src
decl_stmt|;
block|{
name|catbuf
argument_list|(
name|dst
argument_list|,
name|src
operator|->
name|ptr
argument_list|,
name|src
operator|->
name|write_idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|skip_white_and_stars
parameter_list|(
name|src
parameter_list|,
name|idx
parameter_list|)
name|string_type
modifier|*
name|src
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|at
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
operator|)
operator|,
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'*'
comment|/* Don't skip past end-of-comment or star as first 		character on its line.  */
operator|&&
name|at
argument_list|(
name|src
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|!=
literal|'/'
operator|&&
name|at
argument_list|(
name|src
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_decl_stmt
name|string_type
name|stack
index|[
name|STACK
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|string_type
modifier|*
name|tos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|idx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pos in input buffer */
end_comment

begin_decl_stmt
name|string_type
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and the buffer */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|stinst_type
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_decl_stmt
name|stinst_type
modifier|*
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stinst_type
name|sstack
index|[
name|STACK
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stinst_type
modifier|*
name|ssp
init|=
operator|&
name|sstack
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|istack
index|[
name|STACK
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|isp
init|=
operator|&
name|istack
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
modifier|*
name|word_type
typedef|;
end_typedef

begin_struct
struct|struct
name|dict_struct
block|{
name|char
modifier|*
name|word
decl_stmt|;
name|struct
name|dict_struct
modifier|*
name|next
decl_stmt|;
name|stinst_type
modifier|*
name|code
decl_stmt|;
name|int
name|code_length
decl_stmt|;
name|int
name|code_end
decl_stmt|;
name|int
name|var
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|dict_struct
name|dict_type
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|die
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_range
parameter_list|()
block|{
if|if
condition|(
name|tos
operator|<
name|stack
condition|)
name|die
argument_list|(
literal|"underflow in string stack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tos
operator|>=
name|stack
operator|+
name|STACK
condition|)
name|die
argument_list|(
literal|"overflow in string stack"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|icheck_range
parameter_list|()
block|{
if|if
condition|(
name|isp
operator|<
name|istack
condition|)
name|die
argument_list|(
literal|"underflow in integer stack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|>=
name|istack
operator|+
name|STACK
condition|)
name|die
argument_list|(
literal|"overflow in integer stack"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|static
name|void
name|exec
parameter_list|(
name|dict_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|call
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|remchar
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|strip_trailing_newlines
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|push_number
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|push_text
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_noncomments
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|string_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_stack_level
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|paramstuff
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|translatecomments
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|outputdots
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|courierize
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|bulletize
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|do_fancy_stuff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iscommand
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|copy_past_newline
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|string_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|icopy_past_newline
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|kill_bogus_lines
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|indent
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_stuff_in_command
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|swap
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|other_dup
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|drop
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|idrop
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|icatstr
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|skip_past_newline
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|internalmode
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|maybecatstr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|nextword
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dict_type
modifier|*
name|lookup_word
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|perform
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dict_type
modifier|*
name|newentry
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|int
name|add_to_definition
parameter_list|(
name|dict_type
modifier|*
parameter_list|,
name|stinst_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_intrinsic
parameter_list|(
name|char
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_var
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|compile
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bang
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atsign
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hello
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stdout_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stderr_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_in
parameter_list|(
name|string_type
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chew_exit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|exec
parameter_list|(
name|word
parameter_list|)
name|dict_type
modifier|*
name|word
decl_stmt|;
block|{
name|pc
operator|=
name|word
operator|->
name|code
expr_stmt|;
while|while
condition|(
operator|*
name|pc
condition|)
call|(
modifier|*
name|pc
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|call
parameter_list|()
block|{
name|stinst_type
modifier|*
name|oldpc
init|=
name|pc
decl_stmt|;
name|dict_type
modifier|*
name|e
decl_stmt|;
name|e
operator|=
operator|(
name|dict_type
operator|*
operator|)
operator|(
name|pc
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|exec
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|pc
operator|=
name|oldpc
operator|+
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remchar
parameter_list|()
block|{
if|if
condition|(
name|tos
operator|->
name|write_idx
condition|)
name|tos
operator|->
name|write_idx
operator|--
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|strip_trailing_newlines
parameter_list|()
block|{
while|while
condition|(
operator|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|tos
operator|->
name|write_idx
operator|-
literal|1
argument_list|)
argument_list|)
operator|||
name|at
argument_list|(
name|tos
argument_list|,
name|tos
operator|->
name|write_idx
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
operator|)
operator|&&
name|tos
operator|->
name|write_idx
operator|>
literal|0
condition|)
name|tos
operator|->
name|write_idx
operator|--
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_number
parameter_list|()
block|{
name|isp
operator|++
expr_stmt|;
name|icheck_range
argument_list|()
expr_stmt|;
name|pc
operator|++
expr_stmt|;
operator|*
name|isp
operator|=
call|(
name|long
call|)
argument_list|(
operator|*
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_text
parameter_list|()
block|{
name|tos
operator|++
expr_stmt|;
name|check_range
argument_list|()
expr_stmt|;
name|init_string
argument_list|(
name|tos
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
name|cattext
argument_list|(
name|tos
argument_list|,
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|pc
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function removes everything not inside comments starting on    the first char of the line from the  string, also when copying    comments, removes blank space and leading *'s.    Blank lines are turned into one blank line.  */
end_comment

begin_function
specifier|static
name|void
name|remove_noncomments
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|string_type
modifier|*
name|src
decl_stmt|;
name|string_type
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|at
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
condition|)
block|{
comment|/* Now see if we have a comment at the start of the line.  */
if|if
condition|(
name|at
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\n'
operator|&&
name|at
argument_list|(
name|src
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'/'
operator|&&
name|at
argument_list|(
name|src
argument_list|,
name|idx
operator|+
literal|2
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|idx
operator|+=
literal|3
expr_stmt|;
name|idx
operator|=
name|skip_white_and_stars
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* Remove leading dot */
if|if
condition|(
name|at
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
operator|==
literal|'.'
condition|)
name|idx
operator|++
expr_stmt|;
comment|/* Copy to the end of the line, or till the end of the 	     comment.  */
while|while
condition|(
name|at
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
condition|)
block|{
if|if
condition|(
name|at
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
comment|/* end of line, echo and scrape of leading blanks  */
if|if
condition|(
name|at
argument_list|(
name|src
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
name|catchar
argument_list|(
name|dst
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|catchar
argument_list|(
name|dst
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|idx
operator|=
name|skip_white_and_stars
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
operator|==
literal|'*'
operator|&&
name|at
argument_list|(
name|src
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'/'
condition|)
block|{
name|idx
operator|+=
literal|2
expr_stmt|;
name|cattext
argument_list|(
name|dst
argument_list|,
literal|"\nENDDD\n"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|catchar
argument_list|(
name|dst
argument_list|,
name|at
argument_list|(
name|src
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
name|idx
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_stack_level
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current string stack depth = %d, "
argument_list|,
name|tos
operator|-
name|stack
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current integer stack depth = %d\n"
argument_list|,
name|isp
operator|-
name|istack
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* turn:      foobar name(stuff);    into:      foobar      name PARAMS ((stuff));    and a blank line.  */
end_comment

begin_function
specifier|static
name|void
name|paramstuff
parameter_list|()
block|{
name|unsigned
name|int
name|openp
decl_stmt|;
name|unsigned
name|int
name|fname
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|string_type
name|out
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
define|#
directive|define
name|NO_PARAMS
value|1
comment|/* Make sure that it's not already param'd or proto'd.  */
if|if
condition|(
name|NO_PARAMS
operator|||
name|find
argument_list|(
name|tos
argument_list|,
literal|"PARAMS"
argument_list|)
operator|||
name|find
argument_list|(
name|tos
argument_list|,
literal|"PROTO"
argument_list|)
operator|||
operator|!
name|find
argument_list|(
name|tos
argument_list|,
literal|"("
argument_list|)
condition|)
block|{
name|catstr
argument_list|(
operator|&
name|out
argument_list|,
name|tos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the open paren.  */
for|for
control|(
name|openp
operator|=
literal|0
init|;
name|at
argument_list|(
name|tos
argument_list|,
name|openp
argument_list|)
operator|!=
literal|'('
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|openp
argument_list|)
condition|;
name|openp
operator|++
control|)
empty_stmt|;
name|fname
operator|=
name|openp
expr_stmt|;
comment|/* Step back to the fname.  */
name|fname
operator|--
expr_stmt|;
while|while
condition|(
name|fname
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|fname
argument_list|)
argument_list|)
condition|)
name|fname
operator|--
expr_stmt|;
while|while
condition|(
name|fname
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|fname
argument_list|)
argument_list|)
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|fname
argument_list|)
operator|!=
literal|'*'
condition|)
name|fname
operator|--
expr_stmt|;
name|fname
operator|++
expr_stmt|;
comment|/* Output type, omitting trailing whitespace character(s), if          any.  */
for|for
control|(
name|len
operator|=
name|fname
init|;
literal|0
operator|<
name|len
condition|;
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|len
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
break|break;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|len
condition|;
name|idx
operator|++
control|)
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Insert a newline between type and fnname */
comment|/* Output function name, omitting trailing whitespace          character(s), if any.  */
for|for
control|(
name|len
operator|=
name|openp
init|;
literal|0
operator|<
name|len
condition|;
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|len
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
break|break;
block|}
for|for
control|(
name|idx
operator|=
name|fname
init|;
name|idx
operator|<
name|len
condition|;
name|idx
operator|++
control|)
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|" PARAMS ("
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|openp
init|;
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|!=
literal|';'
condition|;
name|idx
operator|++
control|)
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|");\n\n"
argument_list|)
expr_stmt|;
block|}
name|overwrite_string
argument_list|(
name|tos
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* turn {*    and *} into comments */
end_comment

begin_function
specifier|static
name|void
name|translatecomments
parameter_list|()
block|{
name|unsigned
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|string_type
name|out
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
condition|)
block|{
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'{'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"/*"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'*'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'}'
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"*/"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
name|overwrite_string
argument_list|(
name|tos
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is not currently used.  */
end_comment

begin_comment
comment|/* turn everything not starting with a . into a comment */
end_comment

begin_endif
unit|static void manglecomments () {   unsigned int idx = 0;   string_type out;   init_string (&out);    while (at (tos, idx))     {       if (at (tos, idx) == '\n'&& at (tos, idx + 1) == '*') 	{ 	  cattext (&out, "	/*"); 	  idx += 2; 	}       else if (at (tos, idx) == '*'&& at (tos, idx + 1) == '}') 	{ 	  cattext (&out, "*/"); 	  idx += 2; 	}       else 	{ 	  catchar (&out, at (tos, idx)); 	  idx++; 	}     }    overwrite_string (tos,&out);    pc++; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Mod tos so that only lines with leading dots remain */
end_comment

begin_function
specifier|static
name|void
name|outputdots
parameter_list|()
block|{
name|unsigned
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|string_type
name|out
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
condition|)
block|{
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\n'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'.'
condition|)
block|{
name|char
name|c
decl_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'{'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"/*"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'}'
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"*/"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|++
expr_stmt|;
block|}
block|}
name|overwrite_string
argument_list|(
name|tos
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find lines starting with . and | and put example around them on tos */
end_comment

begin_function
specifier|static
name|void
name|courierize
parameter_list|()
block|{
name|string_type
name|out
decl_stmt|;
name|unsigned
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|command
init|=
literal|0
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
condition|)
block|{
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\n'
operator|&&
operator|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'.'
operator|||
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'|'
operator|)
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"\n@example\n"
argument_list|)
expr_stmt|;
do|do
block|{
name|idx
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|command
operator|>
literal|1
condition|)
block|{
comment|/* We are inside {} parameters of some command; 			 Just pass through until matching brace.  */
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'{'
condition|)
operator|++
name|command
expr_stmt|;
elseif|else
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'}'
condition|)
operator|--
name|command
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'{'
condition|)
operator|++
name|command
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|islower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
condition|)
operator|--
name|command
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'@'
operator|&&
name|islower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|command
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'{'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"/*"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'*'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'}'
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"*/"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'{'
operator|||
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'}'
condition|)
block|{
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
block|}
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\n'
operator|&&
operator|(
operator|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'|'
operator|)
operator|)
condition|)
do|;
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"@end example"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
name|overwrite_string
argument_list|(
name|tos
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds any lines starting with "o ", if there are any, then turns    on @itemize @bullet, and @items each of them. Then ends with @end    itemize, inplace at TOS*/
end_comment

begin_function
specifier|static
name|void
name|bulletize
parameter_list|()
block|{
name|unsigned
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|on
init|=
literal|0
decl_stmt|;
name|string_type
name|out
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
condition|)
block|{
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'@'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\n'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'o'
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|on
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"\n@itemize @bullet\n"
argument_list|)
expr_stmt|;
name|on
operator|=
literal|1
expr_stmt|;
block|}
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"\n@item\n"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\n'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'\n'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|2
argument_list|)
operator|!=
literal|'o'
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"@end itemize"
argument_list|)
expr_stmt|;
name|on
operator|=
literal|0
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|on
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"@end itemize\n"
argument_list|)
expr_stmt|;
block|}
name|delete_string
argument_list|(
name|tos
argument_list|)
expr_stmt|;
operator|*
name|tos
operator|=
name|out
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn<<foo>> into @code{foo} in place at TOS*/
end_comment

begin_function
specifier|static
name|void
name|do_fancy_stuff
parameter_list|()
block|{
name|unsigned
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|string_type
name|out
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
condition|)
block|{
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'<'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
operator|==
literal|'<'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|idx
operator|+
literal|2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This qualifies as a<< startup.  */
name|idx
operator|+=
literal|2
expr_stmt|;
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"@code{"
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|!=
literal|'>'
condition|)
block|{
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
name|delete_string
argument_list|(
name|tos
argument_list|)
expr_stmt|;
operator|*
name|tos
operator|=
name|out
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A command is all upper case,and alone on a line.  */
end_comment

begin_function
specifier|static
name|int
name|iscommand
parameter_list|(
name|ptr
parameter_list|,
name|idx
parameter_list|)
name|string_type
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
block|{
name|unsigned
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
argument_list|)
operator|||
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
operator|==
literal|' '
operator|||
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
operator|==
literal|'_'
condition|)
block|{
name|len
operator|++
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|3
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_past_newline
parameter_list|(
name|ptr
parameter_list|,
name|idx
parameter_list|,
name|dst
parameter_list|)
name|string_type
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|string_type
modifier|*
name|dst
decl_stmt|;
block|{
name|int
name|column
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
operator|&&
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\t'
condition|)
block|{
comment|/* Expand tabs.  Neither makeinfo nor TeX can cope well with 	     them.  */
do|do
name|catchar
argument_list|(
name|dst
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
do|while
condition|(
operator|++
name|column
operator|&
literal|7
condition|)
do|;
block|}
else|else
block|{
name|catchar
argument_list|(
name|dst
argument_list|,
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
block|}
name|catchar
argument_list|(
name|dst
argument_list|,
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|icopy_past_newline
parameter_list|()
block|{
name|tos
operator|++
expr_stmt|;
name|check_range
argument_list|()
expr_stmt|;
name|init_string
argument_list|(
name|tos
argument_list|)
expr_stmt|;
name|idx
operator|=
name|copy_past_newline
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|,
name|tos
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* indent    Take the string at the top of the stack, do some prettying.  */
end_comment

begin_function
specifier|static
name|void
name|kill_bogus_lines
parameter_list|()
block|{
name|int
name|sl
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|dot
init|=
literal|0
decl_stmt|;
name|string_type
name|out
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
comment|/* Drop leading nl.  */
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
name|idx
operator|++
expr_stmt|;
block|}
name|c
operator|=
name|idx
expr_stmt|;
comment|/* If the first char is a '.' prepend a newline so that it is      recognized properly later.  */
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
operator|==
literal|'.'
condition|)
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Find the last char.  */
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|idx
operator|++
expr_stmt|;
block|}
comment|/* Find the last non white before the nl.  */
name|idx
operator|--
expr_stmt|;
while|while
condition|(
name|idx
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
condition|)
name|idx
operator|--
expr_stmt|;
name|idx
operator|++
expr_stmt|;
comment|/* Copy buffer upto last char, but blank lines before and after      dots don't count.  */
name|sl
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|<
name|idx
condition|)
block|{
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|c
argument_list|)
operator|==
literal|'\n'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|c
operator|+
literal|1
argument_list|)
operator|==
literal|'\n'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|c
operator|+
literal|2
argument_list|)
operator|==
literal|'.'
condition|)
block|{
comment|/* Ignore two newlines before a dot.  */
name|c
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|c
argument_list|)
operator|==
literal|'.'
operator|&&
name|sl
condition|)
block|{
comment|/* remember that this line started with a dot.  */
name|dot
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|c
argument_list|)
operator|==
literal|'\n'
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|c
operator|+
literal|1
argument_list|)
operator|==
literal|'\n'
operator|&&
name|dot
condition|)
block|{
name|c
operator|++
expr_stmt|;
comment|/* Ignore two newlines when last line was dot.  */
block|}
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|c
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
name|sl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dot
operator|==
literal|2
condition|)
name|dot
operator|=
literal|1
expr_stmt|;
else|else
name|dot
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sl
operator|=
literal|0
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
comment|/* Append nl.  */
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
name|delete_string
argument_list|(
name|tos
argument_list|)
expr_stmt|;
operator|*
name|tos
operator|=
name|out
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|indent
parameter_list|()
block|{
name|string_type
name|out
decl_stmt|;
name|int
name|tab
init|=
literal|0
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|ol
init|=
literal|0
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
condition|)
block|{
case|case
literal|'\n'
case|:
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|tab
operator|&&
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
block|}
name|ol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|tab
operator|++
expr_stmt|;
if|if
condition|(
name|ol
operator|==
literal|0
condition|)
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|ol
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|tab
operator|--
expr_stmt|;
name|cattext
argument_list|(
operator|&
name|out
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|ol
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|catchar
argument_list|(
operator|&
name|out
argument_list|,
name|at
argument_list|(
name|tos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|ol
operator|=
literal|1
expr_stmt|;
name|idx
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|pc
operator|++
expr_stmt|;
name|delete_string
argument_list|(
name|tos
argument_list|)
expr_stmt|;
operator|*
name|tos
operator|=
name|out
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_stuff_in_command
parameter_list|()
block|{
name|tos
operator|++
expr_stmt|;
name|check_range
argument_list|()
expr_stmt|;
name|init_string
argument_list|(
name|tos
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
condition|)
block|{
if|if
condition|(
name|iscommand
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
condition|)
break|break;
name|idx
operator|=
name|copy_past_newline
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|,
name|tos
argument_list|)
expr_stmt|;
block|}
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap
parameter_list|()
block|{
name|string_type
name|t
decl_stmt|;
name|t
operator|=
name|tos
index|[
literal|0
index|]
expr_stmt|;
name|tos
index|[
literal|0
index|]
operator|=
name|tos
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tos
index|[
operator|-
literal|1
index|]
operator|=
name|t
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|other_dup
parameter_list|()
block|{
name|tos
operator|++
expr_stmt|;
name|check_range
argument_list|()
expr_stmt|;
name|init_string
argument_list|(
name|tos
argument_list|)
expr_stmt|;
name|catstr
argument_list|(
name|tos
argument_list|,
name|tos
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drop
parameter_list|()
block|{
name|tos
operator|--
expr_stmt|;
name|check_range
argument_list|()
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|idrop
parameter_list|()
block|{
name|isp
operator|--
expr_stmt|;
name|icheck_range
argument_list|()
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|icatstr
parameter_list|()
block|{
name|tos
operator|--
expr_stmt|;
name|check_range
argument_list|()
expr_stmt|;
name|catstr
argument_list|(
name|tos
argument_list|,
name|tos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|delete_string
argument_list|(
name|tos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|skip_past_newline
parameter_list|()
block|{
while|while
condition|(
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
operator|&&
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
operator|!=
literal|'\n'
condition|)
name|idx
operator|++
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|internalmode
parameter_list|()
block|{
name|internal_mode
operator|=
operator|*
operator|(
name|isp
operator|)
expr_stmt|;
name|isp
operator|--
expr_stmt|;
name|icheck_range
argument_list|()
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybecatstr
parameter_list|()
block|{
if|if
condition|(
name|internal_wanted
operator|==
name|internal_mode
condition|)
block|{
name|catstr
argument_list|(
name|tos
operator|-
literal|1
argument_list|,
name|tos
argument_list|)
expr_stmt|;
block|}
name|delete_string
argument_list|(
name|tos
argument_list|)
expr_stmt|;
name|tos
operator|--
expr_stmt|;
name|check_range
argument_list|()
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|nextword
parameter_list|(
name|string
parameter_list|,
name|word
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
modifier|*
name|word
decl_stmt|;
block|{
name|char
modifier|*
name|word_start
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|string
argument_list|)
operator|||
operator|*
name|string
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
name|string
operator|&&
operator|*
name|string
operator|!=
literal|'\n'
condition|)
name|string
operator|++
expr_stmt|;
block|}
else|else
block|{
name|string
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|string
condition|)
return|return
literal|0
return|;
name|word_start
operator|=
name|string
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'"'
condition|)
block|{
do|do
block|{
name|string
operator|++
expr_stmt|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'\\'
condition|)
block|{
name|string
operator|+=
literal|2
expr_stmt|;
name|length
operator|+=
literal|2
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|string
operator|!=
literal|'"'
condition|)
do|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|string
argument_list|)
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|word
operator|=
name|malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|*
name|word
expr_stmt|;
name|src
operator|=
name|word_start
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|length
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|src
index|[
name|idx
index|]
operator|==
literal|'\\'
condition|)
switch|switch
condition|(
name|src
index|[
name|idx
operator|+
literal|1
index|]
condition|)
block|{
case|case
literal|'n'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|idx
operator|++
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
operator|*
name|dst
operator|++
operator|=
name|src
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
name|idx
operator|++
expr_stmt|;
break|break;
default|default:
operator|*
name|dst
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|dst
operator|++
operator|=
name|src
index|[
name|idx
index|]
expr_stmt|;
block|}
operator|*
name|dst
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
return|return
name|string
operator|+
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|dict_type
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_function
name|dict_type
modifier|*
name|lookup_word
parameter_list|(
name|word
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
block|{
name|dict_type
modifier|*
name|ptr
init|=
name|root
decl_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ptr
operator|->
name|word
argument_list|,
name|word
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ptr
return|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|warning
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find %s\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|perform
parameter_list|()
block|{
name|tos
operator|=
name|stack
expr_stmt|;
while|while
condition|(
name|at
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
condition|)
block|{
comment|/* It's worth looking through the command list.  */
if|if
condition|(
name|iscommand
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|char
modifier|*
name|next
decl_stmt|;
name|dict_type
modifier|*
name|word
decl_stmt|;
operator|(
name|void
operator|)
name|nextword
argument_list|(
name|addr
argument_list|(
name|ptr
argument_list|,
name|idx
argument_list|)
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
name|word
operator|=
name|lookup_word
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
condition|)
block|{
name|exec
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|warning
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning, %s is not recognised\n"
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|skip_past_newline
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|skip_past_newline
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|dict_type
modifier|*
name|newentry
parameter_list|(
name|word
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
block|{
name|dict_type
modifier|*
name|new
init|=
operator|(
name|dict_type
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dict_type
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|word
operator|=
name|word
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|root
expr_stmt|;
name|root
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|code
operator|=
operator|(
name|stinst_type
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stinst_type
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|code_length
operator|=
literal|1
expr_stmt|;
name|new
operator|->
name|code_end
operator|=
literal|0
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|add_to_definition
parameter_list|(
name|entry
parameter_list|,
name|word
parameter_list|)
name|dict_type
modifier|*
name|entry
decl_stmt|;
name|stinst_type
name|word
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|->
name|code_end
operator|==
name|entry
operator|->
name|code_length
condition|)
block|{
name|entry
operator|->
name|code_length
operator|+=
literal|2
expr_stmt|;
name|entry
operator|->
name|code
operator|=
operator|(
name|stinst_type
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|entry
operator|->
name|code
operator|)
argument_list|,
name|entry
operator|->
name|code_length
operator|*
sizeof|sizeof
argument_list|(
name|word_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|entry
operator|->
name|code
index|[
name|entry
operator|->
name|code_end
index|]
operator|=
name|word
expr_stmt|;
return|return
name|entry
operator|->
name|code_end
operator|++
return|;
block|}
end_function

begin_decl_stmt
name|void
name|add_intrinsic
argument_list|(
name|name
argument_list|,
name|func
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|dict_type
modifier|*
name|new
init|=
name|newentry
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|add_to_definition
argument_list|(
name|new
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|add_to_definition
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|add_var
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|dict_type
modifier|*
name|new
init|=
name|newentry
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|add_to_definition
argument_list|(
name|new
argument_list|,
name|push_number
argument_list|)
expr_stmt|;
name|add_to_definition
argument_list|(
name|new
argument_list|,
call|(
name|stinst_type
call|)
argument_list|(
operator|&
operator|(
name|new
operator|->
name|var
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_to_definition
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compile
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
comment|/* Add words to the dictionary.  */
name|char
modifier|*
name|word
decl_stmt|;
name|string
operator|=
name|nextword
argument_list|(
name|string
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
while|while
condition|(
name|string
operator|&&
operator|*
name|string
operator|&&
name|word
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"var"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string
operator|=
name|nextword
argument_list|(
name|string
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
name|add_var
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|string
operator|=
name|nextword
argument_list|(
name|string
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|word
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|dict_type
modifier|*
name|ptr
decl_stmt|;
comment|/* Compile a word and add to dictionary.  */
name|string
operator|=
name|nextword
argument_list|(
name|string
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|newentry
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|string
operator|=
name|nextword
argument_list|(
name|string
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
while|while
condition|(
name|word
index|[
literal|0
index|]
operator|!=
literal|';'
condition|)
block|{
switch|switch
condition|(
name|word
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'"'
case|:
comment|/* got a string, embed magic push string 		     function */
name|add_to_definition
argument_list|(
name|ptr
argument_list|,
name|push_text
argument_list|)
expr_stmt|;
name|add_to_definition
argument_list|(
name|ptr
argument_list|,
call|(
name|stinst_type
call|)
argument_list|(
name|word
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* Got a number, embedd the magic push number 		     function */
name|add_to_definition
argument_list|(
name|ptr
argument_list|,
name|push_number
argument_list|)
expr_stmt|;
name|add_to_definition
argument_list|(
name|ptr
argument_list|,
operator|(
name|stinst_type
operator|)
name|atol
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|add_to_definition
argument_list|(
name|ptr
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|add_to_definition
argument_list|(
name|ptr
argument_list|,
operator|(
name|stinst_type
operator|)
name|lookup_word
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|string
operator|=
name|nextword
argument_list|(
name|string
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
block|}
name|add_to_definition
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|nextword
argument_list|(
name|string
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"syntax error at %s\n"
argument_list|,
name|string
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bang
parameter_list|()
block|{
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
operator|(
name|isp
index|[
literal|0
index|]
operator|)
operator|)
operator|=
name|isp
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|isp
operator|-=
literal|2
expr_stmt|;
name|icheck_range
argument_list|()
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atsign
parameter_list|()
block|{
name|isp
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|isp
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hello
parameter_list|()
block|{
name|printf
argument_list|(
literal|"hello\n"
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stdout_
parameter_list|()
block|{
name|isp
operator|++
expr_stmt|;
name|icheck_range
argument_list|()
expr_stmt|;
operator|*
name|isp
operator|=
literal|1
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stderr_
parameter_list|()
block|{
name|isp
operator|++
expr_stmt|;
name|icheck_range
argument_list|()
expr_stmt|;
operator|*
name|isp
operator|=
literal|2
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print
parameter_list|()
block|{
if|if
condition|(
operator|*
name|isp
operator|==
literal|1
condition|)
name|write_buffer
argument_list|(
name|tos
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|isp
operator|==
literal|2
condition|)
name|write_buffer
argument_list|(
name|tos
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"print: illegal print destination `%ld'\n"
argument_list|,
operator|*
name|isp
argument_list|)
expr_stmt|;
name|isp
operator|--
expr_stmt|;
name|tos
operator|--
expr_stmt|;
name|icheck_range
argument_list|()
expr_stmt|;
name|check_range
argument_list|()
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_in
parameter_list|(
name|str
parameter_list|,
name|file
parameter_list|)
name|string_type
modifier|*
name|str
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|char
name|buff
index|[
literal|10000
index|]
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
do|do
block|{
name|r
operator|=
name|fread
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|catbuf
argument_list|(
name|str
argument_list|,
name|buff
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|r
condition|)
do|;
name|buff
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|catbuf
argument_list|(
name|str
argument_list|,
name|buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: -[d|i|g]<file>file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|33
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* There is no reliable way to declare exit.  Sometimes it returns    int, and sometimes it returns void.  Sometimes it changes between    OS releases.  Trying to get it declared correctly in the hosts file    is a pointless waste of time.  */
end_comment

begin_function
specifier|static
name|void
name|chew_exit
parameter_list|()
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|string_type
name|buffer
decl_stmt|;
name|string_type
name|pptr
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|init_string
argument_list|(
operator|&
name|pptr
argument_list|)
expr_stmt|;
name|init_string
argument_list|(
name|stack
operator|+
literal|0
argument_list|)
expr_stmt|;
name|tos
operator|=
name|stack
operator|+
literal|1
expr_stmt|;
name|ptr
operator|=
operator|&
name|pptr
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"push_text"
argument_list|,
name|push_text
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"!"
argument_list|,
name|bang
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"@"
argument_list|,
name|atsign
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"hello"
argument_list|,
name|hello
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"stdout"
argument_list|,
name|stdout_
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"stderr"
argument_list|,
name|stderr_
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"print"
argument_list|,
name|print
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"skip_past_newline"
argument_list|,
name|skip_past_newline
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"catstr"
argument_list|,
name|icatstr
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"copy_past_newline"
argument_list|,
name|icopy_past_newline
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"dup"
argument_list|,
name|other_dup
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"drop"
argument_list|,
name|drop
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"idrop"
argument_list|,
name|idrop
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"remchar"
argument_list|,
name|remchar
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"get_stuff_in_command"
argument_list|,
name|get_stuff_in_command
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"do_fancy_stuff"
argument_list|,
name|do_fancy_stuff
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"bulletize"
argument_list|,
name|bulletize
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"courierize"
argument_list|,
name|courierize
argument_list|)
expr_stmt|;
comment|/* If the following line gives an error, exit() is not declared in the      ../hosts/foo.h file for this host.  Fix it there, not here!  */
comment|/* No, don't fix it anywhere; see comment on chew_exit--Ian Taylor.  */
name|add_intrinsic
argument_list|(
literal|"exit"
argument_list|,
name|chew_exit
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"swap"
argument_list|,
name|swap
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"outputdots"
argument_list|,
name|outputdots
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"paramstuff"
argument_list|,
name|paramstuff
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"maybecatstr"
argument_list|,
name|maybecatstr
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"translatecomments"
argument_list|,
name|translatecomments
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"kill_bogus_lines"
argument_list|,
name|kill_bogus_lines
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"indent"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"internalmode"
argument_list|,
name|internalmode
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"print_stack_level"
argument_list|,
name|print_stack_level
argument_list|)
expr_stmt|;
name|add_intrinsic
argument_list|(
literal|"strip_trailing_newlines"
argument_list|,
name|strip_trailing_newlines
argument_list|)
expr_stmt|;
comment|/* Put a nl at the start.  */
name|catchar
argument_list|(
operator|&
name|buffer
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|read_in
argument_list|(
operator|&
name|buffer
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|remove_noncomments
argument_list|(
operator|&
name|buffer
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|unsigned
name|int
operator|)
name|ac
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|av
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|av
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'f'
condition|)
block|{
name|string_type
name|b
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|init_string
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|av
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open the input file %s\n"
argument_list|,
name|av
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|33
return|;
block|}
name|read_in
argument_list|(
operator|&
name|b
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|compile
argument_list|(
name|b
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|perform
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|av
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
block|{
name|internal_wanted
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|av
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
block|{
name|warning
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|write_buffer
argument_list|(
name|stack
operator|+
literal|0
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|tos
operator|!=
name|stack
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"finishing with current stack level %d\n"
argument_list|,
name|tos
operator|-
name|stack
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

