begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD library -- caching of file descriptors.    Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001    Free Software Foundation, Inc.    Hacked by Steve Chamberlain of Cygnus Support (steve@cygnus.com).  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* SECTION 	File caching  	The file caching mechanism is embedded within BFD and allows 	the application to open as many BFDs as it wants without 	regard to the underlying operating system's file descriptor 	limit (often as low as 20 open files).  The module in<<cache.c>> maintains a least recently used list of<<BFD_CACHE_MAX_OPEN>> files, and exports the name<<bfd_cache_lookup>>, which runs around and makes sure that 	the required BFD is open. If not, then it chooses a file to 	close, closes it and opens the one wanted, returning its file 	handle.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|insert
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|snip
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|close_one
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|bfd_cache_delete
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	BFD_CACHE_MAX_OPEN macro  DESCRIPTION 	The maximum number of files which the cache will keep open at 	one time.  .#define BFD_CACHE_MAX_OPEN 10  */
end_comment

begin_comment
comment|/* The number of BFD files we have open.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|open_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_last_cache  SYNOPSIS 	extern bfd *bfd_last_cache;  DESCRIPTION 	Zero, or a pointer to the topmost BFD on the chain.  This is 	used by the<<bfd_cache_lookup>> macro in @file{libbfd.h} to 	determine when it can avoid a function call. */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|bfd_last_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   INTERNAL_FUNCTION   	bfd_cache_lookup    DESCRIPTION  	Check to see if the required BFD is the same as the last one  	looked up. If so, then it can use the stream in the BFD with  	impunity, since it can't have changed since the last lookup;  	otherwise, it has to perform the complicated lookup function.    .#define bfd_cache_lookup(x) \   .    ((x)==bfd_last_cache? \   .      (FILE*) (bfd_last_cache->iostream): \   .       bfd_cache_lookup_worker(x))   */
end_comment

begin_comment
comment|/* Insert a BFD into the cache.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|insert
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_last_cache
operator|==
name|NULL
condition|)
block|{
name|abfd
operator|->
name|lru_next
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|lru_prev
operator|=
name|abfd
expr_stmt|;
block|}
else|else
block|{
name|abfd
operator|->
name|lru_next
operator|=
name|bfd_last_cache
expr_stmt|;
name|abfd
operator|->
name|lru_prev
operator|=
name|bfd_last_cache
operator|->
name|lru_prev
expr_stmt|;
name|abfd
operator|->
name|lru_prev
operator|->
name|lru_next
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|lru_next
operator|->
name|lru_prev
operator|=
name|abfd
expr_stmt|;
block|}
name|bfd_last_cache
operator|=
name|abfd
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a BFD from the cache.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|snip
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|abfd
operator|->
name|lru_prev
operator|->
name|lru_next
operator|=
name|abfd
operator|->
name|lru_next
expr_stmt|;
name|abfd
operator|->
name|lru_next
operator|->
name|lru_prev
operator|=
name|abfd
operator|->
name|lru_prev
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|bfd_last_cache
condition|)
block|{
name|bfd_last_cache
operator|=
name|abfd
operator|->
name|lru_next
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|bfd_last_cache
condition|)
name|bfd_last_cache
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We need to open a new file, and the cache is full.  Find the least    recently used cacheable BFD and close it.  */
end_comment

begin_function
specifier|static
name|boolean
name|close_one
parameter_list|()
block|{
specifier|register
name|bfd
modifier|*
name|kill
decl_stmt|;
if|if
condition|(
name|bfd_last_cache
operator|==
name|NULL
condition|)
name|kill
operator|=
name|NULL
expr_stmt|;
else|else
block|{
for|for
control|(
name|kill
operator|=
name|bfd_last_cache
operator|->
name|lru_prev
init|;
operator|!
name|kill
operator|->
name|cacheable
condition|;
name|kill
operator|=
name|kill
operator|->
name|lru_prev
control|)
block|{
if|if
condition|(
name|kill
operator|==
name|bfd_last_cache
condition|)
block|{
name|kill
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|kill
operator|==
name|NULL
condition|)
block|{
comment|/* There are no open cacheable BFD's.  */
return|return
name|true
return|;
block|}
name|kill
operator|->
name|where
operator|=
name|ftell
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|kill
operator|->
name|iostream
argument_list|)
expr_stmt|;
return|return
name|bfd_cache_delete
argument_list|(
name|kill
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close a BFD and remove it from the cache.  */
end_comment

begin_function
specifier|static
name|boolean
name|bfd_cache_delete
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|boolean
name|ret
decl_stmt|;
if|if
condition|(
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|true
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|false
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
block|}
name|snip
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|iostream
operator|=
name|NULL
expr_stmt|;
operator|--
name|open_files
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_cache_init  SYNOPSIS 	boolean bfd_cache_init (bfd *abfd);  DESCRIPTION 	Add a newly opened BFD to the cache. */
end_comment

begin_function
name|boolean
name|bfd_cache_init
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|iostream
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|open_files
operator|>=
name|BFD_CACHE_MAX_OPEN
condition|)
block|{
if|if
condition|(
operator|!
name|close_one
argument_list|()
condition|)
return|return
name|false
return|;
block|}
name|insert
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|++
name|open_files
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_cache_close  SYNOPSIS 	boolean bfd_cache_close (bfd *abfd);  DESCRIPTION 	Remove the BFD @var{abfd} from the cache. If the attached file is open, 	then close it too.  RETURNS<<false>> is returned if closing the file fails,<<true>> is 	returned if all is well. */
end_comment

begin_function
name|boolean
name|bfd_cache_close
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|==
name|NULL
operator|||
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
return|return
name|bfd_cache_delete
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_open_file  SYNOPSIS 	FILE* bfd_open_file(bfd *abfd);  DESCRIPTION 	Call the OS to open a file for @var{abfd}.  Return the<<FILE *>> 	(possibly<<NULL>>) that results from this operation.  Set up the 	BFD so that future accesses know the file is open. If the<<FILE *>> 	returned is<<NULL>>, then it won't have been put in the 	cache, so it won't have to be removed from it. */
end_comment

begin_function
name|FILE
modifier|*
name|bfd_open_file
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|abfd
operator|->
name|cacheable
operator|=
name|true
expr_stmt|;
comment|/* Allow it to be closed later.  */
if|if
condition|(
name|open_files
operator|>=
name|BFD_CACHE_MAX_OPEN
condition|)
block|{
if|if
condition|(
operator|!
name|close_one
argument_list|()
condition|)
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|abfd
operator|->
name|direction
condition|)
block|{
case|case
name|read_direction
case|:
case|case
name|no_direction
case|:
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
break|break;
case|case
name|both_direction
case|:
case|case
name|write_direction
case|:
if|if
condition|(
name|abfd
operator|->
name|opened_once
operator|==
name|true
condition|)
block|{
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_RUB
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|==
name|NULL
condition|)
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_WUB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Create the file.  	     Some operating systems won't let us overwrite a running 	     binary.  For them, we want to unlink the file first.  	     However, gcc 2.95 will create temporary files using 	     O_EXCL and tight permissions to prevent other users from 	     substituting other .o files during the compilation.  gcc 	     will then tell the assembler to use the newly created 	     file as an output file.  If we unlink the file here, we 	     open a brief window when another user could still 	     substitute a file.  	     So we unlink the output file if and only if it has 	     non-zero size.  */
ifndef|#
directive|ifndef
name|__MSDOS__
comment|/* Don't do this for MSDOS: it doesn't care about overwriting 	     a running binary, but if this file is already open by 	     another BFD, we will be in deep trouble if we delete an 	     open file.  In fact, objdump does just that if invoked with 	     the --info option.  */
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|s
operator|.
name|st_size
operator|!=
literal|0
condition|)
name|unlink
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_WUB
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|opened_once
operator|=
name|true
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_cache_init
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_cache_lookup_worker  SYNOPSIS 	FILE *bfd_cache_lookup_worker(bfd *abfd);  DESCRIPTION 	Called when the macro<<bfd_cache_lookup>> fails to find a 	quick answer.  Find a file descriptor for @var{abfd}.  If 	necessary, it open it.  If there are already more than<<BFD_CACHE_MAX_OPEN>> files open, it tries to close one first, to 	avoid running out of file descriptors. */
end_comment

begin_function
name|FILE
modifier|*
name|bfd_cache_lookup_worker
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|abfd
operator|=
name|abfd
operator|->
name|my_archive
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|!=
name|NULL
condition|)
block|{
comment|/* Move the file to the start of the cache.  */
if|if
condition|(
name|abfd
operator|!=
name|bfd_last_cache
condition|)
block|{
name|snip
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bfd_open_file
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fseek
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
argument_list|,
name|abfd
operator|->
name|where
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
return|;
block|}
end_function

end_unit

