begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD library -- caching of file descriptors.     Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002,    2003, 2004, 2005, 2007 Free Software Foundation, Inc.     Hacked by Steve Chamberlain of Cygnus Support (steve@cygnus.com).  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* SECTION 	File caching  	The file caching mechanism is embedded within BFD and allows 	the application to open as many BFDs as it wants without 	regard to the underlying operating system's file descriptor 	limit (often as low as 20 open files).  The module in<<cache.c>> maintains a least recently used list of<<BFD_CACHE_MAX_OPEN>> files, and exports the name<<bfd_cache_lookup>>, which runs around and makes sure that 	the required BFD is open. If not, then it chooses a file to 	close, closes it and opens the one wanted, returning its file 	handle.  SUBSECTION 	Caching functions */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* In some cases we can optimize cache operation when reopening files.    For instance, a flush is entirely unnecessary if the file is already    closed, so a flush would use CACHE_NO_OPEN.  Similarly, a seek using    SEEK_SET or SEEK_END need not first seek to the current position.    For stat we ignore seek errors, just in case the file has changed    while we weren't looking.  If it has, then it's possible that the    file is shorter and we don't want a seek error to prevent us doing    the stat.  */
end_comment

begin_enum
enum|enum
name|cache_flag
block|{
name|CACHE_NORMAL
init|=
literal|0
block|,
name|CACHE_NO_OPEN
init|=
literal|1
block|,
name|CACHE_NO_SEEK
init|=
literal|2
block|,
name|CACHE_NO_SEEK_ERROR
init|=
literal|4
block|}
enum|;
end_enum

begin_comment
comment|/* The maximum number of files which the cache will keep open at    one time.  */
end_comment

begin_define
define|#
directive|define
name|BFD_CACHE_MAX_OPEN
value|10
end_define

begin_comment
comment|/* The number of BFD files we have open.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|open_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero, or a pointer to the topmost BFD on the chain.  This is    used by the<<bfd_cache_lookup>> macro in @file{libbfd.h} to    determine when it can avoid a function call.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|bfd_last_cache
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert a BFD into the cache.  */
end_comment

begin_function
specifier|static
name|void
name|insert
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|bfd_last_cache
operator|==
name|NULL
condition|)
block|{
name|abfd
operator|->
name|lru_next
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|lru_prev
operator|=
name|abfd
expr_stmt|;
block|}
else|else
block|{
name|abfd
operator|->
name|lru_next
operator|=
name|bfd_last_cache
expr_stmt|;
name|abfd
operator|->
name|lru_prev
operator|=
name|bfd_last_cache
operator|->
name|lru_prev
expr_stmt|;
name|abfd
operator|->
name|lru_prev
operator|->
name|lru_next
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|lru_next
operator|->
name|lru_prev
operator|=
name|abfd
expr_stmt|;
block|}
name|bfd_last_cache
operator|=
name|abfd
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a BFD from the cache.  */
end_comment

begin_function
specifier|static
name|void
name|snip
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|abfd
operator|->
name|lru_prev
operator|->
name|lru_next
operator|=
name|abfd
operator|->
name|lru_next
expr_stmt|;
name|abfd
operator|->
name|lru_next
operator|->
name|lru_prev
operator|=
name|abfd
operator|->
name|lru_prev
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|bfd_last_cache
condition|)
block|{
name|bfd_last_cache
operator|=
name|abfd
operator|->
name|lru_next
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|bfd_last_cache
condition|)
name|bfd_last_cache
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Close a BFD and remove it from the cache.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfd_cache_delete
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_boolean
name|ret
decl_stmt|;
if|if
condition|(
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|FALSE
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
block|}
name|snip
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|iostream
operator|=
name|NULL
expr_stmt|;
operator|--
name|open_files
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* We need to open a new file, and the cache is full.  Find the least    recently used cacheable BFD and close it.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|close_one
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|bfd
modifier|*
name|kill
decl_stmt|;
if|if
condition|(
name|bfd_last_cache
operator|==
name|NULL
condition|)
name|kill
operator|=
name|NULL
expr_stmt|;
else|else
block|{
for|for
control|(
name|kill
operator|=
name|bfd_last_cache
operator|->
name|lru_prev
init|;
operator|!
name|kill
operator|->
name|cacheable
condition|;
name|kill
operator|=
name|kill
operator|->
name|lru_prev
control|)
block|{
if|if
condition|(
name|kill
operator|==
name|bfd_last_cache
condition|)
block|{
name|kill
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|kill
operator|==
name|NULL
condition|)
block|{
comment|/* There are no open cacheable BFD's.  */
return|return
name|TRUE
return|;
block|}
name|kill
operator|->
name|where
operator|=
name|real_ftell
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|kill
operator|->
name|iostream
argument_list|)
expr_stmt|;
comment|/* Save the file st_mtime.  This is a hack so that gdb can detect when      an executable has been deleted and recreated.  The only thing that      makes this reasonable is that st_mtime doesn't change when a file      is unlinked, so saving st_mtime makes BFD's file cache operation      a little more transparent for this particular usage pattern.  If we      hadn't closed the file then we would not have lost the original      contents, st_mtime etc.  Of course, if something is writing to an      existing file, then this is the wrong thing to do.      FIXME: gdb should save these times itself on first opening a file,      and this hack be removed.  */
if|if
condition|(
name|kill
operator|->
name|direction
operator|==
name|no_direction
operator|||
name|kill
operator|->
name|direction
operator|==
name|read_direction
condition|)
block|{
name|bfd_get_mtime
argument_list|(
name|kill
argument_list|)
expr_stmt|;
name|kill
operator|->
name|mtime_set
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|bfd_cache_delete
argument_list|(
name|kill
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the required BFD is the same as the last one    looked up. If so, then it can use the stream in the BFD with    impunity, since it can't have changed since the last lookup;    otherwise, it has to perform the complicated lookup function.  */
end_comment

begin_define
define|#
directive|define
name|bfd_cache_lookup
parameter_list|(
name|x
parameter_list|,
name|flag
parameter_list|)
define|\
value|((x) == bfd_last_cache			\    ? (FILE *) (bfd_last_cache->iostream)	\    : bfd_cache_lookup_worker (x, flag))
end_define

begin_comment
comment|/* Called when the macro<<bfd_cache_lookup>> fails to find a    quick answer.  Find a file descriptor for @var{abfd}.  If    necessary, it open it.  If there are already more than<<BFD_CACHE_MAX_OPEN>> files open, it tries to close one first, to    avoid running out of file descriptors.  It will return NULL    if it is unable to (re)open the @var{abfd}.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|bfd_cache_lookup_worker
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|enum
name|cache_flag
name|flag
parameter_list|)
block|{
name|bfd
modifier|*
name|orig_bfd
init|=
name|abfd
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|abfd
operator|=
name|abfd
operator|->
name|my_archive
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|!=
name|NULL
condition|)
block|{
comment|/* Move the file to the start of the cache.  */
if|if
condition|(
name|abfd
operator|!=
name|bfd_last_cache
condition|)
block|{
name|snip
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
return|;
block|}
if|if
condition|(
name|flag
operator|&
name|CACHE_NO_OPEN
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_open_file
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|CACHE_NO_SEEK
operator|)
operator|&&
name|real_fseek
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
argument_list|,
name|abfd
operator|->
name|where
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|flag
operator|&
name|CACHE_NO_SEEK_ERROR
operator|)
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
return|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"reopening %B: %s\n"
argument_list|)
argument_list|,
name|orig_bfd
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|file_ptr
name|cache_btell
parameter_list|(
name|struct
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|,
name|CACHE_NO_OPEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|abfd
operator|->
name|where
return|;
return|return
name|real_ftell
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cache_bseek
parameter_list|(
name|struct
name|bfd
modifier|*
name|abfd
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|,
name|whence
operator|!=
name|SEEK_CUR
condition|?
name|CACHE_NO_SEEK
else|:
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|real_fseek
argument_list|(
name|f
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Note that archive entries don't have streams; they share their parent's.    This allows someone to play with the iostream behind BFD's back.     Also, note that the origin pointer points to the beginning of a file's    contents (0 for non-archive elements).  For archive entries this is the    first octet in the file, NOT the beginning of the archive header.  */
end_comment

begin_function
specifier|static
name|file_ptr
name|cache_bread
parameter_list|(
name|struct
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|file_ptr
name|nbytes
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|file_ptr
name|nread
decl_stmt|;
comment|/* FIXME - this looks like an optimization, but it's really to cover      up for a feature of some OSs (not solaris - sigh) that      ld/pe-dll.c takes advantage of (apparently) when it creates BFDs      internally and tries to link against them.  BFD seems to be smart      enough to realize there are no symbol records in the "file" that      doesn't exist but attempts to read them anyway.  On Solaris,      attempting to read zero bytes from a NULL file results in a core      dump, but on other platforms it just returns zero bytes read.      This makes it to something reasonable. - DJ */
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|f
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|__VAX
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS
argument_list|)
comment|/* Apparently fread on Vax VMS does not keep the record length      information.  */
name|nread
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* Set bfd_error if we did not read as much data as we expected.  If      the read failed due to an error set the bfd_error_system_call,      else set bfd_error_file_truncated.  */
if|if
condition|(
name|nread
operator|==
operator|(
name|file_ptr
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
name|nread
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|nbytes
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Set bfd_error if we did not read as much data as we expected.  If      the read failed due to an error set the bfd_error_system_call,      else set bfd_error_file_truncated.  */
if|if
condition|(
name|nread
operator|<
name|nbytes
operator|&&
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
return|return
name|nread
return|;
block|}
end_function

begin_function
specifier|static
name|file_ptr
name|cache_bwrite
parameter_list|(
name|struct
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|void
modifier|*
name|where
parameter_list|,
name|file_ptr
name|nbytes
parameter_list|)
block|{
name|file_ptr
name|nwrite
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|nwrite
operator|=
name|fwrite
argument_list|(
name|where
argument_list|,
literal|1
argument_list|,
name|nbytes
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwrite
operator|<
name|nbytes
operator|&&
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|nwrite
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cache_bclose
parameter_list|(
name|struct
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
return|return
name|bfd_cache_close
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cache_bflush
parameter_list|(
name|struct
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|sts
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|,
name|CACHE_NO_OPEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|sts
operator|=
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|<
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|sts
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cache_bstat
parameter_list|(
name|struct
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|sts
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|,
name|CACHE_NO_SEEK_ERROR
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|sts
operator|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|<
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|sts
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfd_iovec
name|cache_iovec
init|=
block|{
operator|&
name|cache_bread
block|,
operator|&
name|cache_bwrite
block|,
operator|&
name|cache_btell
block|,
operator|&
name|cache_bseek
block|,
operator|&
name|cache_bclose
block|,
operator|&
name|cache_bflush
block|,
operator|&
name|cache_bstat
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_cache_init  SYNOPSIS 	bfd_boolean bfd_cache_init (bfd *abfd);  DESCRIPTION 	Add a newly opened BFD to the cache. */
end_comment

begin_function
name|bfd_boolean
name|bfd_cache_init
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|iostream
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|open_files
operator|>=
name|BFD_CACHE_MAX_OPEN
condition|)
block|{
if|if
condition|(
operator|!
name|close_one
argument_list|()
condition|)
return|return
name|FALSE
return|;
block|}
name|abfd
operator|->
name|iovec
operator|=
operator|&
name|cache_iovec
expr_stmt|;
name|insert
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|++
name|open_files
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_cache_close  SYNOPSIS 	bfd_boolean bfd_cache_close (bfd *abfd);  DESCRIPTION 	Remove the BFD @var{abfd} from the cache. If the attached file is open, 	then close it too.  RETURNS<<FALSE>> is returned if closing the file fails,<<TRUE>> is 	returned if all is well. */
end_comment

begin_function
name|bfd_boolean
name|bfd_cache_close
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|iovec
operator|!=
operator|&
name|cache_iovec
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|==
name|NULL
condition|)
comment|/* Previously closed.  */
return|return
name|TRUE
return|;
return|return
name|bfd_cache_delete
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_cache_close_all  SYNOPSIS 	bfd_boolean bfd_cache_close_all (void);  DESCRIPTION 	Remove all BFDs from the cache. If the attached file is open, 	then close it too.  RETURNS<<FALSE>> is returned if closing one of the file fails,<<TRUE>> is 	returned if all is well. */
end_comment

begin_function
name|bfd_boolean
name|bfd_cache_close_all
parameter_list|()
block|{
name|bfd_boolean
name|ret
init|=
name|TRUE
decl_stmt|;
while|while
condition|(
name|bfd_last_cache
operator|!=
name|NULL
condition|)
name|ret
operator|&=
name|bfd_cache_close
argument_list|(
name|bfd_last_cache
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_open_file  SYNOPSIS 	FILE* bfd_open_file (bfd *abfd);  DESCRIPTION 	Call the OS to open a file for @var{abfd}.  Return the<<FILE *>> 	(possibly<<NULL>>) that results from this operation.  Set up the 	BFD so that future accesses know the file is open. If the<<FILE *>> 	returned is<<NULL>>, then it won't have been put in the 	cache, so it won't have to be removed from it. */
end_comment

begin_function
name|FILE
modifier|*
name|bfd_open_file
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|abfd
operator|->
name|cacheable
operator|=
name|TRUE
expr_stmt|;
comment|/* Allow it to be closed later.  */
if|if
condition|(
name|open_files
operator|>=
name|BFD_CACHE_MAX_OPEN
condition|)
block|{
if|if
condition|(
operator|!
name|close_one
argument_list|()
condition|)
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|abfd
operator|->
name|direction
condition|)
block|{
case|case
name|read_direction
case|:
case|case
name|no_direction
case|:
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|real_fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
break|break;
case|case
name|both_direction
case|:
case|case
name|write_direction
case|:
if|if
condition|(
name|abfd
operator|->
name|opened_once
condition|)
block|{
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|real_fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_RUB
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|==
name|NULL
condition|)
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|real_fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_WUB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Create the file.  	     Some operating systems won't let us overwrite a running 	     binary.  For them, we want to unlink the file first.  	     However, gcc 2.95 will create temporary files using 	     O_EXCL and tight permissions to prevent other users from 	     substituting other .o files during the compilation.  gcc 	     will then tell the assembler to use the newly created 	     file as an output file.  If we unlink the file here, we 	     open a brief window when another user could still 	     substitute a file.  	     So we unlink the output file if and only if it has 	     non-zero size.  */
ifndef|#
directive|ifndef
name|__MSDOS__
comment|/* Don't do this for MSDOS: it doesn't care about overwriting 	     a running binary, but if this file is already open by 	     another BFD, we will be in deep trouble if we delete an 	     open file.  In fact, objdump does just that if invoked with 	     the --info option.  */
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|s
operator|.
name|st_size
operator|!=
literal|0
condition|)
name|unlink_if_ordinary
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|real_fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_WUB
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|opened_once
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|==
name|NULL
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_cache_init
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
return|;
block|}
end_function

end_unit

