begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic symbol-table support for the BFD library.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002    Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* SECTION 	Symbols  	BFD tries to maintain as much symbol information as it can when 	it moves information from file to file. BFD passes information 	to applications though the<<asymbol>> structure. When the 	application requests the symbol table, BFD reads the table in 	the native form and translates parts of it into the internal 	format. To maintain more than the information passed to 	applications, some targets keep some information ``behind the 	scenes'' in a structure only the particular back end knows 	about. For example, the coff back end keeps the original 	symbol table structure as well as the canonical structure when 	a BFD is read in. On output, the coff back end can reconstruct 	the output symbol table so that no information is lost, even 	information unique to coff which BFD doesn't know or 	understand. If a coff symbol table were read, but were written 	through an a.out back end, all the coff specific information 	would be lost. The symbol table of a BFD 	is not necessarily read in until a canonicalize request is 	made. Then the BFD back end fills in a table provided by the 	application with pointers to the canonical information.  To 	output symbols, the application provides BFD with a table of 	pointers to pointers to<<asymbol>>s. This allows applications 	like the linker to output a symbol as it was read, since the ``behind 	the scenes'' information will be still available. @menu @* Reading Symbols:: @* Writing Symbols:: @* Mini Symbols:: @* typedef asymbol:: @* symbol handling functions:: @end menu  INODE Reading Symbols, Writing Symbols, Symbols, Symbols SUBSECTION 	Reading symbols  	There are two stages to reading a symbol table from a BFD: 	allocating storage, and the actual reading process. This is an 	excerpt from an application which reads the symbol table:  |	  long storage_needed; |	  asymbol **symbol_table; |	  long number_of_symbols; |	  long i; | |	  storage_needed = bfd_get_symtab_upper_bound (abfd); | |         if (storage_needed< 0) |           FAIL | |	  if (storage_needed == 0) { |	     return ; |	  } |	  symbol_table = (asymbol **) xmalloc (storage_needed); |	    ... |	  number_of_symbols = |	     bfd_canonicalize_symtab (abfd, symbol_table); | |         if (number_of_symbols< 0) |           FAIL | |	  for (i = 0; i< number_of_symbols; i++) { |	     process_symbol (symbol_table[i]); |	  }  	All storage for the symbols themselves is in an objalloc 	connected to the BFD; it is freed when the BFD is closed.  INODE Writing Symbols, Mini Symbols, Reading Symbols, Symbols SUBSECTION 	Writing symbols  	Writing of a symbol table is automatic when a BFD open for 	writing is closed. The application attaches a vector of 	pointers to pointers to symbols to the BFD being written, and 	fills in the symbol count. The close and cleanup code reads 	through the table provided and performs all the necessary 	operations. The BFD output code must always be provided with an 	``owned'' symbol: one which has come from another BFD, or one 	which has been created using<<bfd_make_empty_symbol>>.  Here is an 	example showing the creation of a symbol table with only one element:  |	#include "bfd.h" |	main() |	{ |	  bfd *abfd; |	  asymbol *ptrs[2]; |	  asymbol *new; | |	  abfd = bfd_openw("foo","a.out-sunos-big"); |	  bfd_set_format(abfd, bfd_object); |	  new = bfd_make_empty_symbol(abfd); |	  new->name = "dummy_symbol"; |	  new->section = bfd_make_section_old_way(abfd, ".text"); |	  new->flags = BSF_GLOBAL; |	  new->value = 0x12345; | |	  ptrs[0] = new; |	  ptrs[1] = (asymbol *)0; | |	  bfd_set_symtab(abfd, ptrs, 1); |	  bfd_close(abfd); |	} | |	./makesym |	nm foo |	00012345 A dummy_symbol  	Many formats cannot represent arbitary symbol information; for  	instance, the<<a.out>> object format does not allow an 	arbitary number of sections. A symbol pointing to a section 	which is not one  of<<.text>>,<<.data>> or<<.bss>> cannot 	be described.  INODE Mini Symbols, typedef asymbol, Writing Symbols, Symbols SUBSECTION 	Mini Symbols  	Mini symbols provide read-only access to the symbol table. 	They use less memory space, but require more time to access. 	They can be useful for tools like nm or objdump, which may 	have to handle symbol tables of extremely large executables.  	The<<bfd_read_minisymbols>> function will read the symbols 	into memory in an internal form.  It will return a<<void *>> 	pointer to a block of memory, a symbol count, and the size of 	each symbol.  The pointer is allocated using<<malloc>>, and 	should be freed by the caller when it is no longer needed.  	The function<<bfd_minisymbol_to_symbol>> will take a pointer 	to a minisymbol, and a pointer to a structure returned by<<bfd_make_empty_symbol>>, and return a<<asymbol>> structure. 	The return value may or may not be the same as the value from<<bfd_make_empty_symbol>> which was passed in.  */
end_comment

begin_comment
comment|/* DOCDD INODE typedef asymbol, symbol handling functions, Mini Symbols, Symbols  */
end_comment

begin_comment
comment|/* SUBSECTION 	typedef asymbol  	An<<asymbol>> has the form:  */
end_comment

begin_comment
comment|/* CODE_FRAGMENT  . .typedef struct symbol_cache_entry .{ .  {* A pointer to the BFD which owns the symbol. This information .     is necessary so that a back end can work out what additional .     information (invisible to the application writer) is carried .     with the symbol. . .     This field is *almost* redundant, since you can use section->owner .     instead, except that some symbols point to the global sections .     bfd_{abs,com,und}_section.  This could be fixed by making .     these globals be per-bfd (or per-target-flavor).  FIXME.  *} .  struct _bfd *the_bfd; {* Use bfd_asymbol_bfd(sym) to access this field.  *} . .  {* The text of the symbol. The name is left alone, and not copied; the .     application may not alter it.  *} .  const char *name; . .  {* The value of the symbol.  This really should be a union of a .     numeric value with a pointer, since some flags indicate that .     a pointer to another symbol is stored here.  *} .  symvalue value; . .  {* Attributes of a symbol.  *} .#define BSF_NO_FLAGS    0x00 . .  {* The symbol has local scope;<<static>> in<<C>>. The value .     is the offset into the section of the data.  *} .#define BSF_LOCAL	0x01 . .  {* The symbol has global scope; initialized data in<<C>>. The .     value is the offset into the section of the data.  *} .#define BSF_GLOBAL	0x02 . .  {* The symbol has global scope and is exported. The value is .     the offset into the section of the data.  *} .#define BSF_EXPORT	BSF_GLOBAL {* No real difference.  *} . .  {* A normal C symbol would be one of: .<<BSF_LOCAL>>,<<BSF_FORT_COMM>>,<<BSF_UNDEFINED>> or .<<BSF_GLOBAL>>.  *} . .  {* The symbol is a debugging record. The value has an arbitary .     meaning, unless BSF_DEBUGGING_RELOC is also set.  *} .#define BSF_DEBUGGING	0x08 . .  {* The symbol denotes a function entry point.  Used in ELF, .     perhaps others someday.  *} .#define BSF_FUNCTION    0x10 . .  {* Used by the linker.  *} .#define BSF_KEEP        0x20 .#define BSF_KEEP_G      0x40 . .  {* A weak global symbol, overridable without warnings by .     a regular global symbol of the same name.  *} .#define BSF_WEAK        0x80 . .  {* This symbol was created to point to a section, e.g. ELF's .     STT_SECTION symbols.  *} .#define BSF_SECTION_SYM 0x100 . .  {* The symbol used to be a common symbol, but now it is .     allocated.  *} .#define BSF_OLD_COMMON  0x200 . .  {* The default value for common data.  *} .#define BFD_FORT_COMM_DEFAULT_VALUE 0 . .  {* In some files the type of a symbol sometimes alters its .     location in an output file - ie in coff a<<ISFCN>> symbol .     which is also<<C_EXT>> symbol appears where it was .     declared and not at the end of a section.  This bit is set .     by the target BFD part to convey this information.  *} .#define BSF_NOT_AT_END    0x400 . .  {* Signal that the symbol is the label of constructor section.  *} .#define BSF_CONSTRUCTOR   0x800 . .  {* Signal that the symbol is a warning symbol.  The name is a .     warning.  The name of the next symbol is the one to warn about; .     if a reference is made to a symbol with the same name as the next .     symbol, a warning is issued by the linker.  *} .#define BSF_WARNING       0x1000 . .  {* Signal that the symbol is indirect.  This symbol is an indirect .     pointer to the symbol with the same name as the next symbol.  *} .#define BSF_INDIRECT      0x2000 . .  {* BSF_FILE marks symbols that contain a file name.  This is used .     for ELF STT_FILE symbols.  *} .#define BSF_FILE          0x4000 . .  {* Symbol is from dynamic linking information.  *} .#define BSF_DYNAMIC	   0x8000 . .  {* The symbol denotes a data object.  Used in ELF, and perhaps .     others someday.  *} .#define BSF_OBJECT	   0x10000 . .  {* This symbol is a debugging symbol.  The value is the offset .     into the section of the data.  BSF_DEBUGGING should be set .     as well.  *} .#define BSF_DEBUGGING_RELOC 0x20000 . .  flagword flags; . .  {* A pointer to the section to which this symbol is .     relative.  This will always be non NULL, there are special .     sections for undefined and absolute symbols.  *} .  struct sec *section; . .  {* Back end special data.  *} .  union .    { .      PTR p; .      bfd_vma i; .    } .  udata; .} .asymbol; . */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|coff_section_type
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmpindexentry
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DOCDD INODE symbol handling functions,  , typedef asymbol, Symbols SUBSECTION 	Symbol handling functions */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_get_symtab_upper_bound  DESCRIPTION 	Return the number of bytes required to store a vector of pointers 	to<<asymbols>> for all the symbols in the BFD @var{abfd}, 	including a terminal NULL pointer. If there are no symbols in 	the BFD, then return 0.  If an error occurs, return -1.  .#define bfd_get_symtab_upper_bound(abfd) \ .     BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd)) . */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_is_local_label  SYNOPSIS         boolean bfd_is_local_label(bfd *abfd, asymbol *sym);  DESCRIPTION 	Return true if the given symbol @var{sym} in the BFD @var{abfd} is 	a compiler generated local label, else return false. */
end_comment

begin_function
name|boolean
name|bfd_is_local_label
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
comment|/* The BSF_SECTION_SYM check is needed for IA-64, where every label that      starts with '.' is local.  This would accidentally catch section names      if we didn't reject them here.  */
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator||
name|BSF_SECTION_SYM
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|sym
operator|->
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|bfd_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_is_local_label_name  SYNOPSIS         boolean bfd_is_local_label_name(bfd *abfd, const char *name);  DESCRIPTION 	Return true if a symbol with the name @var{name} in the BFD 	@var{abfd} is a compiler generated local label, else return 	false.  This just checks whether the name has the form of a 	local label.  .#define bfd_is_local_label_name(abfd, name) \ .     BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name)) . */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_canonicalize_symtab  DESCRIPTION 	Read the symbols from the BFD @var{abfd}, and fills in 	the vector @var{location} with pointers to the symbols and 	a trailing NULL. 	Return the actual number of symbol pointers, not 	including the NULL.  .#define bfd_canonicalize_symtab(abfd, location) \ .     BFD_SEND (abfd, _bfd_canonicalize_symtab,\ .                  (abfd, location)) . */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_set_symtab  SYNOPSIS 	boolean bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int count);  DESCRIPTION 	Arrange that when the output BFD @var{abfd} is closed, 	the table @var{location} of @var{count} pointers to symbols 	will be written. */
end_comment

begin_function
name|boolean
name|bfd_set_symtab
parameter_list|(
name|abfd
parameter_list|,
name|location
parameter_list|,
name|symcount
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|location
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
operator|)
operator|||
operator|(
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|location
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|symcount
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_print_symbol_vandf  SYNOPSIS 	void bfd_print_symbol_vandf(bfd *abfd, PTR file, asymbol *symbol);  DESCRIPTION 	Print the value and flags of the @var{symbol} supplied to the 	stream @var{file}. */
end_comment

begin_function
name|void
name|bfd_print_symbol_vandf
parameter_list|(
name|abfd
parameter_list|,
name|arg
parameter_list|,
name|symbol
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|arg
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|arg
decl_stmt|;
name|flagword
name|type
init|=
name|symbol
operator|->
name|flags
decl_stmt|;
if|if
condition|(
name|symbol
operator|->
name|section
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|file
argument_list|,
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|file
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* This presumes that a symbol can not be both BSF_DEBUGGING and      BSF_DYNAMIC, nor more than one of BSF_FUNCTION, BSF_FILE, and      BSF_OBJECT.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %c%c%c%c%c%c%c"
argument_list|,
operator|(
operator|(
name|type
operator|&
name|BSF_LOCAL
operator|)
condition|?
operator|(
name|type
operator|&
name|BSF_GLOBAL
operator|)
condition|?
literal|'!'
else|:
literal|'l'
else|:
operator|(
name|type
operator|&
name|BSF_GLOBAL
operator|)
condition|?
literal|'g'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|type
operator|&
name|BSF_WEAK
operator|)
condition|?
literal|'w'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_CONSTRUCTOR
operator|)
condition|?
literal|'C'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_WARNING
operator|)
condition|?
literal|'W'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_INDIRECT
operator|)
condition|?
literal|'I'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_DEBUGGING
operator|)
condition|?
literal|'d'
else|:
operator|(
name|type
operator|&
name|BSF_DYNAMIC
operator|)
condition|?
literal|'D'
else|:
literal|' '
argument_list|,
operator|(
operator|(
name|type
operator|&
name|BSF_FUNCTION
operator|)
condition|?
literal|'F'
else|:
operator|(
operator|(
name|type
operator|&
name|BSF_FILE
operator|)
condition|?
literal|'f'
else|:
operator|(
operator|(
name|type
operator|&
name|BSF_OBJECT
operator|)
condition|?
literal|'O'
else|:
literal|' '
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_make_empty_symbol  DESCRIPTION 	Create a new<<asymbol>> structure for the BFD @var{abfd} 	and return a pointer to it.  	This routine is necessary because each back end has private 	information surrounding the<<asymbol>>. Building your own<<asymbol>> and pointing to it will not create the private 	information, and will cause problems later on.  .#define bfd_make_empty_symbol(abfd) \ .     BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd)) . */
end_comment

begin_comment
comment|/* FUNCTION 	_bfd_generic_make_empty_symbol  SYNOPSIS 	asymbol *_bfd_generic_make_empty_symbol (bfd *);  DESCRIPTION 	Create a new<<asymbol>> structure for the BFD @var{abfd} 	and return a pointer to it.  Used by core file routines, 	binary back-end and anywhere else where no private info 	is needed. */
end_comment

begin_function
name|asymbol
modifier|*
name|_bfd_generic_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|new
init|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
name|new
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_make_debug_symbol  DESCRIPTION 	Create a new<<asymbol>> structure for the BFD @var{abfd}, 	to be used as a debugging symbol.  Further details of its use have 	yet to be worked out.  .#define bfd_make_debug_symbol(abfd,ptr,size) \ .        BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size)) . */
end_comment

begin_struct
struct|struct
name|section_to_type
block|{
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
name|char
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Map section names to POSIX/BSD single-character symbol types.    This table is probably incomplete.  It is sorted for convenience of    adding entries.  Since it is so short, a linear search is used.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|section_to_type
name|stt
index|[]
init|=
block|{
block|{
literal|"*DEBUG*"
block|,
literal|'N'
block|}
block|,
block|{
literal|".bss"
block|,
literal|'b'
block|}
block|,
block|{
literal|"zerovars"
block|,
literal|'b'
block|}
block|,
comment|/* MRI .bss */
block|{
literal|".data"
block|,
literal|'d'
block|}
block|,
block|{
literal|"vars"
block|,
literal|'d'
block|}
block|,
comment|/* MRI .data */
block|{
literal|".rdata"
block|,
literal|'r'
block|}
block|,
comment|/* Read only data.  */
block|{
literal|".rodata"
block|,
literal|'r'
block|}
block|,
comment|/* Read only data.  */
block|{
literal|".sbss"
block|,
literal|'s'
block|}
block|,
comment|/* Small BSS (uninitialized data).  */
block|{
literal|".scommon"
block|,
literal|'c'
block|}
block|,
comment|/* Small common.  */
block|{
literal|".sdata"
block|,
literal|'g'
block|}
block|,
comment|/* Small initialized data.  */
block|{
literal|".text"
block|,
literal|'t'
block|}
block|,
block|{
literal|"code"
block|,
literal|'t'
block|}
block|,
comment|/* MRI .text */
block|{
literal|".drectve"
block|,
literal|'i'
block|}
block|,
comment|/* MSVC's .drective section */
block|{
literal|".idata"
block|,
literal|'i'
block|}
block|,
comment|/* MSVC's .idata (import) section */
block|{
literal|".edata"
block|,
literal|'e'
block|}
block|,
comment|/* MSVC's .edata (export) section */
block|{
literal|".pdata"
block|,
literal|'p'
block|}
block|,
comment|/* MSVC's .pdata (stack unwind) section */
block|{
literal|".debug"
block|,
literal|'N'
block|}
block|,
comment|/* MSVC's .debug (non-standard debug syms) */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the single-character symbol type corresponding to    section S, or '?' for an unknown COFF section.     Check for any leading string which matches, so .text5 returns    't' as well as .text */
end_comment

begin_function
specifier|static
name|char
name|coff_section_type
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|const
name|struct
name|section_to_type
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|stt
index|[
literal|0
index|]
init|;
name|t
operator|->
name|section
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|section
argument_list|,
name|strlen
argument_list|(
name|t
operator|->
name|section
argument_list|)
argument_list|)
condition|)
return|return
name|t
operator|->
name|type
return|;
return|return
literal|'?'
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_decode_symclass  DESCRIPTION 	Return a character corresponding to the symbol 	class of @var{symbol}, or '?' for an unknown class.  SYNOPSIS 	int bfd_decode_symclass(asymbol *symbol); */
end_comment

begin_function
name|int
name|bfd_decode_symclass
parameter_list|(
name|symbol
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'C'
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
condition|)
block|{
comment|/* If weak, determine if it's specifically an object 	     or non-object weak.  */
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_OBJECT
condition|)
return|return
literal|'v'
return|;
else|else
return|return
literal|'w'
return|;
block|}
else|else
return|return
literal|'U'
return|;
block|}
if|if
condition|(
name|bfd_is_ind_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'I'
return|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
condition|)
block|{
comment|/* If weak, determine if it's specifically an object 	 or non-object weak.  */
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_OBJECT
condition|)
return|return
literal|'V'
return|;
else|else
return|return
literal|'W'
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|symbol
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator|)
operator|)
condition|)
return|return
literal|'?'
return|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|c
operator|=
literal|'a'
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
condition|)
name|c
operator|=
name|coff_section_type
argument_list|(
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
return|return
literal|'?'
return|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|c
operator|=
name|TOUPPER
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
comment|/* We don't have to handle these cases just yet, but we will soon:      N_SETV: 'v';      N_SETA: 'l';      N_SETT: 'x';      N_SETD: 'z';      N_SETB: 's';      N_INDR: 'i';      */
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_is_undefined_symclass  DESCRIPTION 	Returns non-zero if the class symbol returned by 	bfd_decode_symclass represents an undefined symbol. 	Returns zero otherwise.  SYNOPSIS 	boolean bfd_is_undefined_symclass (int symclass); */
end_comment

begin_function
name|boolean
name|bfd_is_undefined_symclass
parameter_list|(
name|symclass
parameter_list|)
name|int
name|symclass
decl_stmt|;
block|{
return|return
name|symclass
operator|==
literal|'U'
operator|||
name|symclass
operator|==
literal|'w'
operator|||
name|symclass
operator|==
literal|'v'
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_symbol_info  DESCRIPTION 	Fill in the basic info about symbol that nm needs. 	Additional info may be added by the back-ends after 	calling this function.  SYNOPSIS 	void bfd_symbol_info(asymbol *symbol, symbol_info *ret); */
end_comment

begin_function
name|void
name|bfd_symbol_info
parameter_list|(
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|ret
operator|->
name|type
operator|=
name|bfd_decode_symclass
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_undefined_symclass
argument_list|(
name|ret
operator|->
name|type
argument_list|)
condition|)
name|ret
operator|->
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|->
name|value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|symbol
operator|->
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_copy_private_symbol_data  SYNOPSIS 	boolean bfd_copy_private_symbol_data(bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);  DESCRIPTION 	Copy private symbol information from @var{isym} in the BFD 	@var{ibfd} to the symbol @var{osym} in the BFD @var{obfd}. 	Return<<true>> on success,<<false>> on error.  Possible error 	returns are:  	o<<bfd_error_no_memory>> - 	Not enough memory exists to create private data for @var{osec}.  .#define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \ .     BFD_SEND (obfd, _bfd_copy_private_symbol_data, \ .		(ibfd, isymbol, obfd, osymbol)) . */
end_comment

begin_comment
comment|/* The generic version of the function which returns mini symbols.    This is used when the backend does not provide a more efficient    version.  It just uses BFD asymbol structures as mini symbols.  */
end_comment

begin_function
name|long
name|_bfd_generic_read_minisymbols
parameter_list|(
name|abfd
parameter_list|,
name|dynamic
parameter_list|,
name|minisymsp
parameter_list|,
name|sizep
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|dynamic
decl_stmt|;
name|PTR
modifier|*
name|minisymsp
decl_stmt|;
name|unsigned
name|int
modifier|*
name|sizep
decl_stmt|;
block|{
name|long
name|storage
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|NULL
decl_stmt|;
name|long
name|symcount
decl_stmt|;
if|if
condition|(
name|dynamic
condition|)
name|storage
operator|=
name|bfd_get_dynamic_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
name|storage
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|storage
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|dynamic
condition|)
name|symcount
operator|=
name|bfd_canonicalize_dynamic_symtab
argument_list|(
name|abfd
argument_list|,
name|syms
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|minisymsp
operator|=
operator|(
name|PTR
operator|)
name|syms
expr_stmt|;
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
expr_stmt|;
return|return
name|symcount
return|;
name|error_return
label|:
if|if
condition|(
name|syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The generic version of the function which converts a minisymbol to    an asymbol.  We don't worry about the sym argument we are passed;    we just return the asymbol the minisymbol points to.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|asymbol
modifier|*
name|_bfd_generic_minisymbol_to_symbol
parameter_list|(
name|abfd
parameter_list|,
name|dynamic
parameter_list|,
name|minisym
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|boolean
name|dynamic
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|PTR
name|minisym
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|*
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|minisym
return|;
block|}
end_function

begin_comment
comment|/* Look through stabs debugging information in .stab and .stabstr    sections to find the source file and line closest to a desired    location.  This is used by COFF and ELF targets.  It sets *pfound    to true if it finds some information.  The *pinfo field is used to    pass cached information in and out of this routine; this first time    the routine is called for a BFD, *pinfo should be NULL.  The value    placed in *pinfo should be saved with the BFD, and passed back each    time this function is called.  */
end_comment

begin_comment
comment|/* We use a cache by default.  */
end_comment

begin_define
define|#
directive|define
name|ENABLE_CACHING
end_define

begin_comment
comment|/* We keep an array of indexentry structures to record where in the    stabs section we should look to find line number information for a    particular address.  */
end_comment

begin_struct
struct|struct
name|indexentry
block|{
name|bfd_vma
name|val
decl_stmt|;
name|bfd_byte
modifier|*
name|stab
decl_stmt|;
name|bfd_byte
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|directory_name
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|char
modifier|*
name|function_name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compare two indexentry structures.  This is called via qsort.  */
end_comment

begin_function
specifier|static
name|int
name|cmpindexentry
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|PTR
name|a
decl_stmt|;
specifier|const
name|PTR
name|b
decl_stmt|;
block|{
specifier|const
name|struct
name|indexentry
modifier|*
name|contestantA
init|=
operator|(
specifier|const
expr|struct
name|indexentry
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|struct
name|indexentry
modifier|*
name|contestantB
init|=
operator|(
specifier|const
expr|struct
name|indexentry
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|contestantA
operator|->
name|val
operator|<
name|contestantB
operator|->
name|val
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|contestantA
operator|->
name|val
operator|>
name|contestantB
operator|->
name|val
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A pointer to this structure is stored in *pinfo.  */
end_comment

begin_struct
struct|struct
name|stab_find_info
block|{
comment|/* The .stab section.  */
name|asection
modifier|*
name|stabsec
decl_stmt|;
comment|/* The .stabstr section.  */
name|asection
modifier|*
name|strsec
decl_stmt|;
comment|/* The contents of the .stab section.  */
name|bfd_byte
modifier|*
name|stabs
decl_stmt|;
comment|/* The contents of the .stabstr section.  */
name|bfd_byte
modifier|*
name|strs
decl_stmt|;
comment|/* A table that indexes stabs by memory address.  */
name|struct
name|indexentry
modifier|*
name|indextable
decl_stmt|;
comment|/* The number of entries in indextable.  */
name|int
name|indextablesize
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CACHING
comment|/* Cached values to restart quickly.  */
name|struct
name|indexentry
modifier|*
name|cached_indexentry
decl_stmt|;
name|bfd_vma
name|cached_offset
decl_stmt|;
name|bfd_byte
modifier|*
name|cached_stab
decl_stmt|;
name|char
modifier|*
name|cached_file_name
decl_stmt|;
endif|#
directive|endif
comment|/* Saved ptr to malloc'ed filename.  */
name|char
modifier|*
name|filename
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|boolean
name|_bfd_stab_section_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|symbols
parameter_list|,
name|section
parameter_list|,
name|offset
parameter_list|,
name|pfound
parameter_list|,
name|pfilename
parameter_list|,
name|pfnname
parameter_list|,
name|pline
parameter_list|,
name|pinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|boolean
modifier|*
name|pfound
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pfilename
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pfnname
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pline
decl_stmt|;
name|PTR
modifier|*
name|pinfo
decl_stmt|;
block|{
name|struct
name|stab_find_info
modifier|*
name|info
decl_stmt|;
name|bfd_size_type
name|stabsize
decl_stmt|,
name|strsize
decl_stmt|;
name|bfd_byte
modifier|*
name|stab
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|bfd_byte
modifier|*
name|last_stab
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|stroff
decl_stmt|;
name|struct
name|indexentry
modifier|*
name|indexentry
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|char
modifier|*
name|directory_name
decl_stmt|;
name|int
name|saw_fun
decl_stmt|;
operator|*
name|pfound
operator|=
name|false
expr_stmt|;
operator|*
name|pfilename
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|*
name|pfnname
operator|=
name|NULL
expr_stmt|;
operator|*
name|pline
operator|=
literal|0
expr_stmt|;
comment|/* Stabs entries use a 12 byte format:        4 byte string table index        1 byte stab type        1 byte stab other field        2 byte stab desc field        4 byte stab value      FIXME: This will have to change for a 64 bit object format.       The stabs symbols are divided into compilation units.  For the      first entry in each unit, the type of 0, the value is the length      of the string table for this unit, and the desc field is the      number of stabs symbols for this unit.  */
define|#
directive|define
name|STRDXOFF
value|(0)
define|#
directive|define
name|TYPEOFF
value|(4)
define|#
directive|define
name|OTHEROFF
value|(5)
define|#
directive|define
name|DESCOFF
value|(6)
define|#
directive|define
name|VALOFF
value|(8)
define|#
directive|define
name|STABSIZE
value|(12)
name|info
operator|=
operator|(
expr|struct
name|stab_find_info
operator|*
operator|)
operator|*
name|pinfo
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|stabsec
operator|==
name|NULL
operator|||
name|info
operator|->
name|strsec
operator|==
name|NULL
condition|)
block|{
comment|/* No stabs debugging information.  */
return|return
name|true
return|;
block|}
name|stabsize
operator|=
name|info
operator|->
name|stabsec
operator|->
name|_raw_size
expr_stmt|;
name|strsize
operator|=
name|info
operator|->
name|strsec
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
block|{
name|long
name|reloc_size
decl_stmt|,
name|reloc_count
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|function_name
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
expr|*
name|info
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|stab_find_info
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* FIXME: When using the linker --split-by-file or 	 --split-by-reloc options, it is possible for the .stab and 	 .stabstr sections to be split.  We should handle that.  */
name|info
operator|->
name|stabsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stab"
argument_list|)
expr_stmt|;
name|info
operator|->
name|strsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|stabsec
operator|==
name|NULL
operator|||
name|info
operator|->
name|strsec
operator|==
name|NULL
condition|)
block|{
comment|/* No stabs debugging information.  Set *pinfo so that we              can return quickly in the info != NULL case above.  */
operator|*
name|pinfo
operator|=
operator|(
name|PTR
operator|)
name|info
expr_stmt|;
return|return
name|true
return|;
block|}
name|stabsize
operator|=
name|info
operator|->
name|stabsec
operator|->
name|_raw_size
expr_stmt|;
name|strsize
operator|=
name|info
operator|->
name|strsec
operator|->
name|_raw_size
expr_stmt|;
name|info
operator|->
name|stabs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|stabsize
argument_list|)
expr_stmt|;
name|info
operator|->
name|strs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|stabs
operator|==
name|NULL
operator|||
name|info
operator|->
name|strs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|stabsec
argument_list|,
name|info
operator|->
name|stabs
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|stabsize
argument_list|)
operator|||
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|strsec
argument_list|,
name|info
operator|->
name|strs
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|strsize
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this is a relocateable object file, we have to relocate 	 the entries in .stab.  This should always be simple 32 bit 	 relocations against symbols defined in this object file, so 	 this should be no big deal.  */
name|reloc_size
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|stabsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|reloc_vector
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|stabsec
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|reloc_vector
init|;
operator|*
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|++
control|)
block|{
name|arelent
modifier|*
name|r
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|r
operator|=
operator|*
name|pr
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|howto
operator|->
name|rightshift
operator|!=
literal|0
operator|||
name|r
operator|->
name|howto
operator|->
name|size
operator|!=
literal|2
operator|||
name|r
operator|->
name|howto
operator|->
name|bitsize
operator|!=
literal|32
operator|||
name|r
operator|->
name|howto
operator|->
name|pc_relative
operator|||
name|r
operator|->
name|howto
operator|->
name|bitpos
operator|!=
literal|0
operator|||
name|r
operator|->
name|howto
operator|->
name|dst_mask
operator|!=
literal|0xffffffff
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Unsupported .stab relocation"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|stabs
operator|+
name|r
operator|->
name|address
argument_list|)
expr_stmt|;
name|val
operator|&=
name|r
operator|->
name|howto
operator|->
name|src_mask
expr_stmt|;
name|sym
operator|=
operator|*
name|r
operator|->
name|sym_ptr_ptr
expr_stmt|;
name|val
operator|+=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
operator|+
name|r
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|val
argument_list|,
name|info
operator|->
name|stabs
operator|+
name|r
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
comment|/* First time through this function, build a table matching 	 function VM addresses to stabs, then sort based on starting 	 VM address.  Do this in two passes: once to count how many 	 table entries we'll need, and a second to actually build the 	 table.  */
name|info
operator|->
name|indextablesize
operator|=
literal|0
expr_stmt|;
name|saw_fun
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|stab
operator|=
name|info
operator|->
name|stabs
init|;
name|stab
operator|<
name|info
operator|->
name|stabs
operator|+
name|stabsize
condition|;
name|stab
operator|+=
name|STABSIZE
control|)
block|{
if|if
condition|(
name|stab
index|[
name|TYPEOFF
index|]
operator|==
name|N_SO
condition|)
block|{
comment|/* N_SO with null name indicates EOF */
if|if
condition|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|STRDXOFF
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* if we did not see a function def, leave space for one.  */
if|if
condition|(
name|saw_fun
operator|==
literal|0
condition|)
operator|++
name|info
operator|->
name|indextablesize
expr_stmt|;
name|saw_fun
operator|=
literal|0
expr_stmt|;
comment|/* two N_SO's in a row is a filename and directory. Skip */
if|if
condition|(
name|stab
operator|+
name|STABSIZE
operator|<
name|info
operator|->
name|stabs
operator|+
name|stabsize
operator|&&
operator|*
operator|(
name|stab
operator|+
name|STABSIZE
operator|+
name|TYPEOFF
operator|)
operator|==
name|N_SO
condition|)
block|{
name|stab
operator|+=
name|STABSIZE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stab
index|[
name|TYPEOFF
index|]
operator|==
name|N_FUN
condition|)
block|{
name|saw_fun
operator|=
literal|1
expr_stmt|;
operator|++
name|info
operator|->
name|indextablesize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|saw_fun
operator|==
literal|0
condition|)
operator|++
name|info
operator|->
name|indextablesize
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|indextablesize
operator|==
literal|0
condition|)
return|return
name|true
return|;
operator|++
name|info
operator|->
name|indextablesize
expr_stmt|;
name|amt
operator|=
name|info
operator|->
name|indextablesize
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|indexentry
argument_list|)
expr_stmt|;
name|info
operator|->
name|indextable
operator|=
operator|(
expr|struct
name|indexentry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|indextable
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|file_name
operator|=
name|NULL
expr_stmt|;
name|directory_name
operator|=
name|NULL
expr_stmt|;
name|saw_fun
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|stroff
operator|=
literal|0
operator|,
name|stab
operator|=
name|info
operator|->
name|stabs
operator|,
name|str
operator|=
name|info
operator|->
name|strs
init|;
name|i
operator|<
name|info
operator|->
name|indextablesize
operator|&&
name|stab
operator|<
name|info
operator|->
name|stabs
operator|+
name|stabsize
condition|;
name|stab
operator|+=
name|STABSIZE
control|)
block|{
switch|switch
condition|(
name|stab
index|[
name|TYPEOFF
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* This is the first entry in a compilation unit.  */
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
operator|(
name|info
operator|->
name|strs
operator|+
name|strsize
operator|)
operator|-
name|str
argument_list|)
operator|<
name|stroff
condition|)
break|break;
name|str
operator|+=
name|stroff
expr_stmt|;
name|stroff
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SO
case|:
comment|/* The main file name.  */
comment|/* The following code creates a new indextable entry with 	         a NULL function name if there were no N_FUNs in a file. 	         Note that a N_SO without a file name is an EOF and 	         there could be 2 N_SO following it with the new filename 	         and directory.  */
if|if
condition|(
name|saw_fun
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|last_stab
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|stab
operator|=
name|last_stab
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|directory_name
operator|=
name|directory_name
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|file_name
operator|=
name|file_name
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|function_name
operator|=
name|NULL
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|saw_fun
operator|=
literal|0
expr_stmt|;
name|file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|str
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|file_name
operator|==
literal|'\0'
condition|)
block|{
name|directory_name
operator|=
name|NULL
expr_stmt|;
name|file_name
operator|=
name|NULL
expr_stmt|;
name|saw_fun
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|last_stab
operator|=
name|stab
expr_stmt|;
if|if
condition|(
name|stab
operator|+
name|STABSIZE
operator|>=
name|info
operator|->
name|stabs
operator|+
name|stabsize
operator|||
operator|*
operator|(
name|stab
operator|+
name|STABSIZE
operator|+
name|TYPEOFF
operator|)
operator|!=
name|N_SO
condition|)
block|{
name|directory_name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Two consecutive N_SOs are a directory and a 			 file name.  */
name|stab
operator|+=
name|STABSIZE
expr_stmt|;
name|directory_name
operator|=
name|file_name
expr_stmt|;
name|file_name
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|str
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|STRDXOFF
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|N_SOL
case|:
comment|/* The name of an include file.  */
name|file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|str
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_FUN
case|:
comment|/* A function name.  */
name|saw_fun
operator|=
literal|1
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|str
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
name|function_name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
continue|continue;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|stab
operator|=
name|stab
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|directory_name
operator|=
name|directory_name
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|file_name
operator|=
name|file_name
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|function_name
operator|=
name|function_name
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|saw_fun
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|last_stab
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|stab
operator|=
name|last_stab
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|directory_name
operator|=
name|directory_name
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|file_name
operator|=
name|file_name
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|function_name
operator|=
name|NULL
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|val
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|stab
operator|=
name|info
operator|->
name|stabs
operator|+
name|stabsize
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|directory_name
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|file_name
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|indextable
index|[
name|i
index|]
operator|.
name|function_name
operator|=
name|NULL
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|info
operator|->
name|indextablesize
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|info
operator|->
name|indextable
argument_list|,
operator|(
name|size_t
operator|)
name|i
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|indexentry
argument_list|)
argument_list|,
name|cmpindexentry
argument_list|)
expr_stmt|;
operator|*
name|pinfo
operator|=
operator|(
name|PTR
operator|)
name|info
expr_stmt|;
block|}
comment|/* We are passed a section relative offset.  The offsets in the      stabs information are absolute.  */
name|offset
operator|+=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CACHING
if|if
condition|(
name|info
operator|->
name|cached_indexentry
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|info
operator|->
name|cached_offset
operator|&&
name|offset
operator|<
operator|(
name|info
operator|->
name|cached_indexentry
operator|+
literal|1
operator|)
operator|->
name|val
condition|)
block|{
name|stab
operator|=
name|info
operator|->
name|cached_stab
expr_stmt|;
name|indexentry
operator|=
name|info
operator|->
name|cached_indexentry
expr_stmt|;
name|file_name
operator|=
name|info
operator|->
name|cached_file_name
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Cache non-existant or invalid.  Do binary search on          indextable.  */
name|long
name|low
decl_stmt|,
name|high
decl_stmt|;
name|long
name|mid
init|=
operator|-
literal|1
decl_stmt|;
name|indexentry
operator|=
name|NULL
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|info
operator|->
name|indextablesize
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|low
operator|!=
name|high
condition|)
block|{
name|mid
operator|=
operator|(
name|high
operator|+
name|low
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|info
operator|->
name|indextable
index|[
name|mid
index|]
operator|.
name|val
operator|&&
name|offset
operator|<
name|info
operator|->
name|indextable
index|[
name|mid
operator|+
literal|1
index|]
operator|.
name|val
condition|)
block|{
name|indexentry
operator|=
operator|&
name|info
operator|->
name|indextable
index|[
name|mid
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|info
operator|->
name|indextable
index|[
name|mid
index|]
operator|.
name|val
operator|>
name|offset
condition|)
name|high
operator|=
name|mid
expr_stmt|;
else|else
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|indexentry
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|stab
operator|=
name|indexentry
operator|->
name|stab
operator|+
name|STABSIZE
expr_stmt|;
name|file_name
operator|=
name|indexentry
operator|->
name|file_name
expr_stmt|;
block|}
name|directory_name
operator|=
name|indexentry
operator|->
name|directory_name
expr_stmt|;
name|str
operator|=
name|indexentry
operator|->
name|str
expr_stmt|;
for|for
control|(
init|;
name|stab
operator|<
operator|(
name|indexentry
operator|+
literal|1
operator|)
operator|->
name|stab
condition|;
name|stab
operator|+=
name|STABSIZE
control|)
block|{
name|boolean
name|done
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|done
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|stab
index|[
name|TYPEOFF
index|]
condition|)
block|{
case|case
name|N_SOL
case|:
comment|/* The name of an include file.  */
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
name|offset
condition|)
block|{
name|file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|str
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
operator|*
name|pline
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|N_SLINE
case|:
case|case
name|N_DSLINE
case|:
case|case
name|N_BSLINE
case|:
comment|/* A line number.  The value is relative to the start of the              current function.  */
name|val
operator|=
name|indexentry
operator|->
name|val
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
name|offset
condition|)
block|{
operator|*
name|pline
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|stab
operator|+
name|DESCOFF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CACHING
name|info
operator|->
name|cached_stab
operator|=
name|stab
expr_stmt|;
name|info
operator|->
name|cached_offset
operator|=
name|val
expr_stmt|;
name|info
operator|->
name|cached_file_name
operator|=
name|file_name
expr_stmt|;
name|info
operator|->
name|cached_indexentry
operator|=
name|indexentry
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|val
operator|>
name|offset
condition|)
name|done
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|N_FUN
case|:
case|case
name|N_SO
case|:
name|done
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|done
condition|)
break|break;
block|}
operator|*
name|pfound
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|file_name
argument_list|)
operator|||
name|directory_name
operator|==
name|NULL
condition|)
operator|*
name|pfilename
operator|=
name|file_name
expr_stmt|;
else|else
block|{
name|size_t
name|dirlen
decl_stmt|;
name|dirlen
operator|=
name|strlen
argument_list|(
name|directory_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|filename
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|directory_name
argument_list|,
name|dirlen
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|info
operator|->
name|filename
operator|+
name|dirlen
argument_list|,
name|file_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|filename
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
name|info
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|dirlen
operator|+
name|strlen
argument_list|(
name|file_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|filename
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strcpy
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|directory_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|info
operator|->
name|filename
operator|+
name|dirlen
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
block|}
operator|*
name|pfilename
operator|=
name|info
operator|->
name|filename
expr_stmt|;
block|}
if|if
condition|(
name|indexentry
operator|->
name|function_name
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* This will typically be something like main:F(0,1), so we want          to clobber the colon.  It's OK to change the name, since the          string is in our own local storage anyhow.  */
name|s
operator|=
name|strchr
argument_list|(
name|indexentry
operator|->
name|function_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pfnname
operator|=
name|indexentry
operator|->
name|function_name
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

