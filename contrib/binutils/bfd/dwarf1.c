begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF 1 find nearest line (_bfd_dwarf1_find_nearest_line).    Copyright 1998, 1999 Free Software Foundation, Inc.  Written by Gavin Romig-Koch of Cygnus Solutions (gavin@cygnus.com).    This file is part of BFD.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf.h"
end_include

begin_comment
comment|/* dwarf1_debug is the starting point for all dwarf1 info. */
end_comment

begin_struct
struct|struct
name|dwarf1_debug
block|{
comment|/* The bfd we are working with. */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* List of already parsed compilation units. */
name|struct
name|dwarf1_unit
modifier|*
name|lastUnit
decl_stmt|;
comment|/* The buffer for the .debug section.       Zero indicates that the .debug section failed to load. */
name|char
modifier|*
name|debug_section
decl_stmt|;
comment|/* Pointer to the end of the .debug_info section memory buffer. */
name|char
modifier|*
name|debug_section_end
decl_stmt|;
comment|/* The buffer for the .line section. */
name|char
modifier|*
name|line_section
decl_stmt|;
comment|/* End of that buffer. */
name|char
modifier|*
name|line_section_end
decl_stmt|;
comment|/* The current or next unread die within the .debug section. */
name|char
modifier|*
name|currentDie
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* One dwarf1_unit for each parsed compilation unit die. */
end_comment

begin_struct
struct|struct
name|dwarf1_unit
block|{
comment|/* Linked starting from stash->lastUnit. */
name|struct
name|dwarf1_unit
modifier|*
name|prev
decl_stmt|;
comment|/* Name of the compilation unit. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The highest and lowest address used in the compilation unit. */
name|unsigned
name|long
name|low_pc
decl_stmt|;
name|unsigned
name|long
name|high_pc
decl_stmt|;
comment|/* Does this unit have a statement list? */
name|int
name|has_stmt_list
decl_stmt|;
comment|/* If any, the offset of the line number table in the .line section. */
name|unsigned
name|long
name|stmt_list_offset
decl_stmt|;
comment|/* If non-zero, a pointer to the first child of this unit. */
name|char
modifier|*
name|first_child
decl_stmt|;
comment|/* How many line entries? */
name|unsigned
name|long
name|line_count
decl_stmt|;
comment|/* The decoded line number table (line_count entries). */
name|struct
name|linenumber
modifier|*
name|linenumber_table
decl_stmt|;
comment|/* The list of functions in this unit. */
name|struct
name|dwarf1_func
modifier|*
name|func_list
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* One dwarf1_func for each parsed function die.  */
end_comment

begin_struct
struct|struct
name|dwarf1_func
block|{
comment|/* Linked starting from aUnit->func_list. */
name|struct
name|dwarf1_func
modifier|*
name|prev
decl_stmt|;
comment|/* Name of function. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The highest and lowest address used in the compilation unit. */
name|unsigned
name|long
name|low_pc
decl_stmt|;
name|unsigned
name|long
name|high_pc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to return info about a parsed die. */
end_comment

begin_struct
struct|struct
name|die_info
block|{
name|unsigned
name|long
name|length
decl_stmt|;
name|unsigned
name|long
name|sibling
decl_stmt|;
name|unsigned
name|long
name|low_pc
decl_stmt|;
name|unsigned
name|long
name|high_pc
decl_stmt|;
name|unsigned
name|long
name|stmt_list_offset
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|has_stmt_list
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Parsed line number information. */
end_comment

begin_struct
struct|struct
name|linenumber
block|{
comment|/* First address in the line. */
name|unsigned
name|long
name|addr
decl_stmt|;
comment|/* The line number. */
name|unsigned
name|long
name|linenumber
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Find the form of an attr, from the attr field. */
end_comment

begin_define
define|#
directive|define
name|FORM_FROM_ATTR
parameter_list|(
name|attr
parameter_list|)
value|((attr)& 0xF)
end_define

begin_comment
comment|/* Implicitly specified */
end_comment

begin_comment
comment|/* Return a newly allocated dwarf1_unit.  It should be cleared and    then attached into the 'stash' at 'stash->lastUnit'. */
end_comment

begin_function
specifier|static
name|struct
name|dwarf1_unit
modifier|*
name|alloc_dwarf1_unit
parameter_list|(
name|stash
parameter_list|)
name|struct
name|dwarf1_debug
modifier|*
name|stash
decl_stmt|;
block|{
name|struct
name|dwarf1_unit
modifier|*
name|x
init|=
operator|(
expr|struct
name|dwarf1_unit
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf1_unit
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|->
name|prev
operator|=
name|stash
operator|->
name|lastUnit
expr_stmt|;
name|stash
operator|->
name|lastUnit
operator|=
name|x
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return a newly allocated dwarf1_func.  It must be cleared and    attached into 'aUnit' at 'aUnit->func_list'. */
end_comment

begin_function
specifier|static
name|struct
name|dwarf1_func
modifier|*
name|alloc_dwarf1_func
parameter_list|(
name|stash
parameter_list|,
name|aUnit
parameter_list|)
name|struct
name|dwarf1_debug
modifier|*
name|stash
decl_stmt|;
name|struct
name|dwarf1_unit
modifier|*
name|aUnit
decl_stmt|;
block|{
name|struct
name|dwarf1_func
modifier|*
name|x
init|=
operator|(
expr|struct
name|dwarf1_func
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf1_func
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|->
name|prev
operator|=
name|aUnit
operator|->
name|func_list
expr_stmt|;
name|aUnit
operator|->
name|func_list
operator|=
name|x
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* parse_die - parse a Dwarf1 die.    Parse the die starting at 'aDiePtr' into 'aDieInfo'.    'abfd' must be the bfd from which the section that 'aDiePtr'    points to was pulled from.      Return false if the die is invalidly formatted; true otherwise. */
end_comment

begin_function
specifier|static
name|boolean
name|parse_die
parameter_list|(
name|abfd
parameter_list|,
name|aDieInfo
parameter_list|,
name|aDiePtr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|die_info
modifier|*
name|aDieInfo
decl_stmt|;
name|char
modifier|*
name|aDiePtr
decl_stmt|;
block|{
name|char
modifier|*
name|this_die
init|=
name|aDiePtr
decl_stmt|;
name|char
modifier|*
name|xptr
init|=
name|this_die
decl_stmt|;
name|memset
argument_list|(
name|aDieInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aDieInfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First comes the length. */
name|aDieInfo
operator|->
name|length
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
name|xptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|aDieInfo
operator|->
name|length
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|aDieInfo
operator|->
name|length
operator|<
literal|6
condition|)
block|{
comment|/* Just padding bytes. */
name|aDieInfo
operator|->
name|tag
operator|=
name|TAG_padding
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Then the tag. */
name|aDieInfo
operator|->
name|tag
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
name|xptr
operator|+=
literal|2
expr_stmt|;
comment|/* Then the attributes. */
while|while
condition|(
name|xptr
operator|<
operator|(
name|this_die
operator|+
name|aDieInfo
operator|->
name|length
operator|)
condition|)
block|{
name|unsigned
name|short
name|attr
decl_stmt|;
comment|/* Parse the attribute based on its form.  This section           must handle all dwarf1 forms, but need only handle the 	 actual attributes that we care about. */
name|attr
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
name|xptr
operator|+=
literal|2
expr_stmt|;
switch|switch
condition|(
name|FORM_FROM_ATTR
argument_list|(
name|attr
argument_list|)
condition|)
block|{
case|case
name|FORM_DATA2
case|:
name|xptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|FORM_DATA4
case|:
case|case
name|FORM_REF
case|:
if|if
condition|(
name|attr
operator|==
name|AT_sibling
condition|)
name|aDieInfo
operator|->
name|sibling
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|==
name|AT_stmt_list
condition|)
block|{
name|aDieInfo
operator|->
name|stmt_list_offset
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
name|aDieInfo
operator|->
name|has_stmt_list
operator|=
literal|1
expr_stmt|;
block|}
name|xptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|FORM_DATA8
case|:
name|xptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|FORM_ADDR
case|:
if|if
condition|(
name|attr
operator|==
name|AT_low_pc
condition|)
name|aDieInfo
operator|->
name|low_pc
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|==
name|AT_high_pc
condition|)
name|aDieInfo
operator|->
name|high_pc
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
name|xptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|FORM_BLOCK2
case|:
name|xptr
operator|+=
literal|2
operator|+
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORM_BLOCK4
case|:
name|xptr
operator|+=
literal|4
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORM_STRING
case|:
if|if
condition|(
name|attr
operator|==
name|AT_name
condition|)
name|aDieInfo
operator|->
name|name
operator|=
name|xptr
expr_stmt|;
name|xptr
operator|+=
name|strlen
argument_list|(
name|xptr
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a dwarf1 line number table for 'aUnit->stmt_list_offset'    into 'aUnit->linenumber_table'.  Return false if an error     occurs; true otherwise. */
end_comment

begin_function
specifier|static
name|boolean
name|parse_line_table
parameter_list|(
name|stash
parameter_list|,
name|aUnit
parameter_list|)
name|struct
name|dwarf1_debug
modifier|*
name|stash
decl_stmt|;
name|struct
name|dwarf1_unit
modifier|*
name|aUnit
decl_stmt|;
block|{
name|char
modifier|*
name|xptr
decl_stmt|;
comment|/* Load the ".line" section from the bfd if we haven't already. */
if|if
condition|(
name|stash
operator|->
name|line_section
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
literal|".line"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
return|return
name|false
return|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|msec
argument_list|)
expr_stmt|;
name|stash
operator|->
name|line_section
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|line_section
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|line_section
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|stash
operator|->
name|line_section
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|stash
operator|->
name|line_section_end
operator|=
name|stash
operator|->
name|line_section
operator|+
name|size
expr_stmt|;
block|}
name|xptr
operator|=
name|stash
operator|->
name|line_section
operator|+
name|aUnit
operator|->
name|stmt_list_offset
expr_stmt|;
if|if
condition|(
name|xptr
operator|<
name|stash
operator|->
name|line_section_end
condition|)
block|{
name|unsigned
name|long
name|eachLine
decl_stmt|;
name|char
modifier|*
name|tblend
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
comment|/* First comes the length. */
name|tblend
operator|=
name|bfd_get_32
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
name|xptr
argument_list|)
operator|+
name|xptr
expr_stmt|;
name|xptr
operator|+=
literal|4
expr_stmt|;
comment|/* Then the base address for each address in the table. */
name|base
operator|=
name|bfd_get_32
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
name|xptr
operator|+=
literal|4
expr_stmt|;
comment|/* How many line entrys? 	 10 = 4 (line number) + 2 (pos in line) + 4 (address in line) */
name|aUnit
operator|->
name|line_count
operator|=
operator|(
name|tblend
operator|-
name|xptr
operator|)
operator|/
literal|10
expr_stmt|;
comment|/* Allocate an array for the entries. */
name|aUnit
operator|->
name|linenumber_table
operator|=
operator|(
expr|struct
name|linenumber
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linenumber
argument_list|)
operator|*
name|aUnit
operator|->
name|line_count
argument_list|)
expr_stmt|;
for|for
control|(
name|eachLine
operator|=
literal|0
init|;
name|eachLine
operator|<
name|aUnit
operator|->
name|line_count
condition|;
name|eachLine
operator|++
control|)
block|{
comment|/* A line number. */
name|aUnit
operator|->
name|linenumber_table
index|[
name|eachLine
index|]
operator|.
name|linenumber
operator|=
name|bfd_get_32
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
name|xptr
operator|+=
literal|4
expr_stmt|;
comment|/* Skip the position within the line. */
name|xptr
operator|+=
literal|2
expr_stmt|;
comment|/* And finally the address. */
name|aUnit
operator|->
name|linenumber_table
index|[
name|eachLine
index|]
operator|.
name|addr
operator|=
name|base
operator|+
name|bfd_get_32
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
name|xptr
argument_list|)
expr_stmt|;
name|xptr
operator|+=
literal|4
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse each function die in a compilation unit 'aUnit'.    The first child die of 'aUnit' should be in 'aUnit->first_child',    the result is placed in 'aUnit->func_list'.    Return false if error; true otherwise. */
end_comment

begin_function
specifier|static
name|boolean
name|parse_functions_in_unit
parameter_list|(
name|stash
parameter_list|,
name|aUnit
parameter_list|)
name|struct
name|dwarf1_debug
modifier|*
name|stash
decl_stmt|;
name|struct
name|dwarf1_unit
modifier|*
name|aUnit
decl_stmt|;
block|{
name|char
modifier|*
name|eachDie
decl_stmt|;
if|if
condition|(
name|aUnit
operator|->
name|first_child
condition|)
for|for
control|(
name|eachDie
operator|=
name|aUnit
operator|->
name|first_child
init|;
name|eachDie
operator|<
name|stash
operator|->
name|debug_section_end
condition|;
control|)
block|{
name|struct
name|die_info
name|eachDieInfo
decl_stmt|;
if|if
condition|(
operator|!
name|parse_die
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
operator|&
name|eachDieInfo
argument_list|,
name|eachDie
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|eachDieInfo
operator|.
name|tag
operator|==
name|TAG_global_subroutine
operator|||
name|eachDieInfo
operator|.
name|tag
operator|==
name|TAG_subroutine
operator|||
name|eachDieInfo
operator|.
name|tag
operator|==
name|TAG_inlined_subroutine
operator|||
name|eachDieInfo
operator|.
name|tag
operator|==
name|TAG_entry_point
condition|)
block|{
name|struct
name|dwarf1_func
modifier|*
name|aFunc
init|=
name|alloc_dwarf1_func
argument_list|(
name|stash
argument_list|,
name|aUnit
argument_list|)
decl_stmt|;
name|aFunc
operator|->
name|name
operator|=
name|eachDieInfo
operator|.
name|name
expr_stmt|;
name|aFunc
operator|->
name|low_pc
operator|=
name|eachDieInfo
operator|.
name|low_pc
expr_stmt|;
name|aFunc
operator|->
name|high_pc
operator|=
name|eachDieInfo
operator|.
name|high_pc
expr_stmt|;
block|}
comment|/* Move to next sibling, if none, end loop */
if|if
condition|(
name|eachDieInfo
operator|.
name|sibling
condition|)
name|eachDie
operator|=
name|stash
operator|->
name|debug_section
operator|+
name|eachDieInfo
operator|.
name|sibling
expr_stmt|;
else|else
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find the nearest line to 'addr' in 'aUnit'.    Return whether we found the line (or a function) without error. */
end_comment

begin_function
specifier|static
name|boolean
name|dwarf1_unit_find_nearest_line
parameter_list|(
name|stash
parameter_list|,
name|aUnit
parameter_list|,
name|addr
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|linenumber_ptr
parameter_list|)
name|struct
name|dwarf1_debug
modifier|*
name|stash
decl_stmt|;
name|struct
name|dwarf1_unit
modifier|*
name|aUnit
decl_stmt|;
name|unsigned
name|long
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|linenumber_ptr
decl_stmt|;
block|{
name|int
name|line_p
init|=
name|false
decl_stmt|;
name|int
name|func_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|aUnit
operator|->
name|low_pc
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|aUnit
operator|->
name|high_pc
condition|)
block|{
if|if
condition|(
name|aUnit
operator|->
name|has_stmt_list
condition|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|struct
name|dwarf1_func
modifier|*
name|eachFunc
decl_stmt|;
if|if
condition|(
operator|!
name|aUnit
operator|->
name|linenumber_table
condition|)
block|{
if|if
condition|(
operator|!
name|parse_line_table
argument_list|(
name|stash
argument_list|,
name|aUnit
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|aUnit
operator|->
name|func_list
condition|)
block|{
if|if
condition|(
operator|!
name|parse_functions_in_unit
argument_list|(
name|stash
argument_list|,
name|aUnit
argument_list|)
condition|)
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aUnit
operator|->
name|line_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aUnit
operator|->
name|linenumber_table
index|[
name|i
index|]
operator|.
name|addr
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|aUnit
operator|->
name|linenumber_table
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|addr
condition|)
block|{
operator|*
name|filename_ptr
operator|=
name|aUnit
operator|->
name|name
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|aUnit
operator|->
name|linenumber_table
index|[
name|i
index|]
operator|.
name|linenumber
expr_stmt|;
name|line_p
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|eachFunc
operator|=
name|aUnit
operator|->
name|func_list
init|;
name|eachFunc
condition|;
name|eachFunc
operator|=
name|eachFunc
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|eachFunc
operator|->
name|low_pc
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|eachFunc
operator|->
name|high_pc
condition|)
block|{
operator|*
name|functionname_ptr
operator|=
name|eachFunc
operator|->
name|name
expr_stmt|;
name|func_p
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|line_p
operator|||
name|func_p
return|;
block|}
end_function

begin_comment
comment|/* The DWARF 1 version of find_nearest line.    Return true if the line is found without error. */
end_comment

begin_function
name|boolean
name|_bfd_dwarf1_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|linenumber_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|linenumber_ptr
decl_stmt|;
block|{
name|struct
name|dwarf1_debug
modifier|*
name|stash
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf1_find_line_info
decl_stmt|;
name|struct
name|dwarf1_unit
modifier|*
name|eachUnit
decl_stmt|;
comment|/* What address are we looking for? */
name|bfd_vma
name|addr
init|=
name|offset
operator|+
name|section
operator|->
name|vma
decl_stmt|;
operator|*
name|filename_ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|stash
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf1_find_line_info
operator|=
operator|(
expr|struct
name|dwarf1_debug
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf1_debug
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
return|return
name|false
return|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
comment|/* No dwarf1 info.  Note that at this point the stash 	     has been allocated, but contains zeros, this lets 	     future calls to this function fail quicker. */
return|return
name|false
return|;
block|}
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|msec
argument_list|)
expr_stmt|;
name|stash
operator|->
name|debug_section
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|debug_section
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|debug_section
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|stash
operator|->
name|debug_section
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|stash
operator|->
name|debug_section_end
operator|=
name|stash
operator|->
name|debug_section
operator|+
name|size
expr_stmt|;
name|stash
operator|->
name|currentDie
operator|=
name|stash
operator|->
name|debug_section
expr_stmt|;
name|stash
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
block|}
comment|/* A null debug_section indicates that there was no dwarf1 info      or that an error occured while setting up the stash. */
if|if
condition|(
operator|!
name|stash
operator|->
name|debug_section
condition|)
return|return
name|false
return|;
comment|/* Look at the previously parsed units to see if any contain      the addr. */
for|for
control|(
name|eachUnit
operator|=
name|stash
operator|->
name|lastUnit
init|;
name|eachUnit
condition|;
name|eachUnit
operator|=
name|eachUnit
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|eachUnit
operator|->
name|low_pc
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|eachUnit
operator|->
name|high_pc
condition|)
return|return
name|dwarf1_unit_find_nearest_line
argument_list|(
name|stash
argument_list|,
name|eachUnit
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|)
return|;
block|}
while|while
condition|(
name|stash
operator|->
name|currentDie
operator|<
name|stash
operator|->
name|debug_section_end
condition|)
block|{
name|struct
name|die_info
name|aDieInfo
decl_stmt|;
if|if
condition|(
operator|!
name|parse_die
argument_list|(
name|stash
operator|->
name|abfd
argument_list|,
operator|&
name|aDieInfo
argument_list|,
name|stash
operator|->
name|currentDie
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|aDieInfo
operator|.
name|tag
operator|==
name|TAG_compile_unit
condition|)
block|{
name|struct
name|dwarf1_unit
modifier|*
name|aUnit
init|=
name|alloc_dwarf1_unit
argument_list|(
name|stash
argument_list|)
decl_stmt|;
name|aUnit
operator|->
name|name
operator|=
name|aDieInfo
operator|.
name|name
expr_stmt|;
name|aUnit
operator|->
name|low_pc
operator|=
name|aDieInfo
operator|.
name|low_pc
expr_stmt|;
name|aUnit
operator|->
name|high_pc
operator|=
name|aDieInfo
operator|.
name|high_pc
expr_stmt|;
name|aUnit
operator|->
name|has_stmt_list
operator|=
name|aDieInfo
operator|.
name|has_stmt_list
expr_stmt|;
name|aUnit
operator|->
name|stmt_list_offset
operator|=
name|aDieInfo
operator|.
name|stmt_list_offset
expr_stmt|;
comment|/* A die has a child if it's followed by a die that is 	     not it's sibling. */
if|if
condition|(
name|aDieInfo
operator|.
name|sibling
operator|&&
name|stash
operator|->
name|currentDie
operator|+
name|aDieInfo
operator|.
name|length
operator|<
name|stash
operator|->
name|debug_section_end
operator|&&
name|stash
operator|->
name|currentDie
operator|+
name|aDieInfo
operator|.
name|length
operator|!=
name|stash
operator|->
name|debug_section
operator|+
name|aDieInfo
operator|.
name|sibling
condition|)
name|aUnit
operator|->
name|first_child
operator|=
name|stash
operator|->
name|currentDie
operator|+
name|aDieInfo
operator|.
name|length
expr_stmt|;
else|else
name|aUnit
operator|->
name|first_child
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aUnit
operator|->
name|low_pc
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|aUnit
operator|->
name|high_pc
condition|)
return|return
name|dwarf1_unit_find_nearest_line
argument_list|(
name|stash
argument_list|,
name|aUnit
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|)
return|;
block|}
if|if
condition|(
name|aDieInfo
operator|.
name|sibling
operator|!=
literal|0
condition|)
name|stash
operator|->
name|currentDie
operator|=
name|stash
operator|->
name|debug_section
operator|+
name|aDieInfo
operator|.
name|sibling
expr_stmt|;
else|else
name|stash
operator|->
name|currentDie
operator|+=
name|aDieInfo
operator|.
name|length
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

