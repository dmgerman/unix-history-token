begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* PowerPC64-specific support for 64-bit ELF.    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Written by Linus Nordberg, Swox AB<info@swox.com>,    based on elf32-ppc.c by Ian Lance Taylor.    Largely rewritten by Alan Modra<amodra@bigpond.net.au>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* The 64-bit PowerPC ELF ABI may be found at    http://www.linuxbase.org/spec/ELF/ppc64/PPC-elf64abi.txt, and    http://www.linuxbase.org/spec/ELF/ppc64/spec/book1.html  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc64.h"
end_include

begin_include
include|#
directive|include
file|"elf64-ppc.h"
end_include

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_ha_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_branch_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_brtaken_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_ha_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_ha_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc64_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_unhandled_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|opd_entry_value
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_powerpcle_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-powerpcle"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_powerpc_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-powerpc-freebsd"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_powerpc
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PPC64
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_define
define|#
directive|define
name|ELF_COMMONPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|ppc64_elf_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_alignment
value|3
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_not_loaded
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|8
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_default_execstack
value|0
end_define

begin_define
define|#
directive|define
name|bfd_elf64_mkobject
value|ppc64_elf_mkobject
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
value|ppc64_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_name_lookup
value|ppc64_elf_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_merge_private_bfd_data
value|ppc64_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf64_new_section_hook
value|ppc64_elf_new_section_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
value|ppc64_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_free
value|ppc64_elf_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|bfd_elf64_get_synthetic_symtab
value|ppc64_elf_get_synthetic_symtab
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|ppc64_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|ppc64_elf_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|ppc64_elf_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_write_core_note
value|ppc64_elf_write_core_note
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|ppc64_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|ppc64_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|ppc64_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_directives
value|ppc64_elf_check_directives
end_define

begin_define
define|#
directive|define
name|elf_backend_as_needed_cleanup
value|ppc64_elf_as_needed_cleanup
end_define

begin_define
define|#
directive|define
name|elf_backend_archive_symbol_lookup
value|ppc64_elf_archive_symbol_lookup
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|ppc64_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_dynamic_ref
value|ppc64_elf_gc_mark_dynamic_ref
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|ppc64_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|ppc64_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|ppc64_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|ppc64_elf_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
value|ppc64_elf_func_desc_adjust
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|ppc64_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_init_index_section
value|_bfd_elf_init_2_index_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_action_discarded
value|ppc64_elf_action_discarded
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|ppc64_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|ppc64_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|ppc64_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|ppc64_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
value|ppc64_elf_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|ppc64_elf_special_sections
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|24
end_define

begin_comment
comment|/* The initial size of the plt reserved for the dynamic linker.  */
end_comment

begin_define
define|#
directive|define
name|PLT_INITIAL_ENTRY_SIZE
value|PLT_ENTRY_SIZE
end_define

begin_comment
comment|/* TOC base pointers offset from start of TOC.  */
end_comment

begin_define
define|#
directive|define
name|TOC_BASE_OFF
value|0x8000
end_define

begin_comment
comment|/* Offset of tp and dtp pointers from start of TLS block.  */
end_comment

begin_define
define|#
directive|define
name|TP_OFFSET
value|0x7000
end_define

begin_define
define|#
directive|define
name|DTP_OFFSET
value|0x8000
end_define

begin_comment
comment|/* .plt call stub instructions.  The normal stub is like this, but    sometimes the .plt entry crosses a 64k boundary and we need to    insert an addis to adjust r12.  */
end_comment

begin_define
define|#
directive|define
name|PLT_CALL_STUB_SIZE
value|(7*4)
end_define

begin_define
define|#
directive|define
name|ADDIS_R12_R2
value|0x3d820000
end_define

begin_comment
comment|/* addis %r12,%r2,xxx@ha     */
end_comment

begin_define
define|#
directive|define
name|STD_R2_40R1
value|0xf8410028
end_define

begin_comment
comment|/* std	 %r2,40(%r1)	     */
end_comment

begin_define
define|#
directive|define
name|LD_R11_0R12
value|0xe96c0000
end_define

begin_comment
comment|/* ld	 %r11,xxx+0@l(%r12)  */
end_comment

begin_define
define|#
directive|define
name|LD_R2_0R12
value|0xe84c0000
end_define

begin_comment
comment|/* ld	 %r2,xxx+8@l(%r12)   */
end_comment

begin_define
define|#
directive|define
name|MTCTR_R11
value|0x7d6903a6
end_define

begin_comment
comment|/* mtctr %r11		     */
end_comment

begin_comment
comment|/* ld	 %r11,xxx+16@l(%r12) */
end_comment

begin_define
define|#
directive|define
name|BCTR
value|0x4e800420
end_define

begin_comment
comment|/* bctr			     */
end_comment

begin_define
define|#
directive|define
name|ADDIS_R12_R12
value|0x3d8c0000
end_define

begin_comment
comment|/* addis %r12,%r12,off@ha  */
end_comment

begin_define
define|#
directive|define
name|ADDIS_R2_R2
value|0x3c420000
end_define

begin_comment
comment|/* addis %r2,%r2,off@ha  */
end_comment

begin_define
define|#
directive|define
name|ADDI_R2_R2
value|0x38420000
end_define

begin_comment
comment|/* addi  %r2,%r2,off@l   */
end_comment

begin_define
define|#
directive|define
name|LD_R2_40R1
value|0xe8410028
end_define

begin_comment
comment|/* ld    %r2,40(%r1)     */
end_comment

begin_comment
comment|/* glink call stub instructions.  We enter with the index in R0.  */
end_comment

begin_define
define|#
directive|define
name|GLINK_CALL_STUB_SIZE
value|(16*4)
end_define

begin_comment
comment|/* 0:				*/
end_comment

begin_comment
comment|/*  .quad plt0-1f		*/
end_comment

begin_comment
comment|/* __glink:			*/
end_comment

begin_define
define|#
directive|define
name|MFLR_R12
value|0x7d8802a6
end_define

begin_comment
comment|/*  mflr %12			*/
end_comment

begin_define
define|#
directive|define
name|BCL_20_31
value|0x429f0005
end_define

begin_comment
comment|/*  bcl 20,31,1f		*/
end_comment

begin_comment
comment|/* 1:				*/
end_comment

begin_define
define|#
directive|define
name|MFLR_R11
value|0x7d6802a6
end_define

begin_comment
comment|/*  mflr %11			*/
end_comment

begin_define
define|#
directive|define
name|LD_R2_M16R11
value|0xe84bfff0
end_define

begin_comment
comment|/*  ld %2,(0b-1b)(%11)		*/
end_comment

begin_define
define|#
directive|define
name|MTLR_R12
value|0x7d8803a6
end_define

begin_comment
comment|/*  mtlr %12			*/
end_comment

begin_define
define|#
directive|define
name|ADD_R12_R2_R11
value|0x7d825a14
end_define

begin_comment
comment|/*  add %12,%2,%11		*/
end_comment

begin_comment
comment|/*  ld %11,0(%12)		*/
end_comment

begin_comment
comment|/*  ld %2,8(%12)		*/
end_comment

begin_comment
comment|/*  mtctr %11			*/
end_comment

begin_comment
comment|/*  ld %11,16(%12)		*/
end_comment

begin_comment
comment|/*  bctr			*/
end_comment

begin_comment
comment|/* Pad with this.  */
end_comment

begin_define
define|#
directive|define
name|NOP
value|0x60000000
end_define

begin_comment
comment|/* Some other nops.  */
end_comment

begin_define
define|#
directive|define
name|CROR_151515
value|0x4def7b82
end_define

begin_define
define|#
directive|define
name|CROR_313131
value|0x4ffffb82
end_define

begin_comment
comment|/* .glink entries for the first 32k functions are two instructions.  */
end_comment

begin_define
define|#
directive|define
name|LI_R0_0
value|0x38000000
end_define

begin_comment
comment|/* li    %r0,0		*/
end_comment

begin_define
define|#
directive|define
name|B_DOT
value|0x48000000
end_define

begin_comment
comment|/* b     .		*/
end_comment

begin_comment
comment|/* After that, we need two instructions to load the index, followed by    a branch.  */
end_comment

begin_define
define|#
directive|define
name|LIS_R0_0
value|0x3c000000
end_define

begin_comment
comment|/* lis   %r0,0		*/
end_comment

begin_define
define|#
directive|define
name|ORI_R0_R0_0
value|0x60000000
end_define

begin_comment
comment|/* ori	 %r0,%r0,0	*/
end_comment

begin_comment
comment|/* Instructions used by the save and restore reg functions.  */
end_comment

begin_define
define|#
directive|define
name|STD_R0_0R1
value|0xf8010000
end_define

begin_comment
comment|/* std   %r0,0(%r1)	*/
end_comment

begin_define
define|#
directive|define
name|STD_R0_0R12
value|0xf80c0000
end_define

begin_comment
comment|/* std   %r0,0(%r12)	*/
end_comment

begin_define
define|#
directive|define
name|LD_R0_0R1
value|0xe8010000
end_define

begin_comment
comment|/* ld    %r0,0(%r1)	*/
end_comment

begin_define
define|#
directive|define
name|LD_R0_0R12
value|0xe80c0000
end_define

begin_comment
comment|/* ld    %r0,0(%r12)	*/
end_comment

begin_define
define|#
directive|define
name|STFD_FR0_0R1
value|0xd8010000
end_define

begin_comment
comment|/* stfd  %fr0,0(%r1)	*/
end_comment

begin_define
define|#
directive|define
name|LFD_FR0_0R1
value|0xc8010000
end_define

begin_comment
comment|/* lfd   %fr0,0(%r1)	*/
end_comment

begin_define
define|#
directive|define
name|LI_R12_0
value|0x39800000
end_define

begin_comment
comment|/* li    %r12,0		*/
end_comment

begin_define
define|#
directive|define
name|STVX_VR0_R12_R0
value|0x7c0c01ce
end_define

begin_comment
comment|/* stvx  %v0,%r12,%r0	*/
end_comment

begin_define
define|#
directive|define
name|LVX_VR0_R12_R0
value|0x7c0c00ce
end_define

begin_comment
comment|/* lvx   %v0,%r12,%r0	*/
end_comment

begin_define
define|#
directive|define
name|MTLR_R0
value|0x7c0803a6
end_define

begin_comment
comment|/* mtlr  %r0		*/
end_comment

begin_define
define|#
directive|define
name|BLR
value|0x4e800020
end_define

begin_comment
comment|/* blr			*/
end_comment

begin_comment
comment|/* Since .opd is an array of descriptors and each entry will end up    with identical R_PPC64_RELATIVE relocs, there is really no need to    propagate .opd relocs;  The dynamic linker should be taught to    relocate .opd without reloc entries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPD_RELOCS
end_ifndef

begin_define
define|#
directive|define
name|NO_OPD_RELOCS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_define
define|#
directive|define
name|ONES
parameter_list|(
name|n
parameter_list|)
value|(((bfd_vma) 1<< ((n) - 1)<< 1) - 1)
end_define

begin_comment
comment|/* Relocation HOWTO's.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_PPC64_max
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ppc64_elf_howto_raw
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_PPC64_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 26 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relocation without overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Bits 16-31 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Bits 16-31 of an address, plus 1 if the contents of the low 16      bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_branch_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is expected to be taken.  The lower two      bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14_BRTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is not expected to be taken.  The lower      two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14_BRNTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 26 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_branch_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_branch_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is expected to be taken.  The lower two bits must be      zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14_BRTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is not expected to be taken.  The lower two bits must      be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14_BRNTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but referring to the GOT table entry for the      symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HI, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HA, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This is used only by the dynamic linker.  The symbol should exist      both in the object being run and in some shared library.  The      dynamic linker copies the data addressed by the symbol from the      shared library into the object, because the object being      run has to have the data at some particular address.  */
name|HOWTO
argument_list|(
name|R_PPC64_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* this one is variable size */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_COPY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR64, but used when setting global offset table      entries.  */
name|HOWTO
argument_list|(
name|R_PPC64_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GLOB_DAT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Created by the link editor.  Marks a procedure linkage table      entry for a symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_JMP_SLOT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used only by the dynamic linker.  When the object is run, this      doubleword64 is set to the load address of the object, plus the      addend.  */
name|HOWTO
argument_list|(
name|R_PPC64_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_RELATIVE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR32, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
comment|/* FIXME: Verify.  Was complain_overflow_bitfield.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit relocation to the symbol's procedure linkage table.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative relocation to the symbol's procedure linkage table.      FIXME: R_PPC64_PLTREL32 not supported.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HI, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HA, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF, but no overflow warning.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half adjusted section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_REL24 without touching the two least significant bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL30
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|30
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL30"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocs in the 64-bit PowerPC ELF ABI, not in the 32-bit ABI.  */
comment|/* A standard 64-bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 32-47 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHER
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHER"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 32-47 of an address, plus 1 if the contents of the low      16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHERA
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHERA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 48-63 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHEST
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHEST"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 48-63 of an address, plus 1 if the contents of the low      16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHESTA
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHESTA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like ADDR64, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relocation to the symbol's procedure linkage table.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit PC relative relocation to the symbol's procedure linkage      table.  */
comment|/* FIXME: R_PPC64_PLTREL64 not supported.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTREL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTREL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation.  */
comment|/* R_PPC64_TOC16	  47	   half16*	S + A - .TOC.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation without overflow.  */
comment|/* R_PPC64_TOC16_LO	  48	   half16	 #lo (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation, high 16 bits.  */
comment|/* R_PPC64_TOC16_HI	  49	   half16	 #hi (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation, high 16 bits, plus 1 if the      contents of the low 16 bits, treated as a signed number, is      negative.  */
comment|/* R_PPC64_TOC16_HA	  50	   half16	 #ha (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relocation; insert value of TOC base (.TOC.).  */
comment|/* R_PPC64_TOC		  51	   doubleword64	 .TOC.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc64_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16, but also informs the link editor that the      value to relocate may (!) refer to a PLT entry which the link      editor (a) may replace with the symbol value.  If the link editor      is unable to fully resolve the symbol, it may (b) create a PLT      entry and store the address to the new PLT entry in the GOT.      This permits lazy resolution of function symbols at run time.      The link editor may also skip all of this and just (c) emit a      R_PPC64_GLOB_DAT to tie the symbol to the GOT entry.  */
comment|/* FIXME: R_PPC64_PLTGOT16 not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16, but without overflow.  */
comment|/* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address.  */
comment|/* FIXME: R_PPC64_PLTGOT16_HI not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address, plus      1 if the contents of the low 16 bits, treated as a signed number,      is negative.  */
comment|/* FIXME: R_PPC64_PLTGOT16_HA not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_TOC16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_TOC16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16, but for instructions with a DS field.  */
comment|/* FIXME: R_PPC64_PLTGOT16_DS not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16_LO, but for instructions with a DS field.  */
comment|/* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Marker reloc for TLS.  */
name|HOWTO
argument_list|(
name|R_PPC64_TLS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TLS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes the load module index of the load module that contains the      definition of its TLS sym.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPMOD64
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPMOD64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes a dtv-relative displacement, the difference between the value      of sym+add and the base address of the thread-local storage block that      contains the definition of sym, minus 0x8000.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL64
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit dtprel reloc.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HI, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HIGHER
argument_list|,
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HIGHER"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HIGHER, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HIGHERA
argument_list|,
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HIGHERA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HIGHER, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HIGHEST
argument_list|,
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HIGHEST"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HIGHEST, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HIGHESTA
argument_list|,
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HIGHESTA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16, but for insns with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_DS, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_LO_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes a tp-relative displacement, the difference between the value of      sym+add and the value of the thread pointer (r13).  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL64
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit tprel reloc.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HI, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HIGHER
argument_list|,
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HIGHER"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HIGHER, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HIGHERA
argument_list|,
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HIGHERA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HIGHER, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HIGHEST
argument_list|,
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HIGHEST"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HIGHEST, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HIGHESTA
argument_list|,
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HIGHESTA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16, but for insns with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_DS, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_LO_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates two contiguous entries in the GOT to hold a tls_index structure,      with values (sym+add)@dtpmod and (sym+add)@dtprel, and computes the offset      to the first entry relative to the TOC base (r2).  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSGD16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSGD16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSGD16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSGD16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSGD16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSGD16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSGD16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSGD16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates two contiguous entries in the GOT to hold a tls_index structure,      with values (sym+add)@dtpmod and zero, and computes the offset to the      first entry relative to the TOC base (r2).  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSLD16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSLD16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSLD16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSLD16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSLD16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSLD16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSLD16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSLD16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates an entry in the GOT with value (sym+add)@dtprel, and computes      the offset to the entry relative to the TOC base (r2).  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_DTPREL16_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_DTPREL16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_DS, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_DTPREL16_LO_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_DTPREL16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_LO_DS, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_DTPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_DTPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_DTPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_DTPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates an entry in the GOT with value (sym+add)@tprel, and computes the      offset to the entry relative to the TOC base (r2).  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TPREL16_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TPREL16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_DS, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TPREL16_LO_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TPREL16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_LO_DS, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_PPC64_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_PPC64_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the ppc64_elf_howto_table, so that linear accesses can    be done.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_howto_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ppc64_elf_howto_raw
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ppc64_elf_howto_table
index|[
name|type
index|]
operator|=
operator|&
name|ppc64_elf_howto_raw
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r
init|=
name|R_PPC64_NONE
decl_stmt|;
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
comment|/* Initialize howto table if needed.  */
name|ppc_howto_init
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_NONE
case|:
name|r
operator|=
name|R_PPC64_NONE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|r
operator|=
name|R_PPC64_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA26
case|:
name|r
operator|=
name|R_PPC64_ADDR24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|r
operator|=
name|R_PPC64_ADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|r
operator|=
name|R_PPC64_ADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16
case|:
name|r
operator|=
name|R_PPC64_ADDR14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRTAKEN
case|:
name|r
operator|=
name|R_PPC64_ADDR14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRNTAKEN
case|:
name|r
operator|=
name|R_PPC64_ADDR14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B26
case|:
name|r
operator|=
name|R_PPC64_REL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16
case|:
name|r
operator|=
name|R_PPC64_REL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRTAKEN
case|:
name|r
operator|=
name|R_PPC64_REL14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRNTAKEN
case|:
name|r
operator|=
name|R_PPC64_REL14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_GOTOFF
case|:
name|r
operator|=
name|R_PPC64_GOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_GOTOFF
case|:
name|r
operator|=
name|R_PPC64_GOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_GOTOFF
case|:
name|r
operator|=
name|R_PPC64_GOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_GOTOFF
case|:
name|r
operator|=
name|R_PPC64_GOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_COPY
case|:
name|r
operator|=
name|R_PPC64_COPY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GLOB_DAT
case|:
name|r
operator|=
name|R_PPC64_GLOB_DAT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|r
operator|=
name|R_PPC64_REL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
name|r
operator|=
name|R_PPC64_PLTREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_BASEREL
case|:
name|r
operator|=
name|R_PPC64_SECTOFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_BASEREL
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_BASEREL
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_BASEREL
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CTOR
case|:
name|r
operator|=
name|R_PPC64_ADDR64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
name|r
operator|=
name|R_PPC64_ADDR64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHER
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HIGHER
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHER_S
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HIGHERA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHEST
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HIGHEST
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHEST_S
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HIGHESTA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PCREL
case|:
name|r
operator|=
name|R_PPC64_REL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PLT_PCREL
case|:
name|r
operator|=
name|R_PPC64_PLTREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
name|r
operator|=
name|R_PPC64_TOC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_LO
case|:
name|r
operator|=
name|R_PPC64_TOC16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_HI
case|:
name|r
operator|=
name|R_PPC64_TOC16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_HA
case|:
name|r
operator|=
name|R_PPC64_TOC16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC
case|:
name|r
operator|=
name|R_PPC64_TOC
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_LO
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_HI
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_HA
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_ADDR16_DS
case|:
name|r
operator|=
name|R_PPC64_ADDR16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_ADDR16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_ADDR16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_GOT16_DS
case|:
name|r
operator|=
name|R_PPC64_GOT16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_GOT16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_GOT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLT16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_PLT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_SECTOFF_DS
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_SECTOFF_LO_DS
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_DS
case|:
name|r
operator|=
name|R_PPC64_TOC16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_TOC16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_DS
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TLS
case|:
name|r
operator|=
name|R_PPC64_TLS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPMOD
case|:
name|r
operator|=
name|R_PPC64_DTPMOD64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16
case|:
name|r
operator|=
name|R_PPC64_TPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_LO
case|:
name|r
operator|=
name|R_PPC64_TPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_HI
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_HA
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL
case|:
name|r
operator|=
name|R_PPC64_TPREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16
case|:
name|r
operator|=
name|R_PPC64_DTPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_LO
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_HI
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_HA
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL
case|:
name|r
operator|=
name|R_PPC64_DTPREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSGD16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_LO
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSGD16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_HI
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSGD16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_HA
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSGD16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSLD16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_LO
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSLD16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_HI
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSLD16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_HA
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSLD16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16
case|:
name|r
operator|=
name|R_PPC64_GOT_TPREL16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_LO
case|:
name|r
operator|=
name|R_PPC64_GOT_TPREL16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_HI
case|:
name|r
operator|=
name|R_PPC64_GOT_TPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_HA
case|:
name|r
operator|=
name|R_PPC64_GOT_TPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16
case|:
name|r
operator|=
name|R_PPC64_GOT_DTPREL16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_LO
case|:
name|r
operator|=
name|R_PPC64_GOT_DTPREL16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_HI
case|:
name|r
operator|=
name|R_PPC64_GOT_DTPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_HA
case|:
name|r
operator|=
name|R_PPC64_GOT_DTPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_DS
case|:
name|r
operator|=
name|R_PPC64_TPREL16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_TPREL16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_HIGHER
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HIGHER
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_HIGHERA
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HIGHERA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_HIGHEST
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HIGHEST
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_HIGHESTA
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HIGHESTA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_DS
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_HIGHER
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HIGHER
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_HIGHERA
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HIGHERA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_HIGHEST
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HIGHEST
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_HIGHESTA
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HIGHESTA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|r
operator|=
name|R_PPC64_GNU_VTINHERIT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|r
operator|=
name|R_PPC64_GNU_VTENTRY
expr_stmt|;
break|break;
block|}
return|return
name|ppc64_elf_howto_table
index|[
name|r
index|]
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ppc64_elf_howto_raw
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|ppc64_elf_howto_raw
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|ppc64_elf_howto_raw
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for a PowerPC ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|type
decl_stmt|;
comment|/* Initialize howto table if needed.  */
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
name|ppc_howto_init
argument_list|()
expr_stmt|;
name|type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: invalid relocation type %d"
argument_list|)
argument_list|,
name|abfd
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|R_PPC64_NONE
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|howto
operator|=
name|ppc64_elf_howto_table
index|[
name|type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the R_PPC64_ADDR16_HA and similar relocs.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_ha_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
comment|/* Adjust the addend for sign extension of the low 16 bits.      We won't actually be using the low 16 bits, so trashing them      doesn't matter.  */
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_branch_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|symbol
operator|->
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|dest
init|=
name|opd_entry_value
argument_list|(
name|symbol
operator|->
name|section
argument_list|,
name|symbol
operator|->
name|value
operator|+
name|reloc_entry
operator|->
name|addend
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|reloc_entry
operator|->
name|addend
operator|=
name|dest
operator|-
operator|(
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_brtaken_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|long
name|insn
decl_stmt|;
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|bfd_size_type
name|octets
decl_stmt|;
comment|/* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
name|bfd_boolean
name|is_power4
init|=
name|FALSE
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|octets
operator|=
name|reloc_entry
operator|->
name|address
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
name|insn
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
literal|21
operator|)
expr_stmt|;
name|r_type
operator|=
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_ADDR14_BRTAKEN
operator|||
name|r_type
operator|==
name|R_PPC64_REL14_BRTAKEN
condition|)
name|insn
operator||=
literal|0x01
operator|<<
literal|21
expr_stmt|;
comment|/* 'y' or 't' bit, lowest bit of BO field.  */
if|if
condition|(
name|is_power4
condition|)
block|{
comment|/* Set 'a' bit.  This is 0b00010 in BO field for branch 	 on CR(BI) insns (BO == 001at or 011at), and 0b01000 	 for branch on CTR insns (BO == 1a00t or 1a01t).  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x04
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x02
operator|<<
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x10
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x08
operator|<<
literal|21
expr_stmt|;
else|else
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|bfd_vma
name|target
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|from
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|target
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|target
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|target
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|target
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|from
operator|=
operator|(
name|reloc_entry
operator|->
name|address
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Invert 'y' bit if not the default.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|target
operator|-
name|from
argument_list|)
operator|<
literal|0
condition|)
name|insn
operator|^=
literal|0x01
operator|<<
literal|21
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ppc64_elf_branch_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
comment|/* Subtract the symbol section base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_ha_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
comment|/* Subtract the symbol section base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* Adjust the addend for sign extension of the low 16 bits.  */
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|TOCstart
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOCstart
operator|==
literal|0
condition|)
name|TOCstart
operator|=
name|ppc64_elf_toc
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
comment|/* Subtract the TOC base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_ha_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|TOCstart
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOCstart
operator|==
literal|0
condition|)
name|TOCstart
operator|=
name|ppc64_elf_toc
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
comment|/* Subtract the TOC base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
comment|/* Adjust the addend for sign extension of the low 16 bits.  */
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc64_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|TOCstart
decl_stmt|;
name|bfd_size_type
name|octets
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|TOCstart
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOCstart
operator|==
literal|0
condition|)
name|TOCstart
operator|=
name|ppc64_elf_toc
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|octets
operator|=
name|reloc_entry
operator|->
name|address
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|TOCstart
operator|+
name|TOC_BASE_OFF
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_unhandled_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
if|if
condition|(
name|error_message
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"generic linker can't handle %s"
argument_list|,
name|reloc_entry
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|error_message
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|bfd_reloc_dangerous
return|;
block|}
end_function

begin_struct
struct|struct
name|ppc64_elf_obj_tdata
block|{
name|struct
name|elf_obj_tdata
name|elf
decl_stmt|;
comment|/* Shortcuts to dynamic linker sections.  */
name|asection
modifier|*
name|got
decl_stmt|;
name|asection
modifier|*
name|relgot
decl_stmt|;
comment|/* Used during garbage collection.  We attach global symbols defined      on removed .opd entries to this section so that the sym is removed.  */
name|asection
modifier|*
name|deleted_section
decl_stmt|;
comment|/* TLS local dynamic got entry handling.  Suppose for multiple GOT      sections means we potentially need one of these for each input bfd.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|tlsld_got
union|;
comment|/* A copy of relocs before they are modified for --emit-relocs.  */
name|Elf_Internal_Rela
modifier|*
name|opd_relocs
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ppc64_elf_tdata
parameter_list|(
name|bfd
parameter_list|)
define|\
value|((struct ppc64_elf_obj_tdata *) (bfd)->tdata.any)
end_define

begin_define
define|#
directive|define
name|ppc64_tlsld_got
parameter_list|(
name|bfd
parameter_list|)
define|\
value|(&ppc64_elf_tdata (bfd)->tlsld_got)
end_define

begin_comment
comment|/* Override the generic function because we store some extras.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppc64_elf_obj_tdata
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|bfd_elf_mkobject
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if target is one of ours.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_ppc64_elf_target
parameter_list|(
specifier|const
name|struct
name|bfd_target
modifier|*
name|targ
parameter_list|)
block|{
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf64_powerpc_vec
decl_stmt|;
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf64_powerpcle_vec
decl_stmt|;
return|return
name|targ
operator|==
operator|&
name|bfd_elf64_powerpc_vec
operator|||
name|targ
operator|==
operator|&
name|bfd_elf64_powerpcle_vec
return|;
block|}
end_function

begin_comment
comment|/* Fix bad default arch selected for a 64 bit input bfd when the    default is 32 bit.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|arch_info
operator|->
name|the_default
operator|&&
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|32
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdr
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|i_ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
block|{
comment|/* Relies on arch after 32 bit default being 64 bit default.  */
name|abfd
operator|->
name|arch_info
operator|=
name|abfd
operator|->
name|arch_info
operator|->
name|next
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|size_t
name|offset
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|note
operator|->
name|descsz
operator|!=
literal|504
condition|)
return|return
name|FALSE
return|;
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|112
expr_stmt|;
name|size
operator|=
literal|384
expr_stmt|;
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
if|if
condition|(
name|note
operator|->
name|descsz
operator|!=
literal|136
condition|)
return|return
name|FALSE
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|40
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|56
argument_list|,
literal|80
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ppc64_elf_write_core_note
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bufsiz
parameter_list|,
name|int
name|note_type
parameter_list|,
modifier|...
parameter_list|)
block|{
switch|switch
condition|(
name|note_type
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|NT_PRPSINFO
case|:
block|{
name|char
name|data
index|[
literal|136
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|note_type
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|data
operator|+
literal|40
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|data
operator|+
literal|56
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
literal|"CORE"
argument_list|,
name|note_type
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
return|;
block|}
case|case
name|NT_PRSTATUS
case|:
block|{
name|char
name|data
index|[
literal|504
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|long
name|pid
decl_stmt|;
name|int
name|cursig
decl_stmt|;
specifier|const
name|void
modifier|*
name|greg
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|note_type
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
literal|112
argument_list|)
expr_stmt|;
name|pid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|pid
argument_list|,
name|data
operator|+
literal|32
argument_list|)
expr_stmt|;
name|cursig
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|cursig
argument_list|,
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|greg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
literal|112
argument_list|,
name|greg
argument_list|,
literal|384
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
operator|+
literal|496
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
literal|"CORE"
argument_list|,
name|note_type
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
comment|/* Check if we have the same endianess.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|&&
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
operator|&&
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|ibfd
argument_list|)
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%B: compiled for a big endian system "
literal|"and target is little endian"
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"%B: compiled for a little endian system "
literal|"and target is big endian"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|msg
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add extra PPC sections.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
name|ppc64_elf_special_sections
index|[]
init|=
block|{
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".plt"
argument_list|)
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
literal|0
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".sbss"
argument_list|)
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".sdata"
argument_list|)
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".toc"
argument_list|)
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".toc1"
argument_list|)
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".tocbss"
argument_list|)
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|_ppc64_sec_type
block|{
name|sec_normal
init|=
literal|0
block|,
name|sec_opd
init|=
literal|1
block|,
name|sec_toc
init|=
literal|2
block|}
enum|;
end_enum

begin_struct
struct|struct
name|_ppc64_elf_section_data
block|{
name|struct
name|bfd_elf_section_data
name|elf
decl_stmt|;
comment|/* An array with one entry for each opd function descriptor.  */
union|union
block|{
comment|/* Points to the function code section for local opd entries.  */
name|asection
modifier|*
modifier|*
name|opd_func_sec
decl_stmt|;
comment|/* After editing .opd, adjust references to opd local syms.  */
name|long
modifier|*
name|opd_adjust
decl_stmt|;
comment|/* An array for toc sections, indexed by offset/8.        Specifies the relocation symbol index used at a given toc offset.  */
name|unsigned
modifier|*
name|t_symndx
decl_stmt|;
block|}
name|u
union|;
name|enum
name|_ppc64_sec_type
name|sec_type
range|:
literal|2
decl_stmt|;
comment|/* Flag set when small branches are detected.  Used to      select suitable defaults for the stub group size.  */
name|unsigned
name|int
name|has_14bit_branch
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ppc64_elf_section_data
parameter_list|(
name|sec
parameter_list|)
define|\
value|((struct _ppc64_elf_section_data *) elf_section_data (sec))
end_define

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sec
operator|->
name|used_by_bfd
condition|)
block|{
name|struct
name|_ppc64_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
block|}
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_opd_info
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_type
operator|==
name|sec_opd
condition|)
return|return
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|opd_adjust
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parameters for the qsort hook.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|synthetic_opd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|synthetic_relocatable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* qsort comparison function for ppc64_elf_get_synthetic_symtab.  */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|asymbol
modifier|*
name|a
init|=
operator|*
operator|(
specifier|const
name|asymbol
operator|*
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|asymbol
modifier|*
name|b
init|=
operator|*
operator|(
specifier|const
name|asymbol
operator|*
operator|*
operator|)
name|bp
decl_stmt|;
comment|/* Section symbols first.  */
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|&&
operator|!
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|&&
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
condition|)
return|return
literal|1
return|;
comment|/* then .opd symbols.  */
if|if
condition|(
name|a
operator|->
name|section
operator|==
name|synthetic_opd
operator|&&
name|b
operator|->
name|section
operator|!=
name|synthetic_opd
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|section
operator|!=
name|synthetic_opd
operator|&&
name|b
operator|->
name|section
operator|==
name|synthetic_opd
condition|)
return|return
literal|1
return|;
comment|/* then other code symbols.  */
if|if
condition|(
operator|(
name|a
operator|->
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|==
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator|)
operator|&&
operator|(
name|b
operator|->
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|!=
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|!=
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator|)
operator|&&
operator|(
name|b
operator|->
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|==
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|synthetic_relocatable
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|section
operator|->
name|id
operator|<
name|b
operator|->
name|section
operator|->
name|id
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|section
operator|->
name|id
operator|>
name|b
operator|->
name|section
operator|->
name|id
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|a
operator|->
name|value
operator|+
name|a
operator|->
name|section
operator|->
name|vma
operator|<
name|b
operator|->
name|value
operator|+
name|b
operator|->
name|section
operator|->
name|vma
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|value
operator|+
name|a
operator|->
name|section
operator|->
name|vma
operator|>
name|b
operator|->
name|value
operator|+
name|b
operator|->
name|section
operator|->
name|vma
condition|)
return|return
literal|1
return|;
comment|/* For syms with the same value, prefer strong dynamic global function      syms over other syms.  */
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|==
literal|0
operator|&&
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_DYNAMIC
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|BSF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|b
operator|->
name|flags
operator|&
name|BSF_DYNAMIC
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search SYMS for a symbol of the given VALUE.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|sym_exists_at
parameter_list|(
name|asymbol
modifier|*
modifier|*
name|syms
parameter_list|,
name|long
name|lo
parameter_list|,
name|long
name|hi
parameter_list|,
name|int
name|id
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
name|long
name|mid
decl_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|syms
index|[
name|mid
index|]
operator|->
name|value
operator|+
name|syms
index|[
name|mid
index|]
operator|->
name|section
operator|->
name|vma
operator|<
name|value
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|mid
index|]
operator|->
name|value
operator|+
name|syms
index|[
name|mid
index|]
operator|->
name|section
operator|->
name|vma
operator|>
name|value
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
else|else
return|return
name|syms
index|[
name|mid
index|]
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|syms
index|[
name|mid
index|]
operator|->
name|section
operator|->
name|id
operator|<
name|id
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|mid
index|]
operator|->
name|section
operator|->
name|id
operator|>
name|id
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|mid
index|]
operator|->
name|value
operator|<
name|value
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|mid
index|]
operator|->
name|value
operator|>
name|value
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
else|else
return|return
name|syms
index|[
name|mid
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create synthetic symbols, effectively restoring "dot-symbol" function    entry syms.  */
end_comment

begin_function
specifier|static
name|long
name|ppc64_elf_get_synthetic_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|long
name|static_count
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|static_syms
parameter_list|,
name|long
name|dyn_count
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|dyn_syms
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|asymbol
modifier|*
name|s
decl_stmt|;
name|long
name|i
decl_stmt|;
name|long
name|count
decl_stmt|;
name|char
modifier|*
name|names
decl_stmt|;
name|long
name|symcount
decl_stmt|,
name|codesecsym
decl_stmt|,
name|codesecsymend
decl_stmt|,
name|secsymend
decl_stmt|,
name|opdsymend
decl_stmt|;
name|asection
modifier|*
name|opd
decl_stmt|;
name|bfd_boolean
name|relocatable
init|=
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
operator|*
name|ret
operator|=
name|NULL
expr_stmt|;
name|opd
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|symcount
operator|=
name|static_count
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable
condition|)
name|symcount
operator|+=
name|dyn_count
expr_stmt|;
if|if
condition|(
name|symcount
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|syms
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|syms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|relocatable
operator|&&
name|static_count
operator|!=
literal|0
operator|&&
name|dyn_count
operator|!=
literal|0
condition|)
block|{
comment|/* Use both symbol tables.  */
name|memcpy
argument_list|(
name|syms
argument_list|,
name|static_syms
argument_list|,
name|static_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|syms
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|syms
operator|+
name|static_count
argument_list|,
name|dyn_syms
argument_list|,
operator|(
name|dyn_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|syms
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|relocatable
operator|&&
name|static_count
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
name|syms
argument_list|,
name|dyn_syms
argument_list|,
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|syms
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|syms
argument_list|,
name|static_syms
argument_list|,
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|syms
argument_list|)
argument_list|)
expr_stmt|;
name|synthetic_opd
operator|=
name|opd
expr_stmt|;
name|synthetic_relocatable
operator|=
name|relocatable
expr_stmt|;
name|qsort
argument_list|(
name|syms
argument_list|,
name|symcount
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|syms
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable
operator|&&
name|symcount
operator|>
literal|1
condition|)
block|{
name|long
name|j
decl_stmt|;
comment|/* Trim duplicate syms, since we may have merged the normal and 	 dynamic symbols.  Actually, we only care about syms that have 	 different values, so trim any with the same value.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
name|symcount
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|syms
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|value
operator|+
name|syms
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|section
operator|->
name|vma
operator|!=
name|syms
index|[
name|i
index|]
operator|->
name|value
operator|+
name|syms
index|[
name|i
index|]
operator|->
name|section
operator|->
name|vma
condition|)
name|syms
index|[
name|j
operator|++
index|]
operator|=
name|syms
index|[
name|i
index|]
expr_stmt|;
name|symcount
operator|=
name|j
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|syms
index|[
name|i
index|]
operator|->
name|section
operator|==
name|opd
condition|)
operator|++
name|i
expr_stmt|;
name|codesecsym
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|symcount
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
operator|(
name|syms
index|[
name|i
index|]
operator|->
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|!=
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|||
operator|(
name|syms
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
break|break;
name|codesecsymend
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|symcount
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|syms
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
break|break;
name|secsymend
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|symcount
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|syms
index|[
name|i
index|]
operator|->
name|section
operator|!=
name|opd
condition|)
break|break;
name|opdsymend
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|symcount
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|syms
index|[
name|i
index|]
operator|->
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|!=
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator|)
condition|)
break|break;
name|symcount
operator|=
name|i
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opdsymend
operator|==
name|secsymend
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|relocatable
condition|)
block|{
name|bfd_boolean
function_decl|(
modifier|*
name|slurp_relocs
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|asymbol
modifier|*
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
name|arelent
modifier|*
name|r
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|slurp_relocs
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|slurp_reloc_table
expr_stmt|;
name|relcount
operator|=
operator|(
name|opd
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
condition|?
name|opd
operator|->
name|reloc_count
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|relcount
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
call|(
modifier|*
name|slurp_relocs
call|)
argument_list|(
name|abfd
argument_list|,
name|opd
argument_list|,
name|static_syms
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|count
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|secsymend
operator|,
name|r
operator|=
name|opd
operator|->
name|relocation
init|;
name|i
operator|<
name|opdsymend
condition|;
operator|++
name|i
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
while|while
condition|(
name|r
operator|<
name|opd
operator|->
name|relocation
operator|+
name|relcount
operator|&&
name|r
operator|->
name|address
operator|<
name|syms
index|[
name|i
index|]
operator|->
name|value
operator|+
name|opd
operator|->
name|vma
condition|)
operator|++
name|r
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|opd
operator|->
name|relocation
operator|+
name|relcount
condition|)
break|break;
if|if
condition|(
name|r
operator|->
name|address
operator|!=
name|syms
index|[
name|i
index|]
operator|->
name|value
operator|+
name|opd
operator|->
name|vma
condition|)
continue|continue;
if|if
condition|(
name|r
operator|->
name|howto
operator|->
name|type
operator|!=
name|R_PPC64_ADDR64
condition|)
continue|continue;
name|sym
operator|=
operator|*
name|r
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|sym_exists_at
argument_list|(
name|syms
argument_list|,
name|opdsymend
argument_list|,
name|symcount
argument_list|,
name|sym
operator|->
name|section
operator|->
name|id
argument_list|,
name|sym
operator|->
name|value
operator|+
name|r
operator|->
name|addend
argument_list|)
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
block|}
name|s
operator|=
operator|*
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|count
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|names
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|s
operator|+
name|count
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|secsymend
operator|,
name|r
operator|=
name|opd
operator|->
name|relocation
init|;
name|i
operator|<
name|opdsymend
condition|;
operator|++
name|i
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
while|while
condition|(
name|r
operator|<
name|opd
operator|->
name|relocation
operator|+
name|relcount
operator|&&
name|r
operator|->
name|address
operator|<
name|syms
index|[
name|i
index|]
operator|->
name|value
operator|+
name|opd
operator|->
name|vma
condition|)
operator|++
name|r
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|opd
operator|->
name|relocation
operator|+
name|relcount
condition|)
break|break;
if|if
condition|(
name|r
operator|->
name|address
operator|!=
name|syms
index|[
name|i
index|]
operator|->
name|value
operator|+
name|opd
operator|->
name|vma
condition|)
continue|continue;
if|if
condition|(
name|r
operator|->
name|howto
operator|->
name|type
operator|!=
name|R_PPC64_ADDR64
condition|)
continue|continue;
name|sym
operator|=
operator|*
name|r
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|sym_exists_at
argument_list|(
name|syms
argument_list|,
name|opdsymend
argument_list|,
name|symcount
argument_list|,
name|sym
operator|->
name|section
operator|->
name|id
argument_list|,
name|sym
operator|->
name|value
operator|+
name|r
operator|->
name|addend
argument_list|)
condition|)
block|{
name|size_t
name|len
decl_stmt|;
operator|*
name|s
operator|=
operator|*
name|syms
index|[
name|i
index|]
expr_stmt|;
name|s
operator|->
name|section
operator|=
name|sym
operator|->
name|section
expr_stmt|;
name|s
operator|->
name|value
operator|=
name|sym
operator|->
name|value
operator|+
name|r
operator|->
name|addend
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|names
expr_stmt|;
operator|*
name|names
operator|++
operator|=
literal|'.'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|names
argument_list|,
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|names
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|opd
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
block|{
if|if
condition|(
name|contents
condition|)
block|{
name|free_contents_and_exit
label|:
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|secsymend
init|;
name|i
operator|<
name|opdsymend
condition|;
operator|++
name|i
control|)
block|{
name|bfd_vma
name|ent
decl_stmt|;
name|ent
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|syms
index|[
name|i
index|]
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_exists_at
argument_list|(
name|syms
argument_list|,
name|opdsymend
argument_list|,
name|symcount
argument_list|,
operator|-
literal|1
argument_list|,
name|ent
argument_list|)
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
block|}
name|s
operator|=
operator|*
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
goto|goto
name|free_contents_and_exit
goto|;
name|names
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|s
operator|+
name|count
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|secsymend
init|;
name|i
operator|<
name|opdsymend
condition|;
operator|++
name|i
control|)
block|{
name|bfd_vma
name|ent
decl_stmt|;
name|ent
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|syms
index|[
name|i
index|]
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_exists_at
argument_list|(
name|syms
argument_list|,
name|opdsymend
argument_list|,
name|symcount
argument_list|,
operator|-
literal|1
argument_list|,
name|ent
argument_list|)
condition|)
block|{
name|long
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
operator|*
name|s
operator|=
operator|*
name|syms
index|[
name|i
index|]
expr_stmt|;
name|lo
operator|=
name|codesecsym
expr_stmt|;
name|hi
operator|=
name|codesecsymend
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|long
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>
literal|1
decl_stmt|;
if|if
condition|(
name|syms
index|[
name|mid
index|]
operator|->
name|section
operator|->
name|vma
operator|<
name|ent
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|mid
index|]
operator|->
name|section
operator|->
name|vma
operator|>
name|ent
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
else|else
block|{
name|sec
operator|=
name|syms
index|[
name|mid
index|]
operator|->
name|section
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|lo
operator|>=
name|hi
operator|&&
name|lo
operator|>
name|codesecsym
condition|)
name|sec
operator|=
name|syms
index|[
name|lo
operator|-
literal|1
index|]
operator|->
name|section
expr_stmt|;
for|for
control|(
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|vma
operator|>
name|ent
condition|)
break|break;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|section
operator|=
name|sec
expr_stmt|;
block|}
name|s
operator|->
name|value
operator|=
name|ent
operator|-
name|s
operator|->
name|section
operator|->
name|vma
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|names
expr_stmt|;
operator|*
name|names
operator|++
operator|=
literal|'.'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|names
argument_list|,
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|names
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are specific to the ELF linker, while    functions above are used generally.  Those named ppc64_elf_* are    called by the main ELF linker code.  They appear in this file more    or less in the order in which they are called.  eg.    ppc64_elf_check_relocs is called early in the link process,    ppc64_elf_finish_dynamic_sections is one of the last functions    called.     PowerPC64-ELF uses a similar scheme to PowerPC64-XCOFF in that    functions have both a function code symbol and a function descriptor    symbol.  A call to foo in a relocatable object file looks like:     .		.text    .	x:    .		bl	.foo    .		nop     The function definition in another object file might be:     .		.section .opd    .	foo:	.quad	.foo    .		.quad	.TOC.@tocbase    .		.quad	0    .    .		.text    .	.foo:	blr     When the linker resolves the call during a static link, the branch    unsurprisingly just goes to .foo and the .opd information is unused.    If the function definition is in a shared library, things are a little    different:  The call goes via a plt call stub, the opd information gets    copied to the plt, and the linker patches the nop.     .	x:    .		bl	.foo_stub    .		ld	2,40(1)    .    .    .	.foo_stub:    .		addis	12,2,Lfoo@toc@ha	# in practice, the call stub    .		addi	12,12,Lfoo@toc@l	# is slightly optimized, but    .		std	2,40(1)			# this is the general idea    .		ld	11,0(12)    .		ld	2,8(12)    .		mtctr	11    .		ld	11,16(12)    .		bctr    .    .		.section .plt    .	Lfoo:	reloc (R_PPC64_JMP_SLOT, foo)     The "reloc ()" notation is supposed to indicate that the linker emits    an R_PPC64_JMP_SLOT reloc against foo.  The dynamic linker does the opd    copying.     What are the difficulties here?  Well, firstly, the relocations    examined by the linker in check_relocs are against the function code    sym .foo, while the dynamic relocation in the plt is emitted against    the function descriptor symbol, foo.  Somewhere along the line, we need    to carefully copy dynamic link information from one symbol to the other.    Secondly, the generic part of the elf linker will make .foo a dynamic    symbol as is normal for most other backends.  We need foo dynamic    instead, at least for an application final link.  However, when    creating a shared library containing foo, we need to have both symbols    dynamic so that references to .foo are satisfied during the early    stages of linking.  Otherwise the linker might decide to pull in a    definition from some other object, eg. a static library.     Update: As of August 2004, we support a new convention.  Function    calls may use the function descriptor symbol, ie. "bl foo".  This    behaves exactly as "bl .foo".  */
end_comment

begin_comment
comment|/* The linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_dyn_relocs
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Track GOT entries needed for a given symbol.  We might need more    than one got entry per symbol.  */
end_comment

begin_struct
struct|struct
name|got_entry
block|{
name|struct
name|got_entry
modifier|*
name|next
decl_stmt|;
comment|/* The symbol addend that we'll be placing in the GOT.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* Unlike other ELF targets, we use separate GOT entries for the same      symbol referenced from different input files.  This is to support      automatic multiple TOC/GOT sections, where the TOC base can vary      from one input file to another.       Point to the BFD owning this GOT entry.  */
name|bfd
modifier|*
name|owner
decl_stmt|;
comment|/* Zero for non-tls entries, or TLS_TLS and one of TLS_GD, TLS_LD,      TLS_TPREL or TLS_DTPREL for tls entries.  */
name|char
name|tls_type
decl_stmt|;
comment|/* Reference count until size_dynamic_sections, GOT offset thereafter.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|got
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The same for PLT.  */
end_comment

begin_struct
struct|struct
name|plt_entry
block|{
name|struct
name|plt_entry
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|plt
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Of those relocs that might be copied as dynamic relocs, this macro    selects those that must be copied when linking a shared library,    even when the symbol is local.  */
end_comment

begin_define
define|#
directive|define
name|MUST_BE_DYN_RELOC
parameter_list|(
name|RTYPE
parameter_list|)
define|\
value|((RTYPE) != R_PPC64_REL32			\&& (RTYPE) != R_PPC64_REL64			\&& (RTYPE) != R_PPC64_REL30)
end_define

begin_comment
comment|/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid    copying dynamic variables from a shared lib into an app's dynbss    section, and instead use a dynamic relocation to point into the    shared lib.  With code that gcc generates, it's vital that this be    enabled;  In the PowerPC64 ABI, the address of a function is actually    the address of a function descriptor, which resides in the .opd    section.  gcc uses the descriptor directly rather than going via the    GOT as some other ABI's do, which means that initialized function    pointers must reference the descriptor.  Thus, a function pointer    initialized to the address of a function in a shared library will    either require a copy reloc, or a dynamic reloc.  Using a copy reloc    redefines the function descriptor symbol to point to the copy.  This    presents a problem as a plt entry for that function is also    initialized from the function descriptor symbol and the copy reloc    may not be initialized first.  */
end_comment

begin_define
define|#
directive|define
name|ELIMINATE_COPY_RELOCS
value|1
end_define

begin_comment
comment|/* Section name for stubs is the associated section name plus this    string.  */
end_comment

begin_define
define|#
directive|define
name|STUB_SUFFIX
value|".stub"
end_define

begin_comment
comment|/* Linker stubs.    ppc_stub_long_branch:    Used when a 14 bit branch (or even a 24 bit branch) can't reach its    destination, but a 24 bit branch in a stub section will reach.    .	b	dest     ppc_stub_plt_branch:    Similar to the above, but a 24 bit branch in the stub section won't    reach its destination.    .	addis	%r12,%r2,xxx@toc@ha    .	ld	%r11,xxx@toc@l(%r12)    .	mtctr	%r11    .	bctr     ppc_stub_plt_call:    Used to call a function in a shared library.  If it so happens that    the plt entry referenced crosses a 64k boundary, then an extra    "addis %r12,%r12,1" will be inserted before the load at xxx+8 or    xxx+16 as appropriate.    .	addis	%r12,%r2,xxx@toc@ha    .	std	%r2,40(%r1)    .	ld	%r11,xxx+0@toc@l(%r12)    .	ld	%r2,xxx+8@toc@l(%r12)    .	mtctr	%r11    .	ld	%r11,xxx+16@toc@l(%r12)    .	bctr     ppc_stub_long_branch and ppc_stub_plt_branch may also have additional    code to adjust the value and save r2 to support multiple toc sections.    A ppc_stub_long_branch with an r2 offset looks like:    .	std	%r2,40(%r1)    .	addis	%r2,%r2,off@ha    .	addi	%r2,%r2,off@l    .	b	dest     A ppc_stub_plt_branch with an r2 offset looks like:    .	std	%r2,40(%r1)    .	addis	%r12,%r2,xxx@toc@ha    .	ld	%r11,xxx@toc@l(%r12)    .	addis	%r2,%r2,off@ha    .	addi	%r2,%r2,off@l    .	mtctr	%r11    .	bctr */
end_comment

begin_enum
enum|enum
name|ppc_stub_type
block|{
name|ppc_stub_none
block|,
name|ppc_stub_long_branch
block|,
name|ppc_stub_long_branch_r2off
block|,
name|ppc_stub_plt_branch
block|,
name|ppc_stub_plt_branch_r2off
block|,
name|ppc_stub_plt_call
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ppc_stub_hash_entry
block|{
comment|/* Base hash table entry structure.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
name|enum
name|ppc_stub_type
name|stub_type
decl_stmt|;
comment|/* The stub section.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
comment|/* Offset within stub_sec of the beginning of this stub.  */
name|bfd_vma
name|stub_offset
decl_stmt|;
comment|/* Given the symbol's value and its section we can determine its final      value when building the stubs (so the stub knows where to jump.  */
name|bfd_vma
name|target_value
decl_stmt|;
name|asection
modifier|*
name|target_section
decl_stmt|;
comment|/* The symbol table entry, if any, that this was derived from.  */
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* And the reloc addend that this was derived from.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* Where this stub is being called from, or, in the case of combined      stub sections, the first input section in the group.  */
name|asection
modifier|*
name|id_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ppc_branch_hash_entry
block|{
comment|/* Base hash table entry structure.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Offset within branch lookup table.  */
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Generation marker.  */
name|unsigned
name|int
name|iter
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ppc_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
union|union
block|{
comment|/* A pointer to the most recently used stub hash entry against this        symbol.  */
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_cache
decl_stmt|;
comment|/* A pointer to the next symbol starting with a '.'  */
name|struct
name|ppc_link_hash_entry
modifier|*
name|next_dot_sym
decl_stmt|;
block|}
name|u
union|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|ppc_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
comment|/* Link between function code and descriptor symbols.  */
name|struct
name|ppc_link_hash_entry
modifier|*
name|oh
decl_stmt|;
comment|/* Flag function code and descriptor symbols.  */
name|unsigned
name|int
name|is_func
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_func_descriptor
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|fake
range|:
literal|1
decl_stmt|;
comment|/* Whether global opd/toc sym has been adjusted or not.      After ppc64_elf_edit_opd/ppc64_elf_edit_toc has run, this flag      should be set for all globals defined in any opd/toc section.  */
name|unsigned
name|int
name|adjust_done
range|:
literal|1
decl_stmt|;
comment|/* Set if we twiddled this symbol to weak at some stage.  */
name|unsigned
name|int
name|was_undefined
range|:
literal|1
decl_stmt|;
comment|/* Contexts in which symbol is used in the GOT (or TOC).      TLS_GD .. TLS_EXPLICIT bits are or'd into the mask as the      corresponding relocs are encountered during check_relocs.      tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to      indicate the corresponding GOT entry type is not needed.      tls_optimize may also set TLS_TPRELGD when a GD reloc turns into      a TPREL one.  We use a separate flag rather than setting TPREL      just for convenience in distinguishing the two cases.  */
define|#
directive|define
name|TLS_GD
value|1
comment|/* GD reloc. */
define|#
directive|define
name|TLS_LD
value|2
comment|/* LD reloc. */
define|#
directive|define
name|TLS_TPREL
value|4
comment|/* TPREL reloc, => IE. */
define|#
directive|define
name|TLS_DTPREL
value|8
comment|/* DTPREL reloc, => LD. */
define|#
directive|define
name|TLS_TLS
value|16
comment|/* Any TLS reloc.  */
define|#
directive|define
name|TLS_EXPLICIT
value|32
comment|/* Marks TOC section TLS relocs. */
define|#
directive|define
name|TLS_TPRELGD
value|64
comment|/* TPREL reloc resulting from GD->IE. */
name|char
name|tls_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ppc64 ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* The stub hash table.  */
name|struct
name|bfd_hash_table
name|stub_hash_table
decl_stmt|;
comment|/* Another hash table for plt_branch stubs.  */
name|struct
name|bfd_hash_table
name|branch_hash_table
decl_stmt|;
comment|/* Linker stub bfd.  */
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
comment|/* Linker call-backs.  */
name|asection
modifier|*
function_decl|(
modifier|*
name|add_stub_section
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|layout_sections_again
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Array to keep track of which stub sections have been created, and      information on stub grouping.  */
struct|struct
name|map_stub
block|{
comment|/* This is the section to which stubs in the group will be attached.  */
name|asection
modifier|*
name|link_sec
decl_stmt|;
comment|/* The stub section.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
comment|/* Along with elf_gp, specifies the TOC pointer used in this group.  */
name|bfd_vma
name|toc_off
decl_stmt|;
block|}
modifier|*
name|stub_group
struct|;
comment|/* Temp used when calculating TOC pointers.  */
name|bfd_vma
name|toc_curr
decl_stmt|;
comment|/* Highest input section id.  */
name|int
name|top_id
decl_stmt|;
comment|/* Highest output section index.  */
name|int
name|top_index
decl_stmt|;
comment|/* Used when adding symbols.  */
name|struct
name|ppc_link_hash_entry
modifier|*
name|dot_syms
decl_stmt|;
comment|/* List of input sections for each output section.  */
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|got
decl_stmt|;
name|asection
modifier|*
name|plt
decl_stmt|;
name|asection
modifier|*
name|relplt
decl_stmt|;
name|asection
modifier|*
name|dynbss
decl_stmt|;
name|asection
modifier|*
name|relbss
decl_stmt|;
name|asection
modifier|*
name|glink
decl_stmt|;
name|asection
modifier|*
name|sfpr
decl_stmt|;
name|asection
modifier|*
name|brlt
decl_stmt|;
name|asection
modifier|*
name|relbrlt
decl_stmt|;
comment|/* Shortcut to .__tls_get_addr and __tls_get_addr.  */
name|struct
name|ppc_link_hash_entry
modifier|*
name|tls_get_addr
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|tls_get_addr_fd
decl_stmt|;
comment|/* Statistics.  */
name|unsigned
name|long
name|stub_count
index|[
name|ppc_stub_plt_call
index|]
decl_stmt|;
comment|/* Number of stubs against global syms.  */
name|unsigned
name|long
name|stub_globals
decl_stmt|;
comment|/* Set if we should emit symbols for stubs.  */
name|unsigned
name|int
name|emit_stub_syms
range|:
literal|1
decl_stmt|;
comment|/* Support for multiple toc sections.  */
name|unsigned
name|int
name|no_multi_toc
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|multi_toc_needed
range|:
literal|1
decl_stmt|;
comment|/* Set on error.  */
name|unsigned
name|int
name|stub_error
range|:
literal|1
decl_stmt|;
comment|/* Temp used by ppc64_elf_check_directives.  */
name|unsigned
name|int
name|twiddled_syms
range|:
literal|1
decl_stmt|;
comment|/* Incremented every time we size stubs.  */
name|unsigned
name|int
name|stub_iteration
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Rename some of the generic section flags to better document how they    are used here.  */
end_comment

begin_define
define|#
directive|define
name|has_toc_reloc
value|has_gp_reloc
end_define

begin_define
define|#
directive|define
name|makes_toc_func_call
value|need_finalize_relax
end_define

begin_define
define|#
directive|define
name|call_check_in_progress
value|reloc_done
end_define

begin_comment
comment|/* Get the ppc64 ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|ppc_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct ppc_link_hash_table *) ((p)->hash))
end_define

begin_define
define|#
directive|define
name|ppc_stub_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct ppc_stub_hash_entry *) \    bfd_hash_lookup ((table), (string), (create), (copy)))
end_define

begin_define
define|#
directive|define
name|ppc_branch_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct ppc_branch_hash_entry *) \    bfd_hash_lookup ((table), (string), (create), (copy)))
end_define

begin_comment
comment|/* Create an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stub_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_stub_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|eh
operator|=
operator|(
expr|struct
name|ppc_stub_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|stub_type
operator|=
name|ppc_stub_none
expr_stmt|;
name|eh
operator|->
name|stub_sec
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_value
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_section
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|h
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|id_sec
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in the branch hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|branch_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_branch_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_branch_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|eh
operator|=
operator|(
expr|struct
name|ppc_branch_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|iter
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in a ppc64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
init|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
name|memset
argument_list|(
operator|&
name|eh
operator|->
name|u
operator|.
name|stub_cache
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_entry
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|ppc_link_hash_entry
argument_list|,
name|u
operator|.
name|stub_cache
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* When making function calls, old ABI code references function entry 	 points (dot symbols), while new ABI code references the function 	 descriptor symbol.  We need to make any combination of reference and 	 definition work together, without breaking archive linking.  	 For a defined function "foo" and an undefined call to "bar": 	 An old object defines "foo" and ".foo", references ".bar" (possibly 	 "bar" too). 	 A new object defines "foo" and references "bar".  	 A new object thus has no problem with its undefined symbols being 	 satisfied by definitions in an old object.  On the other hand, the 	 old object won't have ".bar" satisfied by a new object.  	 Keep a list of newly added dot-symbols.  */
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
operator|(
expr|struct
name|ppc_link_hash_table
operator|*
operator|)
name|table
expr_stmt|;
name|eh
operator|->
name|u
operator|.
name|next_dot_sym
operator|=
name|htab
operator|->
name|dot_syms
expr_stmt|;
name|htab
operator|->
name|dot_syms
operator|=
name|eh
expr_stmt|;
block|}
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create a ppc64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc64_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_table
argument_list|)
decl_stmt|;
name|htab
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|htab
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Init the stub hash table too.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_stub_hash_entry
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* And the branch hash table.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|branch_hash_table
argument_list|,
name|branch_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_branch_hash_entry
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Initializing two fields of the union is just cosmetic.  We really      only care about glist, but when compiled on a 32-bit host the      bfd_vma fields are larger.  Setting the bfd_vma to zero makes      debugger inspection of these fields look nicer.  */
name|htab
operator|->
name|elf
operator|.
name|init_got_refcount
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_got_refcount
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_plt_refcount
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_plt_refcount
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_got_offset
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_got_offset
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_plt_offset
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_plt_offset
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|htab
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Free the derived linker hash table.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_link_hash_table_free
parameter_list|(
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|ret
init|=
operator|(
expr|struct
name|ppc_link_hash_table
operator|*
operator|)
name|hash
decl_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ret
operator|->
name|stub_hash_table
argument_list|)
expr_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ret
operator|->
name|branch_hash_table
argument_list|)
expr_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Satisfy the ELF linker by filling in some fields in our fake bfd.  */
end_comment

begin_function
name|void
name|ppc64_elf_init_stub_bfd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELFCLASS64
expr_stmt|;
comment|/* Always hook our dynamic sections into the first bfd, which is the    linker created stub bfd.  This ensures that the GOT header is at    the start of the output TOC section.  */
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_bfd
operator|=
name|abfd
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a name for an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ppc_stub_name
parameter_list|(
specifier|const
name|asection
modifier|*
name|input_section
parameter_list|,
specifier|const
name|asection
modifier|*
name|sym_sec
parameter_list|,
specifier|const
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
comment|/* rel->r_addend is actually 64 bit, but who uses more than +/- 2^31      offsets from a sym as a branch target?  In fact, we could      probably assume the addend is always zero.  */
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
operator|)
operator|==
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|stub_name
return|;
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%08x.%s+%x"
argument_list|,
name|input_section
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|stub_name
return|;
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%08x.%x:%x+%x"
argument_list|,
name|input_section
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
name|sym_sec
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stub_name
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'+'
operator|&&
name|stub_name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'0'
condition|)
name|stub_name
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|stub_name
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in the stub hash.  Stub entries are cached because    creating the stub name takes a bit of time.  */
end_comment

begin_function
specifier|static
name|struct
name|ppc_stub_hash_entry
modifier|*
name|ppc_get_stub_entry
parameter_list|(
specifier|const
name|asection
modifier|*
name|input_section
parameter_list|,
specifier|const
name|asection
modifier|*
name|sym_sec
parameter_list|,
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
specifier|const
name|asection
modifier|*
name|id_sec
decl_stmt|;
comment|/* If this input section is part of a group of sections sharing one      stub section, then use the id of the first section in the group.      Stub names need to include a section id, as there may well be      more than one stub used to reach say, printf, and we need to      distinguish between them.  */
name|id_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|u
operator|.
name|stub_cache
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|u
operator|.
name|stub_cache
operator|->
name|h
operator|==
name|h
operator|&&
name|h
operator|->
name|u
operator|.
name|stub_cache
operator|->
name|id_sec
operator|==
name|id_sec
condition|)
block|{
name|stub_entry
operator|=
name|h
operator|->
name|u
operator|.
name|stub_cache
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|stub_name
operator|=
name|ppc_stub_name
argument_list|(
name|id_sec
argument_list|,
name|sym_sec
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|stub_entry
operator|=
name|ppc_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|u
operator|.
name|stub_cache
operator|=
name|stub_entry
expr_stmt|;
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
block|}
return|return
name|stub_entry
return|;
block|}
end_function

begin_comment
comment|/* Add a new stub entry to the stub hash.  Not all fields of the new    stub entry are initialised.  */
end_comment

begin_function
specifier|static
name|struct
name|ppc_stub_hash_entry
modifier|*
name|ppc_add_stub
parameter_list|(
specifier|const
name|char
modifier|*
name|stub_name
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|asection
modifier|*
name|link_sec
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|link_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
name|stub_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|stub_sec
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
block|{
name|stub_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|link_sec
operator|->
name|id
index|]
operator|.
name|stub_sec
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
block|{
name|size_t
name|namelen
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
name|char
modifier|*
name|s_name
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|link_sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|namelen
operator|+
sizeof|sizeof
argument_list|(
name|STUB_SUFFIX
argument_list|)
expr_stmt|;
name|s_name
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|s_name
argument_list|,
name|link_sec
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s_name
operator|+
name|namelen
argument_list|,
name|STUB_SUFFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|STUB_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|stub_sec
operator|=
call|(
modifier|*
name|htab
operator|->
name|add_stub_section
call|)
argument_list|(
name|s_name
argument_list|,
name|link_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|htab
operator|->
name|stub_group
index|[
name|link_sec
operator|->
name|id
index|]
operator|.
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
block|}
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
block|}
comment|/* Enter this entry into the linker stub hash table.  */
name|stub_entry
operator|=
name|ppc_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: cannot create stub entry %s"
argument_list|)
argument_list|,
name|section
operator|->
name|owner
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|stub_entry
operator|->
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
name|stub_entry
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|stub_entry
operator|->
name|id_sec
operator|=
name|link_sec
expr_stmt|;
return|return
name|stub_entry
return|;
block|}
end_function

begin_comment
comment|/* Create sections for linker generated code.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|create_linkage_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Create .sfpr for code to save and restore fp regs.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|sfpr
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".sfpr"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sfpr
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create .glink for lazy dynamic linking support.  */
name|htab
operator|->
name|glink
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".glink"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|glink
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|glink
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create branch lookup table for plt_branch stubs.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|brlt
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".branch_lt"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|brlt
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|brlt
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|relbrlt
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".rela.branch_lt"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|relbrlt
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|relbrlt
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create .got and .rela.got sections in ABFD, and .got in dynobj if    not already done.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|create_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|got
decl_stmt|,
modifier|*
name|relgot
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|got
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|got
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|got
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|got
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|got
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|relgot
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rela.got"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relgot
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|relgot
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ppc64_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
operator|=
name|got
expr_stmt|;
name|ppc64_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|relgot
operator|=
name|relgot
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create the dynamic sections, and set up shortcuts.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|got
condition|)
name|htab
operator|->
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|relplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|dynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|relbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|got
operator|||
operator|!
name|htab
operator|->
name|plt
operator|||
operator|!
name|htab
operator|->
name|relplt
operator|||
operator|!
name|htab
operator|->
name|dynbss
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|htab
operator|->
name|relbss
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge PLT info on FROM with that on TO.  */
end_comment

begin_function
specifier|static
name|void
name|move_plt_plist
parameter_list|(
name|struct
name|ppc_link_hash_entry
modifier|*
name|from
parameter_list|,
name|struct
name|ppc_link_hash_entry
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|to
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|plt_entry
modifier|*
modifier|*
name|entp
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|entp
operator|=
operator|&
name|from
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
operator|(
name|ent
operator|=
operator|*
name|entp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|plt_entry
modifier|*
name|dent
decl_stmt|;
for|for
control|(
name|dent
operator|=
name|to
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|dent
operator|!=
name|NULL
condition|;
name|dent
operator|=
name|dent
operator|->
name|next
control|)
if|if
condition|(
name|dent
operator|->
name|addend
operator|==
name|ent
operator|->
name|addend
condition|)
block|{
name|dent
operator|->
name|plt
operator|.
name|refcount
operator|+=
name|ent
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
operator|*
name|entp
operator|=
name|ent
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dent
operator|==
name|NULL
condition|)
name|entp
operator|=
operator|&
name|ent
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|entp
operator|=
name|to
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
expr_stmt|;
block|}
name|to
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|=
name|from
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
expr_stmt|;
name|from
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_copy_indirect_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
comment|/* Copy over any dynamic relocs we may have on the indirect sym.  */
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
comment|/* Add reloc counts against the indirect sym to the direct sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|edir
operator|->
name|is_func
operator||=
name|eind
operator|->
name|is_func
expr_stmt|;
name|edir
operator|->
name|is_func_descriptor
operator||=
name|eind
operator|->
name|is_func_descriptor
expr_stmt|;
name|edir
operator|->
name|tls_mask
operator||=
name|eind
operator|->
name|tls_mask
expr_stmt|;
comment|/* If called to transfer flags for a weakdef during processing      of elf_adjust_dynamic_symbol, don't copy NON_GOT_REF.      We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
if|if
condition|(
operator|!
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
name|eind
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
operator|&&
name|edir
operator|->
name|elf
operator|.
name|dynamic_adjusted
operator|)
condition|)
name|edir
operator|->
name|elf
operator|.
name|non_got_ref
operator||=
name|eind
operator|->
name|elf
operator|.
name|non_got_ref
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|ref_dynamic
operator||=
name|eind
operator|->
name|elf
operator|.
name|ref_dynamic
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|ref_regular
operator||=
name|eind
operator|->
name|elf
operator|.
name|ref_regular
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|ref_regular_nonweak
operator||=
name|eind
operator|->
name|elf
operator|.
name|ref_regular_nonweak
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|needs_plt
operator||=
name|eind
operator|->
name|elf
operator|.
name|needs_plt
expr_stmt|;
comment|/* If we were called to copy over info for a weak sym, that's all.  */
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return;
comment|/* Copy over got entries that we may have already seen to the      symbol which just became indirect.  */
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|got_entry
modifier|*
modifier|*
name|entp
decl_stmt|;
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|entp
operator|=
operator|&
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
init|;
operator|(
name|ent
operator|=
operator|*
name|entp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|got_entry
modifier|*
name|dent
decl_stmt|;
for|for
control|(
name|dent
operator|=
name|edir
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
init|;
name|dent
operator|!=
name|NULL
condition|;
name|dent
operator|=
name|dent
operator|->
name|next
control|)
if|if
condition|(
name|dent
operator|->
name|addend
operator|==
name|ent
operator|->
name|addend
operator|&&
name|dent
operator|->
name|owner
operator|==
name|ent
operator|->
name|owner
operator|&&
name|dent
operator|->
name|tls_type
operator|==
name|ent
operator|->
name|tls_type
condition|)
block|{
name|dent
operator|->
name|got
operator|.
name|refcount
operator|+=
name|ent
operator|->
name|got
operator|.
name|refcount
expr_stmt|;
operator|*
name|entp
operator|=
name|ent
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dent
operator|==
name|NULL
condition|)
name|entp
operator|=
operator|&
name|ent
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|entp
operator|=
name|edir
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
expr_stmt|;
block|}
name|edir
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|=
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* And plt entries.  */
name|move_plt_plist
argument_list|(
name|eind
argument_list|,
name|edir
argument_list|)
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|_bfd_elf_strtab_delref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|edir
operator|->
name|elf
operator|.
name|dynstr_index
argument_list|)
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|dynindx
operator|=
name|eind
operator|->
name|elf
operator|.
name|dynindx
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|dynstr_index
operator|=
name|eind
operator|->
name|elf
operator|.
name|dynstr_index
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|dynstr_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the function descriptor hash entry from the given function code    hash entry FH.  Link the entries via their OH fields.  */
end_comment

begin_function
specifier|static
name|struct
name|ppc_link_hash_entry
modifier|*
name|get_fdh
parameter_list|(
name|struct
name|ppc_link_hash_entry
modifier|*
name|fh
parameter_list|,
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
init|=
name|fh
operator|->
name|oh
decl_stmt|;
if|if
condition|(
name|fdh
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|fd_name
init|=
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
decl_stmt|;
name|fdh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|fd_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|!=
name|NULL
condition|)
block|{
name|fdh
operator|->
name|is_func_descriptor
operator|=
literal|1
expr_stmt|;
name|fdh
operator|->
name|oh
operator|=
name|fh
expr_stmt|;
name|fh
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
name|fh
operator|->
name|oh
operator|=
name|fdh
expr_stmt|;
block|}
block|}
return|return
name|fdh
return|;
block|}
end_function

begin_comment
comment|/* Make a fake function descriptor sym for the code sym FH.  */
end_comment

begin_function
specifier|static
name|struct
name|ppc_link_hash_entry
modifier|*
name|make_fdh
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|ppc_link_hash_entry
modifier|*
name|fh
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|newsym
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|abfd
operator|=
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
name|newsym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|newsym
operator|->
name|name
operator|=
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
expr_stmt|;
name|newsym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|newsym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|newsym
operator|->
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|newsym
operator|->
name|name
argument_list|,
name|newsym
operator|->
name|flags
argument_list|,
name|newsym
operator|->
name|section
argument_list|,
name|newsym
operator|->
name|value
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
condition|)
return|return
name|NULL
return|;
name|fdh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|non_elf
operator|=
literal|0
expr_stmt|;
name|fdh
operator|->
name|fake
operator|=
literal|1
expr_stmt|;
name|fdh
operator|->
name|is_func_descriptor
operator|=
literal|1
expr_stmt|;
name|fdh
operator|->
name|oh
operator|=
name|fh
expr_stmt|;
name|fh
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
name|fh
operator|->
name|oh
operator|=
name|fdh
expr_stmt|;
return|return
name|fdh
return|;
block|}
end_function

begin_comment
comment|/* Fix function descriptor symbols defined in .opd sections to be    function type.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|ibfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|isym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|flagword
modifier|*
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|sec
parameter_list|,
name|bfd_vma
modifier|*
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|*
name|sec
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|ibfd
argument_list|,
operator|*
name|sec
argument_list|)
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
name|isym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function makes an old ABI object reference to ".bar" cause the    inclusion of a new ABI object archive that defines "bar".    NAME is a symbol defined in an archive.  Return a symbol in the hash    table that might be satisfied by the archive symbols.  */
end_comment

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|ppc64_elf_archive_symbol_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|dot_name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|h
operator|=
name|_bfd_elf_archive_symbol_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
comment|/* Don't return this sym if it is a fake function descriptor 	 created by add_symbol_adjust.  */
operator|&&
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|fake
operator|)
condition|)
return|return
name|h
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
name|h
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dot_name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_name
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
literal|0
operator|-
literal|1
return|;
name|dot_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|memcpy
argument_list|(
name|dot_name
operator|+
literal|1
argument_list|,
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|h
operator|=
name|_bfd_elf_archive_symbol_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|dot_name
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|dot_name
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* This function satisfies all old ABI object references to ".bar" if a    new ABI object defines "bar".  Well, at least, undefined dot symbols    are made weak.  This stops later archive searches from including an    object if we already have a function descriptor definition.  It also    prevents the linker complaining about undefined symbols.    We also check and correct mismatched symbol visibility here.  The    most restrictive visibility of the function descriptor and the    function entry symbol is used.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|add_symbol_adjust
parameter_list|(
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fdh
operator|=
name|get_fdh
argument_list|(
name|eh
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|==
name|NULL
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
operator|&&
name|eh
operator|->
name|elf
operator|.
name|ref_regular
condition|)
block|{
comment|/* Make an undefweak function descriptor sym, which is enough to 	 pull in an --as-needed shared lib, but won't cause link 	 errors.  Archives are handled elsewhere.  */
name|fdh
operator|=
name|make_fdh
argument_list|(
name|info
argument_list|,
name|eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
else|else
name|fdh
operator|->
name|elf
operator|.
name|ref_regular
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdh
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|entry_vis
init|=
name|ELF_ST_VISIBILITY
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|descr_vis
init|=
name|ELF_ST_VISIBILITY
argument_list|(
name|fdh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|entry_vis
operator|<
name|descr_vis
condition|)
name|fdh
operator|->
name|elf
operator|.
name|other
operator|+=
name|entry_vis
operator|-
name|descr_vis
expr_stmt|;
elseif|else
if|if
condition|(
name|entry_vis
operator|>
name|descr_vis
condition|)
name|eh
operator|->
name|elf
operator|.
name|other
operator|+=
name|descr_vis
operator|-
name|entry_vis
expr_stmt|;
if|if
condition|(
operator|(
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefweak
expr_stmt|;
name|eh
operator|->
name|was_undefined
operator|=
literal|1
expr_stmt|;
name|htab
operator|->
name|twiddled_syms
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Process list of dot-symbols we made in link_hash_newfunc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_check_directives
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|eh
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_ppc64_elf_target
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|root
operator|.
name|creator
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|is_ppc64_elf_target
argument_list|(
name|ibfd
operator|->
name|xvec
argument_list|)
condition|)
block|{
name|p
operator|=
operator|&
name|htab
operator|->
name|dot_syms
expr_stmt|;
while|while
condition|(
operator|(
name|eh
operator|=
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|add_symbol_adjust
argument_list|(
name|eh
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
operator|&
name|eh
operator|->
name|u
operator|.
name|next_dot_sym
expr_stmt|;
block|}
block|}
comment|/* Clear the list for non-ppc64 input files.  */
name|p
operator|=
operator|&
name|htab
operator|->
name|dot_syms
expr_stmt|;
while|while
condition|(
operator|(
name|eh
operator|=
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|eh
operator|->
name|u
operator|.
name|next_dot_sym
expr_stmt|;
block|}
comment|/* We need to fix the undefs list for any syms we have twiddled to      undef_weak.  */
if|if
condition|(
name|htab
operator|->
name|twiddled_syms
condition|)
block|{
name|bfd_link_repair_undef_list
argument_list|(
operator|&
name|htab
operator|->
name|elf
operator|.
name|root
argument_list|)
expr_stmt|;
name|htab
operator|->
name|twiddled_syms
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Undo hash table changes when an --as-needed input file is determined    not to be needed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_as_needed_cleanup
parameter_list|(
name|bfd
modifier|*
name|ibfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dot_syms
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|update_local_sym_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|bfd_vma
name|r_addend
parameter_list|,
name|int
name|tls_type
parameter_list|)
block|{
name|struct
name|got_entry
modifier|*
modifier|*
name|local_got_ents
init|=
name|elf_local_got_ents
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|local_got_tls_masks
decl_stmt|;
if|if
condition|(
name|local_got_ents
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
init|=
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
operator|*
name|local_got_ents
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|local_got_tls_masks
argument_list|)
expr_stmt|;
name|local_got_ents
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_ents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_ents
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_ents
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tls_type
operator|&
name|TLS_EXPLICIT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|local_got_ents
index|[
name|r_symndx
index|]
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|r_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|abfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
decl_stmt|;
name|ent
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ent
operator|->
name|next
operator|=
name|local_got_ents
index|[
name|r_symndx
index|]
expr_stmt|;
name|ent
operator|->
name|addend
operator|=
name|r_addend
expr_stmt|;
name|ent
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|ent
operator|->
name|tls_type
operator|=
name|tls_type
expr_stmt|;
name|ent
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|local_got_ents
index|[
name|r_symndx
index|]
operator|=
name|ent
expr_stmt|;
block|}
name|ent
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
name|local_got_tls_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_ents
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|local_got_tls_masks
index|[
name|r_symndx
index|]
operator||=
name|tls_type
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|update_plt_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|eh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|addend
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
decl_stmt|;
name|ent
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ent
operator|->
name|next
operator|=
name|eh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
expr_stmt|;
name|ent
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|=
name|ent
expr_stmt|;
block|}
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|needs_plt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|eh
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    calculate needed space in the global offset table, procedure    linkage table, and dynamic reloc sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|asection
modifier|*
modifier|*
name|opd_sym_map
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* Don't do anything special with non-loaded, non-alloced sections.      In particular, any relocs in such sections should not affect GOT      and PLT reference counting (ie. we don't allow them to create GOT      or PLT entries), there's no possibility or desire to optimize TLS      relocs, and there's not much point in propagating relocs to shared      libs that the dynamic linker won't relocate.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
operator|(
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|opd_sym_map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Garbage collection needs some extra help with .opd sections. 	 We don't want to necessarily keep everything referenced by 	 relocs in .opd, as that would keep all functions.  Instead, 	 if we reference an .opd symbol (a function descriptor), we 	 want to keep the function code symbol's section.  This is 	 easy for global symbols, but for local syms we need to keep 	 information about the associated function section.  Later, if 	 edit_opd deletes entries, we'll use this array to adjust 	 local syms in .opd.  */
union|union
name|opd_info
block|{
name|asection
modifier|*
name|func_section
decl_stmt|;
name|long
name|entry_adjust
decl_stmt|;
block|}
union|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
name|sec
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|opd_info
argument_list|)
operator|/
literal|8
expr_stmt|;
name|opd_sym_map
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_sym_map
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|opd_func_sec
operator|=
name|opd_sym_map
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_type
operator|==
name|sec_normal
argument_list|)
expr_stmt|;
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_type
operator|=
name|sec_opd
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|==
name|NULL
operator|&&
operator|!
name|create_linkage_sections
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|int
name|tls_type
init|=
literal|0
decl_stmt|;
name|struct
name|_ppc64_elf_section_data
modifier|*
name|ppc64_sec
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
name|ppc64_tlsld_got
argument_list|(
name|abfd
argument_list|)
operator|->
name|refcount
operator|+=
literal|1
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_HI
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC64_GOT_DTPREL16_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
name|dogottls
label|:
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
comment|/* Fall thru */
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
comment|/* This symbol requires a global offset table entry.  */
name|sec
operator|->
name|has_toc_reloc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ppc64_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
operator|==
name|NULL
operator|&&
operator|!
name|create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|abfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
decl_stmt|;
name|ent
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ent
operator|->
name|next
operator|=
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
expr_stmt|;
name|ent
operator|->
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|ent
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|ent
operator|->
name|tls_type
operator|=
name|tls_type
expr_stmt|;
name|ent
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|=
name|ent
expr_stmt|;
block|}
name|ent
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|eh
operator|->
name|tls_mask
operator||=
name|tls_type
expr_stmt|;
block|}
elseif|else
comment|/* This is a global offset table entry for a local symbol.  */
if|if
condition|(
operator|!
name|update_local_sym_info
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|tls_type
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol, 	     because this might be a case of linking PIC code without 	     linking in any dynamic objects, in which case we don't 	     need to generate a procedure linkage table after all.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* It does not make sense to have a procedure linkage 		 table entry for a local symbol.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|update_plt_info
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* The following relocations don't need to propagate the 	     relocation if linking a shared object since they are 	     section relative.  */
case|case
name|R_PPC64_SECTOFF
case|:
case|case
name|R_PPC64_SECTOFF_LO
case|:
case|case
name|R_PPC64_SECTOFF_HI
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_DTPREL16
case|:
case|case
name|R_PPC64_DTPREL16_LO
case|:
case|case
name|R_PPC64_DTPREL16_HI
case|:
case|case
name|R_PPC64_DTPREL16_HA
case|:
case|case
name|R_PPC64_DTPREL16_DS
case|:
case|case
name|R_PPC64_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_DTPREL16_HIGHER
case|:
case|case
name|R_PPC64_DTPREL16_HIGHERA
case|:
case|case
name|R_PPC64_DTPREL16_HIGHEST
case|:
case|case
name|R_PPC64_DTPREL16_HIGHESTA
case|:
break|break;
comment|/* Nor do these.  */
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
name|sec
operator|->
name|has_toc_reloc
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_PPC64_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
block|{
name|asection
modifier|*
name|dest
init|=
name|NULL
decl_stmt|;
comment|/* Heuristic: If jumping outside our section, chances are 	       we are going to need a stub.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* If the sym is weak it may be overridden later, so 		   don't assume we know where a weak sym lives.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|dest
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
else|else
name|dest
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|sec
condition|)
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|has_14bit_branch
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* We may need a .plt entry if the function this reloc 		 refers to is in a shared lib.  */
if|if
condition|(
operator|!
name|update_plt_info
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|==
operator|&
name|htab
operator|->
name|tls_get_addr
operator|->
name|elf
operator|||
name|h
operator|==
operator|&
name|htab
operator|->
name|tls_get_addr_fd
operator|->
name|elf
condition|)
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|htab
operator|->
name|tls_get_addr
operator|==
name|NULL
operator|&&
name|CONST_STRNEQ
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|".__tls_get_addr"
argument_list|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|15
index|]
operator|==
literal|0
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|15
index|]
operator|==
literal|'@'
operator|)
condition|)
block|{
name|htab
operator|->
name|tls_get_addr
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|htab
operator|->
name|tls_get_addr_fd
operator|==
name|NULL
operator|&&
name|CONST_STRNEQ
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"__tls_get_addr"
argument_list|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|14
index|]
operator|==
literal|0
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|14
index|]
operator|==
literal|'@'
operator|)
condition|)
block|{
name|htab
operator|->
name|tls_get_addr_fd
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_PPC64_TPREL64
case|:
name|tls_type
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
goto|goto
name|dotlstoc
goto|;
case|case
name|R_PPC64_DTPMOD64
case|:
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|rel_end
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|==
name|rel
operator|->
name|r_offset
operator|+
literal|8
condition|)
name|tls_type
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
else|else
name|tls_type
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dotlstoc
goto|;
case|case
name|R_PPC64_DTPREL64
case|:
name|tls_type
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
name|relocs
operator|&&
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_DTPMOD64
argument_list|)
operator|&&
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_offset
operator|==
name|rel
operator|->
name|r_offset
operator|-
literal|8
condition|)
comment|/* This is the second reloc of a dtpmod, dtprel pair. 	       Don't mark with TLS_DTPREL.  */
goto|goto
name|dodyn
goto|;
name|dotlstoc
label|:
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|eh
operator|->
name|tls_mask
operator||=
name|tls_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|update_local_sym_info
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|tls_type
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ppc64_sec
operator|=
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc64_sec
operator|->
name|sec_type
operator|!=
name|sec_toc
condition|)
block|{
comment|/* One extra to simplify get_tls_mask.  */
name|bfd_size_type
name|amt
init|=
name|sec
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|/
literal|8
operator|+
literal|1
decl_stmt|;
name|ppc64_sec
operator|->
name|u
operator|.
name|t_symndx
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc64_sec
operator|->
name|u
operator|.
name|t_symndx
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|ppc64_sec
operator|->
name|sec_type
operator|==
name|sec_normal
argument_list|)
expr_stmt|;
name|ppc64_sec
operator|->
name|sec_type
operator|=
name|sec_toc
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ppc64_sec
operator|->
name|u
operator|.
name|t_symndx
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
index|]
operator|=
name|r_symndx
expr_stmt|;
comment|/* Mark the second slot of a GD or LD entry. 	     -1 to indicate GD and -2 to indicate LD.  */
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
name|ppc64_sec
operator|->
name|u
operator|.
name|t_symndx
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
operator|+
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
name|ppc64_sec
operator|->
name|u
operator|.
name|t_symndx
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
operator|+
literal|1
index|]
operator|=
operator|-
literal|2
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC64_TPREL16
case|:
case|case
name|R_PPC64_TPREL16_LO
case|:
case|case
name|R_PPC64_TPREL16_HI
case|:
case|case
name|R_PPC64_TPREL16_HA
case|:
case|case
name|R_PPC64_TPREL16_DS
case|:
case|case
name|R_PPC64_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_TPREL16_HIGHER
case|:
case|case
name|R_PPC64_TPREL16_HIGHERA
case|:
case|case
name|R_PPC64_TPREL16_HIGHEST
case|:
case|case
name|R_PPC64_TPREL16_HIGHESTA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
goto|goto
name|dodyn
goto|;
block|}
break|break;
case|case
name|R_PPC64_ADDR64
case|:
if|if
condition|(
name|opd_sym_map
operator|!=
name|NULL
operator|&&
name|rel
operator|+
literal|1
operator|<
name|rel_end
operator|&&
name|ELF64_R_TYPE
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
name|get_fdh
argument_list|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|htab
argument_list|)
condition|)
empty_stmt|;
else|else
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
name|s
operator|!=
name|sec
condition|)
name|opd_sym_map
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
index|]
operator|=
name|s
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
case|case
name|R_PPC64_REL30
case|:
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL64
case|:
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
case|case
name|R_PPC64_TOC
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
comment|/* We may need a copy reloc.  */
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
comment|/* Don't propagate .opd relocs.  */
if|if
condition|(
name|NO_OPD_RELOCS
operator|&&
name|opd_sym_map
operator|!=
name|NULL
condition|)
break|break;
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  In case of a weak definition, 	     DEF_REGULAR may be cleared later by a strong definition in 	     a shared library.  We account for that possibility below by 	     storing information in the dyn_relocs field of the hash 	     table entry.  A similar situation occurs when creating 	     shared libraries and symbol visibility changes render the 	     symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
name|dodyn
label|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* We must copy these reloc types into the output file. 		 Create a reloc section in dynobj and make room for 		 this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|)
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: bad relocation section name `%s\'"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|vpp
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|vpp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
name|vpp
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|p
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* OFFSET in OPD_SEC specifies a function descriptor.  Return the address    of the code entry point, and its section.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|opd_entry_value
parameter_list|(
name|asection
modifier|*
name|opd_sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|asection
modifier|*
modifier|*
name|code_sec
parameter_list|,
name|bfd_vma
modifier|*
name|code_off
parameter_list|)
block|{
name|bfd
modifier|*
name|opd_bfd
init|=
name|opd_sec
operator|->
name|owner
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|,
modifier|*
name|look
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
comment|/* No relocs implies we are linking a --just-symbols object.  */
if|if
condition|(
name|opd_sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|opd_bfd
argument_list|,
name|opd_sec
argument_list|,
operator|&
name|val
argument_list|,
name|offset
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
if|if
condition|(
name|code_sec
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|likely
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|opd_bfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|sec
operator|->
name|vma
operator|<=
name|val
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|likely
operator|=
name|sec
expr_stmt|;
if|if
condition|(
name|likely
operator|!=
name|NULL
condition|)
block|{
operator|*
name|code_sec
operator|=
name|likely
expr_stmt|;
if|if
condition|(
name|code_off
operator|!=
name|NULL
condition|)
operator|*
name|code_off
operator|=
name|val
operator|-
name|likely
operator|->
name|vma
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
name|relocs
operator|=
name|ppc64_elf_tdata
argument_list|(
name|opd_bfd
argument_list|)
operator|->
name|opd_relocs
expr_stmt|;
if|if
condition|(
name|relocs
operator|==
name|NULL
condition|)
name|relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|opd_bfd
argument_list|,
name|opd_sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Go find the opd reloc at the sym address.  */
name|lo
operator|=
name|relocs
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hi
operator|=
name|lo
operator|+
name|opd_sec
operator|->
name|reloc_count
operator|-
literal|1
expr_stmt|;
comment|/* ignore last reloc */
name|val
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|look
operator|=
name|lo
operator|+
operator|(
name|hi
operator|-
name|lo
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|look
operator|->
name|r_offset
operator|<
name|offset
condition|)
name|lo
operator|=
name|look
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|look
operator|->
name|r_offset
operator|>
name|offset
condition|)
name|hi
operator|=
name|look
expr_stmt|;
else|else
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|opd_bfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
if|if
condition|(
name|ELF64_R_TYPE
argument_list|(
name|look
operator|->
name|r_info
argument_list|)
operator|==
name|R_PPC64_ADDR64
operator|&&
name|ELF64_R_TYPE
argument_list|(
operator|(
name|look
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC
condition|)
block|{
name|unsigned
name|long
name|symndx
init|=
name|ELF64_R_SYM
argument_list|(
name|look
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|sym
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|opd_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
break|break;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|sym
expr_stmt|;
block|}
name|sym
operator|+=
name|symndx
expr_stmt|;
name|val
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|)
operator|||
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
name|sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|opd_bfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|rh
decl_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|opd_bfd
argument_list|)
expr_stmt|;
name|rh
operator|=
name|sym_hashes
index|[
name|symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|rh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|rh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|rh
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|rh
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|rh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|val
operator|=
name|rh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|sec
operator|=
name|rh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
name|val
operator|+=
name|look
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|code_off
operator|!=
name|NULL
condition|)
operator|*
name|code_off
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|code_sec
operator|!=
name|NULL
condition|)
operator|*
name|code_sec
operator|=
name|sec
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|val
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Mark sections containing dynamically referenced symbols.  When    building shared libraries, we must assume that any visible symbol is    referenced.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_gc_mark_dynamic_ref
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
init|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
decl_stmt|;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Dynamic linking info is on the func descriptor sym.  */
if|if
condition|(
name|eh
operator|->
name|oh
operator|!=
name|NULL
operator|&&
name|eh
operator|->
name|oh
operator|->
name|is_func_descriptor
operator|&&
operator|(
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|eh
operator|=
name|eh
operator|->
name|oh
expr_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|eh
operator|->
name|elf
operator|.
name|ref_dynamic
operator|||
operator|(
operator|!
name|info
operator|->
name|executable
operator|&&
name|eh
operator|->
name|elf
operator|.
name|def_regular
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|!=
name|STV_INTERNAL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|!=
name|STV_HIDDEN
operator|)
operator|)
condition|)
block|{
name|asection
modifier|*
name|code_sec
decl_stmt|;
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
comment|/* Function descriptor syms cause the associated 	 function code sym section to be marked.  */
if|if
condition|(
name|eh
operator|->
name|is_func_descriptor
operator|&&
operator|(
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
elseif|else
if|if
condition|(
name|get_opd_info
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|!=
name|NULL
operator|&&
name|opd_entry_value
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
operator|&
name|code_sec
argument_list|,
name|NULL
argument_list|)
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|code_sec
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|ppc64_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|asection
modifier|*
name|rsec
decl_stmt|;
comment|/* First mark all our entry sym sections.  */
if|if
condition|(
name|info
operator|->
name|gc_sym_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|struct
name|bfd_sym_chain
modifier|*
name|sym
init|=
name|info
operator|->
name|gc_sym_list
decl_stmt|;
name|info
operator|->
name|gc_sym_list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|next
control|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|sym
operator|->
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
continue|continue;
if|if
condition|(
name|eh
operator|->
name|is_func_descriptor
operator|&&
operator|(
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|rsec
operator|=
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
elseif|else
if|if
condition|(
name|get_opd_info
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|!=
name|NULL
operator|&&
name|opd_entry_value
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
operator|&
name|rsec
argument_list|,
name|NULL
argument_list|)
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
empty_stmt|;
else|else
continue|continue;
if|if
condition|(
operator|!
name|rsec
operator|->
name|gc_mark
condition|)
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|rsec
argument_list|,
name|ppc64_elf_gc_mark_hook
argument_list|)
expr_stmt|;
name|rsec
operator|=
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
operator|!
name|rsec
operator|->
name|gc_mark
condition|)
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|rsec
argument_list|,
name|ppc64_elf_gc_mark_hook
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Syms return NULL if we're marking .opd, so we avoid marking all      function sections, as all functions are referenced in .opd.  */
name|rsec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|get_opd_info
argument_list|(
name|sec
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|rsec
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
case|case
name|R_PPC64_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|oh
operator|!=
name|NULL
operator|&&
name|eh
operator|->
name|oh
operator|->
name|is_func_descriptor
operator|&&
operator|(
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|eh
operator|=
name|eh
operator|->
name|oh
expr_stmt|;
comment|/* Function descriptor syms cause the associated 		 function code sym section to be marked.  */
if|if
condition|(
name|eh
operator|->
name|is_func_descriptor
operator|&&
operator|(
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
comment|/* They also mark their opd section.  */
if|if
condition|(
operator|!
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|gc_mark
condition|)
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|ppc64_elf_gc_mark_hook
argument_list|)
expr_stmt|;
name|rsec
operator|=
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|get_opd_info
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|!=
name|NULL
operator|&&
name|opd_entry_value
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
operator|&
name|rsec
argument_list|,
name|NULL
argument_list|)
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|gc_mark
condition|)
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|ppc64_elf_gc_mark_hook
argument_list|)
expr_stmt|;
block|}
else|else
name|rsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|rsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
name|asection
modifier|*
modifier|*
name|opd_sym_section
decl_stmt|;
name|rsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|opd_sym_section
operator|=
name|get_opd_info
argument_list|(
name|rsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_sym_section
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|rsec
operator|->
name|gc_mark
condition|)
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|rsec
argument_list|,
name|ppc64_elf_gc_mark_hook
argument_list|)
expr_stmt|;
name|rsec
operator|=
name|opd_sym_section
index|[
operator|(
name|sym
operator|->
name|st_value
operator|+
name|rel
operator|->
name|r_addend
operator|)
operator|/
literal|8
index|]
expr_stmt|;
block|}
block|}
return|return
name|rsec
return|;
block|}
end_function

begin_comment
comment|/* Update the .got, .plt. and dynamic reloc reference counts for the    section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|got_entry
modifier|*
modifier|*
name|local_got_ents
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_ents
operator|=
name|elf_local_got_ents
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|char
name|tls_type
init|=
literal|0
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
comment|/* Everything must go for SEC.  */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
name|ppc64_tlsld_got
argument_list|(
name|abfd
argument_list|)
operator|->
name|refcount
operator|-=
literal|1
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_HI
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_DTPREL16_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
name|dogot
label|:
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|ent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
expr_stmt|;
else|else
name|ent
operator|=
name|local_got_ents
index|[
name|r_symndx
index|]
expr_stmt|;
for|for
control|(
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|abfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
condition|)
break|break;
if|if
condition|(
name|ent
operator|!=
name|NULL
operator|&&
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The maximum size of .sfpr.  */
end_comment

begin_define
define|#
directive|define
name|SFPR_MAX
value|(218*4)
end_define

begin_struct
struct|struct
name|sfpr_def_parms
block|{
specifier|const
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
name|unsigned
name|char
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|bfd_byte
modifier|*
function_decl|(
modifier|*
name|write_ent
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|bfd_byte
modifier|*
function_decl|(
modifier|*
name|write_tail
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Auto-generate _save*, _rest* functions in .sfpr.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|sfpr_define
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|struct
name|sfpr_def_parms
modifier|*
name|parm
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|parm
operator|->
name|name
argument_list|)
decl_stmt|;
name|bfd_boolean
name|writing
init|=
name|FALSE
decl_stmt|;
name|char
name|sym
index|[
literal|16
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|sym
argument_list|,
name|parm
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sym
index|[
name|len
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|parm
operator|->
name|lo
init|;
name|i
operator|<=
name|parm
operator|->
name|hi
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|sym
index|[
name|len
operator|+
literal|0
index|]
operator|=
name|i
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
name|sym
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|sym
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|sfpr
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|htab
operator|->
name|sfpr
operator|->
name|size
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|writing
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|htab
operator|->
name|sfpr
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|SFPR_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|writing
condition|)
block|{
name|bfd_byte
modifier|*
name|p
init|=
name|htab
operator|->
name|sfpr
operator|->
name|contents
operator|+
name|htab
operator|->
name|sfpr
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|parm
operator|->
name|hi
condition|)
name|p
operator|=
call|(
modifier|*
name|parm
operator|->
name|write_ent
call|)
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
call|(
modifier|*
name|parm
operator|->
name|write_tail
call|)
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sfpr
operator|->
name|size
operator|=
name|p
operator|-
name|htab
operator|->
name|sfpr
operator|->
name|contents
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|savegpr0
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|STD_R0_0R1
operator|+
operator|(
name|r
operator|<<
literal|21
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|32
operator|-
name|r
operator|)
operator|*
literal|8
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|savegpr0_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|p
operator|=
name|savegpr0
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|STD_R0_0R1
operator|+
literal|16
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|restgpr0
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|LD_R0_0R1
operator|+
operator|(
name|r
operator|<<
literal|21
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|32
operator|-
name|r
operator|)
operator|*
literal|8
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|restgpr0_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|LD_R0_0R1
operator|+
literal|16
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
literal|4
expr_stmt|;
name|p
operator|=
name|restgpr0
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|MTLR_R0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|29
condition|)
block|{
name|p
operator|=
name|restgpr0
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|p
operator|=
name|restgpr0
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
literal|31
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|savegpr1
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|STD_R0_0R12
operator|+
operator|(
name|r
operator|<<
literal|21
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|32
operator|-
name|r
operator|)
operator|*
literal|8
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|savegpr1_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|p
operator|=
name|savegpr1
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|restgpr1
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|LD_R0_0R12
operator|+
operator|(
name|r
operator|<<
literal|21
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|32
operator|-
name|r
operator|)
operator|*
literal|8
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|restgpr1_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|p
operator|=
name|restgpr1
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|savefpr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|STFD_FR0_0R1
operator|+
operator|(
name|r
operator|<<
literal|21
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|32
operator|-
name|r
operator|)
operator|*
literal|8
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|savefpr0_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|p
operator|=
name|savefpr
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|STD_R0_0R1
operator|+
literal|16
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|restfpr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|LFD_FR0_0R1
operator|+
operator|(
name|r
operator|<<
literal|21
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|32
operator|-
name|r
operator|)
operator|*
literal|8
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|restfpr0_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|LD_R0_0R1
operator|+
literal|16
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
literal|4
expr_stmt|;
name|p
operator|=
name|restfpr
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|MTLR_R0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|29
condition|)
block|{
name|p
operator|=
name|restfpr
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|p
operator|=
name|restfpr
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
literal|31
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|savefpr1_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|p
operator|=
name|savefpr
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|restfpr1_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|p
operator|=
name|restfpr
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|savevr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|LI_R12_0
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|32
operator|-
name|r
operator|)
operator|*
literal|16
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|STVX_VR0_R12_R0
operator|+
operator|(
name|r
operator|<<
literal|21
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|savevr_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|p
operator|=
name|savevr
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|restvr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|LI_R12_0
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|32
operator|-
name|r
operator|)
operator|*
literal|16
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|LVX_VR0_R12_R0
operator|+
operator|(
name|r
operator|<<
literal|21
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|restvr_tail
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|p
operator|=
name|restvr
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Called via elf_link_hash_traverse to transfer dynamic linking    information on function code symbol entries to their corresponding    function descriptor symbol entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|func_desc_adjust
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fh
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|bfd_boolean
name|force_local
decl_stmt|;
name|fh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|fh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
name|inf
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Resolve undefined references to dot-symbols as the value      in the function descriptor, if we have one in a regular object.      This is to satisfy cases like ".quad .foo".  Calls to functions      in dynamic objects are handled elsewhere.  */
if|if
condition|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|fh
operator|->
name|was_undefined
operator|&&
operator|(
name|fh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|fh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|get_opd_info
argument_list|(
name|fh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|!=
name|NULL
operator|&&
name|opd_entry_value
argument_list|(
name|fh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|fh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
operator|&
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
operator|&
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|)
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|=
name|fh
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
expr_stmt|;
name|fh
operator|->
name|elf
operator|.
name|forced_local
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is a function code symbol, transfer dynamic linking      information to the function descriptor symbol.  */
if|if
condition|(
operator|!
name|fh
operator|->
name|is_func
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|ent
operator|=
name|fh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
operator|||
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
comment|/* Find the corresponding function descriptor symbol.  Create it      as undefined if necessary.  */
name|fdh
operator|=
name|get_fdh
argument_list|(
name|fh
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|!=
name|NULL
condition|)
while|while
condition|(
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|fdh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|fdh
operator|==
name|NULL
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|fdh
operator|=
name|make_fdh
argument_list|(
name|info
argument_list|,
name|fh
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Fake function descriptors are made undefweak.  If the function      code symbol is strong undefined, make the fake sym the same.      If the function code symbol is defined, then force the fake      descriptor local;  We can't support overriding of symbols in a      shared library on a fake descriptor.  */
if|if
condition|(
name|fdh
operator|!=
name|NULL
operator|&&
name|fdh
operator|->
name|fake
operator|&&
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|bfd_link_add_undef
argument_list|(
operator|&
name|htab
operator|->
name|elf
operator|.
name|root
argument_list|,
operator|&
name|fdh
operator|->
name|elf
operator|.
name|root
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|fdh
operator|->
name|elf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fdh
operator|!=
name|NULL
operator|&&
operator|!
name|fdh
operator|->
name|elf
operator|.
name|forced_local
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|fdh
operator|->
name|elf
operator|.
name|def_dynamic
operator|||
name|fdh
operator|->
name|elf
operator|.
name|ref_dynamic
operator|||
operator|(
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|fdh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fdh
operator|->
name|elf
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|fdh
operator|->
name|elf
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fdh
operator|->
name|elf
operator|.
name|ref_regular
operator||=
name|fh
operator|->
name|elf
operator|.
name|ref_regular
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|ref_dynamic
operator||=
name|fh
operator|->
name|elf
operator|.
name|ref_dynamic
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|ref_regular_nonweak
operator||=
name|fh
operator|->
name|elf
operator|.
name|ref_regular_nonweak
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|non_got_ref
operator||=
name|fh
operator|->
name|elf
operator|.
name|non_got_ref
expr_stmt|;
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|fh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
block|{
name|move_plt_plist
argument_list|(
name|fh
argument_list|,
name|fdh
argument_list|)
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|needs_plt
operator|=
literal|1
expr_stmt|;
block|}
name|fdh
operator|->
name|is_func_descriptor
operator|=
literal|1
expr_stmt|;
name|fdh
operator|->
name|oh
operator|=
name|fh
expr_stmt|;
name|fh
operator|->
name|oh
operator|=
name|fdh
expr_stmt|;
block|}
comment|/* Now that the info is on the function descriptor, clear the      function code sym info.  Any function code syms for which we      don't have a definition in a regular file, we force local.      This prevents a shared library from exporting syms that have      been imported from another library.  Function code syms that      are really in the library we must leave global to prevent the      linker dragging in a definition from a static library.  */
name|force_local
operator|=
operator|(
operator|!
name|fh
operator|->
name|elf
operator|.
name|def_regular
operator|||
name|fdh
operator|==
name|NULL
operator|||
operator|!
name|fdh
operator|->
name|elf
operator|.
name|def_regular
operator|||
name|fdh
operator|->
name|elf
operator|.
name|forced_local
operator|)
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|fh
operator|->
name|elf
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called near the start of bfd_elf_size_dynamic_sections.  We use    this hook to a) provide some gcc support functions, and b) transfer    dynamic linking information gathered so far on function code symbol    entries, to their corresponding function descriptor symbol entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_func_desc_adjust
parameter_list|(
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|sfpr_def_parms
name|funcs
index|[]
init|=
block|{
block|{
literal|"_savegpr0_"
block|,
literal|14
block|,
literal|31
block|,
name|savegpr0
block|,
name|savegpr0_tail
block|}
block|,
block|{
literal|"_restgpr0_"
block|,
literal|14
block|,
literal|29
block|,
name|restgpr0
block|,
name|restgpr0_tail
block|}
block|,
block|{
literal|"_restgpr0_"
block|,
literal|30
block|,
literal|31
block|,
name|restgpr0
block|,
name|restgpr0_tail
block|}
block|,
block|{
literal|"_savegpr1_"
block|,
literal|14
block|,
literal|31
block|,
name|savegpr1
block|,
name|savegpr1_tail
block|}
block|,
block|{
literal|"_restgpr1_"
block|,
literal|14
block|,
literal|31
block|,
name|restgpr1
block|,
name|restgpr1_tail
block|}
block|,
block|{
literal|"_savefpr_"
block|,
literal|14
block|,
literal|31
block|,
name|savefpr
block|,
name|savefpr0_tail
block|}
block|,
block|{
literal|"_restfpr_"
block|,
literal|14
block|,
literal|29
block|,
name|restfpr
block|,
name|restfpr0_tail
block|}
block|,
block|{
literal|"_restfpr_"
block|,
literal|30
block|,
literal|31
block|,
name|restfpr
block|,
name|restfpr0_tail
block|}
block|,
block|{
literal|"._savef"
block|,
literal|14
block|,
literal|31
block|,
name|savefpr
block|,
name|savefpr1_tail
block|}
block|,
block|{
literal|"._restf"
block|,
literal|14
block|,
literal|31
block|,
name|restfpr
block|,
name|restfpr1_tail
block|}
block|,
block|{
literal|"_savevr_"
block|,
literal|20
block|,
literal|31
block|,
name|savevr
block|,
name|savevr_tail
block|}
block|,
block|{
literal|"_restvr_"
block|,
literal|20
block|,
literal|31
block|,
name|restvr
block|,
name|restvr_tail
block|}
block|}
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|==
name|NULL
condition|)
comment|/* We don't have any relocs.  */
return|return
name|TRUE
return|;
comment|/* Provide any missing _save* and _rest* functions.  */
name|htab
operator|->
name|sfpr
operator|->
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|funcs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|funcs
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|sfpr_define
argument_list|(
name|info
argument_list|,
operator|&
name|funcs
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|func_desc_adjust
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|->
name|size
operator|==
literal|0
condition|)
name|htab
operator|->
name|sfpr
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Deal with function syms.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
condition|)
block|{
comment|/* Clear procedure linkage table information for any symbol that 	 won't need a .plt entry.  */
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
operator|||
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
name|h
operator|->
name|non_got_ref
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|non_got_ref
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
condition|)
return|return
name|TRUE
return|;
comment|/* Don't generate a copy reloc for symbols defined in the executable.  */
if|if
condition|(
operator|!
name|h
operator|->
name|def_dynamic
operator|||
operator|!
name|h
operator|->
name|ref_regular
operator|||
name|h
operator|->
name|def_regular
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in read-only sections, then 	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|non_got_ref
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|plist
operator|!=
name|NULL
condition|)
block|{
comment|/* We should never get here, but unfortunately there are versions 	 of gcc out there that improperly (for this ABI) put initialized 	 function pointers, vtable refs and suchlike in read-only 	 sections.  Allow them to proceed, but warn that this might 	 break at runtime.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"copy reloc against `%s' requires lazy plt linking; "
literal|"avoid setting LD_BIND_NOW=1 or upgrade gcc"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynamic variable `%s' is zero size"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
comment|/* We must generate a R_PPC64_COPY reloc to tell the dynamic linker      to copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|relbss
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|htab
operator|->
name|dynbss
expr_stmt|;
return|return
name|_bfd_elf_adjust_dynamic_copy
argument_list|(
name|h
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If given a function descriptor symbol, hide both the function code    sym and the descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_hide_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_boolean
name|force_local
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|is_func_descriptor
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|fh
init|=
name|eh
operator|->
name|oh
decl_stmt|;
if|if
condition|(
name|fh
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* We aren't supposed to use alloca in BFD because on 	     systems which do not have alloca the version in libiberty 	     calls xmalloc, which might cause the program to crash 	     when it runs out of memory.  This function doesn't have a 	     return status, so there's no way to gracefully return an 	     error.  So cheat.  We know that string[-1] can be safely 	     accessed;  It's either a string in an ELF string table, 	     or allocated in an objalloc structure.  */
name|p
operator|=
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|-
literal|1
expr_stmt|;
name|save
operator|=
operator|*
name|p
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|p
operator|=
literal|'.'
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|p
operator|=
name|save
expr_stmt|;
comment|/* Unfortunately, if it so happens that the string we were 	     looking for was allocated immediately before this string, 	     then we overwrote the string terminator.  That's the only 	     reason the lookup should fail.  */
if|if
condition|(
name|fh
operator|==
name|NULL
condition|)
block|{
name|q
operator|=
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|+
name|strlen
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|>=
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|&&
operator|*
name|q
operator|==
operator|*
name|p
condition|)
operator|--
name|q
operator|,
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|q
operator|<
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|&&
operator|*
name|p
operator|==
literal|'.'
condition|)
name|fh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fh
operator|!=
name|NULL
condition|)
block|{
name|eh
operator|->
name|oh
operator|=
name|fh
expr_stmt|;
name|fh
operator|->
name|oh
operator|=
name|eh
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fh
operator|!=
name|NULL
condition|)
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|fh
operator|->
name|elf
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|get_sym_h
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hp
parameter_list|,
name|Elf_Internal_Sym
modifier|*
modifier|*
name|symp
parameter_list|,
name|asection
modifier|*
modifier|*
name|symsecp
parameter_list|,
name|char
modifier|*
modifier|*
name|tls_maskp
parameter_list|,
name|Elf_Internal_Sym
modifier|*
modifier|*
name|locsymsp
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
init|=
name|elf_sym_hashes
argument_list|(
name|ibfd
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
operator|*
name|hp
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|symp
operator|!=
name|NULL
condition|)
operator|*
name|symp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symsecp
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|symsec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|symsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
operator|*
name|symsecp
operator|=
name|symsec
expr_stmt|;
block|}
if|if
condition|(
name|tls_maskp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
operator|*
name|tls_maskp
operator|=
operator|&
name|eh
operator|->
name|tls_mask
expr_stmt|;
block|}
block|}
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|locsyms
init|=
operator|*
name|locsymsp
decl_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
block|{
name|locsyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
name|locsyms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|locsymsp
operator|=
name|locsyms
expr_stmt|;
block|}
name|sym
operator|=
name|locsyms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
operator|*
name|hp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symp
operator|!=
name|NULL
condition|)
operator|*
name|symp
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|symsecp
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|symsec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|)
operator|||
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
name|symsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|ibfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|symsecp
operator|=
name|symsec
expr_stmt|;
block|}
if|if
condition|(
name|tls_maskp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|got_entry
modifier|*
modifier|*
name|lgot_ents
decl_stmt|;
name|char
modifier|*
name|tls_mask
decl_stmt|;
name|tls_mask
operator|=
name|NULL
expr_stmt|;
name|lgot_ents
operator|=
name|elf_local_got_ents
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lgot_ents
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|lgot_masks
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lgot_ents
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
decl_stmt|;
name|tls_mask
operator|=
operator|&
name|lgot_masks
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
operator|*
name|tls_maskp
operator|=
name|tls_mask
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Returns TLS_MASKP for the given REL symbol.  Function return is 0 on    error, 2 on a toc GD type suitable for optimization, 3 on a toc LD    type suitable for optimization, and 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|get_tls_mask
parameter_list|(
name|char
modifier|*
modifier|*
name|tls_maskp
parameter_list|,
name|unsigned
name|long
modifier|*
name|toc_symndx
parameter_list|,
name|Elf_Internal_Sym
modifier|*
modifier|*
name|locsymsp
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|next_r
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|tls_maskp
argument_list|,
name|locsymsp
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|*
name|tls_maskp
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|tls_maskp
operator|!=
literal|0
operator|)
operator|||
name|sec
operator|==
name|NULL
operator|||
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_type
operator|!=
name|sec_toc
condition|)
return|return
literal|1
return|;
comment|/* Look inside a TOC section too.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
name|off
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
else|else
name|off
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|off
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|t_symndx
index|[
name|off
operator|/
literal|8
index|]
expr_stmt|;
name|next_r
operator|=
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|t_symndx
index|[
name|off
operator|/
literal|8
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|tls_maskp
argument_list|,
name|locsymsp
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|toc_symndx
operator|!=
name|NULL
condition|)
operator|*
name|toc_symndx
operator|=
name|r_symndx
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|==
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|h
operator|->
name|def_dynamic
operator|)
operator|)
operator|&&
operator|(
name|next_r
operator|==
operator|-
literal|1
operator|||
name|next_r
operator|==
operator|-
literal|2
operator|)
condition|)
return|return
literal|1
operator|-
name|next_r
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Adjust all global syms defined in opd sections.  In gcc generated    code for the old ABI, these will already have been done.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|adjust_opd_syms
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|long
modifier|*
name|opd_adjust
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
return|return
name|TRUE
return|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|adjust_done
condition|)
return|return
name|TRUE
return|;
name|sym_sec
operator|=
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|opd_adjust
operator|=
name|get_opd_info
argument_list|(
name|sym_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_adjust
operator|!=
name|NULL
condition|)
block|{
name|long
name|adjust
init|=
name|opd_adjust
index|[
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|/
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|adjust
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This entry has been deleted.  */
name|asection
modifier|*
name|dsec
init|=
name|ppc64_elf_tdata
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|)
operator|->
name|deleted_section
decl_stmt|;
if|if
condition|(
name|dsec
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|dsec
operator|=
name|sym_sec
operator|->
name|owner
operator|->
name|sections
init|;
name|dsec
condition|;
name|dsec
operator|=
name|dsec
operator|->
name|next
control|)
if|if
condition|(
name|elf_discarded_section
argument_list|(
name|dsec
argument_list|)
condition|)
block|{
name|ppc64_elf_tdata
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|)
operator|->
name|deleted_section
operator|=
name|dsec
expr_stmt|;
break|break;
block|}
block|}
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|dsec
expr_stmt|;
block|}
else|else
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+=
name|adjust
expr_stmt|;
name|eh
operator|->
name|adjust_done
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Handles decrementing dynamic reloc counts for the reloc specified by    R_INFO in section SEC.  If LOCAL_SYMS is NULL, then H and SYM_SEC    have already been determined.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|dec_dynrel_count
parameter_list|(
name|bfd_vma
name|r_info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
modifier|*
name|local_syms
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|asection
modifier|*
name|sym_sec
parameter_list|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
comment|/* Can this reloc be dynamic?  This switch, and later tests here      should be kept in sync with the code in check_relocs.  */
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
return|return
name|TRUE
return|;
case|case
name|R_PPC64_TPREL16
case|:
case|case
name|R_PPC64_TPREL16_LO
case|:
case|case
name|R_PPC64_TPREL16_HI
case|:
case|case
name|R_PPC64_TPREL16_HA
case|:
case|case
name|R_PPC64_TPREL16_DS
case|:
case|case
name|R_PPC64_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_TPREL16_HIGHER
case|:
case|case
name|R_PPC64_TPREL16_HIGHERA
case|:
case|case
name|R_PPC64_TPREL16_HIGHEST
case|:
case|case
name|R_PPC64_TPREL16_HIGHESTA
case|:
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
case|case
name|R_PPC64_TPREL64
case|:
case|case
name|R_PPC64_DTPMOD64
case|:
case|case
name|R_PPC64_DTPREL64
case|:
case|case
name|R_PPC64_ADDR64
case|:
case|case
name|R_PPC64_REL30
case|:
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL64
case|:
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
case|case
name|R_PPC64_TOC
case|:
break|break;
block|}
if|if
condition|(
name|local_syms
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|bfd
modifier|*
name|ibfd
init|=
name|sec
operator|->
name|owner
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
name|local_syms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|pp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sym_sec
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|vpp
init|=
operator|&
name|elf_section_data
argument_list|(
name|sym_sec
argument_list|)
operator|->
name|local_dynrel
decl_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
name|vpp
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|vpp
init|=
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
decl_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
name|vpp
expr_stmt|;
block|}
comment|/* elf_gc_sweep may have already removed all dyn relocs associated 	 with local syms for a given section.  Don't report a dynreloc 	 miscount.  */
if|if
condition|(
operator|*
name|pp
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
block|}
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
if|if
condition|(
operator|!
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
name|p
operator|->
name|pc_count
operator|-=
literal|1
expr_stmt|;
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynreloc miscount for %B, section %A"
argument_list|)
argument_list|,
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Remove unused Official Procedure Descriptor entries.  Currently we    only remove those associated with functions in discarded link-once    sections, or weakly defined functions that have been overridden.  It    would be possible to remove many more entries for statically linked    applications.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_edit_opd
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|no_opd_opt
parameter_list|,
name|bfd_boolean
name|non_overlapping
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd_boolean
name|some_edited
init|=
name|FALSE
decl_stmt|;
name|asection
modifier|*
name|need_pad
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|long
modifier|*
name|opd_adjust
decl_stmt|;
name|bfd_boolean
name|need_edit
decl_stmt|,
name|add_aux_fields
decl_stmt|;
name|bfd_size_type
name|cnt_16b
init|=
literal|0
decl_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|size
operator|==
literal|0
condition|)
continue|continue;
name|amt
operator|=
name|sec
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
literal|8
expr_stmt|;
name|opd_adjust
operator|=
name|get_opd_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_adjust
operator|==
name|NULL
condition|)
block|{
comment|/* check_relocs hasn't been called.  Must be a ld -r link 	     or --just-symbols object.   */
name|opd_adjust
operator|=
name|bfd_alloc
argument_list|(
name|obfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_adjust
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|opd_adjust
operator|=
name|opd_adjust
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_type
operator|==
name|sec_normal
argument_list|)
expr_stmt|;
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_type
operator|=
name|sec_opd
expr_stmt|;
block|}
name|memset
argument_list|(
name|opd_adjust
argument_list|,
literal|0
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_opd_opt
condition|)
continue|continue;
if|if
condition|(
name|sec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_JUST_SYMS
condition|)
continue|continue;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
continue|continue;
comment|/* Look through the section relocs.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|local_syms
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
comment|/* Read the relocations.  */
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* First run through the relocs to check they are sane, and to 	 determine whether we need to edit this opd section.  */
name|need_edit
operator|=
name|FALSE
expr_stmt|;
name|need_pad
operator|=
name|sec
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
comment|/* .opd contains a regular array of 16 or 24 byte entries.  We're 	     only interested in the reloc pointing to a function entry 	     point.  */
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|!=
name|offset
operator|||
name|rel
operator|+
literal|1
operator|>=
name|relend
operator|||
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_offset
operator|!=
name|offset
operator|+
literal|8
condition|)
block|{
comment|/* If someone messes with .opd alignment then after a 		 "ld -r" we might have padding in the middle of .opd. 		 Also, there's nothing to prevent someone putting 		 something silly in .opd with the assembler.  No .opd 		 optimization for them!  */
name|broken_opd
label|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: .opd is not a regular array of opd entries"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|need_edit
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|)
operator|!=
name|R_PPC64_ADDR64
operator|||
operator|(
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|)
operator|)
operator|!=
name|R_PPC64_TOC
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unexpected reloc type %u in .opd section"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|need_edit
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
name|sym_name
operator|=
name|bfd_elf_sym_name
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|sym
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: undefined sym `%s' in .opd section"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|need_edit
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* opd entries are always for functions defined in the 	     current input bfd.  If the symbol isn't defined in the 	     input bfd, then we won't be using the function in this 	     bfd;  It must be defined in a linkonce section in another 	     bfd, or is weak.  It's also possible that we are 	     discarding the function due to a linker script /DISCARD/, 	     which we test for via the output_section.  */
if|if
condition|(
name|sym_sec
operator|->
name|owner
operator|!=
name|ibfd
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
name|need_edit
operator|=
name|TRUE
expr_stmt|;
name|rel
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|rel
operator|==
name|relend
operator|||
operator|(
name|rel
operator|+
literal|1
operator|==
name|relend
operator|&&
name|rel
operator|->
name|r_offset
operator|==
name|offset
operator|+
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|sec
operator|->
name|size
operator|==
name|offset
operator|+
literal|24
condition|)
block|{
name|need_pad
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rel
operator|==
name|relend
operator|&&
name|sec
operator|->
name|size
operator|==
name|offset
operator|+
literal|16
condition|)
block|{
name|cnt_16b
operator|++
expr_stmt|;
break|break;
block|}
goto|goto
name|broken_opd
goto|;
block|}
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|==
name|offset
operator|+
literal|24
condition|)
name|offset
operator|+=
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|!=
name|offset
operator|+
literal|16
condition|)
goto|goto
name|broken_opd
goto|;
elseif|else
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_ADDR64
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC
condition|)
block|{
name|offset
operator|+=
literal|16
expr_stmt|;
name|cnt_16b
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rel
operator|+
literal|2
operator|<
name|relend
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_ADDR64
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|2
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC
condition|)
block|{
name|offset
operator|+=
literal|24
expr_stmt|;
name|rel
operator|+=
literal|1
expr_stmt|;
block|}
else|else
goto|goto
name|broken_opd
goto|;
block|}
name|add_aux_fields
operator|=
name|non_overlapping
operator|&&
name|cnt_16b
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|need_edit
operator|||
name|add_aux_fields
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|write_rel
decl_stmt|;
name|bfd_byte
modifier|*
name|rptr
decl_stmt|,
modifier|*
name|wptr
decl_stmt|;
name|bfd_byte
modifier|*
name|new_contents
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|;
name|long
name|opd_ent_size
decl_stmt|;
comment|/* This seems a waste of time as input .opd sections are all 	     zeros as generated by gcc, but I suppose there's no reason 	     this will always be so.  We might start putting something in 	     the third word of .opd entries.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_IN_MEMORY
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
operator|&
name|loc
argument_list|)
condition|)
block|{
if|if
condition|(
name|loc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|error_ret
label|:
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sec
operator|->
name|contents
operator|=
name|loc
expr_stmt|;
name|sec
operator|->
name|flags
operator||=
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|relstart
expr_stmt|;
name|new_contents
operator|=
name|sec
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|add_aux_fields
condition|)
block|{
name|new_contents
operator|=
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|size
operator|+
name|cnt_16b
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|need_pad
operator|=
name|FALSE
expr_stmt|;
block|}
name|wptr
operator|=
name|new_contents
expr_stmt|;
name|rptr
operator|=
name|sec
operator|->
name|contents
expr_stmt|;
name|write_rel
operator|=
name|relstart
expr_stmt|;
name|skip
operator|=
name|FALSE
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|opd_ent_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|==
name|offset
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
init|=
name|NULL
decl_stmt|;
comment|/* See if the .opd entry is full 24 byte or 		     16 byte (with fd_aux entry overlapped with next 		     fd_func).  */
name|opd_ent_size
operator|=
literal|24
expr_stmt|;
if|if
condition|(
operator|(
name|rel
operator|+
literal|2
operator|==
name|relend
operator|&&
name|sec
operator|->
name|size
operator|==
name|offset
operator|+
literal|16
operator|)
operator|||
operator|(
name|rel
operator|+
literal|3
operator|<
name|relend
operator|&&
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|==
name|offset
operator|+
literal|16
operator|&&
name|rel
index|[
literal|3
index|]
operator|.
name|r_offset
operator|==
name|offset
operator|+
literal|24
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|2
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_ADDR64
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|3
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC
operator|)
condition|)
name|opd_ent_size
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|fdh
operator|=
name|get_fdh
argument_list|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|!=
name|NULL
operator|&&
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|fdh
operator|=
name|NULL
expr_stmt|;
block|}
name|skip
operator|=
operator|(
name|sym_sec
operator|->
name|owner
operator|!=
name|ibfd
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
if|if
condition|(
name|fdh
operator|!=
name|NULL
operator|&&
name|sym_sec
operator|->
name|owner
operator|==
name|ibfd
condition|)
block|{
comment|/* Arrange for the function descriptor sym 			     to be dropped.  */
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|sym_sec
expr_stmt|;
block|}
name|opd_adjust
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We'll be keeping this opd entry.  */
if|if
condition|(
name|fdh
operator|!=
name|NULL
condition|)
block|{
comment|/* Redefine the function descriptor symbol to 			     this location in the opd section.  It is 			     necessary to update the value here rather 			     than using an array of adjustments as we do 			     for local symbols, because various places 			     in the generic ELF code use the value 			     stored in u.def.value.  */
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|wptr
operator|-
name|new_contents
expr_stmt|;
name|fdh
operator|->
name|adjust_done
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Local syms are a bit tricky.  We could 			 tweak them as they can be cached, but 			 we'd need to look through the local syms 			 for the function descriptor sym which we 			 don't have at the moment.  So keep an 			 array of adjustments.  */
name|opd_adjust
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
index|]
operator|=
operator|(
name|wptr
operator|-
name|new_contents
operator|)
operator|-
operator|(
name|rptr
operator|-
name|sec
operator|->
name|contents
operator|)
expr_stmt|;
if|if
condition|(
name|wptr
operator|!=
name|rptr
condition|)
name|memcpy
argument_list|(
name|wptr
argument_list|,
name|rptr
argument_list|,
name|opd_ent_size
argument_list|)
expr_stmt|;
name|wptr
operator|+=
name|opd_ent_size
expr_stmt|;
if|if
condition|(
name|add_aux_fields
operator|&&
name|opd_ent_size
operator|==
literal|16
condition|)
block|{
name|memset
argument_list|(
name|wptr
argument_list|,
literal|'\0'
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|wptr
operator|+=
literal|8
expr_stmt|;
block|}
block|}
name|rptr
operator|+=
name|opd_ent_size
expr_stmt|;
name|offset
operator|+=
name|opd_ent_size
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
block|{
if|if
condition|(
operator|!
name|NO_OPD_RELOCS
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|!
name|dec_dynrel_count
argument_list|(
name|rel
operator|->
name|r_info
argument_list|,
name|sec
argument_list|,
name|info
argument_list|,
name|NULL
argument_list|,
name|h
argument_list|,
name|sym_sec
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
block|}
else|else
block|{
comment|/* We need to adjust any reloc offsets to point to the 		     new opd entries.  While we're at it, we may as well 		     remove redundant relocs.  */
name|rel
operator|->
name|r_offset
operator|+=
name|opd_adjust
index|[
operator|(
name|offset
operator|-
name|opd_ent_size
operator|)
operator|/
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|write_rel
operator|!=
name|rel
condition|)
name|memcpy
argument_list|(
name|write_rel
argument_list|,
name|rel
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rel
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|write_rel
expr_stmt|;
block|}
block|}
name|sec
operator|->
name|size
operator|=
name|wptr
operator|-
name|new_contents
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
name|write_rel
operator|-
name|relstart
expr_stmt|;
if|if
condition|(
name|add_aux_fields
condition|)
block|{
name|free
argument_list|(
name|sec
operator|->
name|contents
argument_list|)
expr_stmt|;
name|sec
operator|->
name|contents
operator|=
name|new_contents
expr_stmt|;
block|}
comment|/* Fudge the header size too, as this is used later in 	     elf_bfd_final_link if we are emitting relocs.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_size
operator|=
name|sec
operator|->
name|reloc_count
operator|*
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|some_edited
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
block|}
if|if
condition|(
name|some_edited
condition|)
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|adjust_opd_syms
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we are doing a final link and the last .opd entry is just 16 byte      long, add a 8 byte padding after it.  */
if|if
condition|(
name|need_pad
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|bfd_byte
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|need_pad
operator|->
name|flags
operator|&
name|SEC_IN_MEMORY
operator|)
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|need_pad
operator|->
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|bfd_malloc
argument_list|(
name|need_pad
operator|->
name|size
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|need_pad
operator|->
name|owner
argument_list|,
name|need_pad
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
name|need_pad
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|need_pad
operator|->
name|contents
operator|=
name|p
expr_stmt|;
name|need_pad
operator|->
name|flags
operator||=
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|bfd_realloc
argument_list|(
name|need_pad
operator|->
name|contents
argument_list|,
name|need_pad
operator|->
name|size
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|need_pad
operator|->
name|contents
operator|=
name|p
expr_stmt|;
block|}
name|memset
argument_list|(
name|need_pad
operator|->
name|contents
operator|+
name|need_pad
operator|->
name|size
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|need_pad
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */
end_comment

begin_function
name|asection
modifier|*
name|ppc64_elf_tls_setup
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|tls_get_addr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
init|=
name|htab
operator|->
name|tls_get_addr
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|htab
operator|->
name|tls_get_addr
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|tls_get_addr_fd
operator|==
name|NULL
operator|&&
name|h
operator|->
name|oh
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|oh
operator|->
name|is_func_descriptor
operator|&&
operator|(
name|h
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|htab
operator|->
name|tls_get_addr_fd
operator|=
name|h
operator|->
name|oh
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|tls_get_addr_fd
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
init|=
name|htab
operator|->
name|tls_get_addr_fd
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|htab
operator|->
name|tls_get_addr_fd
operator|=
name|h
expr_stmt|;
block|}
return|return
name|_bfd_elf_tls_setup
argument_list|(
name|obfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Run through all the TLS relocs looking for optimization    opportunities.  The linker has been hacked (see ppc64elf.em) to do    a preliminary section layout so that we know the TLS segment    offsets.  We can't optimize earlier because some optimizations need    to know the tp offset, and we need to optimize before allocating    dynamic relocations.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_tls_optimize
parameter_list|(
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|locsyms
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|toc
init|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
literal|".toc"
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|toc_ref
init|=
name|NULL
decl_stmt|;
comment|/* Look at all the sections for this file, with TOC last.  */
for|for
control|(
name|sec
operator|=
operator|(
name|ibfd
operator|->
name|sections
operator|==
name|toc
operator|&&
name|toc
operator|&&
name|toc
operator|->
name|next
condition|?
name|toc
operator|->
name|next
else|:
name|ibfd
operator|->
name|sections
operator|)
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
operator|(
name|sec
operator|==
name|toc
condition|?
name|NULL
else|:
name|sec
operator|->
name|next
operator|==
name|NULL
condition|?
name|toc
else|:
name|sec
operator|->
name|next
operator|==
name|toc
operator|&&
name|toc
operator|->
name|next
condition|?
name|toc
operator|->
name|next
else|:
name|sec
operator|->
name|next
operator|)
control|)
if|if
condition|(
name|sec
operator|->
name|has_tls_reloc
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|int
name|expecting_tls_get_addr
decl_stmt|;
name|long
name|toc_ref_index
init|=
literal|0
decl_stmt|;
comment|/* Read the relocations.  */
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|char
modifier|*
name|tls_mask
decl_stmt|;
name|char
name|tls_set
decl_stmt|,
name|tls_clear
decl_stmt|,
name|tls_type
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_boolean
name|ok_tprel
decl_stmt|,
name|is_local
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
operator|&
name|tls_mask
argument_list|,
operator|&
name|locsyms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
block|{
name|err_free_rel
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|toc_ref
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|toc_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|locsyms
operator|!=
name|NULL
operator|&&
operator|(
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
operator|)
condition|)
name|free
argument_list|(
name|locsyms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
continue|continue;
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
else|else
comment|/* Symbols referenced by TLS relocs must be of type 		     STT_TLS.  So no need for .opd local sym adjust.  */
name|value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ok_tprel
operator|=
name|FALSE
expr_stmt|;
name|is_local
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|!
name|h
operator|->
name|def_dynamic
condition|)
block|{
name|is_local
operator|=
name|TRUE
expr_stmt|;
name|value
operator|+=
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|+=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
expr_stmt|;
name|ok_tprel
operator|=
operator|(
name|value
operator|+
name|TP_OFFSET
operator|+
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|<
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
comment|/* These relocs should never be against a symbol 		       defined in a shared lib.  Leave them alone if 		       that turns out to be the case.  */
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|refcount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|is_local
condition|)
continue|continue;
comment|/* LD -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
name|tls_clear
operator|=
name|TLS_LD
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
name|expecting_tls_get_addr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
if|if
condition|(
name|ok_tprel
condition|)
comment|/* GD -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
else|else
comment|/* GD -> IE */
name|tls_set
operator|=
name|TLS_TLS
operator||
name|TLS_TPRELGD
expr_stmt|;
name|tls_clear
operator|=
name|TLS_GD
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
name|expecting_tls_get_addr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_HI
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ok_tprel
condition|)
block|{
comment|/* IE -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
name|tls_clear
operator|=
name|TLS_TPREL
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|==
operator|&
name|htab
operator|->
name|tls_get_addr
operator|->
name|elf
operator|||
name|h
operator|==
operator|&
name|htab
operator|->
name|tls_get_addr_fd
operator|->
name|elf
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|expecting_tls_get_addr
operator|&&
name|rel
operator|!=
name|relstart
operator|&&
operator|(
operator|(
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC16
operator|)
operator|||
operator|(
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC16_LO
operator|)
operator|)
condition|)
block|{
comment|/* Check for toc tls entries.  */
name|char
modifier|*
name|toc_tls
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|get_tls_mask
argument_list|(
operator|&
name|toc_tls
argument_list|,
name|NULL
argument_list|,
operator|&
name|locsyms
argument_list|,
name|rel
operator|-
literal|1
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
goto|goto
name|err_free_rel
goto|;
if|if
condition|(
name|retval
operator|>
literal|1
operator|&&
name|toc_tls
operator|!=
name|NULL
condition|)
block|{
name|expecting_tls_get_addr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|toc_ref
operator|!=
name|NULL
condition|)
name|toc_ref
index|[
name|toc_ref_index
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expecting_tls_get_addr
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TLS
case|:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|==
name|toc
operator|&&
name|toc
operator|!=
name|NULL
condition|)
block|{
comment|/* Mark this toc entry as referenced by a TLS 			   code sequence.  We can do that now in the 			   case of R_PPC64_TLS, and after checking for 			   tls_get_addr for the TOC16 relocs.  */
if|if
condition|(
name|toc_ref
operator|==
name|NULL
condition|)
block|{
name|toc_ref
operator|=
name|bfd_zmalloc
argument_list|(
name|toc
operator|->
name|size
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|toc_ref
operator|==
name|NULL
condition|)
goto|goto
name|err_free_rel
goto|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|value
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|value
operator|<
name|toc
operator|->
name|size
operator|&&
name|value
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|toc_ref_index
operator|=
name|value
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_TLS
condition|)
name|toc_ref
index|[
name|toc_ref_index
index|]
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
name|R_PPC64_TPREL64
case|:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|toc
operator|||
name|toc_ref
operator|==
name|NULL
operator|||
operator|!
name|toc_ref
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
index|]
condition|)
continue|continue;
if|if
condition|(
name|ok_tprel
condition|)
block|{
comment|/* IE -> LE */
name|tls_set
operator|=
name|TLS_EXPLICIT
expr_stmt|;
name|tls_clear
operator|=
name|TLS_TPREL
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
case|case
name|R_PPC64_DTPMOD64
case|:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|toc
operator|||
name|toc_ref
operator|==
name|NULL
operator|||
operator|!
name|toc_ref
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
index|]
condition|)
continue|continue;
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
operator|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
operator|)
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|==
name|rel
operator|->
name|r_offset
operator|+
literal|8
condition|)
block|{
if|if
condition|(
name|ok_tprel
condition|)
comment|/* GD -> LE */
name|tls_set
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_GD
expr_stmt|;
else|else
comment|/* GD -> IE */
name|tls_set
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_GD
operator||
name|TLS_TPRELGD
expr_stmt|;
name|tls_clear
operator|=
name|TLS_GD
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|is_local
condition|)
continue|continue;
comment|/* LD -> LE */
name|tls_set
operator|=
name|TLS_EXPLICIT
expr_stmt|;
name|tls_clear
operator|=
name|TLS_LD
expr_stmt|;
block|}
break|break;
default|default:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|tls_set
operator|&
name|TLS_EXPLICIT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
comment|/* Adjust got entry for this reloc.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|ent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
expr_stmt|;
else|else
name|ent
operator|=
name|elf_local_got_ents
argument_list|(
name|ibfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
for|for
control|(
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|ibfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tls_set
operator|==
literal|0
condition|)
block|{
comment|/* We managed to get rid of a got entry.  */
if|if
condition|(
name|ent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we got rid of a DTPMOD/DTPREL reloc pair then 		       we'll lose one or two dyn relocs.  */
if|if
condition|(
operator|!
name|dec_dynrel_count
argument_list|(
name|rel
operator|->
name|r_info
argument_list|,
name|sec
argument_list|,
name|info
argument_list|,
name|NULL
argument_list|,
name|h
argument_list|,
name|sym_sec
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|tls_set
operator|==
operator|(
name|TLS_EXPLICIT
operator||
name|TLS_GD
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|dec_dynrel_count
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|,
name|sec
argument_list|,
name|info
argument_list|,
name|NULL
argument_list|,
name|h
argument_list|,
name|sym_sec
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
operator|*
name|tls_mask
operator||=
name|tls_set
expr_stmt|;
operator|*
name|tls_mask
operator|&=
operator|~
name|tls_clear
expr_stmt|;
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toc_ref
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|toc_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|locsyms
operator|!=
name|NULL
operator|&&
operator|(
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|locsyms
argument_list|)
expr_stmt|;
else|else
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called via elf_link_hash_traverse from ppc64_elf_edit_toc to adjust    the values of any global symbols in a toc section that has been    edited.  Globals in toc sections should be a rarity, so this function    sets a flag if any are found in toc sections other than the one just    edited, so that futher hash table traversals can be avoided.  */
end_comment

begin_struct
struct|struct
name|adjust_toc_info
block|{
name|asection
modifier|*
name|toc
decl_stmt|;
name|unsigned
name|long
modifier|*
name|skip
decl_stmt|;
name|bfd_boolean
name|global_toc_syms
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|adjust_toc_syms
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|adjust_toc_info
modifier|*
name|toc_inf
init|=
operator|(
expr|struct
name|adjust_toc_info
operator|*
operator|)
name|inf
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
return|return
name|TRUE
return|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|adjust_done
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|toc_inf
operator|->
name|toc
condition|)
block|{
name|unsigned
name|long
name|skip
init|=
name|toc_inf
operator|->
name|skip
index|[
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>>
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|skip
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|skip
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s defined in removed toc entry"
argument_list|)
argument_list|,
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
operator|&
name|bfd_abs_section
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|eh
operator|->
name|adjust_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|name
argument_list|,
literal|".toc"
argument_list|)
operator|==
literal|0
condition|)
name|toc_inf
operator|->
name|global_toc_syms
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Examine all relocs referencing .toc sections in order to remove    unused .toc entries.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_edit_toc
parameter_list|(
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|struct
name|adjust_toc_info
name|toc_inf
decl_stmt|;
name|toc_inf
operator|.
name|global_toc_syms
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|toc
decl_stmt|,
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|;
name|unsigned
name|long
modifier|*
name|skip
decl_stmt|,
modifier|*
name|drop
decl_stmt|;
name|unsigned
name|char
modifier|*
name|used
decl_stmt|;
name|unsigned
name|char
modifier|*
name|keep
decl_stmt|,
name|last
decl_stmt|,
name|some_unused
decl_stmt|;
name|toc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
literal|".toc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|toc
operator|==
name|NULL
operator|||
name|toc
operator|->
name|size
operator|==
literal|0
operator|||
name|toc
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_JUST_SYMS
operator|||
name|elf_discarded_section
argument_list|(
name|toc
argument_list|)
condition|)
continue|continue;
name|local_syms
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
comment|/* Look at sections dropped from the final link.  */
name|skip
operator|=
name|NULL
expr_stmt|;
name|relstart
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|!
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
operator|||
name|get_opd_info
argument_list|(
name|sec
argument_list|)
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
goto|goto
name|error_ret
goto|;
comment|/* Run through the relocs to see which toc entries might be 	     unused.  */
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
condition|;
operator|++
name|rel
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
continue|continue;
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
break|break;
block|}
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
if|if
condition|(
name|sym_sec
operator|!=
name|toc
condition|)
continue|continue;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|val
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|val
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|val
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|toc
operator|->
name|size
condition|)
continue|continue;
comment|/* Anything in the toc ought to be aligned to 8 bytes. 		 If not, don't mark as unused.  */
if|if
condition|(
name|val
operator|&
literal|7
condition|)
continue|continue;
if|if
condition|(
name|skip
operator|==
name|NULL
condition|)
block|{
name|skip
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|skip
argument_list|)
operator|*
operator|(
name|toc
operator|->
name|size
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|==
name|NULL
condition|)
goto|goto
name|error_ret
goto|;
block|}
name|skip
index|[
name|val
operator|>>
literal|3
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skip
operator|==
name|NULL
condition|)
continue|continue;
name|used
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|used
argument_list|)
operator|*
operator|(
name|toc
operator|->
name|size
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
operator|==
name|NULL
condition|)
block|{
name|error_ret
label|:
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|relstart
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|skip
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now check all kept sections that might reference the toc. 	 Check the toc itself last.  */
for|for
control|(
name|sec
operator|=
operator|(
name|ibfd
operator|->
name|sections
operator|==
name|toc
operator|&&
name|toc
operator|->
name|next
condition|?
name|toc
operator|->
name|next
else|:
name|ibfd
operator|->
name|sections
operator|)
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
operator|(
name|sec
operator|==
name|toc
condition|?
name|NULL
else|:
name|sec
operator|->
name|next
operator|==
name|NULL
condition|?
name|toc
else|:
name|sec
operator|->
name|next
operator|==
name|toc
operator|&&
name|toc
operator|->
name|next
condition|?
name|toc
operator|->
name|next
else|:
name|sec
operator|->
name|next
operator|)
control|)
block|{
name|int
name|repeat
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
operator|||
name|get_opd_info
argument_list|(
name|sec
argument_list|)
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
goto|goto
name|error_ret
goto|;
comment|/* Mark toc entries referenced as used.  */
name|repeat
operator|=
literal|0
expr_stmt|;
do|do
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
condition|;
operator|++
name|rel
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
comment|/* In case we're taking addresses of toc entries.  */
case|case
name|R_PPC64_ADDR64
case|:
break|break;
default|default:
continue|continue;
block|}
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|used
argument_list|)
expr_stmt|;
goto|goto
name|error_ret
goto|;
block|}
if|if
condition|(
name|sym_sec
operator|!=
name|toc
condition|)
continue|continue;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|val
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|val
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|val
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|toc
operator|->
name|size
condition|)
continue|continue;
comment|/* For the toc section, we only mark as used if 		   this entry itself isn't unused.  */
if|if
condition|(
name|sec
operator|==
name|toc
operator|&&
operator|!
name|used
index|[
name|val
operator|>>
literal|3
index|]
operator|&&
operator|(
name|used
index|[
name|rel
operator|->
name|r_offset
operator|>>
literal|3
index|]
operator|||
operator|!
name|skip
index|[
name|rel
operator|->
name|r_offset
operator|>>
literal|3
index|]
operator|)
condition|)
comment|/* Do all the relocs again, to catch reference 		     chains.  */
name|repeat
operator|=
literal|1
expr_stmt|;
name|used
index|[
name|val
operator|>>
literal|3
index|]
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|repeat
condition|)
do|;
block|}
comment|/* Merge the used and skip arrays.  Assume that TOC 	 doublewords not appearing as either used or unused belong 	 to to an entry more than one doubleword in size.  */
for|for
control|(
name|drop
operator|=
name|skip
operator|,
name|keep
operator|=
name|used
operator|,
name|last
operator|=
literal|0
operator|,
name|some_unused
operator|=
literal|0
init|;
name|drop
operator|<
name|skip
operator|+
operator|(
name|toc
operator|->
name|size
operator|+
literal|7
operator|)
operator|/
literal|8
condition|;
operator|++
name|drop
operator|,
operator|++
name|keep
control|)
block|{
if|if
condition|(
operator|*
name|keep
condition|)
block|{
operator|*
name|drop
operator|=
literal|0
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|drop
condition|)
block|{
name|some_unused
operator|=
literal|1
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|drop
operator|=
name|last
expr_stmt|;
block|}
name|free
argument_list|(
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|some_unused
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|unsigned
name|long
name|off
decl_stmt|;
comment|/* Shuffle the toc contents, and at the same time convert the 	     skip array from booleans into offsets.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|ibfd
argument_list|,
name|toc
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
name|elf_section_data
argument_list|(
name|toc
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
for|for
control|(
name|src
operator|=
name|contents
operator|,
name|off
operator|=
literal|0
operator|,
name|drop
operator|=
name|skip
init|;
name|src
operator|<
name|contents
operator|+
name|toc
operator|->
name|size
condition|;
name|src
operator|+=
literal|8
operator|,
operator|++
name|drop
control|)
block|{
if|if
condition|(
operator|*
name|drop
condition|)
block|{
operator|*
name|drop
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|off
operator|!=
literal|0
condition|)
block|{
operator|*
name|drop
operator|=
name|off
expr_stmt|;
name|memcpy
argument_list|(
name|src
operator|-
name|off
argument_list|,
name|src
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
name|toc
operator|->
name|rawsize
operator|=
name|toc
operator|->
name|size
expr_stmt|;
name|toc
operator|->
name|size
operator|=
name|src
operator|-
name|contents
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|toc
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|wrel
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|;
comment|/* Read toc relocs.  */
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|toc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
goto|goto
name|error_ret
goto|;
comment|/* Remove unused toc relocs, and adjust those we keep.  */
name|wrel
operator|=
name|relstart
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relstart
operator|+
name|toc
operator|->
name|reloc_count
condition|;
operator|++
name|rel
control|)
if|if
condition|(
name|skip
index|[
name|rel
operator|->
name|r_offset
operator|>>
literal|3
index|]
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
name|wrel
operator|->
name|r_offset
operator|=
name|rel
operator|->
name|r_offset
operator|-
name|skip
index|[
name|rel
operator|->
name|r_offset
operator|>>
literal|3
index|]
expr_stmt|;
name|wrel
operator|->
name|r_info
operator|=
name|rel
operator|->
name|r_info
expr_stmt|;
name|wrel
operator|->
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
operator|++
name|wrel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dec_dynrel_count
argument_list|(
name|rel
operator|->
name|r_info
argument_list|,
name|toc
argument_list|,
name|info
argument_list|,
operator|&
name|local_syms
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
name|toc
operator|->
name|reloc_count
operator|=
name|wrel
operator|-
name|relstart
expr_stmt|;
name|sz
operator|=
name|elf_section_data
argument_list|(
name|toc
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|elf_section_data
argument_list|(
name|toc
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_size
operator|=
name|toc
operator|->
name|reloc_count
operator|*
name|sz
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|toc
argument_list|)
operator|->
name|rel_hdr2
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust addends for relocs against the toc section sym.  */
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
continue|continue;
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
goto|goto
name|error_ret
goto|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
condition|;
operator|++
name|rel
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
continue|continue;
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
case|case
name|R_PPC64_ADDR64
case|:
break|break;
block|}
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
if|if
condition|(
name|sym_sec
operator|!=
name|toc
operator|||
name|h
operator|!=
name|NULL
operator|||
name|sym
operator|->
name|st_value
operator|!=
literal|0
condition|)
continue|continue;
name|rel
operator|->
name|r_addend
operator|-=
name|skip
index|[
name|rel
operator|->
name|r_addend
operator|>>
literal|3
index|]
expr_stmt|;
block|}
block|}
comment|/* We shouldn't have local or global symbols defined in the TOC, 	     but handle them anyway.  */
if|if
condition|(
name|local_syms
operator|!=
name|NULL
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|local_syms
init|;
name|sym
operator|<
name|local_syms
operator|+
name|symtab_hdr
operator|->
name|sh_info
condition|;
operator|++
name|sym
control|)
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|(
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
operator|)
operator|&&
name|sym
operator|->
name|st_value
operator|!=
literal|0
operator|&&
name|bfd_section_from_elf_index
argument_list|(
name|ibfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
operator|==
name|toc
condition|)
block|{
if|if
condition|(
name|skip
index|[
name|sym
operator|->
name|st_value
operator|>>
literal|3
index|]
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
name|sym
operator|->
name|st_value
operator|-=
name|skip
index|[
name|sym
operator|->
name|st_value
operator|>>
literal|3
index|]
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s defined in removed toc entry"
argument_list|)
argument_list|,
name|bfd_elf_sym_name
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|sym
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
block|}
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
block|}
comment|/* Finally, adjust any global syms defined in the toc.  */
if|if
condition|(
name|toc_inf
operator|.
name|global_toc_syms
condition|)
block|{
name|toc_inf
operator|.
name|toc
operator|=
name|toc
expr_stmt|;
name|toc_inf
operator|.
name|skip
operator|=
name|skip
expr_stmt|;
name|toc_inf
operator|.
name|global_toc_syms
operator|=
name|FALSE
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|adjust_toc_syms
argument_list|,
operator|&
name|toc_inf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
name|free
argument_list|(
name|skip
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|got_entry
modifier|*
name|gent
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|pent
decl_stmt|;
name|bfd_boolean
name|doneone
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|pent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|pent
operator|!=
name|NULL
condition|;
name|pent
operator|=
name|pent
operator|->
name|next
control|)
if|if
condition|(
name|pent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* If this is the first .plt entry, make room for the special 	       first entry.  */
name|s
operator|=
name|htab
operator|->
name|plt
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|size
operator|+=
name|PLT_INITIAL_ENTRY_SIZE
expr_stmt|;
name|pent
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Make room for this entry.  */
name|s
operator|->
name|size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Make room for the .glink code.  */
name|s
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|size
operator|+=
name|GLINK_CALL_STUB_SIZE
expr_stmt|;
comment|/* We need bigger stubs past index 32767.  */
if|if
condition|(
name|s
operator|->
name|size
operator|>=
name|GLINK_CALL_STUB_SIZE
operator|+
literal|32768
operator|*
literal|2
operator|*
literal|4
condition|)
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|2
operator|*
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
name|s
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|doneone
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|pent
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|doneone
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Run through the TLS GD got entries first if we're changing them      to TPREL.  */
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_TPRELGD
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|gent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
init|;
name|gent
operator|!=
name|NULL
condition|;
name|gent
operator|=
name|gent
operator|->
name|next
control|)
if|if
condition|(
name|gent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
operator|&&
operator|(
name|gent
operator|->
name|tls_type
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This was a GD entry that has been converted to TPREL.  If 	     there happens to be a TPREL entry we can use that one.  */
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
operator|&&
operator|(
name|ent
operator|->
name|tls_type
operator|&
name|TLS_TPREL
operator|)
operator|!=
literal|0
operator|&&
name|ent
operator|->
name|addend
operator|==
name|gent
operator|->
name|addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|gent
operator|->
name|owner
condition|)
block|{
name|gent
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If not, then we'll be using our own TPREL entry.  */
if|if
condition|(
name|gent
operator|->
name|got
operator|.
name|refcount
operator|!=
literal|0
condition|)
name|gent
operator|->
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
block|}
for|for
control|(
name|gent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
init|;
name|gent
operator|!=
name|NULL
condition|;
name|gent
operator|=
name|gent
operator|->
name|next
control|)
if|if
condition|(
name|gent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	   Undefined weak syms won't yet be marked as dynamic, 	   nor will all TLS symbols.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|gent
operator|->
name|tls_type
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|h
operator|->
name|def_dynamic
condition|)
block|{
name|gent
operator|->
name|got
operator|.
name|offset
operator|=
name|ppc64_tlsld_got
argument_list|(
name|gent
operator|->
name|owner
argument_list|)
operator|->
name|offset
expr_stmt|;
continue|continue;
block|}
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|gent
operator|->
name|owner
argument_list|)
operator|->
name|got
expr_stmt|;
name|gent
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
operator|(
name|gent
operator|->
name|tls_type
operator|&
name|eh
operator|->
name|tls_mask
operator|&
operator|(
name|TLS_GD
operator||
name|TLS_LD
operator|)
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
operator|)
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
name|ppc64_elf_tdata
argument_list|(
name|gent
operator|->
name|owner
argument_list|)
operator|->
name|relgot
operator|->
name|size
operator|+=
operator|(
name|gent
operator|->
name|tls_type
operator|&
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_GD
condition|?
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|gent
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for relocs that have become local due to symbol visibility      changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Relocs that use pc_count are those that appear on a call insn, 	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be 	 generated via assembly.  We want calls to protected symbols to 	 resolve directly to the function rather than going via the plt. 	 If people want function pointer comparisons to work as expected 	 then they should avoid writing weird assembly.  */
if|if
condition|(
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also discard relocs on undefined weak syms with non-default 	 visibility.  */
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
elseif|else
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
operator|&&
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|readonly_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|struct
name|got_entry
modifier|*
modifier|*
name|lgot_ents
decl_stmt|;
name|struct
name|got_entry
modifier|*
modifier|*
name|end_lgot_ents
decl_stmt|;
name|char
modifier|*
name|lgot_masks
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
operator|!
name|is_ppc64_elf_target
argument_list|(
name|ibfd
operator|->
name|xvec
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|got
expr_stmt|;
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|16
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|srel
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|relgot
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|lgot_ents
operator|=
name|elf_local_got_ents
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lgot_ents
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_lgot_ents
operator|=
name|lgot_ents
operator|+
name|locsymcount
expr_stmt|;
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
name|end_lgot_ents
expr_stmt|;
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|got
expr_stmt|;
name|srel
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|relgot
expr_stmt|;
for|for
control|(
init|;
name|lgot_ents
operator|<
name|end_lgot_ents
condition|;
operator|++
name|lgot_ents
operator|,
operator|++
name|lgot_masks
control|)
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
operator|*
name|lgot_ents
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ent
operator|->
name|tls_type
operator|&
operator|*
name|lgot_masks
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|16
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
name|ent
operator|->
name|got
operator|.
name|offset
operator|=
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|ent
operator|->
name|tls_type
operator|&
operator|*
name|lgot_masks
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|size
operator|+=
literal|16
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|ent
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* We now have determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|brlt
operator|||
name|s
operator|==
name|htab
operator|->
name|relbrlt
condition|)
comment|/* These haven't been allocated yet;  don't strip.  */
continue|continue;
elseif|else
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|got
operator|||
name|s
operator|==
name|htab
operator|->
name|plt
operator|||
name|s
operator|==
name|htab
operator|->
name|glink
operator|||
name|s
operator|==
name|htab
operator|->
name|dynbss
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|!=
name|htab
operator|->
name|relplt
condition|)
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rela.bss and 	     .rela.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  We use bfd_zalloc 	 here in case unused entries are not reclaimed before the 	 section's contents are written out.  This should not happen, 	 but this way if it does we get a R_PPC64_NONE reloc in .rela 	 sections instead of garbage. 	 We also rely on the section contents being zero when writing 	 the GOT.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
if|if
condition|(
operator|!
name|is_ppc64_elf_target
argument_list|(
name|ibfd
operator|->
name|xvec
argument_list|)
condition|)
continue|continue;
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|got
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|!=
name|htab
operator|->
name|got
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
else|else
block|{
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|ibfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|relgot
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
else|else
block|{
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|ibfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|relocs
operator|=
name|TRUE
expr_stmt|;
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in ppc64_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|plt
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_GLINK
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|NO_OPD_RELOCS
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_OPD
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_OPDSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If any dynamic relocs apply to a read-only section, 	     then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|readonly_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Determine the type of stub needed, if any, for a call.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|ppc_stub_type
name|ppc_type_of_stub
parameter_list|(
name|asection
modifier|*
name|input_sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|ppc_link_hash_entry
modifier|*
modifier|*
name|hash
parameter_list|,
name|bfd_vma
name|destination
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
init|=
operator|*
name|hash
decl_stmt|;
name|bfd_vma
name|location
decl_stmt|;
name|bfd_vma
name|branch_offset
decl_stmt|;
name|bfd_vma
name|max_branch_offset
decl_stmt|;
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
init|=
name|h
decl_stmt|;
if|if
condition|(
name|fdh
operator|->
name|oh
operator|!=
name|NULL
operator|&&
name|fdh
operator|->
name|oh
operator|->
name|is_func_descriptor
condition|)
name|fdh
operator|=
name|fdh
operator|->
name|oh
expr_stmt|;
if|if
condition|(
name|fdh
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|fdh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
operator|*
name|hash
operator|=
name|fdh
expr_stmt|;
return|return
name|ppc_stub_plt_call
return|;
block|}
block|}
comment|/* Here, we know we don't have a plt entry.  If we don't have a 	 either a defined function descriptor or a defined entry symbol 	 in a regular object file, then it is pointless trying to make 	 any other type of stub.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
operator|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
operator|)
condition|)
return|return
name|ppc_stub_none
return|;
block|}
comment|/* Determine where the call point is.  */
name|location
operator|=
operator|(
name|input_sec
operator|->
name|output_offset
operator|+
name|input_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|branch_offset
operator|=
name|destination
operator|-
name|location
expr_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Determine if a long branch stub is needed.  */
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_PPC64_REL24
condition|)
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|15
expr_stmt|;
if|if
condition|(
name|branch_offset
operator|+
name|max_branch_offset
operator|>=
literal|2
operator|*
name|max_branch_offset
condition|)
comment|/* We need a stub.  Figure out whether a long_branch or plt_branch        is needed later.  */
return|return
name|ppc_stub_long_branch
return|;
return|return
name|ppc_stub_none
return|;
block|}
end_function

begin_comment
comment|/* Build a .plt call stub.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_byte
modifier|*
name|build_plt_stub
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
define|#
directive|define
name|PPC_LO
parameter_list|(
name|v
parameter_list|)
value|((v)& 0xffff)
define|#
directive|define
name|PPC_HI
parameter_list|(
name|v
parameter_list|)
value|(((v)>> 16)& 0xffff)
define|#
directive|define
name|PPC_HA
parameter_list|(
name|v
parameter_list|)
value|PPC_HI ((v) + 0x8000)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R2
operator||
name|PPC_HA
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|STD_R2_40R1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|offset
operator|+
literal|8
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|offset
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R12
operator||
literal|1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R2_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|offset
operator|+
literal|8
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|offset
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R12
operator||
literal|1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|MTCTR_R11
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|BCTR
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ppc_build_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|ppc_branch_hash_entry
modifier|*
name|br_entry
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|bfd_vma
name|dest
decl_stmt|,
name|off
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|ppc_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|info
operator|=
name|in_arg
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Make a note of the offset within the stubs for this entry.  */
name|stub_entry
operator|->
name|stub_offset
operator|=
name|stub_entry
operator|->
name|stub_sec
operator|->
name|size
expr_stmt|;
name|loc
operator|=
name|stub_entry
operator|->
name|stub_sec
operator|->
name|contents
operator|+
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
name|htab
operator|->
name|stub_count
index|[
name|stub_entry
operator|->
name|stub_type
operator|-
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|stub_entry
operator|->
name|stub_type
condition|)
block|{
case|case
name|ppc_stub_long_branch
case|:
case|case
name|ppc_stub_long_branch_r2off
case|:
comment|/* Branches are relative.  This is where we are going to.  */
name|off
operator|=
name|dest
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* And this is where we are coming from.  */
name|off
operator|-=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|!=
name|ppc_stub_long_branch_r2off
condition|)
name|size
operator|=
literal|4
expr_stmt|;
else|else
block|{
name|bfd_vma
name|r2off
decl_stmt|;
name|r2off
operator|=
operator|(
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|target_section
operator|->
name|id
index|]
operator|.
name|toc_off
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|STD_R2_40R1
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDIS_R2_R2
operator||
name|PPC_HA
argument_list|(
name|r2off
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDI_R2_R2
operator||
name|PPC_LO
argument_list|(
name|r2off
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|off
operator|-=
literal|12
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|B_DOT
operator||
operator|(
name|off
operator|&
literal|0x3fffffc
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|>=
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
literal|26
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"long branch stub `%s' offset overflow"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|emitrelocations
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|struct
name|bfd_elf_section_data
modifier|*
name|elfsec_data
decl_stmt|;
name|elfsec_data
operator|=
name|elf_section_data
argument_list|(
name|stub_entry
operator|->
name|stub_sec
argument_list|)
expr_stmt|;
name|relocs
operator|=
name|elfsec_data
operator|->
name|relocs
expr_stmt|;
if|if
condition|(
name|relocs
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|relsize
decl_stmt|;
name|relsize
operator|=
name|stub_entry
operator|->
name|stub_sec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|relocs
argument_list|)
expr_stmt|;
name|relocs
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|relsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elfsec_data
operator|->
name|relocs
operator|=
name|relocs
expr_stmt|;
name|elfsec_data
operator|->
name|rel_hdr
operator|.
name|sh_size
operator|=
name|relsize
expr_stmt|;
name|elfsec_data
operator|->
name|rel_hdr
operator|.
name|sh_entsize
operator|=
literal|24
expr_stmt|;
name|stub_entry
operator|->
name|stub_sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
name|r
operator|=
name|relocs
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|reloc_count
expr_stmt|;
name|stub_entry
operator|->
name|stub_sec
operator|->
name|reloc_count
operator|+=
literal|1
expr_stmt|;
name|r
operator|->
name|r_offset
operator|=
name|loc
operator|-
name|stub_entry
operator|->
name|stub_sec
operator|->
name|contents
expr_stmt|;
name|r
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_REL24
argument_list|)
expr_stmt|;
name|r
operator|->
name|r_addend
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hashes
decl_stmt|;
name|unsigned
name|long
name|symndx
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashes
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|hsize
decl_stmt|;
name|hsize
operator|=
operator|(
name|htab
operator|->
name|stub_globals
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|hashes
argument_list|)
expr_stmt|;
name|hashes
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashes
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_sym_hashes
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|)
operator|=
name|hashes
expr_stmt|;
name|htab
operator|->
name|stub_globals
operator|=
literal|1
expr_stmt|;
block|}
name|symndx
operator|=
name|htab
operator|->
name|stub_globals
operator|++
expr_stmt|;
name|h
operator|=
name|stub_entry
operator|->
name|h
expr_stmt|;
name|hashes
index|[
name|symndx
index|]
operator|=
operator|&
name|h
operator|->
name|elf
expr_stmt|;
name|r
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|symndx
argument_list|,
name|R_PPC64_REL24
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|oh
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|oh
operator|->
name|is_func
condition|)
name|h
operator|=
name|h
operator|->
name|oh
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|!=
name|stub_entry
operator|->
name|target_section
condition|)
comment|/* H is an opd symbol.  The addend must be zero.  */
name|r
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|off
operator|=
operator|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|r
operator|->
name|r_addend
operator|-=
name|off
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ppc_stub_plt_branch
case|:
case|case
name|ppc_stub_plt_branch_r2off
case|:
name|br_entry
operator|=
name|ppc_branch_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|branch_hash_table
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|br_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"can't find branch stub `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|off
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|htab
operator|->
name|brlt
operator|->
name|owner
argument_list|,
name|off
argument_list|,
name|htab
operator|->
name|brlt
operator|->
name|contents
operator|+
name|br_entry
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|relbrlt
operator|!=
name|NULL
condition|)
block|{
comment|/* Create a reloc for the branch lookup table entry.  */
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|rl
decl_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|br_entry
operator|->
name|offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|off
expr_stmt|;
name|rl
operator|=
name|htab
operator|->
name|relbrlt
operator|->
name|contents
expr_stmt|;
name|rl
operator|+=
name|htab
operator|->
name|relbrlt
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|htab
operator|->
name|relbrlt
operator|->
name|owner
argument_list|,
operator|&
name|rela
argument_list|,
name|rl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|emitrelocations
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|struct
name|bfd_elf_section_data
modifier|*
name|elfsec_data
decl_stmt|;
name|elfsec_data
operator|=
name|elf_section_data
argument_list|(
name|htab
operator|->
name|brlt
argument_list|)
expr_stmt|;
name|relocs
operator|=
name|elfsec_data
operator|->
name|relocs
expr_stmt|;
if|if
condition|(
name|relocs
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|relsize
decl_stmt|;
name|relsize
operator|=
name|htab
operator|->
name|brlt
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|relocs
argument_list|)
expr_stmt|;
name|relocs
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|brlt
operator|->
name|owner
argument_list|,
name|relsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elfsec_data
operator|->
name|relocs
operator|=
name|relocs
expr_stmt|;
name|elfsec_data
operator|->
name|rel_hdr
operator|.
name|sh_size
operator|=
name|relsize
expr_stmt|;
name|elfsec_data
operator|->
name|rel_hdr
operator|.
name|sh_entsize
operator|=
literal|24
expr_stmt|;
name|htab
operator|->
name|brlt
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
name|r
operator|=
name|relocs
operator|+
name|htab
operator|->
name|brlt
operator|->
name|reloc_count
expr_stmt|;
name|htab
operator|->
name|brlt
operator|->
name|reloc_count
operator|+=
literal|1
expr_stmt|;
name|r
operator|->
name|r_offset
operator|=
operator|(
name|br_entry
operator|->
name|offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|r
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
name|r
operator|->
name|r_addend
operator|=
name|off
expr_stmt|;
block|}
name|off
operator|=
operator|(
name|br_entry
operator|->
name|offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|brlt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
literal|0x80008000
operator|>
literal|0xffffffff
operator|||
operator|(
name|off
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"linkage table error against `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|indx
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|!=
name|ppc_stub_plt_branch_r2off
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDIS_R12_R2
operator||
name|PPC_HA
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|r2off
decl_stmt|;
name|r2off
operator|=
operator|(
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|target_section
operator|->
name|id
index|]
operator|.
name|toc_off
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|STD_R2_40R1
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDIS_R12_R2
operator||
name|PPC_HA
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDIS_R2_R2
operator||
name|PPC_HA
argument_list|(
name|r2off
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDI_R2_R2
operator||
name|PPC_LO
argument_list|(
name|r2off
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|size
operator|=
literal|28
expr_stmt|;
block|}
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|MTCTR_R11
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|BCTR
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ppc_stub_plt_call
case|:
comment|/* Do the best we can for shared libraries built without 	 exporting ".foo" for each "foo".  This can happen when symbol 	 versioning scripts strip all bar a subset of symbols.  */
if|if
condition|(
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|!=
name|NULL
operator|&&
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* Point the symbol at the stub.  There may be multiple stubs, 	     we don't really care;  The main thing is to make this sym 	     defined somewhere.  Maybe defining the symbol in the stub 	     section is a silly idea.  If we didn't do this, htab->top_id 	     could disappear.  */
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|stub_entry
operator|->
name|stub_sec
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
block|}
comment|/* Now build the stub.  */
name|off
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|stub_entry
operator|->
name|addend
condition|)
block|{
name|off
operator|=
name|ent
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
name|off
operator|+=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
literal|0x80008000
operator|>
literal|0xffffffff
operator|||
operator|(
name|off
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"linkage table error against `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p
operator|=
name|build_plt_stub
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|loc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|size
operator|=
name|p
operator|-
name|loc
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|stub_entry
operator|->
name|stub_sec
operator|->
name|size
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|emit_stub_syms
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|stub_str
index|[]
init|=
block|{
literal|"long_branch"
block|,
literal|"long_branch_r2off"
block|,
literal|"plt_branch"
block|,
literal|"plt_branch_r2off"
block|,
literal|"plt_call"
block|}
decl_stmt|;
name|len1
operator|=
name|strlen
argument_list|(
name|stub_str
index|[
name|stub_entry
operator|->
name|stub_type
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_malloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
operator|+
literal|9
argument_list|,
name|stub_str
index|[
name|stub_entry
operator|->
name|stub_type
operator|-
literal|1
index|]
argument_list|,
name|len1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
operator|+
name|len1
operator|+
literal|9
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|8
argument_list|,
name|len2
operator|-
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|stub_entry
operator|->
name|stub_sec
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
name|h
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* As above, but don't actually build the stub.  Just bump offset so    we know stub section sizes, and select plt_branch stubs where    long_branch stubs won't do.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_size_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|ppc_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|info
operator|=
name|in_arg
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|off
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|stub_entry
operator|->
name|addend
condition|)
block|{
name|off
operator|=
name|ent
operator|->
name|plt
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|+=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
name|size
operator|=
name|PLT_CALL_STUB_SIZE
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|off
operator|+
literal|16
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|off
argument_list|)
condition|)
name|size
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* ppc_stub_long_branch or ppc_stub_plt_branch, or their r2off 	 variants.  */
name|off
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|off
operator|-=
operator|(
name|stub_entry
operator|->
name|stub_sec
operator|->
name|size
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Reset the stub type from the plt variant in case we now 	 can reach with a shorter stub.  */
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|>=
name|ppc_stub_plt_branch
condition|)
name|stub_entry
operator|->
name|stub_type
operator|+=
name|ppc_stub_long_branch
operator|-
name|ppc_stub_plt_branch
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_long_branch_r2off
condition|)
block|{
name|off
operator|-=
literal|12
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
block|}
comment|/* If the branch offset if too big, use a ppc_stub_plt_branch.  */
if|if
condition|(
name|off
operator|+
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|>=
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
literal|26
argument_list|)
condition|)
block|{
name|struct
name|ppc_branch_hash_entry
modifier|*
name|br_entry
decl_stmt|;
name|br_entry
operator|=
name|ppc_branch_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|branch_hash_table
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|br_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"can't build branch stub `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|br_entry
operator|->
name|iter
operator|!=
name|htab
operator|->
name|stub_iteration
condition|)
block|{
name|br_entry
operator|->
name|iter
operator|=
name|htab
operator|->
name|stub_iteration
expr_stmt|;
name|br_entry
operator|->
name|offset
operator|=
name|htab
operator|->
name|brlt
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|brlt
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|relbrlt
operator|!=
name|NULL
condition|)
name|htab
operator|->
name|relbrlt
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|emitrelocations
condition|)
block|{
name|htab
operator|->
name|brlt
operator|->
name|reloc_count
operator|+=
literal|1
expr_stmt|;
name|htab
operator|->
name|brlt
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
block|}
block|}
name|stub_entry
operator|->
name|stub_type
operator|+=
name|ppc_stub_plt_branch
operator|-
name|ppc_stub_long_branch
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|!=
name|ppc_stub_plt_branch
condition|)
name|size
operator|=
literal|28
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|emitrelocations
condition|)
block|{
name|stub_entry
operator|->
name|stub_sec
operator|->
name|reloc_count
operator|+=
literal|1
expr_stmt|;
name|stub_entry
operator|->
name|stub_sec
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
block|}
block|}
name|stub_entry
operator|->
name|stub_sec
operator|->
name|size
operator|+=
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set up various things so that we can make a list of input sections    for each output section included in the link.  Returns -1 on error,    0 when no stubs will be needed, and 1 on success.  */
end_comment

begin_function
name|int
name|ppc64_elf_setup_section_lists
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|int
name|no_multi_toc
parameter_list|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|int
name|top_id
decl_stmt|,
name|top_index
decl_stmt|,
name|id
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|htab
operator|->
name|no_multi_toc
operator|=
name|no_multi_toc
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|brlt
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Find the top input section id.  */
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|top_id
operator|=
literal|3
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|top_id
operator|<
name|section
operator|->
name|id
condition|)
name|top_id
operator|=
name|section
operator|->
name|id
expr_stmt|;
block|}
block|}
name|htab
operator|->
name|top_id
operator|=
name|top_id
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|map_stub
argument_list|)
operator|*
operator|(
name|top_id
operator|+
literal|1
operator|)
expr_stmt|;
name|htab
operator|->
name|stub_group
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|stub_group
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set toc_off for com, und, abs and ind sections.  */
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
literal|3
condition|;
name|id
operator|++
control|)
name|htab
operator|->
name|stub_group
index|[
name|id
index|]
operator|.
name|toc_off
operator|=
name|TOC_BASE_OFF
expr_stmt|;
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|=
name|htab
operator|->
name|toc_curr
operator|=
name|ppc64_elf_toc
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* We can't use output_bfd->section_count here to find the top output      section index as some sections may have been removed, and      strip_excluded_output_sections doesn't renumber the indices.  */
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
operator|,
name|top_index
operator|=
literal|0
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|top_index
operator|<
name|section
operator|->
name|index
condition|)
name|top_index
operator|=
name|section
operator|->
name|index
expr_stmt|;
block|}
name|htab
operator|->
name|top_index
operator|=
name|top_index
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|*
operator|(
name|top_index
operator|+
literal|1
operator|)
expr_stmt|;
name|input_list
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|htab
operator|->
name|input_list
operator|=
name|input_list
expr_stmt|;
if|if
condition|(
name|input_list
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The linker repeatedly calls this function for each TOC input section    and linker generated GOT section.  Group input bfds such that the toc    within a group is less than 64k in size.  Will break with cute linker    scripts that play games with dot in the output toc section.  */
end_comment

begin_function
name|void
name|ppc64_elf_next_toc_section
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|no_multi_toc
condition|)
block|{
name|bfd_vma
name|addr
init|=
name|isec
operator|->
name|output_offset
operator|+
name|isec
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
name|bfd_vma
name|off
init|=
name|addr
operator|-
name|htab
operator|->
name|toc_curr
decl_stmt|;
if|if
condition|(
name|off
operator|+
name|isec
operator|->
name|size
operator|>
literal|0x10000
condition|)
name|htab
operator|->
name|toc_curr
operator|=
name|addr
expr_stmt|;
name|elf_gp
argument_list|(
name|isec
operator|->
name|owner
argument_list|)
operator|=
operator|(
name|htab
operator|->
name|toc_curr
operator|-
name|elf_gp
argument_list|(
name|isec
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|+
name|TOC_BASE_OFF
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after the last call to the above function.  */
end_comment

begin_function
name|void
name|ppc64_elf_reinit_toc
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|htab
operator|->
name|multi_toc_needed
operator|=
name|htab
operator|->
name|toc_curr
operator|!=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* toc_curr tracks the TOC offset used for code sections below in      ppc64_elf_next_input_section.  Start off at 0x8000.  */
name|htab
operator|->
name|toc_curr
operator|=
name|TOC_BASE_OFF
expr_stmt|;
block|}
end_function

begin_comment
comment|/* No toc references were found in ISEC.  If the code in ISEC makes no    calls, then there's no need to use toc adjusting stubs when branching    into ISEC.  Actually, indirect calls from ISEC are OK as they will    load r2.  Returns -1 on error, 0 for no stub needed, 1 for stub    needed, and 2 if a cyclical call-graph was found but no other reason    for a stub was detected.  If called from the top level, a return of    2 means the same as a return of 0.  */
end_comment

begin_function
specifier|static
name|int
name|toc_adjusting_stub_needed
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
comment|/* We know none of our code bearing sections will need toc stubs.  */
if|if
condition|(
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isec
operator|->
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isec
operator|->
name|output_section
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Hack for linux kernel.  .fixup contains branches, but only back to      the function that hit an exception.  */
if|if
condition|(
name|strcmp
argument_list|(
name|isec
operator|->
name|name
argument_list|,
literal|".fixup"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|isec
operator|->
name|owner
argument_list|,
name|isec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Look for branches to outside of this section.  */
name|local_syms
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relstart
operator|+
name|isec
operator|->
name|reloc_count
condition|;
operator|++
name|rel
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|long
modifier|*
name|opd_adjust
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|bfd_vma
name|dest
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_PPC64_REL24
operator|&&
name|r_type
operator|!=
name|R_PPC64_REL14
operator|&&
name|r_type
operator|!=
name|R_PPC64_REL14_BRTAKEN
operator|&&
name|r_type
operator|!=
name|R_PPC64_REL14_BRNTAKEN
condition|)
continue|continue;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_symndx
argument_list|,
name|isec
operator|->
name|owner
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Calls to dynamic lib functions go through a plt call stub 	 that uses r2.  Branches to undefined symbols might be a call 	 using old-style dot symbols that can be satisfied by a plt 	 call into a new-style dynamic library.  */
if|if
condition|(
name|sym_sec
operator|==
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
init|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
decl_stmt|;
if|if
condition|(
name|eh
operator|!=
name|NULL
operator|&&
name|eh
operator|->
name|oh
operator|!=
name|NULL
operator|&&
name|eh
operator|->
name|oh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Ignore other undefined symbols.  */
continue|continue;
block|}
comment|/* Assume branches to other sections not included in the link need 	 stubs too, to cover -R and absolute syms.  */
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|sym_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sym_value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
name|sym_value
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
comment|/* If this branch reloc uses an opd sym, find the code section.  */
name|opd_adjust
operator|=
name|get_opd_info
argument_list|(
name|sym_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_adjust
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|long
name|adjust
decl_stmt|;
name|adjust
operator|=
name|opd_adjust
index|[
name|sym
operator|->
name|st_value
operator|/
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|adjust
operator|==
operator|-
literal|1
condition|)
comment|/* Assume deleted functions won't ever be called.  */
continue|continue;
name|sym_value
operator|+=
name|adjust
expr_stmt|;
block|}
name|dest
operator|=
name|opd_entry_value
argument_list|(
name|sym_sec
argument_list|,
name|sym_value
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
continue|continue;
block|}
else|else
name|dest
operator|=
operator|(
name|sym_value
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Ignore branch to self.  */
if|if
condition|(
name|sym_sec
operator|==
name|isec
condition|)
continue|continue;
comment|/* If the called function uses the toc, we need a stub.  */
if|if
condition|(
name|sym_sec
operator|->
name|has_toc_reloc
operator|||
name|sym_sec
operator|->
name|makes_toc_func_call
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Assume any branch that needs a long branch stub might in fact 	 need a plt_branch stub.  A plt_branch stub uses r2.  */
elseif|else
if|if
condition|(
name|dest
operator|-
operator|(
name|isec
operator|->
name|output_offset
operator|+
name|isec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|rel
operator|->
name|r_offset
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|>=
operator|(
literal|2
operator|<<
literal|25
operator|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If calling back to a section in the process of being tested, we 	 can't say for sure that no toc adjusting stubs are needed, so 	 don't return zero.  */
elseif|else
if|if
condition|(
name|sym_sec
operator|->
name|call_check_in_progress
condition|)
name|ret
operator|=
literal|2
expr_stmt|;
comment|/* Branches to another section that itself doesn't have any TOC 	 references are OK.  Recursively call ourselves to check.  */
elseif|else
if|if
condition|(
name|sym_sec
operator|->
name|id
operator|<=
name|htab
operator|->
name|top_id
operator|&&
name|htab
operator|->
name|stub_group
index|[
name|sym_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|==
literal|0
condition|)
block|{
name|int
name|recur
decl_stmt|;
comment|/* Mark current section as indeterminate, so that other 	     sections that call back to current won't be marked as 	     known.  */
name|isec
operator|->
name|call_check_in_progress
operator|=
literal|1
expr_stmt|;
name|recur
operator|=
name|toc_adjusting_stub_needed
argument_list|(
name|info
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
name|isec
operator|->
name|call_check_in_progress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|recur
operator|<
literal|0
condition|)
block|{
comment|/* An error.  Exit.  */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|recur
operator|<=
literal|1
condition|)
block|{
comment|/* Known result.  Mark as checked and set section flag.  */
name|htab
operator|->
name|stub_group
index|[
name|sym_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|recur
operator|!=
literal|0
condition|)
block|{
name|sym_sec
operator|->
name|makes_toc_func_call
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Unknown result.  Continue checking.  */
name|ret
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
operator|(
name|elf_tdata
argument_list|(
name|isec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
operator|)
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* The linker repeatedly calls this function for each input section,    in the order that input sections are linked into output sections.    Build lists of input sections to determine groupings between which    we may insert linker stubs.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_next_input_section
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|isec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
operator|&&
name|isec
operator|->
name|output_section
operator|->
name|index
operator|<=
name|htab
operator|->
name|top_index
condition|)
block|{
name|asection
modifier|*
modifier|*
name|list
init|=
name|htab
operator|->
name|input_list
operator|+
name|isec
operator|->
name|output_section
operator|->
name|index
decl_stmt|;
comment|/* Steal the link_sec pointer for our list.  */
define|#
directive|define
name|PREV_SEC
parameter_list|(
name|sec
parameter_list|)
value|(htab->stub_group[(sec)->id].link_sec)
comment|/* This happens to make the list in reverse order, 	 which is what we want.  */
name|PREV_SEC
argument_list|(
name|isec
argument_list|)
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|multi_toc_needed
condition|)
block|{
comment|/* If a code section has a function that uses the TOC then we need 	 to use the right TOC (obviously).  Also, make sure that .opd gets 	 the correct TOC value for R_PPC64_TOC relocs that don't have or 	 can't find their function symbol (shouldn't ever happen now).  */
if|if
condition|(
name|isec
operator|->
name|has_toc_reloc
operator|||
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|elf_gp
argument_list|(
name|isec
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
name|htab
operator|->
name|toc_curr
operator|=
name|elf_gp
argument_list|(
name|isec
operator|->
name|owner
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|htab
operator|->
name|stub_group
index|[
name|isec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|==
literal|0
condition|)
block|{
name|int
name|ret
init|=
name|toc_adjusting_stub_needed
argument_list|(
name|info
argument_list|,
name|isec
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
else|else
name|isec
operator|->
name|makes_toc_func_call
operator|=
name|ret
operator|&
literal|1
expr_stmt|;
block|}
block|}
comment|/* Functions that don't use the TOC can belong in any TOC group.      Use the last TOC base.  This happens to make _init and _fini      pasting work.  */
name|htab
operator|->
name|stub_group
index|[
name|isec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|=
name|htab
operator|->
name|toc_curr
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* See whether we can group stub sections together.  Grouping stub    sections may result in fewer stubs.  More importantly, we need to    put all .init* and .fini* stubs at the beginning of the .init or    .fini output sections respectively, because glibc splits the    _init and _fini functions into multiple parts.  Putting a stub in    the middle of a function is not a good idea.  */
end_comment

begin_function
specifier|static
name|void
name|group_sections
parameter_list|(
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
parameter_list|,
name|bfd_size_type
name|stub_group_size
parameter_list|,
name|bfd_boolean
name|stubs_always_before_branch
parameter_list|)
block|{
name|asection
modifier|*
modifier|*
name|list
decl_stmt|;
name|bfd_size_type
name|stub14_group_size
decl_stmt|;
name|bfd_boolean
name|suppress_size_errors
decl_stmt|;
name|suppress_size_errors
operator|=
name|FALSE
expr_stmt|;
name|stub14_group_size
operator|=
name|stub_group_size
expr_stmt|;
if|if
condition|(
name|stub_group_size
operator|==
literal|1
condition|)
block|{
comment|/* Default values.  */
if|if
condition|(
name|stubs_always_before_branch
condition|)
block|{
name|stub_group_size
operator|=
literal|0x1e00000
expr_stmt|;
name|stub14_group_size
operator|=
literal|0x7800
expr_stmt|;
block|}
else|else
block|{
name|stub_group_size
operator|=
literal|0x1c00000
expr_stmt|;
name|stub14_group_size
operator|=
literal|0x7000
expr_stmt|;
block|}
name|suppress_size_errors
operator|=
name|TRUE
expr_stmt|;
block|}
name|list
operator|=
name|htab
operator|->
name|input_list
operator|+
name|htab
operator|->
name|top_index
expr_stmt|;
do|do
block|{
name|asection
modifier|*
name|tail
init|=
operator|*
name|list
decl_stmt|;
while|while
condition|(
name|tail
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|curr
decl_stmt|;
name|asection
modifier|*
name|prev
decl_stmt|;
name|bfd_size_type
name|total
decl_stmt|;
name|bfd_boolean
name|big_sec
decl_stmt|;
name|bfd_vma
name|curr_toc
decl_stmt|;
name|curr
operator|=
name|tail
expr_stmt|;
name|total
operator|=
name|tail
operator|->
name|size
expr_stmt|;
name|big_sec
operator|=
name|total
operator|>
operator|(
name|ppc64_elf_section_data
argument_list|(
name|tail
argument_list|)
operator|->
name|has_14bit_branch
condition|?
name|stub14_group_size
else|:
name|stub_group_size
operator|)
expr_stmt|;
if|if
condition|(
name|big_sec
operator|&&
operator|!
name|suppress_size_errors
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B section %A exceeds stub group size"
argument_list|)
argument_list|,
name|tail
operator|->
name|owner
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|curr_toc
operator|=
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|toc_off
expr_stmt|;
while|while
condition|(
operator|(
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|curr
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|total
operator|+=
name|curr
operator|->
name|output_offset
operator|-
name|prev
operator|->
name|output_offset
operator|)
operator|<
operator|(
name|ppc64_elf_section_data
argument_list|(
name|prev
argument_list|)
operator|->
name|has_14bit_branch
condition|?
name|stub14_group_size
else|:
name|stub_group_size
operator|)
operator|)
operator|&&
name|htab
operator|->
name|stub_group
index|[
name|prev
operator|->
name|id
index|]
operator|.
name|toc_off
operator|==
name|curr_toc
condition|)
name|curr
operator|=
name|prev
expr_stmt|;
comment|/* OK, the size from the start of CURR to the end is less 	     than stub_group_size and thus can be handled by one stub 	     section.  (or the tail section is itself larger than 	     stub_group_size, in which case we may be toast.)  We 	     should really be keeping track of the total size of stubs 	     added here, as stubs contribute to the final output 	     section size.  That's a little tricky, and this way will 	     only break if stubs added make the total size more than 	     2^25, ie. for the default stub_group_size, if stubs total 	     more than 2097152 bytes, or nearly 75000 plt call stubs.  */
do|do
block|{
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Set up this stub group.  */
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|link_sec
operator|=
name|curr
expr_stmt|;
block|}
do|while
condition|(
name|tail
operator|!=
name|curr
operator|&&
operator|(
name|tail
operator|=
name|prev
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* But wait, there's more!  Input sections up to stub_group_size 	     bytes before the stub section can be handled by it too. 	     Don't do this if we have a really large section after the 	     stubs, as adding more stubs increases the chance that 	     branches may not reach into the stub section.  */
if|if
condition|(
operator|!
name|stubs_always_before_branch
operator|&&
operator|!
name|big_sec
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|prev
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|total
operator|+=
name|tail
operator|->
name|output_offset
operator|-
name|prev
operator|->
name|output_offset
operator|)
operator|<
operator|(
name|ppc64_elf_section_data
argument_list|(
name|prev
argument_list|)
operator|->
name|has_14bit_branch
condition|?
name|stub14_group_size
else|:
name|stub_group_size
operator|)
operator|)
operator|&&
name|htab
operator|->
name|stub_group
index|[
name|prev
operator|->
name|id
index|]
operator|.
name|toc_off
operator|==
name|curr_toc
condition|)
block|{
name|tail
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|link_sec
operator|=
name|curr
expr_stmt|;
block|}
block|}
name|tail
operator|=
name|prev
expr_stmt|;
block|}
block|}
do|while
condition|(
name|list
operator|--
operator|!=
name|htab
operator|->
name|input_list
condition|)
do|;
name|free
argument_list|(
name|htab
operator|->
name|input_list
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PREV_SEC
block|}
end_function

begin_comment
comment|/* Determine and set the size of the stub section for a final link.     The basic idea here is to examine all the relocations looking for    PC-relative calls to a target that is unreachable with a "bl"    instruction.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_size_stubs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_signed_vma
name|group_size
parameter_list|,
name|asection
modifier|*
function_decl|(
modifier|*
name|add_stub_section
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|layout_sections_again
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|bfd_size_type
name|stub_group_size
decl_stmt|;
name|bfd_boolean
name|stubs_always_before_branch
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* Stash our params away.  */
name|htab
operator|->
name|add_stub_section
operator|=
name|add_stub_section
expr_stmt|;
name|htab
operator|->
name|layout_sections_again
operator|=
name|layout_sections_again
expr_stmt|;
name|stubs_always_before_branch
operator|=
name|group_size
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|group_size
operator|<
literal|0
condition|)
name|stub_group_size
operator|=
operator|-
name|group_size
expr_stmt|;
else|else
name|stub_group_size
operator|=
name|group_size
expr_stmt|;
name|group_sections
argument_list|(
name|htab
argument_list|,
name|stub_group_size
argument_list|,
name|stubs_always_before_branch
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|unsigned
name|int
name|bfd_indx
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|htab
operator|->
name|stub_iteration
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_indx
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|is_ppc64_elf_target
argument_list|(
name|input_bfd
operator|->
name|xvec
argument_list|)
condition|)
continue|continue;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
comment|/* Walk over each section attached to the input bfd.  */
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|,
modifier|*
name|irelaend
decl_stmt|,
modifier|*
name|irela
decl_stmt|;
comment|/* If there aren't any relocs, then there's nothing more 		 to do.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this section is a link-once section that will be 		 discarded, then don't create any stubs.  */
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|section
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|output_bfd
condition|)
continue|continue;
comment|/* Get the relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_local
goto|;
comment|/* Now examine each relocation.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|int
name|r_indx
decl_stmt|;
name|enum
name|ppc_stub_type
name|stub_type
decl_stmt|;
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|,
modifier|*
name|code_sec
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|bfd_vma
name|destination
decl_stmt|;
name|bfd_boolean
name|ok_dest
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|stub_name
decl_stmt|;
specifier|const
name|asection
modifier|*
name|id_sec
decl_stmt|;
name|long
modifier|*
name|opd_adjust
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_indx
operator|=
name|ELF64_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>=
name|R_PPC64_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
comment|/* Only look for stubs on branch instructions.  */
if|if
condition|(
name|r_type
operator|!=
name|R_PPC64_REL24
operator|&&
name|r_type
operator|!=
name|R_PPC64_REL14
operator|&&
name|r_type
operator|!=
name|R_PPC64_REL14_BRTAKEN
operator|&&
name|r_type
operator|!=
name|R_PPC64_REL14_BRNTAKEN
condition|)
continue|continue;
comment|/* Now determine the call target, its name, value, 		     section.  */
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_indx
argument_list|,
name|input_bfd
argument_list|)
condition|)
goto|goto
name|error_ret_free_internal
goto|;
name|hash
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|ok_dest
operator|=
name|FALSE
expr_stmt|;
name|fdh
operator|=
name|NULL
expr_stmt|;
name|sym_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
block|{
name|sym_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ok_dest
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_value
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|ok_dest
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
comment|/* Recognise an old ABI func code entry sym, and 			 use the func descriptor sym instead if it is 			 defined.  */
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|fdh
operator|=
name|get_fdh
argument_list|(
name|hash
argument_list|,
name|htab
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_sec
operator|=
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sym_value
operator|=
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|ok_dest
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fdh
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
name|destination
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ok_dest
condition|)
block|{
name|sym_value
operator|+=
name|irela
operator|->
name|r_addend
expr_stmt|;
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
name|code_sec
operator|=
name|sym_sec
expr_stmt|;
name|opd_adjust
operator|=
name|get_opd_info
argument_list|(
name|sym_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_adjust
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|dest
decl_stmt|;
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
block|{
name|long
name|adjust
init|=
name|opd_adjust
index|[
name|sym_value
operator|/
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|adjust
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|sym_value
operator|+=
name|adjust
expr_stmt|;
block|}
name|dest
operator|=
name|opd_entry_value
argument_list|(
name|sym_sec
argument_list|,
name|sym_value
argument_list|,
operator|&
name|code_sec
argument_list|,
operator|&
name|sym_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|destination
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|fdh
operator|!=
name|NULL
condition|)
block|{
comment|/* Fixup old ABI sym to point at code 				 entry.  */
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defweak
expr_stmt|;
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|code_sec
expr_stmt|;
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|sym_value
expr_stmt|;
block|}
block|}
block|}
comment|/* Determine what (if any) linker stub is needed.  */
name|stub_type
operator|=
name|ppc_type_of_stub
argument_list|(
name|section
argument_list|,
name|irela
argument_list|,
operator|&
name|hash
argument_list|,
name|destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_type
operator|!=
name|ppc_stub_plt_call
condition|)
block|{
comment|/* Check whether we need a TOC adjusting stub. 			 Since the linker pastes together pieces from 			 different object files when creating the 			 _init and _fini functions, it may be that a 			 call to what looks like a local sym is in 			 fact a call needing a TOC adjustment.  */
if|if
condition|(
name|code_sec
operator|!=
name|NULL
operator|&&
name|code_sec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
operator|(
name|htab
operator|->
name|stub_group
index|[
name|code_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|!=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
operator|&&
operator|(
name|code_sec
operator|->
name|has_toc_reloc
operator|||
name|code_sec
operator|->
name|makes_toc_func_call
operator|)
condition|)
name|stub_type
operator|=
name|ppc_stub_long_branch_r2off
expr_stmt|;
block|}
if|if
condition|(
name|stub_type
operator|==
name|ppc_stub_none
condition|)
continue|continue;
comment|/* __tls_get_addr calls might be eliminated.  */
if|if
condition|(
name|stub_type
operator|!=
name|ppc_stub_plt_call
operator|&&
name|hash
operator|!=
name|NULL
operator|&&
operator|(
name|hash
operator|==
name|htab
operator|->
name|tls_get_addr
operator|||
name|hash
operator|==
name|htab
operator|->
name|tls_get_addr_fd
operator|)
operator|&&
name|section
operator|->
name|has_tls_reloc
operator|&&
name|irela
operator|!=
name|internal_relocs
condition|)
block|{
comment|/* Get tls info.  */
name|char
modifier|*
name|tls_mask
decl_stmt|;
if|if
condition|(
operator|!
name|get_tls_mask
argument_list|(
operator|&
name|tls_mask
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|irela
operator|-
literal|1
argument_list|,
name|input_bfd
argument_list|)
condition|)
goto|goto
name|error_ret_free_internal
goto|;
if|if
condition|(
operator|*
name|tls_mask
operator|!=
literal|0
condition|)
continue|continue;
block|}
comment|/* Support for grouping stub sections.  */
name|id_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
comment|/* Get the name of this stub.  */
name|stub_name
operator|=
name|ppc_stub_name
argument_list|(
name|id_sec
argument_list|,
name|sym_sec
argument_list|,
name|hash
argument_list|,
name|irela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_name
condition|)
goto|goto
name|error_ret_free_internal
goto|;
name|stub_entry
operator|=
name|ppc_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|!=
name|NULL
condition|)
block|{
comment|/* The proper stub has already been created.  */
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stub_entry
operator|=
name|ppc_add_stub
argument_list|(
name|stub_name
argument_list|,
name|section
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
name|error_ret_free_internal
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|error_ret_free_local
label|:
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
operator|)
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|stub_entry
operator|->
name|stub_type
operator|=
name|stub_type
expr_stmt|;
name|stub_entry
operator|->
name|target_value
operator|=
name|sym_value
expr_stmt|;
name|stub_entry
operator|->
name|target_section
operator|=
name|code_sec
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|=
name|hash
expr_stmt|;
name|stub_entry
operator|->
name|addend
operator|=
name|irela
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|h
operator|!=
name|NULL
condition|)
name|htab
operator|->
name|stub_globals
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* We're done with the internal relocs, free them.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
block|}
comment|/* We may have added some stubs.  Find out the new size of the 	 stub sections.  */
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|stub_sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
name|stub_sec
operator|->
name|rawsize
operator|=
name|stub_sec
operator|->
name|size
expr_stmt|;
name|stub_sec
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|stub_sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|stub_sec
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
block|}
name|htab
operator|->
name|brlt
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|brlt
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|brlt
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|relbrlt
operator|!=
name|NULL
condition|)
name|htab
operator|->
name|relbrlt
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|ppc_size_one_stub
argument_list|,
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|stub_sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
operator|&&
name|stub_sec
operator|->
name|rawsize
operator|!=
name|stub_sec
operator|->
name|size
condition|)
break|break;
comment|/* Exit from this loop when no stubs have been added, and no stubs 	 have changed size.  */
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
break|break;
comment|/* Ask the linker to do its stuff.  */
call|(
modifier|*
name|htab
operator|->
name|layout_sections_again
call|)
argument_list|()
expr_stmt|;
block|}
comment|/* It would be nice to strip htab->brlt from the output if the      section is empty, but it's too late.  If we strip sections here,      the dynamic symbol table is corrupted since the section symbol      for the stripped section isn't written.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called after we have determined section placement.  If sections    move, we'll be called again.  Provide a value for TOCstart.  */
end_comment

begin_function
name|bfd_vma
name|ppc64_elf_toc
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* The TOC consists of sections .got, .toc, .tocbss, .plt in that      order.  The TOC starts where the first of these sections starts.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".toc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".tocbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* This may happen for 	 o  references to TOC base (SYM@toc / TOC[tc0]) without a 	 .toc directive 	 o  bad linker script 	 o --gc-sections and empty TOC sections  	 FIXME: Warn user?  */
comment|/* Look for a likely section.  We probably won't even be 	 using TOCstart.  */
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
name|SEC_ALLOC
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
name|SEC_ALLOC
condition|)
break|break;
block|}
name|TOCstart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|TOCstart
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
return|return
name|TOCstart
return|;
block|}
end_function

begin_comment
comment|/* Build all the stubs associated with the current output file.    The stubs are kept in a hash table attached to the main linker    hash table.  This function is called via gldelf64ppc_finish.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_build_stubs
parameter_list|(
name|bfd_boolean
name|emit_stub_syms
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|char
modifier|*
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|int
name|stub_sec_count
init|=
literal|0
decl_stmt|;
name|htab
operator|->
name|emit_stub_syms
operator|=
name|emit_stub_syms
expr_stmt|;
comment|/* Allocate memory to hold the linker stubs.  */
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|stub_sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
operator|&&
name|stub_sec
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|stub_sec
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|stub_sec
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* We want to check that built size is the same as calculated 	   size.  rawsize is a convenient location to use.  */
name|stub_sec
operator|->
name|rawsize
operator|=
name|stub_sec
operator|->
name|size
expr_stmt|;
name|stub_sec
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|glink
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|glink
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|indx
decl_stmt|;
name|bfd_vma
name|plt0
decl_stmt|;
comment|/* Build the .glink plt call stub.  */
if|if
condition|(
name|htab
operator|->
name|emit_stub_syms
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
literal|"__glink"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|8
expr_stmt|;
name|h
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|p
operator|=
name|htab
operator|->
name|glink
operator|->
name|contents
expr_stmt|;
name|plt0
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|-
operator|(
name|htab
operator|->
name|glink
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_offset
operator|+
literal|16
operator|)
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|plt0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|MFLR_R12
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|BCL_20_31
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|MFLR_R11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LD_R2_M16R11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|MTLR_R12
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|ADD_R12_R2_R11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LD_R11_0R12
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LD_R2_0R12
operator||
literal|8
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|MTCTR_R11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LD_R11_0R12
operator||
literal|16
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|BCTR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
name|p
operator|-
name|htab
operator|->
name|glink
operator|->
name|contents
operator|<
name|GLINK_CALL_STUB_SIZE
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|NOP
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Build the .glink lazy link call stubs.  */
name|indx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|htab
operator|->
name|glink
operator|->
name|contents
operator|+
name|htab
operator|->
name|glink
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|indx
operator|<
literal|0x8000
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LI_R0_0
operator||
name|indx
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LIS_R0_0
operator||
name|PPC_HI
argument_list|(
name|indx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|ORI_R0_R0_0
operator||
name|PPC_LO
argument_list|(
name|indx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|B_DOT
operator||
operator|(
operator|(
name|htab
operator|->
name|glink
operator|->
name|contents
operator|-
name|p
operator|+
literal|8
operator|)
operator|&
literal|0x3fffffc
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|htab
operator|->
name|glink
operator|->
name|rawsize
operator|=
name|p
operator|-
name|htab
operator|->
name|glink
operator|->
name|contents
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|brlt
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|brlt
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|brlt
operator|->
name|owner
argument_list|,
name|htab
operator|->
name|brlt
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|brlt
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|relbrlt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|relbrlt
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|relbrlt
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|relbrlt
operator|->
name|owner
argument_list|,
name|htab
operator|->
name|relbrlt
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|relbrlt
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Build the stubs as directed by the stub hash table.  */
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|ppc_build_one_stub
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|relbrlt
operator|!=
name|NULL
condition|)
name|htab
operator|->
name|relbrlt
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|stub_sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
name|stub_sec_count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|->
name|rawsize
operator|!=
name|stub_sec
operator|->
name|size
condition|)
break|break;
block|}
if|if
condition|(
name|stub_sec
operator|!=
name|NULL
operator|||
name|htab
operator|->
name|glink
operator|->
name|rawsize
operator|!=
name|htab
operator|->
name|glink
operator|->
name|size
condition|)
block|{
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stubs don't match calculated size"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|stub_error
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|stats
operator|!=
name|NULL
condition|)
block|{
operator|*
name|stats
operator|=
name|bfd_malloc
argument_list|(
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|stats
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sprintf
argument_list|(
operator|*
name|stats
argument_list|,
name|_
argument_list|(
literal|"linker stubs in %u group%s\n"
literal|"  branch       %lu\n"
literal|"  toc adjust   %lu\n"
literal|"  long branch  %lu\n"
literal|"  long toc adj %lu\n"
literal|"  plt call     %lu"
argument_list|)
argument_list|,
name|stub_sec_count
argument_list|,
name|stub_sec_count
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_long_branch
operator|-
literal|1
index|]
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_long_branch_r2off
operator|-
literal|1
index|]
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_plt_branch
operator|-
literal|1
index|]
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_plt_branch_r2off
operator|-
literal|1
index|]
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_plt_call
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function undoes the changes made by add_symbol_adjust.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|undo_symbol_twiddle
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|||
operator|!
name|eh
operator|->
name|was_undefined
condition|)
return|return
name|TRUE
return|;
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|ppc64_elf_restore_symbols
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|undo_symbol_twiddle
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* What to do when ld finds relocations against symbols defined in    discarded sections.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ppc64_elf_action_discarded
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|".opd"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
literal|".toc"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
literal|".toc1"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
return|return
literal|0
return|;
return|return
name|_bfd_elf_default_action_discarded
argument_list|(
name|sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjust the section contents as    necessary, and (if using Rela relocs and generating a    relocatable output file) adjusting the reloc addend as    necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|struct
name|got_entry
modifier|*
modifier|*
name|local_got_ents
decl_stmt|;
name|bfd_vma
name|TOCstart
decl_stmt|;
name|bfd_boolean
name|ret
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|is_opd
decl_stmt|;
comment|/* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
name|bfd_boolean
name|is_power4
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|d_offset
init|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
literal|2
else|:
literal|0
operator|)
decl_stmt|;
comment|/* Initialize howto table if needed.  */
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
name|ppc_howto_init
argument_list|()
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Don't relocate stub sections.  */
if|if
condition|(
name|input_section
operator|->
name|owner
operator|==
name|htab
operator|->
name|stub_bfd
condition|)
return|return
name|TRUE
return|;
name|local_got_ents
operator|=
name|elf_local_got_ents
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|TOCstart
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|is_opd
operator|=
name|ppc64_elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sec_type
operator|==
name|sec_opd
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|,
name|orig_addend
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h_elf
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|,
name|toc_symndx
decl_stmt|;
name|char
name|tls_mask
decl_stmt|,
name|tls_gd
decl_stmt|,
name|tls_type
decl_stmt|;
name|char
name|sym_type
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_boolean
name|warned
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|bfd_vma
name|max_br_offset
decl_stmt|;
name|bfd_vma
name|from
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* For old style R_PPC64_TOC relocs with a zero symbol, use the 	 symbol of the previous ADDR64 reloc.  The symbol gives us the 	 proper TOC base to use.  */
if|if
condition|(
name|rel
operator|->
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_TOC
argument_list|)
operator|&&
name|rel
operator|!=
name|relocs
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_ADDR64
operator|&&
name|is_opd
condition|)
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|h_elf
operator|=
name|NULL
expr_stmt|;
name|sym_name
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|warned
operator|=
name|FALSE
expr_stmt|;
name|orig_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* It's a local symbol.  */
name|long
modifier|*
name|opd_adjust
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_sym_name
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|sym_type
operator|=
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|opd_adjust
operator|=
name|get_opd_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_adjust
operator|!=
name|NULL
condition|)
block|{
name|long
name|adjust
init|=
name|opd_adjust
index|[
operator|(
name|sym
operator|->
name|st_value
operator|+
name|rel
operator|->
name|r_addend
operator|)
operator|/
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|adjust
operator|==
operator|-
literal|1
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* If this is a relocation against the opd section sym 		     and we have edited .opd, adjust the reloc addend so 		     that ld -r and ld --emit-relocs output is correct. 		     If it is a reloc against some other .opd symbol, 		     then the symbol value will be adjusted later.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
name|rel
operator|->
name|r_addend
operator|+=
name|adjust
expr_stmt|;
else|else
name|relocation
operator|+=
name|adjust
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h_elf
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|h_elf
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|sym_type
operator|=
name|h_elf
operator|->
name|type
expr_stmt|;
block|}
name|h
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h_elf
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
comment|/* TLS optimizations.  Replace instruction sequences and relocs 	 based on information we collected in tls_optimize.  We edit 	 RELOCS so that --emit-relocs will output something sensible 	 for the final instruction stream.  */
name|tls_mask
operator|=
literal|0
expr_stmt|;
name|tls_gd
operator|=
literal|0
expr_stmt|;
name|toc_symndx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_PPC64_TLS_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|tls_mask
operator|=
name|h
operator|->
name|tls_mask
expr_stmt|;
elseif|else
if|if
condition|(
name|local_got_ents
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|lgot_masks
decl_stmt|;
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_ents
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|tls_mask
operator|=
name|lgot_masks
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
if|if
condition|(
name|tls_mask
operator|==
literal|0
operator|&&
name|r_type
operator|==
name|R_PPC64_TLS
condition|)
block|{
comment|/* Check for toc tls entries.  */
name|char
modifier|*
name|toc_tls
decl_stmt|;
if|if
condition|(
operator|!
name|get_tls_mask
argument_list|(
operator|&
name|toc_tls
argument_list|,
operator|&
name|toc_symndx
argument_list|,
operator|&
name|local_syms
argument_list|,
name|rel
argument_list|,
name|input_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|toc_tls
condition|)
name|tls_mask
operator|=
operator|*
name|toc_tls
expr_stmt|;
block|}
block|}
comment|/* Check that tls relocs are used with tls syms, and non-tls 	 relocs are used with non-tls syms.  */
if|if
condition|(
name|r_symndx
operator|!=
literal|0
operator|&&
name|r_type
operator|!=
name|R_PPC64_NONE
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|IS_PPC64_TLS_RELOC
argument_list|(
name|r_type
argument_list|)
operator|!=
operator|(
name|sym_type
operator|==
name|STT_TLS
operator|)
condition|)
block|{
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_TLS
operator|&&
name|tls_mask
operator|!=
literal|0
condition|)
comment|/* R_PPC64_TLS is OK against a symbol in the TOC.  */
empty_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|sym_type
operator|==
name|STT_TLS
condition|?
name|_
argument_list|(
literal|"%B(%A+0x%lx): %s used with TLS symbol %s"
argument_list|)
else|:
name|_
argument_list|(
literal|"%B(%A+0x%lx): %s used with non-TLS symbol %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure reloc mapping code below stays sane.  */
if|if
condition|(
name|R_PPC64_TOC16_LO_DS
operator|!=
name|R_PPC64_TOC16_DS
operator|+
literal|1
operator|||
name|R_PPC64_TOC16_LO
operator|!=
name|R_PPC64_TOC16
operator|+
literal|1
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_LO
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TLSGD16_LO
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_HI
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TLSGD16_HI
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_HA
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TLSGD16_HA
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TPREL16_DS
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_LO
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TPREL16_LO_DS
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_HI
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TPREL16_HI
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_HA
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TPREL16_HA
operator|&
literal|3
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
block|{
comment|/* Check for toc tls entries.  */
name|char
modifier|*
name|toc_tls
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|get_tls_mask
argument_list|(
operator|&
name|toc_tls
argument_list|,
operator|&
name|toc_symndx
argument_list|,
operator|&
name|local_syms
argument_list|,
name|rel
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|toc_tls
condition|)
block|{
name|tls_mask
operator|=
operator|*
name|toc_tls
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_TOC16_DS
operator|||
name|r_type
operator|==
name|R_PPC64_TOC16_LO_DS
condition|)
block|{
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
operator|(
name|TLS_DTPREL
operator||
name|TLS_TPREL
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|toctprel
goto|;
block|}
else|else
block|{
comment|/* If we found a GD reloc pair, then we might be 		       doing a GD->IE transition.  */
if|if
condition|(
name|retval
operator|==
literal|2
condition|)
block|{
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_get_addr_check
goto|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_get_addr_check
goto|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|toctprel
label|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
name|d_offset
argument_list|)
expr_stmt|;
name|insn
operator|&=
literal|31
operator|<<
literal|21
expr_stmt|;
name|insn
operator||=
literal|0x3c0d0000
expr_stmt|;
comment|/* addis 0,13,0 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
name|d_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_TPREL16_HA
expr_stmt|;
if|if
condition|(
name|toc_symndx
operator|!=
literal|0
condition|)
block|{
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|toc_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
comment|/* We changed the symbol.  Start over in order to 		     get h, sym, sec etc. right.  */
name|rel
operator|--
expr_stmt|;
continue|continue;
block|}
else|else
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_TLS
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|rtra
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator||
operator|(
literal|31
operator|<<
literal|11
operator|)
operator|)
operator|)
operator|==
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|13
operator|<<
literal|11
operator|)
operator|)
condition|)
name|rtra
operator|=
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator||
operator|(
literal|31
operator|<<
literal|16
operator|)
operator|)
operator|)
operator|==
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|13
operator|<<
literal|16
operator|)
operator|)
condition|)
name|rtra
operator|=
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|21
operator|)
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|11
operator|)
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
operator|==
literal|266
operator|<<
literal|1
condition|)
comment|/* add -> addi.  */
name|insn
operator|=
literal|14
operator|<<
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|23
operator|<<
literal|1
operator|&&
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|<
literal|14
operator|<<
literal|6
operator|||
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|>=
literal|16
operator|<<
literal|6
operator|&&
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|<
literal|24
operator|<<
literal|6
operator|)
operator|)
condition|)
comment|/* load and store indexed -> dform.  */
name|insn
operator|=
operator|(
literal|32
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|31
operator|)
operator|)
operator|<<
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|21
operator|<<
literal|1
operator|&&
operator|(
name|insn
operator|&
operator|(
literal|0x1a
operator|<<
literal|6
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
name|insn
operator|=
operator|(
operator|(
operator|(
literal|58
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|4
operator|)
operator|)
operator|<<
literal|26
operator|)
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|21
operator|<<
literal|1
operator|&&
operator|(
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
operator|==
literal|341
operator|<<
literal|1
condition|)
comment|/* lwax -> lwa.  */
name|insn
operator|=
operator|(
literal|58
operator|<<
literal|26
operator|)
operator||
literal|2
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|insn
operator||=
name|rtra
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Was PPC64_TLS which sits on insn boundary, now 		 PPC64_TPREL16_LO which is at low-order half-word.  */
name|rel
operator|->
name|r_offset
operator|+=
name|d_offset
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_TPREL16_LO
expr_stmt|;
if|if
condition|(
name|toc_symndx
operator|!=
literal|0
condition|)
block|{
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|toc_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
comment|/* We changed the symbol.  Start over in order to 		     get h, sym, sec etc. right.  */
name|rel
operator|--
expr_stmt|;
continue|continue;
block|}
else|else
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_gdld_hi
goto|;
break|break;
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|tls_gdld_hi
label|:
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|tls_gd
operator|)
operator|!=
literal|0
condition|)
name|r_type
operator|=
operator|(
operator|(
operator|(
name|r_type
operator|-
operator|(
name|R_PPC64_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
name|R_PPC64_GOT_TPREL16_DS
operator|)
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_offset
operator|-=
name|d_offset
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_NONE
expr_stmt|;
block|}
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_get_addr_check
goto|;
break|break;
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|tls_get_addr_check
label|:
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
condition|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type2
decl_stmt|;
name|unsigned
name|long
name|r_symndx2
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h2
decl_stmt|;
name|bfd_vma
name|insn1
decl_stmt|,
name|insn2
decl_stmt|,
name|insn3
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
comment|/* The next instruction should be a call to 		     __tls_get_addr.  Peek at the reloc to be sure.  */
name|r_type2
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx2
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx2
operator|<
name|symtab_hdr
operator|->
name|sh_info
operator|||
operator|(
name|r_type2
operator|!=
name|R_PPC64_REL14
operator|&&
name|r_type2
operator|!=
name|R_PPC64_REL14_BRTAKEN
operator|&&
name|r_type2
operator|!=
name|R_PPC64_REL14_BRNTAKEN
operator|&&
name|r_type2
operator|!=
name|R_PPC64_REL24
operator|)
condition|)
break|break;
name|h2
operator|=
name|sym_hashes
index|[
name|r_symndx2
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h2
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h2
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h2
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h2
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h2
operator|==
name|NULL
operator|||
operator|(
name|h2
operator|!=
operator|&
name|htab
operator|->
name|tls_get_addr
operator|->
name|elf
operator|&&
name|h2
operator|!=
operator|&
name|htab
operator|->
name|tls_get_addr_fd
operator|->
name|elf
operator|)
condition|)
break|break;
comment|/* OK, it checks out.  Replace the call.  */
name|offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
expr_stmt|;
name|insn1
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
name|d_offset
argument_list|)
expr_stmt|;
name|insn3
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|tls_gd
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* IE */
name|insn1
operator|&=
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
name|insn1
operator||=
literal|58
operator|<<
literal|26
expr_stmt|;
comment|/* ld */
name|insn2
operator|=
literal|0x7c636a14
expr_stmt|;
comment|/* add 3,3,13 */
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx2
argument_list|,
name|R_PPC64_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_EXPLICIT
operator|)
operator|==
literal|0
condition|)
name|r_type
operator|=
operator|(
operator|(
operator|(
name|r_type
operator|-
operator|(
name|R_PPC64_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
name|R_PPC64_GOT_TPREL16_DS
operator|)
expr_stmt|;
else|else
name|r_type
operator|+=
name|R_PPC64_TOC16_DS
operator|-
name|R_PPC64_TOC16
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* LE */
name|insn1
operator|=
literal|0x3c6d0000
expr_stmt|;
comment|/* addis 3,13,0 */
name|insn2
operator|=
literal|0x38630000
expr_stmt|;
comment|/* addi 3,3,0 */
if|if
condition|(
name|tls_gd
operator|==
literal|0
condition|)
block|{
comment|/* Was an LD reloc.  */
name|r_symndx
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_addend
operator|=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toc_symndx
operator|!=
literal|0
condition|)
name|r_symndx
operator|=
name|toc_symndx
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_TPREL16_HA
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_TPREL16_LO
argument_list|)
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
name|d_offset
expr_stmt|;
block|}
if|if
condition|(
name|insn3
operator|==
name|NOP
operator|||
name|insn3
operator|==
name|CROR_151515
operator|||
name|insn3
operator|==
name|CROR_313131
condition|)
block|{
name|insn3
operator|=
name|insn2
expr_stmt|;
name|insn2
operator|=
name|NOP
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
name|d_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn2
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn3
argument_list|,
name|contents
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_gd
operator|==
literal|0
operator|||
name|toc_symndx
operator|!=
literal|0
condition|)
block|{
comment|/* We changed the symbol.  Start over in order 			 to get h, sym, sec etc. right.  */
name|rel
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
block|}
break|break;
case|case
name|R_PPC64_DTPMOD64
case|:
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|==
name|rel
operator|->
name|r_offset
operator|+
literal|8
condition|)
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
block|{
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_TPRELGD
operator|)
operator|!=
literal|0
condition|)
name|r_type
operator|=
name|R_PPC64_TPREL64
expr_stmt|;
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
literal|1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_NONE
expr_stmt|;
block|}
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
literal|1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_NONE
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_PPC64_TPREL64
case|:
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|r_type
operator|=
name|R_PPC64_NONE
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Handle other relocations that tweak non-addend part of insn.  */
name|insn
operator|=
literal|0
expr_stmt|;
name|max_br_offset
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
comment|/* Branch taken prediction relocations.  */
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
name|insn
operator|=
literal|0x01
operator|<<
literal|21
expr_stmt|;
comment|/* 'y' or 't' bit, lowest bit of BO field.  */
comment|/* Fall thru.  */
comment|/* Branch not taken prediction relocations.  */
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
name|insn
operator||=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
operator|&
operator|~
operator|(
literal|0x01
operator|<<
literal|21
operator|)
expr_stmt|;
comment|/* Fall thru.  */
case|case
name|R_PPC64_REL14
case|:
name|max_br_offset
operator|=
literal|1
operator|<<
literal|15
expr_stmt|;
comment|/* Fall thru.  */
case|case
name|R_PPC64_REL24
case|:
comment|/* Calls to functions with a different TOC, such as calls to 	     shared objects, need to alter the TOC pointer.  This is 	     done using a linkage stub.  A REL24 branching to these 	     linkage stubs needs to be followed by a nop, as the nop 	     will be replaced with an instruction to restore the TOC 	     base pointer.  */
name|stub_entry
operator|=
name|NULL
expr_stmt|;
name|fdh
operator|=
name|h
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|(
name|fdh
operator|=
name|h
operator|->
name|oh
operator|)
operator|!=
name|NULL
operator|&&
name|fdh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|fdh
operator|=
name|h
operator|)
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|!=
name|NULL
operator|)
operator|)
operator|||
operator|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|id
operator|<=
name|htab
operator|->
name|top_id
operator|&&
operator|(
name|htab
operator|->
name|stub_group
index|[
name|sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|!=
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
operator|)
operator|)
operator|&&
operator|(
name|stub_entry
operator|=
name|ppc_get_stub_entry
argument_list|(
name|input_section
argument_list|,
name|sec
argument_list|,
name|fdh
argument_list|,
name|rel
argument_list|,
name|htab
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
operator|||
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_branch_r2off
operator|||
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_long_branch_r2off
operator|)
condition|)
block|{
name|bfd_boolean
name|can_plt_call
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|+
literal|8
operator|<=
name|input_section
operator|->
name|size
condition|)
block|{
name|unsigned
name|long
name|nop
decl_stmt|;
name|nop
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|nop
operator|==
name|NOP
operator|||
name|nop
operator|==
name|CROR_151515
operator|||
name|nop
operator|==
name|CROR_313131
condition|)
block|{
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|LD_R2_40R1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|can_plt_call
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|can_plt_call
condition|)
block|{
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
condition|)
block|{
comment|/* If this is a plain branch rather than a branch 			 and link, don't require a nop.  However, don't 			 allow tail calls in a shared library as they 			 will result in r2 being corrupted.  */
name|unsigned
name|long
name|br
decl_stmt|;
name|br
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|(
name|br
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|can_plt_call
operator|=
name|TRUE
expr_stmt|;
else|else
name|stub_entry
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|".__libc_start_main"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Allow crt1 branch to go via a toc adjusting stub.  */
name|can_plt_call
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): automatic multiple TOCs "
literal|"not supported using your crt files; "
literal|"recompile with -mminimal-toc or upgrade gcc"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): sibling call optimization to `%s' "
literal|"does not allow automatic multiple TOCs; "
literal|"recompile with -mminimal-toc or "
literal|"-fno-optimize-sibling-calls, "
literal|"or make `%s' extern"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|sym_name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|can_plt_call
operator|&&
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
condition|)
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|stub_entry
operator|==
name|NULL
operator|&&
name|get_opd_info
argument_list|(
name|sec
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* The branch destination is the value of the opd entry. */
name|bfd_vma
name|off
init|=
operator|(
name|relocation
operator|+
name|addend
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|sec
operator|->
name|output_offset
operator|)
decl_stmt|;
name|bfd_vma
name|dest
init|=
name|opd_entry_value
argument_list|(
name|sec
argument_list|,
name|off
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|relocation
operator|=
name|dest
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the branch is out of reach we ought to have a long 	     branch stub.  */
name|from
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
operator|&&
operator|(
name|relocation
operator|+
name|addend
operator|-
name|from
operator|+
name|max_br_offset
operator|>=
literal|2
operator|*
name|max_br_offset
operator|)
operator|&&
name|r_type
operator|!=
name|R_PPC64_ADDR14_BRTAKEN
operator|&&
name|r_type
operator|!=
name|R_PPC64_ADDR14_BRNTAKEN
condition|)
name|stub_entry
operator|=
name|ppc_get_stub_entry
argument_list|(
name|input_section
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|!=
name|NULL
condition|)
block|{
comment|/* Munge up the value and addend so that we call the stub 		 rather than the procedure directly.  */
name|relocation
operator|=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|is_power4
condition|)
block|{
comment|/* Set 'a' bit.  This is 0b00010 in BO field for branch 		     on CR(BI) insns (BO == 001at or 011at), and 0b01000 		     for branch on CTR insns (BO == 1a00t or 1a01t).  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x04
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x02
operator|<<
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x10
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x08
operator|<<
literal|21
expr_stmt|;
else|else
break|break;
block|}
else|else
block|{
comment|/* Invert 'y' bit if not the default.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|relocation
operator|+
name|addend
operator|-
name|from
argument_list|)
operator|<
literal|0
condition|)
name|insn
operator|^=
literal|0x01
operator|<<
literal|21
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
comment|/* NOP out calls to undefined weak functions. 	     We can thus call a weak function without first 	     checking whether the function is defined.  */
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|r_type
operator|==
name|R_PPC64_REL24
operator|&&
name|relocation
operator|==
literal|0
operator|&&
name|addend
operator|==
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* Set `addend'.  */
name|tls_type
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unknown relocation type %d for symbol %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
case|case
name|R_PPC64_NONE
case|:
case|case
name|R_PPC64_TLS
case|:
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
case|case
name|R_PPC64_GNU_VTENTRY
case|:
continue|continue;
comment|/* GOT16 relocations.  Like an ADDR16 using the symbol's 	     address in the GOT as relocation value instead of the 	     symbol's value itself.  Also, create a GOT entry for the 	     symbol and put the symbol value there.  */
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_HI
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_DTPREL16_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
name|dogot
label|:
block|{
comment|/* Relocation is to the entry for this symbol in the global 	       offset table.  */
name|asection
modifier|*
name|got
decl_stmt|;
name|bfd_vma
modifier|*
name|offp
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|unsigned
name|long
name|indx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
operator|!
name|h
operator|->
name|elf
operator|.
name|def_dynamic
operator|)
condition|)
name|offp
operator|=
operator|&
name|ppc64_tlsld_got
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|offset
expr_stmt|;
else|else
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
init|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
decl_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
operator|&
name|h
operator|->
name|elf
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|elf
argument_list|)
operator|)
condition|)
comment|/* This is actually a static link, or it is a 			 -Bsymbolic link and the symbol is defined 			 locally, or the symbol was forced to be local 			 because of a version file.  */
empty_stmt|;
else|else
block|{
name|indx
operator|=
name|h
operator|->
name|elf
operator|.
name|dynindx
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
name|ent
operator|=
name|h
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_ents
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ent
operator|=
name|local_got_ents
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
for|for
control|(
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|orig_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|input_bfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offp
operator|=
operator|&
name|ent
operator|->
name|got
operator|.
name|offset
expr_stmt|;
block|}
name|got
operator|=
name|ppc64_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|got
expr_stmt|;
if|if
condition|(
name|got
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The offset must always be a multiple of 8.  We use the 	       least significant bit to record whether we have already 	       processed this entry.  */
name|off
operator|=
operator|*
name|offp
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
comment|/* Generate relocs for the dynamic linker, except in 		   the case of TLSLD where we'll use one entry per 		   module.  */
name|asection
modifier|*
name|relgot
init|=
name|ppc64_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|relgot
decl_stmt|;
operator|*
name|offp
operator|=
name|off
operator||
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|indx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|got
operator|->
name|output_section
operator|->
name|vma
operator|+
name|got
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
if|if
condition|(
name|tls_type
operator|&
operator|(
name|TLS_LD
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_DTPMOD64
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|loc
operator|=
name|relgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|relgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
literal|8
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_DTPREL
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_TPREL
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_TPREL64
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
comment|/* Write the .got section contents for the sake 			   of prelink.  */
name|loc
operator|=
name|got
operator|->
name|contents
operator|+
name|off
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|outrel
operator|.
name|r_addend
operator|+
name|relocation
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
else|else
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_GLOB_DAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
operator|&&
name|tls_type
operator|!=
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_addend
operator|+=
name|relocation
expr_stmt|;
if|if
condition|(
name|tls_type
operator|&
operator|(
name|TLS_GD
operator||
name|TLS_DTPREL
operator||
name|TLS_TPREL
operator|)
condition|)
name|outrel
operator|.
name|r_addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
expr_stmt|;
block|}
name|loc
operator|=
name|relgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|relgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Init the .got section contents here if we're not 		   emitting a reloc.  */
else|else
block|{
name|relocation
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
name|relocation
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_type
operator|!=
literal|0
condition|)
block|{
name|relocation
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_TPREL
operator|)
condition|)
name|relocation
operator|+=
name|DTP_OFFSET
operator|-
name|TP_OFFSET
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|got
operator|->
name|contents
operator|+
name|off
operator|+
literal|8
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|got
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|relocation
operator|=
name|got
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
comment|/* TOC base (r2) is TOC start plus 0x8000.  */
name|addend
operator|=
operator|-
name|TOC_BASE_OFF
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
comment|/* Resolve a PLT reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
comment|/* It's possible that we didn't make a PLT entry for this 	     symbol.  This happens when statically linking PIC code, 	     or when using -Bsymbolic.  Go find a match if there is a 	     PLT entry.  */
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|orig_addend
operator|&&
name|ent
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|relocation
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_PPC64_TOC
case|:
comment|/* Relocation value is TOC base.  */
name|relocation
operator|=
name|TOCstart
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
name|relocation
operator|+=
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|toc_off
expr_stmt|;
elseif|else
if|if
condition|(
name|unresolved_reloc
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|id
operator|<=
name|htab
operator|->
name|top_id
condition|)
name|relocation
operator|+=
name|htab
operator|->
name|stub_group
index|[
name|sec
operator|->
name|id
index|]
operator|.
name|toc_off
expr_stmt|;
else|else
name|unresolved_reloc
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|dodyn
goto|;
comment|/* TOC16 relocs.  We want the offset relative to the TOC base, 	     which is the address of the start of the TOC plus 0x8000. 	     The TOC consists of sections .got, .toc, .tocbss, and .plt, 	     in this order.  */
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
name|addend
operator|-=
name|TOCstart
operator|+
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|toc_off
expr_stmt|;
break|break;
comment|/* Relocate against the beginning of the section.  */
case|case
name|R_PPC64_SECTOFF
case|:
case|case
name|R_PPC64_SECTOFF_LO
case|:
case|case
name|R_PPC64_SECTOFF_HI
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL24
case|:
break|break;
case|case
name|R_PPC64_TPREL16
case|:
case|case
name|R_PPC64_TPREL16_LO
case|:
case|case
name|R_PPC64_TPREL16_HI
case|:
case|case
name|R_PPC64_TPREL16_HA
case|:
case|case
name|R_PPC64_TPREL16_DS
case|:
case|case
name|R_PPC64_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_TPREL16_HIGHER
case|:
case|case
name|R_PPC64_TPREL16_HIGHERA
case|:
case|case
name|R_PPC64_TPREL16_HIGHEST
case|:
case|case
name|R_PPC64_TPREL16_HIGHESTA
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|TP_OFFSET
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
comment|/* The TPREL16 relocs shouldn't really be used in shared 	       libs as they will result in DT_TEXTREL being set, but 	       support them anyway.  */
goto|goto
name|dodyn
goto|;
break|break;
case|case
name|R_PPC64_DTPREL16
case|:
case|case
name|R_PPC64_DTPREL16_LO
case|:
case|case
name|R_PPC64_DTPREL16_HI
case|:
case|case
name|R_PPC64_DTPREL16_HA
case|:
case|case
name|R_PPC64_DTPREL16_DS
case|:
case|case
name|R_PPC64_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_DTPREL16_HIGHER
case|:
case|case
name|R_PPC64_DTPREL16_HIGHERA
case|:
case|case
name|R_PPC64_DTPREL16_HIGHEST
case|:
case|case
name|R_PPC64_DTPREL16_HIGHESTA
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
break|break;
case|case
name|R_PPC64_DTPMOD64
case|:
name|relocation
operator|=
literal|1
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC64_TPREL64
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|TP_OFFSET
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC64_DTPREL64
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
comment|/* Fall thru */
comment|/* Relocations that may need to be propagated if this is a 	     dynamic object.  */
case|case
name|R_PPC64_REL30
case|:
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL64
case|:
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_ADDR64
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
name|dodyn
label|:
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|NO_OPD_RELOCS
operator|&&
name|is_opd
condition|)
break|break;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|elf
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|elf
operator|.
name|non_got_ref
operator|&&
name|h
operator|->
name|elf
operator|.
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|elf
operator|.
name|def_regular
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|out_off
decl_stmt|;
comment|/* When generating a dynamic object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
name|skip
operator|=
name|FALSE
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|out_off
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_off
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|out_off
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|out_off
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|out_off
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
comment|/* Optimize unaligned reloc use.  */
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_PPC64_ADDR64
operator|&&
operator|(
name|out_off
operator|&
literal|7
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_PPC64_UADDR64
operator|&&
operator|(
name|out_off
operator|&
literal|7
operator|)
operator|==
literal|0
operator|)
condition|)
name|r_type
operator|^=
name|R_PPC64_ADDR64
operator|^
name|R_PPC64_UADDR64
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_PPC64_ADDR32
operator|&&
operator|(
name|out_off
operator|&
literal|3
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_PPC64_UADDR32
operator|&&
operator|(
name|out_off
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
condition|)
name|r_type
operator|^=
name|R_PPC64_ADDR32
operator|^
name|R_PPC64_UADDR32
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_PPC64_ADDR16
operator|&&
operator|(
name|out_off
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_PPC64_UADDR16
operator|&&
operator|(
name|out_off
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
name|r_type
operator|^=
name|R_PPC64_ADDR16
operator|^
name|R_PPC64_UADDR16
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|elf
argument_list|)
operator|&&
operator|!
name|is_opd
operator|&&
name|r_type
operator|!=
name|R_PPC64_TOC
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|elf
operator|.
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This symbol is local, or marked to become local, 		     or this is an opd section reloc which must point 		     at a local function.  */
name|outrel
operator|.
name|r_addend
operator|+=
name|relocation
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_ADDR64
operator|||
name|r_type
operator|==
name|R_PPC64_TOC
condition|)
block|{
if|if
condition|(
name|is_opd
operator|&&
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Lie about opd entries.  This case occurs 			     when building shared libraries and we 			     reference a function in another shared 			     lib.  The same thing happens for a weak 			     definition in an application that's 			     overridden by a strong definition in a 			     shared lib.  (I believe this is a generic 			     bug in binutils handling of weak syms.) 			     In these cases we won't use the opd 			     entry in this lib.  */
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
comment|/* We need to relocate .opd contents for ld.so. 			 Prelink also wants simple and consistent rules 			 for relocs.  This make all RELATIVE relocs have 			 *r_offset equal to r_addend.  */
name|relocate
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|osec
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
operator|&&
name|htab
operator|->
name|elf
operator|.
name|data_index_section
operator|!=
name|NULL
condition|)
name|osec
operator|=
name|htab
operator|->
name|elf
operator|.
name|data_index_section
expr_stmt|;
else|else
name|osec
operator|=
name|htab
operator|->
name|elf
operator|.
name|text_index_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|indx
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* We are turning this relocation into one 			     against a section symbol, so subtract out 			     the output section's address but not the 			     offset of the input section in the output 			     section.  */
name|outrel
operator|.
name|r_addend
operator|-=
name|osec
operator|->
name|vma
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|>=
name|sreloc
operator|->
name|size
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an external symbol, it will 		 be computed at runtime, so there's no need to do 		 anything now.  However, for the sake of prelink ensure 		 that the section contents are a known value.  */
if|if
condition|(
operator|!
name|relocate
condition|)
block|{
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
comment|/* The value chosen here is quite arbitrary as ld.so 		     ignores section contents except for the special 		     case of .opd where the contents might be accessed 		     before relocation.  Choose zero, as that won't 		     cause reloc overflow.  */
name|relocation
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
comment|/* Use *r_offset == r_addend for R_PPC64_ADDR64 relocs 		     to improve backward compatibility with older 		     versions of ld.  */
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_ADDR64
condition|)
name|addend
operator|=
name|outrel
operator|.
name|r_addend
expr_stmt|;
comment|/* Adjust pc_relative relocs to have zero in *r_offset.  */
elseif|else
if|if
condition|(
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|pc_relative
condition|)
name|addend
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_PPC64_COPY
case|:
case|case
name|R_PPC64_GLOB_DAT
case|:
case|case
name|R_PPC64_JMP_SLOT
case|:
case|case
name|R_PPC64_RELATIVE
case|:
comment|/* We shouldn't ever see these dynamic relocs in relocatable 	     files.  */
comment|/* Fall through.  */
case|case
name|R_PPC64_PLTGOT16
case|:
case|case
name|R_PPC64_PLTGOT16_DS
case|:
case|case
name|R_PPC64_PLTGOT16_HA
case|:
case|case
name|R_PPC64_PLTGOT16_HI
case|:
case|case
name|R_PPC64_PLTGOT16_LO
case|:
case|case
name|R_PPC64_PLTGOT16_LO_DS
case|:
case|case
name|R_PPC64_PLTREL32
case|:
case|case
name|R_PPC64_PLTREL64
case|:
comment|/* These ones haven't been implemented yet.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: relocation %s is not supported for symbol %s."
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* Do any further special processing.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
case|case
name|R_PPC64_TPREL16_HA
case|:
case|case
name|R_PPC64_DTPREL16_HA
case|:
case|case
name|R_PPC64_TPREL16_HIGHER
case|:
case|case
name|R_PPC64_TPREL16_HIGHERA
case|:
case|case
name|R_PPC64_TPREL16_HIGHEST
case|:
case|case
name|R_PPC64_TPREL16_HIGHESTA
case|:
case|case
name|R_PPC64_DTPREL16_HIGHER
case|:
case|case
name|R_PPC64_DTPREL16_HIGHERA
case|:
case|case
name|R_PPC64_DTPREL16_HIGHEST
case|:
case|case
name|R_PPC64_DTPREL16_HIGHESTA
case|:
comment|/* It's just possible that this symbol is a weak symbol 	     that's not actually defined anywhere. In that case, 	     'sec' would be NULL, and we should leave the symbol 	     alone (it will be set to zero elsewhere in the link).  */
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
break|break;
comment|/* Fall thru */
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_PLTGOT16_HA
case|:
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HA
case|:
comment|/* Add 0x10000 if sign bit in 0:15 is set. 	     Bits 0:15 are not used.  */
name|addend
operator|+=
literal|0x8000
expr_stmt|;
break|break;
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
case|case
name|R_PPC64_PLT16_LO_DS
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
case|case
name|R_PPC64_PLTGOT16_DS
case|:
case|case
name|R_PPC64_PLTGOT16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_TPREL16_DS
case|:
case|case
name|R_PPC64_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_DTPREL16_DS
case|:
case|case
name|R_PPC64_DTPREL16_LO_DS
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
operator|(
name|rel
operator|->
name|r_offset
operator|&
operator|~
literal|3
operator|)
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|3
expr_stmt|;
comment|/* If this reloc is against an lq insn, then the value must be 	     a multiple of 16.  This is somewhat of a hack, but the 	     "correct" way to do this by defining _DQ forms of all the 	     _DS relocs bloats all reloc switches in this file.  It 	     doesn't seem to make much sense to use any of these relocs 	     in data, so testing the insn should be safe.  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator|)
operator|==
operator|(
literal|56u
operator|<<
literal|26
operator|)
condition|)
name|mask
operator|=
literal|15
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|)
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: error: relocation %s not a multiple of %d"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|mask
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|elf
operator|.
name|def_dynamic
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
if|if
condition|(
name|sym_name
operator|==
name|NULL
condition|)
name|sym_name
operator|=
literal|"(null)"
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
if|if
condition|(
name|warned
condition|)
continue|continue;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|pc_relative
condition|)
block|{
comment|/* Assume this is a call protected by other code that 		     detects the symbol is undefined.  If this is the case, 		     we can safely ignore the overflow.  If not, the 		     program is hosed anyway, and a little warning isn't 		     going to help.  */
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|elf
operator|.
name|root
else|:
name|NULL
operator|)
argument_list|,
name|sym_name
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|orig_addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): %s reloc against `%s': error %d"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|sym_name
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
comment|/* If we're emitting relocations, then shortly after this function      returns, reloc offsets and addends for this section will be      adjusted.  Worse, reloc symbol indices will be for the output      file rather than the input.  Save a copy of the relocs for      opd_entry_value.  */
if|if
condition|(
name|is_opd
operator|&&
operator|(
name|info
operator|->
name|emitrelocations
operator|||
name|info
operator|->
name|relocatable
operator|)
condition|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
name|input_section
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
expr_stmt|;
name|rel
operator|=
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ppc64_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|opd_relocs
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ppc64_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|opd_relocs
operator|=
name|rel
expr_stmt|;
if|if
condition|(
name|rel
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|rel
argument_list|,
name|relocs
argument_list|,
name|amt
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Adjust the value of any local symbols in opd sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|elfsym
parameter_list|,
name|asection
modifier|*
name|input_sec
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|long
modifier|*
name|opd_adjust
decl_stmt|,
name|adjust
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
name|opd_adjust
operator|=
name|get_opd_info
argument_list|(
name|input_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_adjust
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|value
operator|=
name|elfsym
operator|->
name|st_value
operator|-
name|input_sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
name|value
operator|-=
name|input_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|adjust
operator|=
name|opd_adjust
index|[
name|value
operator|/
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|adjust
operator|==
operator|-
literal|1
condition|)
name|elfsym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
else|else
name|elfsym
operator|->
name|st_value
operator|+=
name|adjust
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* This symbol has an entry in the procedure linkage 	   table.  Set it up.  */
if|if
condition|(
name|htab
operator|->
name|plt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|relplt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|glink
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a JMP_SLOT reloc to inform the dynamic linker to 	   fill in the PLT entry.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|ent
operator|->
name|addend
expr_stmt|;
name|loc
operator|=
name|htab
operator|->
name|relplt
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
operator|(
name|ent
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|||
name|htab
operator|->
name|relbss
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|htab
operator|->
name|relbss
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|relbss
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Used to decide how to sort relocs in an optimal manner for the    dynamic linker, before writing them out.  */
end_comment

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|ppc64_elf_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_PPC64_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_PPC64_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|Elf64_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
operator|||
name|htab
operator|->
name|got
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf64_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
continue|continue;
case|case
name|DT_PPC64_GLINK
case|:
name|s
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
comment|/* We stupidly defined DT_PPC64_GLINK to be the start 		 of glink rather than the first entry point, which is 		 what ld.so needs, and now have a bigger stub to 		 support automatic multiple TOCs.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|+=
name|GLINK_CALL_STUB_SIZE
operator|-
literal|32
expr_stmt|;
break|break;
case|case
name|DT_PPC64_OPD
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_PPC64_OPDSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|s
operator|=
name|htab
operator|->
name|plt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|htab
operator|->
name|relplt
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* Don't count procedure linkage table relocs in the 		 overall reloc count.  */
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
comment|/* We may not be using the standard ELF linker script. 		 If .rela.plt is the first .rela section, we adjust 		 DT_RELA to not include it.  */
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|!=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|+=
name|s
operator|->
name|size
expr_stmt|;
break|break;
block|}
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|got
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|got
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* Fill in the first entry in the global offset table. 	 We use it to hold the link-time TOCbase.  */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|TOC_BASE_OFF
argument_list|,
name|htab
operator|->
name|got
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* Set .got entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|got
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|plt
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* Set .plt entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|plt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
comment|/* brlt is SEC_LINKER_CREATED, so we need to write out relocs for      brlt ourselves if emitrelocations.  */
if|if
condition|(
name|htab
operator|->
name|brlt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|brlt
operator|->
name|reloc_count
operator|!=
literal|0
operator|&&
operator|!
name|_bfd_elf_link_output_relocs
argument_list|(
name|output_bfd
argument_list|,
name|htab
operator|->
name|brlt
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|htab
operator|->
name|brlt
argument_list|)
operator|->
name|rel_hdr
argument_list|,
name|elf_section_data
argument_list|(
name|htab
operator|->
name|brlt
argument_list|)
operator|->
name|relocs
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We need to handle writing out multiple GOT sections ourselves,      since we didn't add them to DYNOBJ.  We know dynobj is the first      bfd.  */
while|while
condition|(
operator|(
name|dynobj
operator|=
name|dynobj
operator|->
name|link_next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|is_ppc64_elf_target
argument_list|(
name|dynobj
operator|->
name|xvec
argument_list|)
condition|)
continue|continue;
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|dynobj
argument_list|)
operator|->
name|got
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|size
operator|!=
literal|0
operator|&&
name|s
operator|->
name|output_section
operator|!=
name|bfd_abs_section_ptr
operator|&&
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|,
name|s
operator|->
name|contents
argument_list|,
name|s
operator|->
name|output_offset
argument_list|,
name|s
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|dynobj
argument_list|)
operator|->
name|relgot
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|size
operator|!=
literal|0
operator|&&
name|s
operator|->
name|output_section
operator|!=
name|bfd_abs_section_ptr
operator|&&
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|,
name|s
operator|->
name|contents
argument_list|,
name|s
operator|->
name|output_offset
argument_list|,
name|s
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

