begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* PowerPC64-specific support for 64-bit ELF.    Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Linus Nordberg, Swox AB<info@swox.com>,    based on elf32-ppc.c by Ian Lance Taylor.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is based on the 64-bit PowerPC ELF ABI.  It is also based    on the file elf32-ppc.c.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_include
include|#
directive|include
file|"elf64-ppc.h"
end_include

begin_define
define|#
directive|define
name|USE_RELA
end_define

begin_comment
comment|/* we want RELA relocations, not REL.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ppc_howto_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc64_elf_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|cache_ptr
operator|,
name|Elf64_Internal_Rela
operator|*
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_ha_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_brtaken_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_ha_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_ha_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc64_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_unhandled_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|24
end_define

begin_comment
comment|/* The initial size of the plt reserved for the dynamic linker.  */
end_comment

begin_define
define|#
directive|define
name|PLT_INITIAL_ENTRY_SIZE
value|PLT_ENTRY_SIZE
end_define

begin_comment
comment|/* TOC base pointers offset from start of TOC.  */
end_comment

begin_define
define|#
directive|define
name|TOC_BASE_OFF
value|(0x8000)
end_define

begin_comment
comment|/* .plt call stub instructions.  */
end_comment

begin_define
define|#
directive|define
name|ADDIS_R12_R2
value|0x3d820000
end_define

begin_comment
comment|/* addis %r12,%r2,xxx@ha     */
end_comment

begin_define
define|#
directive|define
name|STD_R2_40R1
value|0xf8410028
end_define

begin_comment
comment|/* std	 %r2,40(%r1)	     */
end_comment

begin_define
define|#
directive|define
name|LD_R11_0R12
value|0xe96c0000
end_define

begin_comment
comment|/* ld	 %r11,xxx+0@l(%r12)  */
end_comment

begin_define
define|#
directive|define
name|LD_R2_0R12
value|0xe84c0000
end_define

begin_comment
comment|/* ld	 %r2,xxx+8@l(%r12)   */
end_comment

begin_define
define|#
directive|define
name|MTCTR_R11
value|0x7d6903a6
end_define

begin_comment
comment|/* mtctr %r11		     */
end_comment

begin_comment
comment|/* ld	 %r11,xxx+16@l(%r12) */
end_comment

begin_define
define|#
directive|define
name|BCTR
value|0x4e800420
end_define

begin_comment
comment|/* bctr			     */
end_comment

begin_comment
comment|/* The normal stub is this size.  */
end_comment

begin_define
define|#
directive|define
name|PLT_CALL_STUB_SIZE
value|(7*4)
end_define

begin_comment
comment|/* But sometimes the .plt entry crosses a 64k boundary, and we need    to adjust the high word with this insn.  */
end_comment

begin_define
define|#
directive|define
name|ADDIS_R12_R12_1
value|0x3d8c0001
end_define

begin_comment
comment|/* addis %r12,%r12,1	*/
end_comment

begin_comment
comment|/* The .glink fixup call stub is the same as the .plt call stub, but    the first instruction restores r2, and the std is omitted.  */
end_comment

begin_define
define|#
directive|define
name|LD_R2_40R1
value|0xe8410028
end_define

begin_comment
comment|/* ld    %r2,40(%r1)	*/
end_comment

begin_comment
comment|/* Always allow this much space.  */
end_comment

begin_define
define|#
directive|define
name|GLINK_CALL_STUB_SIZE
value|(8*4)
end_define

begin_comment
comment|/* Pad with this.  */
end_comment

begin_define
define|#
directive|define
name|NOP
value|0x60000000
end_define

begin_comment
comment|/* Some other nops.  */
end_comment

begin_define
define|#
directive|define
name|CROR_151515
value|0x4def7b82
end_define

begin_define
define|#
directive|define
name|CROR_313131
value|0x4ffffb82
end_define

begin_comment
comment|/* .glink entries for the first 32k functions are two instructions.  */
end_comment

begin_define
define|#
directive|define
name|LI_R0_0
value|0x38000000
end_define

begin_comment
comment|/* li    %r0,0		*/
end_comment

begin_define
define|#
directive|define
name|B_DOT
value|0x48000000
end_define

begin_comment
comment|/* b     .		*/
end_comment

begin_comment
comment|/* After that, we need two instructions to load the index, followed by    a branch.  */
end_comment

begin_define
define|#
directive|define
name|LIS_R0_0
value|0x3c000000
end_define

begin_comment
comment|/* lis   %r0,0		*/
end_comment

begin_define
define|#
directive|define
name|ORI_R0_R0_0
value|0x60000000
end_define

begin_comment
comment|/* ori	 %r0,%r0,0	*/
end_comment

begin_comment
comment|/* Instructions to save and restore floating point regs.  */
end_comment

begin_define
define|#
directive|define
name|STFD_FR0_0R1
value|0xd8010000
end_define

begin_comment
comment|/* stfd  %fr0,0(%r1)	*/
end_comment

begin_define
define|#
directive|define
name|LFD_FR0_0R1
value|0xc8010000
end_define

begin_comment
comment|/* lfd   %fr0,0(%r1)	*/
end_comment

begin_define
define|#
directive|define
name|BLR
value|0x4e800020
end_define

begin_comment
comment|/* blr			*/
end_comment

begin_comment
comment|/* Since .opd is an array of descriptors and each entry will end up    with identical R_PPC64_RELATIVE relocs, there is really no need to    propagate .opd relocs;  The dynamic linker should be taught to    relocate .opd without reloc entries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPD_RELOCS
end_ifndef

begin_define
define|#
directive|define
name|NO_OPD_RELOCS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_define
define|#
directive|define
name|ONES
parameter_list|(
name|n
parameter_list|)
value|(((bfd_vma) 1<< ((n) - 1)<< 1) - 1)
end_define

begin_comment
comment|/* Relocation HOWTO's.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_PPC_max
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ppc64_elf_howto_raw
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_PPC64_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 26 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR24"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relocation without overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Bits 16-31 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Bits 16-31 of an address, plus 1 if the contents of the low 16      bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is expected to be taken.  The lower two      bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14_BRTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is not expected to be taken.  The lower      two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14_BRNTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 26 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL24"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is expected to be taken.  The lower two bits must be      zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14_BRTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is not expected to be taken.  The lower two bits must      be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14_BRNTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but referring to the GOT table entry for the      symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HI, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HA, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This is used only by the dynamic linker.  The symbol should exist      both in the object being run and in some shared library.  The      dynamic linker copies the data addressed by the symbol from the      shared library into the object, because the object being      run has to have the data at some particular address.  */
name|HOWTO
argument_list|(
name|R_PPC64_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* this one is variable size */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_COPY"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR64, but used when setting global offset table      entries.  */
name|HOWTO
argument_list|(
name|R_PPC64_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GLOB_DAT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Created by the link editor.  Marks a procedure linkage table      entry for a symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_JMP_SLOT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used only by the dynamic linker.  When the object is run, this      doubleword64 is set to the load address of the object, plus the      addend.  */
name|HOWTO
argument_list|(
name|R_PPC64_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_RELATIVE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR32, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
comment|/* FIXME: Verify.  Was complain_overflow_bitfield.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit relocation to the symbol's procedure linkage table.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative relocation to the symbol's procedure linkage table.      FIXME: R_PPC64_PLTREL32 not supported.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTREL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HI, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HA, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF, but no overflow warning.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half adjusted section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_REL24 without touching the two least significant      bits.  Should have been named R_PPC64_REL30!  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR30
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|30
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR30"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffffffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocs in the 64-bit PowerPC ELF ABI, not in the 32-bit ABI.  */
comment|/* A standard 64-bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 32-47 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHER
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHER"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 32-47 of an address, plus 1 if the contents of the low      16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHERA
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHERA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 48-63 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHEST
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHEST"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 48-63 of an address, plus 1 if the contents of the low      16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHESTA
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHESTA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like ADDR64, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relocation to the symbol's procedure linkage table.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit PC relative relocation to the symbol's procedure linkage      table.  */
comment|/* FIXME: R_PPC64_PLTREL64 not supported.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTREL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTREL64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation.  */
comment|/* R_PPC64_TOC16	  47	   half16*	S + A - .TOC.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation without overflow.  */
comment|/* R_PPC64_TOC16_LO	  48	   half16	 #lo (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation, high 16 bits.  */
comment|/* R_PPC64_TOC16_HI	  49	   half16	 #hi (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation, high 16 bits, plus 1 if the      contents of the low 16 bits, treated as a signed number, is      negative.  */
comment|/* R_PPC64_TOC16_HA	  50	   half16	 #ha (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relocation; insert value of TOC base (.TOC.).  */
comment|/* R_PPC64_TOC		  51	   doubleword64	 .TOC.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc64_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16, but also informs the link editor that the      value to relocate may (!) refer to a PLT entry which the link      editor (a) may replace with the symbol value.  If the link editor      is unable to fully resolve the symbol, it may (b) create a PLT      entry and store the address to the new PLT entry in the GOT.      This permits lazy resolution of function symbols at run time.      The link editor may also skip all of this and just (c) emit a      R_PPC64_GLOB_DAT to tie the symbol to the GOT entry.  */
comment|/* FIXME: R_PPC64_PLTGOT16 not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16, but without overflow.  */
comment|/* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address.  */
comment|/* FIXME: R_PPC64_PLTGOT16_HI not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address, plus      1 if the contents of the low 16 bits, treated as a signed number,      is negative.  */
comment|/* FIXME: R_PPC64_PLTGOT16_HA not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_TOC16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_TOC16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16, but for instructions with a DS field.  */
comment|/* FIXME: R_PPC64_PLTGOT16_DS not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16_LO, but for instructions with a DS field.  */
comment|/* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_PPC64_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_PPC64_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the ppc64_elf_howto_table, so that linear accesses can    be done.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_howto_init
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ppc64_elf_howto_raw
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ppc64_elf_howto_table
index|[
name|type
index|]
operator|=
operator|&
name|ppc64_elf_howto_raw
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|enum
name|elf_ppc_reloc_type
name|ppc_reloc
init|=
name|R_PPC_NONE
decl_stmt|;
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
comment|/* Initialize howto table if needed.  */
name|ppc_howto_init
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|code
condition|)
block|{
default|default:
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
case|case
name|BFD_RELOC_NONE
case|:
name|ppc_reloc
operator|=
name|R_PPC64_NONE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA26
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRNTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B26
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRNTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_COPY
case|:
name|ppc_reloc
operator|=
name|R_PPC64_COPY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GLOB_DAT
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GLOB_DAT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CTOR
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHER
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HIGHER
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHER_S
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HIGHERA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHEST
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HIGHEST
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHEST_S
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HIGHESTA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PLT_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_LO
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_HI
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_HA
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_LO
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_HI
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_HA
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_ADDR16_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_ADDR16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_GOT16_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_GOT16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLT16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_SECTOFF_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_SECTOFF_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GNU_VTINHERIT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GNU_VTENTRY
expr_stmt|;
break|break;
block|}
return|return
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|ppc_reloc
index|]
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Set the howto pointer for a PowerPC ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf64_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|type
decl_stmt|;
comment|/* Initialize howto table if needed.  */
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
name|ppc_howto_init
argument_list|()
expr_stmt|;
name|type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|ppc64_elf_howto_table
index|[
name|type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the R_PPC_ADDR16_HA and similar relocs.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_ha_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
comment|/* Adjust the addend for sign extension of the low 16 bits.      We won't actually be using the low 16 bits, so trashing them      doesn't matter.  */
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_brtaken_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|long
name|insn
decl_stmt|;
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|bfd_size_type
name|octets
decl_stmt|;
comment|/* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
name|boolean
name|is_power4
init|=
name|false
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|octets
operator|=
name|reloc_entry
operator|->
name|address
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
name|insn
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
literal|21
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_ADDR14_BRTAKEN
operator|||
name|r_type
operator|==
name|R_PPC64_REL14_BRTAKEN
condition|)
name|insn
operator||=
literal|0x01
operator|<<
literal|21
expr_stmt|;
comment|/* 'y' or 't' bit, lowest bit of BO field.  */
if|if
condition|(
name|is_power4
condition|)
block|{
comment|/* Set 'a' bit.  This is 0b00010 in BO field for branch 	 on CR(BI) insns (BO == 001at or 011at), and 0b01000 	 for branch on CTR insns (BO == 1a00t or 1a01t).  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x04
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x02
operator|<<
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x10
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x08
operator|<<
literal|21
expr_stmt|;
else|else
return|return
name|bfd_reloc_continue
return|;
block|}
else|else
block|{
name|bfd_vma
name|target
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|from
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|target
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|target
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|target
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|target
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|from
operator|=
operator|(
name|reloc_entry
operator|->
name|address
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Invert 'y' bit if not the default.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|target
operator|-
name|from
argument_list|)
operator|<
literal|0
condition|)
name|insn
operator|^=
literal|0x01
operator|<<
literal|21
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
comment|/* Subtract the symbol section base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_ha_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
comment|/* Subtract the symbol section base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* Adjust the addend for sign extension of the low 16 bits.  */
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|TOCstart
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOCstart
operator|==
literal|0
condition|)
name|TOCstart
operator|=
name|ppc64_elf_toc
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
comment|/* Subtract the TOC base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_ha_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|TOCstart
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOCstart
operator|==
literal|0
condition|)
name|TOCstart
operator|=
name|ppc64_elf_toc
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
comment|/* Subtract the TOC base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
comment|/* Adjust the addend for sign extension of the low 16 bits.  */
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc64_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_vma
name|TOCstart
decl_stmt|;
name|bfd_size_type
name|octets
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|TOCstart
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOCstart
operator|==
literal|0
condition|)
name|TOCstart
operator|=
name|ppc64_elf_toc
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|octets
operator|=
name|reloc_entry
operator|->
name|address
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|TOCstart
operator|+
name|TOC_BASE_OFF
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_unhandled_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
if|if
condition|(
name|error_message
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"generic linker can't handle %s"
argument_list|,
name|reloc_entry
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|error_message
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|bfd_reloc_dangerous
return|;
block|}
end_function

begin_comment
comment|/* Fix bad default arch selected for a 64 bit input bfd when the    default is 32 bit.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|arch_info
operator|->
name|the_default
operator|&&
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|32
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdr
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|i_ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
block|{
comment|/* Relies on arch after 32 bit default being 64 bit default.  */
name|abfd
operator|->
name|arch_info
operator|=
name|abfd
operator|->
name|arch_info
operator|->
name|next
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
comment|/* Check if we have the same endianess.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|&&
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|ibfd
argument_list|)
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled for a big endian system and target is little endian"
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled for a little endian system and target is big endian"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|msg
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are specific to the ELF linker, while    functions above are used generally.  Those named ppc64_elf_* are    called by the main ELF linker code.  They appear in this file more    or less in the order in which they are called.  eg.    ppc64_elf_check_relocs is called early in the link process,    ppc64_elf_finish_dynamic_sections is one of the last functions    called.     PowerPC64-ELF uses a similar scheme to PowerPC64-XCOFF in that    functions have both a function code symbol and a function descriptor    symbol.  A call to foo in a relocatable object file looks like:     .		.text    .	x:    .		bl	.foo    .		nop     The function definition in another object file might be:     .		.section .opd    .	foo:	.quad	.foo    .		.quad	.TOC.@tocbase    .		.quad	0    .    .		.text    .	.foo:	blr     When the linker resolves the call during a static link, the branch    unsurprisingly just goes to .foo and the .opd information is unused.    If the function definition is in a shared library, things are a little    different:  The call goes via a plt call stub, the opd information gets    copied to the plt, and the linker patches the nop.     .	x:    .		bl	.foo_stub    .		ld	2,40(1)    .    .    .	.foo_stub:    .		addis	12,2,Lfoo@toc@ha	# in practice, the call stub    .		addi	12,12,Lfoo@toc@l	# is slightly optimised, but    .		std	2,40(1)			# this is the general idea    .		ld	11,0(12)    .		ld	2,8(12)    .		mtctr	11    .		ld	11,16(12)    .		bctr    .    .		.section .plt    .	Lfoo:	reloc (R_PPC64_JMP_SLOT, foo)     The "reloc ()" notation is supposed to indicate that the linker emits    an R_PPC64_JMP_SLOT reloc against foo.  The dynamic linker does the opd    copying.     What are the difficulties here?  Well, firstly, the relocations    examined by the linker in check_relocs are against the function code    sym .foo, while the dynamic relocation in the plt is emitted against    the function descriptor symbol, foo.  Somewhere along the line, we need    to carefully copy dynamic link information from one symbol to the other.    Secondly, the generic part of the elf linker will make .foo a dynamic    symbol as is normal for most other backends.  We need foo dynamic    instead, at least for an application final link.  However, when    creating a shared library containing foo, we need to have both symbols    dynamic so that references to .foo are satisfied during the early    stages of linking.  Otherwise the linker might decide to pull in a    definition from some other object, eg. a static library.  */
end_comment

begin_comment
comment|/* The linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_dyn_relocs
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Of those relocs that might be copied as dynamic relocs, this macro    selects between relative and absolute types.  */
end_comment

begin_define
define|#
directive|define
name|IS_ABSOLUTE_RELOC
parameter_list|(
name|RTYPE
parameter_list|)
define|\
value|((RTYPE) != R_PPC64_REL32			\&& (RTYPE) != R_PPC64_REL64			\&& (RTYPE) != R_PPC64_ADDR30)
end_define

begin_comment
comment|/* Section name for stubs is the associated section name plus this    string.  */
end_comment

begin_define
define|#
directive|define
name|STUB_SUFFIX
value|".stub"
end_define

begin_comment
comment|/* Linker stubs.    ppc_stub_long_branch:    Used when a 14 bit branch (or even a 24 bit branch) can't reach its    destination, but a 24 bit branch in a stub section will reach.    .	b	dest     ppc_stub_plt_branch:    Similar to the above, but a 24 bit branch in the stub section won't    reach its destination.    .	addis	%r12,%r2,xxx@ha    .	ld	%r11,xxx@l(%r12)    .	mtctr	%r11    .	bctr     ppc_stub_plt_call:    Used to call a function in a shared library.    .	addis	%r12,%r2,xxx@ha    .	std	%r2,40(%r1)    .	ld	%r11,xxx+0@l(%r12)    .	ld	%r2,xxx+8@l(%r12)    .	mtctr	%r11    .	ld	%r11,xxx+16@l(%r12)    .	bctr */
end_comment

begin_enum
enum|enum
name|ppc_stub_type
block|{
name|ppc_stub_none
block|,
name|ppc_stub_long_branch
block|,
name|ppc_stub_plt_branch
block|,
name|ppc_stub_plt_call
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ppc_stub_hash_entry
block|{
comment|/* Base hash table entry structure.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* The stub section.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
comment|/* Offset within stub_sec of the beginning of this stub.  */
name|bfd_vma
name|stub_offset
decl_stmt|;
comment|/* Given the symbol's value and its section we can determine its final      value when building the stubs (so the stub knows where to jump.  */
name|bfd_vma
name|target_value
decl_stmt|;
name|asection
modifier|*
name|target_section
decl_stmt|;
name|enum
name|ppc_stub_type
name|stub_type
decl_stmt|;
comment|/* The symbol table entry, if any, that this was derived from.  */
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Where this stub is being called from, or, in the case of combined      stub sections, the first input section in the group.  */
name|asection
modifier|*
name|id_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ppc_branch_hash_entry
block|{
comment|/* Base hash table entry structure.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Offset within .branch_lt.  */
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Generation marker.  */
name|unsigned
name|int
name|iter
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ppc_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
comment|/* A pointer to the most recently used stub hash entry against this      symbol.  */
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_cache
decl_stmt|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|ppc_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
comment|/* Link between function code and descriptor symbols.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|oh
decl_stmt|;
comment|/* Flag function code and descriptor symbols.  */
name|unsigned
name|int
name|is_func
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_func_descriptor
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_entry
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ppc64 ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* The stub hash table.  */
name|struct
name|bfd_hash_table
name|stub_hash_table
decl_stmt|;
comment|/* Another hash table for plt_branch stubs.  */
name|struct
name|bfd_hash_table
name|branch_hash_table
decl_stmt|;
comment|/* Linker stub bfd.  */
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
comment|/* Linker call-backs.  */
name|asection
operator|*
operator|(
operator|*
name|add_stub_section
operator|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*layout_sections_again
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Array to keep track of which stub sections have been created, and      information on stub grouping.  */
struct|struct
name|map_stub
block|{
comment|/* This is the section to which stubs in the group will be attached.  */
name|asection
modifier|*
name|link_sec
decl_stmt|;
comment|/* The stub section.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
block|}
modifier|*
name|stub_group
struct|;
comment|/* Assorted information used by ppc64_elf_size_stubs.  */
name|int
name|top_index
decl_stmt|;
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelbss
decl_stmt|;
name|asection
modifier|*
name|sglink
decl_stmt|;
name|asection
modifier|*
name|sfpr
decl_stmt|;
name|asection
modifier|*
name|sbrlt
decl_stmt|;
name|asection
modifier|*
name|srelbrlt
decl_stmt|;
comment|/* Set on error.  */
name|unsigned
name|int
name|stub_error
decl_stmt|;
comment|/* Flag set when small branches are detected.  Used to      select suitable defaults for the stub group size.  */
name|unsigned
name|int
name|has_14bit_branch
decl_stmt|;
comment|/* Set if we detect a reference undefined weak symbol.  */
name|unsigned
name|int
name|have_undefweak
decl_stmt|;
comment|/* Incremented every time we size stubs.  */
name|unsigned
name|int
name|stub_iteration
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stub_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|branch_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc64_elf_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc64_elf_link_hash_table_free
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_stub_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|asection
operator|*
operator|,
specifier|const
name|asection
operator|*
operator|,
specifier|const
expr|struct
name|ppc_link_hash_entry
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppc_stub_hash_entry
modifier|*
name|ppc_get_stub_entry
name|PARAMS
argument_list|(
operator|(
specifier|const
name|asection
operator|*
operator|,
specifier|const
name|asection
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|ppc_link_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppc_stub_hash_entry
modifier|*
name|ppc_add_stub
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|ppc_link_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|create_linkage_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc64_elf_copy_indirect_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_backend_data
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|ppc64_elf_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|func_desc_adjust
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_func_desc_adjust
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc64_elf_hide_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|edit_opd
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_dynrelocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|readonly_dynrelocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|ppc64_elf_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|enum
name|ppc_stub_type
name|ppc_type_of_stub
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|ppc_link_hash_entry
operator|*
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|build_plt_stub
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_build_one_stub
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_size_one_stub
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|group_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ppc_link_hash_table
operator|*
operator|,
name|bfd_size_type
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
name|relocs
operator|,
name|Elf_Internal_Sym
operator|*
name|local_syms
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the ppc64 ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|ppc_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct ppc_link_hash_table *) ((p)->hash))
end_define

begin_define
define|#
directive|define
name|ppc_stub_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct ppc_stub_hash_entry *) \    bfd_hash_lookup ((table), (string), (create), (copy)))
end_define

begin_define
define|#
directive|define
name|ppc_branch_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct ppc_branch_hash_entry *) \    bfd_hash_lookup ((table), (string), (create), (copy)))
end_define

begin_comment
comment|/* Create an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stub_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_stub_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|eh
operator|=
operator|(
expr|struct
name|ppc_stub_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|stub_sec
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_value
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_section
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|stub_type
operator|=
name|ppc_stub_none
expr_stmt|;
name|eh
operator|->
name|h
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|id_sec
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in the branch hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|branch_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_branch_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_branch_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|eh
operator|=
operator|(
expr|struct
name|ppc_branch_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|iter
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in a ppc64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
init|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
name|eh
operator|->
name|stub_cache
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|oh
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|is_func
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|is_func_descriptor
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|is_entry
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create a ppc64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc64_elf_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_table
argument_list|)
decl_stmt|;
name|htab
operator|=
operator|(
expr|struct
name|ppc_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|htab
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Init the stub hash table too.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_hash_newfunc
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* And the branch hash table.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|branch_hash_table
argument_list|,
name|branch_hash_newfunc
argument_list|)
condition|)
return|return
name|NULL
return|;
name|htab
operator|->
name|stub_bfd
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|add_stub_section
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|layout_sections_again
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|stub_group
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|sglink
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|sfpr
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|sbrlt
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|srelbrlt
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|has_14bit_branch
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|have_undefweak
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|stub_iteration
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|htab
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Free the derived linker hash table.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_link_hash_table_free
parameter_list|(
name|hash
parameter_list|)
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|ret
init|=
operator|(
expr|struct
name|ppc_link_hash_table
operator|*
operator|)
name|hash
decl_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ret
operator|->
name|stub_hash_table
argument_list|)
expr_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ret
operator|->
name|branch_hash_table
argument_list|)
expr_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a name for an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ppc_stub_name
parameter_list|(
name|input_section
parameter_list|,
name|sym_sec
parameter_list|,
name|h
parameter_list|,
name|rel
parameter_list|)
specifier|const
name|asection
modifier|*
name|input_section
decl_stmt|;
specifier|const
name|asection
modifier|*
name|sym_sec
decl_stmt|;
specifier|const
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
comment|/* rel->r_addend is actually 64 bit, but who uses more than +/- 2^31      offsets from a sym as a branch target?  In fact, we could      probably assume the addend is always zero.  */
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
operator|)
operator|==
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%08x_%s+%x"
argument_list|,
name|input_section
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|16
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%08x_%x:%x+%x"
argument_list|,
name|input_section
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
name|sym_sec
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stub_name
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in the stub hash.  Stub entries are cached because    creating the stub name takes a bit of time.  */
end_comment

begin_function
specifier|static
name|struct
name|ppc_stub_hash_entry
modifier|*
name|ppc_get_stub_entry
parameter_list|(
name|input_section
parameter_list|,
name|sym_sec
parameter_list|,
name|hash
parameter_list|,
name|rel
parameter_list|,
name|htab
parameter_list|)
specifier|const
name|asection
modifier|*
name|input_section
decl_stmt|;
specifier|const
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hash
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
init|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|hash
decl_stmt|;
specifier|const
name|asection
modifier|*
name|id_sec
decl_stmt|;
comment|/* If this input section is part of a group of sections sharing one      stub section, then use the id of the first section in the group.      Stub names need to include a section id, as there may well be      more than one stub used to reach say, printf, and we need to      distinguish between them.  */
name|id_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|stub_cache
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|stub_cache
operator|->
name|h
operator|==
name|h
operator|&&
name|h
operator|->
name|stub_cache
operator|->
name|id_sec
operator|==
name|id_sec
condition|)
block|{
name|stub_entry
operator|=
name|h
operator|->
name|stub_cache
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|stub_name
operator|=
name|ppc_stub_name
argument_list|(
name|id_sec
argument_list|,
name|sym_sec
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|stub_entry
operator|=
name|ppc_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|stub_cache
operator|=
name|stub_entry
expr_stmt|;
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
block|}
return|return
name|stub_entry
return|;
block|}
end_function

begin_comment
comment|/* Add a new stub entry to the stub hash.  Not all fields of the new    stub entry are initialised.  */
end_comment

begin_function
specifier|static
name|struct
name|ppc_stub_hash_entry
modifier|*
name|ppc_add_stub
parameter_list|(
name|stub_name
parameter_list|,
name|section
parameter_list|,
name|htab
parameter_list|)
specifier|const
name|char
modifier|*
name|stub_name
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
block|{
name|asection
modifier|*
name|link_sec
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|link_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
name|stub_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|stub_sec
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
block|{
name|stub_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|link_sec
operator|->
name|id
index|]
operator|.
name|stub_sec
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
block|{
name|size_t
name|namelen
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
name|char
modifier|*
name|s_name
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|link_sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|namelen
operator|+
sizeof|sizeof
argument_list|(
name|STUB_SUFFIX
argument_list|)
expr_stmt|;
name|s_name
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|s_name
argument_list|,
name|link_sec
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s_name
operator|+
name|namelen
argument_list|,
name|STUB_SUFFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|STUB_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|stub_sec
operator|=
call|(
modifier|*
name|htab
operator|->
name|add_stub_section
call|)
argument_list|(
name|s_name
argument_list|,
name|link_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|htab
operator|->
name|stub_group
index|[
name|link_sec
operator|->
name|id
index|]
operator|.
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
block|}
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
block|}
comment|/* Enter this entry into the linker stub hash table.  */
name|stub_entry
operator|=
name|ppc_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: cannot create stub entry %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|section
operator|->
name|owner
argument_list|)
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|stub_entry
operator|->
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
name|stub_entry
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|stub_entry
operator|->
name|id_sec
operator|=
name|link_sec
expr_stmt|;
return|return
name|stub_entry
return|;
block|}
end_function

begin_comment
comment|/* Create sections for linker generated code.  */
end_comment

begin_function
specifier|static
name|boolean
name|create_linkage_sections
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Create .sfpr for code to save and restore fp regs.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|sfpr
operator|=
name|bfd_make_section_anyway
argument_list|(
name|dynobj
argument_list|,
literal|".sfpr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sfpr
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sfpr
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create .glink for lazy dynamic linking support.  */
name|htab
operator|->
name|sglink
operator|=
name|bfd_make_section_anyway
argument_list|(
name|dynobj
argument_list|,
literal|".glink"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sglink
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sglink
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sglink
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create .branch_lt for plt_branch stubs.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|sbrlt
operator|=
name|bfd_make_section_anyway
argument_list|(
name|dynobj
argument_list|,
literal|".branch_lt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sbrlt
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sbrlt
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sbrlt
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|srelbrlt
operator|=
name|bfd_make_section_anyway
argument_list|(
name|dynobj
argument_list|,
literal|".rela.branch_lt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|srelbrlt
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelbrlt
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelbrlt
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create .got and .rela.got sections in DYNOBJ, and set up    shortcuts to them in our hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|create_got_section
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|srelgot
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create the dynamic sections, and set up shortcuts.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_create_dynamic_sections
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|&&
operator|!
name|create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|htab
operator|->
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|splt
operator|||
operator|!
name|htab
operator|->
name|srelplt
operator|||
operator|!
name|htab
operator|->
name|sdynbss
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|htab
operator|->
name|srelbss
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_copy_indirect_symbol
parameter_list|(
name|bed
parameter_list|,
name|dir
parameter_list|,
name|ind
parameter_list|)
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
decl_stmt|,
decl|*
name|ind
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add reloc counts against the weak sym to the strong sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|edir
operator|->
name|is_func
operator||=
name|eind
operator|->
name|is_func
expr_stmt|;
name|edir
operator|->
name|is_func_descriptor
operator||=
name|eind
operator|->
name|is_func_descriptor
expr_stmt|;
name|edir
operator|->
name|is_entry
operator||=
name|eind
operator|->
name|is_entry
expr_stmt|;
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|bed
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Set a flag, used by ppc64_elf_gc_mark_hook, on the entry symbol and    symbols undefined on the command-line.  */
end_comment

begin_function
name|boolean
name|ppc64_elf_mark_entry_syms
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|bfd_sym_chain
modifier|*
name|sym
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|info
operator|->
name|gc_sym_list
init|;
name|sym
condition|;
name|sym
operator|=
name|sym
operator|->
name|next
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|sym
operator|->
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_entry
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    calculate needed space in the global offset table, procedure    linkage table, and dynamic reloc sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|asection
modifier|*
modifier|*
name|opd_sym_map
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
operator|(
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|opd_sym_map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Garbage collection needs some extra help with .opd sections. 	 We don't want to necessarily keep everything referenced by 	 relocs in .opd, as that would keep all functions.  Instead, 	 if we reference an .opd symbol (a function descriptor), we 	 want to keep the function code symbol's section.  This is 	 easy for global symbols, but for local syms we need to keep 	 information about the associated function section.  Later, if 	 edit_opd deletes entries, we'll use this array to adjust 	 local syms in .opd.  */
union|union
name|opd_info
block|{
name|asection
modifier|*
name|func_section
decl_stmt|;
name|long
name|entry_adjust
decl_stmt|;
block|}
union|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
name|sec
operator|->
name|_raw_size
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|opd_info
argument_list|)
operator|/
literal|24
expr_stmt|;
name|opd_sym_map
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_sym_map
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tdata
operator|=
name|opd_sym_map
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|==
name|NULL
operator|&&
operator|!
name|create_linkage_sections
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
comment|/* GOT16 relocations */
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
operator|&&
operator|!
name|create_got_section
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol, 	     because this might be a case of linking PIC code without 	     linking in any dynamic objects, in which case we don't 	     need to generate a procedure linkage table after all.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* It does not make sense to have a procedure linkage 		 table entry for a local symbol.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* The following relocations don't need to propagate the 	     relocation if linking a shared object since they are 	     section relative.  */
case|case
name|R_PPC64_SECTOFF
case|:
case|case
name|R_PPC64_SECTOFF_LO
case|:
case|case
name|R_PPC64_SECTOFF_HI
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|_bfd_elf64_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_PPC64_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|_bfd_elf64_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
name|htab
operator|->
name|has_14bit_branch
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* We may need a .plt entry if the function this reloc 		 refers to is in a shared lib.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_ADDR64
case|:
if|if
condition|(
name|opd_sym_map
operator|!=
name|NULL
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|fdh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|)
operator|->
name|is_func_descriptor
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|)
operator|->
name|oh
operator|=
name|h
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|oh
operator|=
name|fdh
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opd_sym_map
operator|!=
name|NULL
operator|&&
name|h
operator|==
name|NULL
operator|&&
name|rel
operator|+
literal|1
operator|<
name|rel_end
operator|&&
operator|(
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC
operator|)
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|s
operator|!=
name|sec
condition|)
name|opd_sym_map
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|24
index|]
operator|=
name|s
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|R_PPC64_REL64
case|:
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR30
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
case|case
name|R_PPC64_TOC
case|:
comment|/* Don't propagate .opd relocs.  */
if|if
condition|(
name|NO_OPD_RELOCS
operator|&&
name|opd_sym_map
operator|!=
name|NULL
condition|)
break|break;
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  In case of a weak definition, 	     DEF_REGULAR may be cleared later by a strong definition in 	     a shared library.  We account for that possibility below by 	     storing information in the relocs_copied field of the hash 	     table entry.  A similar situation occurs when creating 	     shared libraries and symbol visibility changes render the 	     symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* We must copy these reloc types into the output file. 		 Create a reloc section in dynobj and make room for 		 this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad relocation section name `%s\'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|p
operator|=
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|ppc64_elf_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|asection
modifier|*
name|rsec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
case|case
name|R_PPC64_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|fdh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Function descriptor syms cause the associated 		 function code sym section to be marked.  */
if|if
condition|(
name|fdh
operator|->
name|is_func_descriptor
condition|)
name|rsec
operator|=
name|fdh
operator|->
name|oh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
comment|/* Function entry syms return NULL if they are in .opd 		 and are not ._start (or others undefined on the ld 		 command line).  Thus we avoid marking all function 		 sections, as all functions are referenced in .opd.  */
elseif|else
if|if
condition|(
operator|(
name|fdh
operator|->
name|oh
operator|!=
name|NULL
operator|&&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|->
name|oh
operator|)
operator|->
name|is_entry
operator|)
operator|||
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
name|rsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|rsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
name|asection
modifier|*
modifier|*
name|opd_sym_section
decl_stmt|;
name|rsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|opd_sym_section
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|elf_section_data
argument_list|(
name|rsec
argument_list|)
operator|->
name|tdata
expr_stmt|;
if|if
condition|(
name|opd_sym_section
operator|!=
name|NULL
condition|)
name|rsec
operator|=
name|opd_sym_section
index|[
name|sym
operator|->
name|st_value
operator|/
literal|24
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tdata
operator|!=
name|NULL
condition|)
name|rsec
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|rsec
return|;
block|}
end_function

begin_comment
comment|/* Update the .got, .plt. and dynamic reloc reference counts for the    section being removed.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL64
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
name|p
operator|->
name|pc_count
operator|-=
literal|1
expr_stmt|;
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR30
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_ADDR64
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
case|case
name|R_PPC64_TOC
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Called via elf_link_hash_traverse to transfer dynamic linking    information on function code symbol entries to their corresponding    function descriptor symbol entries.  */
end_comment

begin_function
specifier|static
name|boolean
name|func_desc_adjust
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* If this is a function code symbol, transfer dynamic linking      information to the function descriptor symbol.  */
if|if
condition|(
operator|!
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
condition|)
name|htab
operator|->
name|have_undefweak
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|fdh
init|=
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|oh
decl_stmt|;
name|boolean
name|force_local
decl_stmt|;
comment|/* Find the corresponding function descriptor symbol.  Create it 	 as undefined if necessary.  */
if|if
condition|(
name|fdh
operator|==
name|NULL
condition|)
name|fdh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|==
name|NULL
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|newsym
decl_stmt|;
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
name|newsym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|newsym
operator|->
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
expr_stmt|;
name|newsym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|newsym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|newsym
operator|->
name|flags
operator|=
name|BSF_OBJECT
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|newsym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|newsym
operator|->
name|name
argument_list|,
name|newsym
operator|->
name|flags
argument_list|,
name|newsym
operator|->
name|section
argument_list|,
name|newsym
operator|->
name|value
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|fdh
argument_list|)
operator|)
condition|)
block|{
return|return
name|false
return|;
block|}
name|fdh
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
block|}
if|if
condition|(
name|fdh
operator|!=
name|NULL
operator|&&
operator|(
name|fdh
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|fdh
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|fdh
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fdh
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|fdh
argument_list|)
condition|)
return|return
name|false
return|;
name|fdh
operator|->
name|elf_link_hash_flags
operator||=
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_NON_GOT_REF
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
block|{
name|fdh
operator|->
name|plt
operator|.
name|refcount
operator|=
name|h
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
name|fdh
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|)
operator|->
name|is_func_descriptor
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|)
operator|->
name|oh
operator|=
name|h
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|oh
operator|=
name|fdh
expr_stmt|;
block|}
comment|/* Now that the info is on the function descriptor, clear the 	 function code sym info.  Any function code syms for which we 	 don't have a definition in a regular file, we force local. 	 This prevents a shared library from exporting syms that have 	 been imported from another library.  Function code syms that 	 are really in the library we must leave global to prevent the 	 linker dragging in a definition from a static library.  */
name|force_local
operator|=
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|||
name|fdh
operator|==
name|NULL
operator|||
operator|(
name|fdh
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|||
operator|(
name|fdh
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MIN_SAVE_FPR
value|14
end_define

begin_define
define|#
directive|define
name|MAX_SAVE_FPR
value|31
end_define

begin_comment
comment|/* Called near the start of bfd_elf_size_dynamic_sections.  We use    this hook to a) provide some gcc support functions, and b) transfer    dynamic linking information gathered so far on function code symbol    entries, to their corresponding function descriptor symbol entries.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_func_desc_adjust
parameter_list|(
name|obfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|unsigned
name|int
name|lowest_savef
init|=
name|MAX_SAVE_FPR
operator|+
literal|2
decl_stmt|;
name|unsigned
name|int
name|lowest_restf
init|=
name|MAX_SAVE_FPR
operator|+
literal|2
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|char
name|sym
index|[
literal|10
index|]
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|==
name|NULL
condition|)
comment|/* We don't have any relocs.  */
return|return
name|true
return|;
comment|/* First provide any missing ._savef* and ._restf* functions.  */
name|memcpy
argument_list|(
name|sym
argument_list|,
literal|"._savef14"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_SAVE_FPR
init|;
name|i
operator|<=
name|MAX_SAVE_FPR
condition|;
name|i
operator|++
control|)
block|{
name|sym
index|[
literal|7
index|]
operator|=
name|i
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
name|sym
index|[
literal|8
index|]
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|sym
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
if|if
condition|(
name|lowest_savef
operator|>
name|i
condition|)
name|lowest_savef
operator|=
name|i
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|sfpr
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
operator|(
name|i
operator|-
name|lowest_savef
operator|)
operator|*
literal|4
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|sym
argument_list|,
literal|"._restf14"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_SAVE_FPR
init|;
name|i
operator|<=
name|MAX_SAVE_FPR
condition|;
name|i
operator|++
control|)
block|{
name|sym
index|[
literal|7
index|]
operator|=
name|i
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
name|sym
index|[
literal|8
index|]
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|sym
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
if|if
condition|(
name|lowest_restf
operator|>
name|i
condition|)
name|lowest_restf
operator|=
name|i
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|sfpr
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
operator|(
operator|(
name|MAX_SAVE_FPR
operator|+
literal|2
operator|-
name|lowest_savef
operator|)
operator|*
literal|4
operator|+
operator|(
name|i
operator|-
name|lowest_restf
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
block|}
block|}
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|func_desc_adjust
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|=
operator|(
operator|(
name|MAX_SAVE_FPR
operator|+
literal|2
operator|-
name|lowest_savef
operator|)
operator|*
literal|4
operator|+
operator|(
name|MAX_SAVE_FPR
operator|+
literal|2
operator|-
name|lowest_restf
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|htab
operator|->
name|have_undefweak
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|htab
operator|->
name|sfpr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|=
literal|4
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|htab
operator|->
name|sfpr
operator|->
name|contents
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowest_savef
init|;
name|i
operator|<=
name|MAX_SAVE_FPR
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|fpr
init|=
name|i
operator|<<
literal|21
decl_stmt|;
name|unsigned
name|int
name|stackoff
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
name|MAX_SAVE_FPR
operator|+
literal|1
operator|-
name|i
operator|)
operator|*
literal|8
decl_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|STFD_FR0_0R1
operator|+
name|fpr
operator|+
name|stackoff
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|lowest_savef
operator|<=
name|MAX_SAVE_FPR
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|lowest_restf
init|;
name|i
operator|<=
name|MAX_SAVE_FPR
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|fpr
init|=
name|i
operator|<<
literal|21
decl_stmt|;
name|unsigned
name|int
name|stackoff
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
name|MAX_SAVE_FPR
operator|+
literal|1
operator|-
name|i
operator|)
operator|*
literal|8
decl_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|LFD_FR0_0R1
operator|+
name|fpr
operator|+
name|stackoff
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|lowest_restf
operator|<=
name|MAX_SAVE_FPR
operator|||
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|==
literal|4
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Deal with function syms.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clear procedure linkage table information for any symbol that 	 won't need a .plt entry.  */
if|if
condition|(
operator|!
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
operator|||
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|true
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in read-only sections, then      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
comment|/* We must generate a R_PPC_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|srelbss
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|4
condition|)
name|power_of_two
operator|=
literal|4
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|=
name|htab
operator|->
name|sdynbss
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If given a function descriptor symbol, hide both the function code    sym and the descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_hide_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|,
name|force_local
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|force_local
decl_stmt|;
block|{
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|fh
init|=
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|oh
decl_stmt|;
if|if
condition|(
name|fh
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* We aren't supposed to use alloca in BFD because on 	     systems which do not have alloca the version in libiberty 	     calls xmalloc, which might cause the program to crash 	     when it runs out of memory.  This function doesn't have a 	     return status, so there's no way to gracefully return an 	     error.  So cheat.  We know that string[-1] can be safely 	     dereferenced;  It's either a string in an ELF string 	     table, or allocated in an objalloc structure.  */
name|p
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|-
literal|1
expr_stmt|;
name|save
operator|=
operator|*
name|p
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|p
operator|=
literal|'.'
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|p
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|p
operator|=
name|save
expr_stmt|;
comment|/* Unfortunately, if it so happens that the string we were 	     looking for was allocated immediately before this string, 	     then we overwrote the string terminator.  That's the only 	     reason the lookup should fail.  */
if|if
condition|(
name|fh
operator|==
name|NULL
condition|)
block|{
name|q
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|>=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|&&
operator|*
name|q
operator|==
operator|*
name|p
condition|)
operator|--
name|q
operator|,
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|q
operator|<
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|&&
operator|*
name|p
operator|==
literal|'.'
condition|)
name|fh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|p
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fh
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|oh
operator|=
name|fh
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fh
operator|)
operator|->
name|oh
operator|=
name|h
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fh
operator|!=
name|NULL
condition|)
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|fh
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|edit_opd
parameter_list|(
name|obfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|unsigned
name|int
name|bfd_indx
decl_stmt|;
for|for
control|(
name|bfd_indx
operator|=
literal|0
operator|,
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|long
modifier|*
name|adjust
decl_stmt|;
name|boolean
name|need_edit
decl_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
continue|continue;
name|adjust
operator|=
operator|(
name|long
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|adjust
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|adjust
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|sec
operator|->
name|_raw_size
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
continue|continue;
comment|/* Look through the section relocs.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|local_syms
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
comment|/* Read the relocations.  */
name|relstart
operator|=
name|_bfd_elf64_link_read_relocs
argument_list|(
name|obfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* First run through the relocs to check they are sane, and to 	 determine whether we need to edit this opd section.  */
name|need_edit
operator|=
name|false
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
comment|/* .opd contains a regular array of 24 byte entries.  We're 	     only interested in the reloc pointing to a function entry 	     point.  */
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_TOC
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|!=
name|R_PPC64_ADDR64
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unexpected reloc type %u in .opd section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|need_edit
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rel
operator|+
literal|1
operator|>=
name|relend
condition|)
continue|continue;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_PPC64_TOC
condition|)
continue|continue;
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|!=
name|offset
condition|)
block|{
comment|/* If someone messes with .opd alignment then after a 		 "ld -r" we might have padding in the middle of .opd. 		 Also, there's nothing to prevent someone putting 		 something silly in .opd with the assembler.  No .opd 		 optimization for them!  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: .opd is not a regular array of opd entries"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|need_edit
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|sym_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
block|{
name|local_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
name|local_syms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_free_rel
goto|;
block|}
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|)
operator|||
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|ibfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: undefined sym `%s' in .opd section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|h
operator|!=
name|NULL
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<local symbol>"
argument_list|)
expr_stmt|;
name|need_edit
operator|=
name|false
expr_stmt|;
break|break;
block|}
comment|/* opd entries are always for functions defined in the 	     current input bfd.  If the symbol isn't defined in the 	     input bfd, then we won't be using the function in this 	     bfd;  It must be defined in a linkonce section in another 	     bfd, or is weak.  It's also possible that we are 	     discarding the function due to a linker script /DISCARD/, 	     which we test for via the output_section.  */
if|if
condition|(
name|sym_sec
operator|->
name|owner
operator|!=
name|ibfd
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
name|need_edit
operator|=
name|true
expr_stmt|;
name|offset
operator|+=
literal|24
expr_stmt|;
block|}
if|if
condition|(
name|need_edit
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|write_rel
decl_stmt|;
name|bfd_byte
modifier|*
name|rptr
decl_stmt|,
modifier|*
name|wptr
decl_stmt|;
name|boolean
name|skip
decl_stmt|;
comment|/* This seems a waste of time as input .opd sections are all 	     zeros as generated by gcc, but I suppose there's no reason 	     this will always be so.  We might start putting something in 	     the third word of .opd entries.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_IN_MEMORY
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|loc
init|=
name|bfd_alloc
argument_list|(
name|ibfd
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
operator|||
operator|!
name|bfd_get_section_contents
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|loc
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
block|{
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
name|error_free_rel
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|sec
operator|->
name|contents
operator|=
name|loc
expr_stmt|;
name|sec
operator|->
name|flags
operator||=
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|relstart
expr_stmt|;
name|wptr
operator|=
name|sec
operator|->
name|contents
expr_stmt|;
name|rptr
operator|=
name|sec
operator|->
name|contents
expr_stmt|;
name|write_rel
operator|=
name|relstart
expr_stmt|;
name|skip
operator|=
name|false
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|==
name|offset
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|sym_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|)
operator|||
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|ibfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
operator|(
name|sym_sec
operator|->
name|owner
operator|!=
name|ibfd
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|sym_sec
operator|->
name|owner
operator|==
name|ibfd
condition|)
block|{
comment|/* Arrange for the function descriptor sym 			     to be dropped.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fh
decl_stmt|;
name|fh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|fh
operator|->
name|is_func
argument_list|)
expr_stmt|;
name|fdh
operator|=
name|fh
operator|->
name|oh
expr_stmt|;
name|fdh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|fdh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|sym_sec
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We'll be keeping this opd entry.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Redefine the function descriptor symbol 			     to this location in the opd section. 			     We've checked above that opd relocs are 			     ordered.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fh
decl_stmt|;
name|fh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|fh
operator|->
name|is_func
argument_list|)
expr_stmt|;
name|fdh
operator|=
name|fh
operator|->
name|oh
expr_stmt|;
name|fdh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|wptr
operator|-
name|sec
operator|->
name|contents
expr_stmt|;
block|}
else|else
block|{
comment|/* Local syms are a bit tricky.  We could 			     tweak them as they can be cached, but 			     we'd need to look through the local syms 			     for the function descriptor sym which we 			     don't have at the moment.  So keep an 			     array of adjustments.  */
name|adjust
index|[
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|wptr
operator|-
name|rptr
operator|)
operator|/
literal|24
index|]
operator|=
name|wptr
operator|-
name|rptr
expr_stmt|;
block|}
if|if
condition|(
name|wptr
operator|!=
name|rptr
condition|)
name|memcpy
argument_list|(
name|wptr
argument_list|,
name|rptr
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|wptr
operator|+=
literal|24
expr_stmt|;
block|}
name|rptr
operator|+=
literal|24
expr_stmt|;
name|offset
operator|+=
literal|24
expr_stmt|;
block|}
comment|/* We need to adjust any reloc offsets to point to the 		 new opd entries.  While we're at it, we may as well 		 remove redundant relocs.  */
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|rel
operator|->
name|r_offset
operator|+=
name|wptr
operator|-
name|rptr
expr_stmt|;
if|if
condition|(
name|write_rel
operator|!=
name|rel
condition|)
name|memcpy
argument_list|(
name|write_rel
argument_list|,
name|rel
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rel
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|write_rel
expr_stmt|;
block|}
block|}
name|sec
operator|->
name|_cooked_size
operator|=
name|wptr
operator|-
name|sec
operator|->
name|contents
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
name|write_rel
operator|-
name|relstart
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is the condition under which ppc64_elf_finish_dynamic_symbol    will be called from elflink.h.  If elflink.h doesn't call our    finish_dynamic_symbol routine, we'll need to do something about    initializing any .plt and .got entries in ppc64_elf_relocate_section.  */
end_comment

begin_define
define|#
directive|define
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
parameter_list|(
name|DYN
parameter_list|,
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|((DYN)								\&& ((INFO)->shared							\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) == 0)	\&& ((H)->dynindx != -1						\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) != 0))
end_define

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_dynrelocs
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
comment|/* If this is the first .plt entry, make room for the special 	     first entry.  */
name|s
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_INITIAL_ENTRY_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make room for this entry.  */
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Make room for the .glink code.  */
name|s
operator|=
name|htab
operator|->
name|sglink
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|GLINK_CALL_STUB_SIZE
expr_stmt|;
comment|/* We need bigger stubs past index 32767.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|>=
name|GLINK_CALL_STUB_SIZE
operator|+
literal|32768
operator|*
literal|2
operator|*
literal|4
condition|)
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|2
operator|*
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|boolean
name|dyn
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for relocs that have become local due to symbol visibility      changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
operator|||
name|info
operator|->
name|symbolic
operator|)
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|readonly_dynrelocs
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
control|)
block|{
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|edit_opd
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* We now have determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|sbrlt
operator|||
name|s
operator|==
name|htab
operator|->
name|srelbrlt
condition|)
comment|/* These haven't been allocated yet;  don't strip.  */
continue|continue;
elseif|else
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|splt
operator|||
name|s
operator|==
name|htab
operator|->
name|sgot
operator|||
name|s
operator|==
name|htab
operator|->
name|sglink
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 		 output file.  This is mostly to handle .rela.bss and 		 .rela.plt.  We must create both sections in 		 create_dynamic_sections, because they must be created 		 before the linker maps input sections to output 		 sections.  The linker does that before 		 adjust_dynamic_symbol is called, and it is that 		 function which decides whether anything needs to go 		 into these sections.  */
block|}
else|else
block|{
if|if
condition|(
name|s
operator|!=
name|htab
operator|->
name|srelplt
condition|)
name|relocs
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* .plt is in the bss section.  We don't initialise it.  */
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  We use bfd_zalloc 	 here in case unused entries are not reclaimed before the 	 section's contents are written out.  This should not happen, 	 but this way if it does, we get a R_PPC64_NONE reloc instead 	 of garbage.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in ppc64_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_GLINK
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|NO_OPD_RELOCS
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_OPD
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_OPDSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If any dynamic relocs apply to a read-only section, 	     then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|readonly_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine the type of stub needed, if any, for a call.  */
end_comment

begin_function
specifier|static
name|INLINE
name|enum
name|ppc_stub_type
name|ppc_type_of_stub
parameter_list|(
name|input_sec
parameter_list|,
name|rel
parameter_list|,
name|hash
parameter_list|,
name|destination
parameter_list|)
name|asection
modifier|*
name|input_sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
modifier|*
name|hash
decl_stmt|;
name|bfd_vma
name|destination
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
init|=
operator|*
name|hash
decl_stmt|;
name|bfd_vma
name|location
decl_stmt|;
name|bfd_vma
name|branch_offset
decl_stmt|;
name|bfd_vma
name|max_branch_offset
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|oh
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|oh
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|h
operator|->
name|oh
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|hash
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|oh
expr_stmt|;
return|return
name|ppc_stub_plt_call
return|;
block|}
if|if
condition|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
return|return
name|ppc_stub_none
return|;
block|}
comment|/* Determine where the call point is.  */
name|location
operator|=
operator|(
name|input_sec
operator|->
name|output_offset
operator|+
name|input_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|branch_offset
operator|=
name|destination
operator|-
name|location
expr_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Determine if a long branch stub is needed.  */
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|R_PPC64_REL24
condition|)
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|15
expr_stmt|;
if|if
condition|(
name|branch_offset
operator|+
name|max_branch_offset
operator|>=
literal|2
operator|*
name|max_branch_offset
condition|)
comment|/* We need a stub.  Figure out whether a long_branch or plt_branch        is needed later.  */
return|return
name|ppc_stub_long_branch
return|;
return|return
name|ppc_stub_none
return|;
block|}
end_function

begin_comment
comment|/* Build a .plt call stub.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|build_plt_stub
parameter_list|(
name|obfd
parameter_list|,
name|p
parameter_list|,
name|offset
parameter_list|,
name|glink
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|glink
decl_stmt|;
block|{
define|#
directive|define
name|PPC_LO
parameter_list|(
name|v
parameter_list|)
value|((v)& 0xffff)
define|#
directive|define
name|PPC_HI
parameter_list|(
name|v
parameter_list|)
value|(((v)>> 16)& 0xffff)
define|#
directive|define
name|PPC_HA
parameter_list|(
name|v
parameter_list|)
value|PPC_HI ((v) + 0x8000)
if|if
condition|(
name|glink
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R2_40R1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R2
operator||
name|PPC_HA
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|glink
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|STD_R2_40R1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|offset
operator|+
literal|8
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|offset
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R12_1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R2_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|offset
operator|+
literal|8
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|offset
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R12_1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|MTCTR_R11
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|BCTR
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ppc_build_one_stub
parameter_list|(
name|gen_entry
parameter_list|,
name|in_arg
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
decl_stmt|;
name|PTR
name|in_arg
decl_stmt|;
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|ppc_branch_hash_entry
modifier|*
name|br_entry
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|ppc_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|in_arg
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|stub_sec
operator|=
name|stub_entry
operator|->
name|stub_sec
expr_stmt|;
comment|/* Make a note of the offset within the stubs for this entry.  */
name|stub_entry
operator|->
name|stub_offset
operator|=
name|stub_sec
operator|->
name|_cooked_size
expr_stmt|;
name|loc
operator|=
name|stub_sec
operator|->
name|contents
operator|+
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
name|stub_bfd
operator|=
name|stub_sec
operator|->
name|owner
expr_stmt|;
switch|switch
condition|(
name|stub_entry
operator|->
name|stub_type
condition|)
block|{
case|case
name|ppc_stub_long_branch
case|:
comment|/* Branches are relative.  This is where we are going to.  */
name|off
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* And this is where we are coming from.  */
name|off
operator|-=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|+
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|<
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
literal|26
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|B_DOT
operator||
operator|(
name|off
operator|&
literal|0x3fffffc
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|ppc_stub_plt_branch
case|:
name|br_entry
operator|=
name|ppc_branch_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|branch_hash_table
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|br_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"can't find branch stub `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
name|off
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|htab
operator|->
name|sbrlt
operator|->
name|owner
argument_list|,
name|off
argument_list|,
name|htab
operator|->
name|sbrlt
operator|->
name|contents
operator|+
name|br_entry
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Create a reloc for the branch lookup table entry.  */
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|r
decl_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|br_entry
operator|->
name|offset
operator|+
name|htab
operator|->
name|sbrlt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|sbrlt
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|off
expr_stmt|;
name|r
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelbrlt
operator|->
name|contents
expr_stmt|;
name|r
operator|+=
name|htab
operator|->
name|srelbrlt
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|htab
operator|->
name|srelbrlt
operator|->
name|owner
argument_list|,
operator|&
name|rela
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|off
operator|=
operator|(
name|br_entry
operator|->
name|offset
operator|+
name|htab
operator|->
name|sbrlt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|sbrlt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|sbrlt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|TOC_BASE_OFF
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
literal|0x80000000
operator|>
literal|0xffffffff
operator|||
operator|(
name|off
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"linkage table error against `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
name|indx
operator|=
name|off
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ADDIS_R12_R2
operator||
name|PPC_HA
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|MTCTR_R11
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|BCTR
argument_list|,
name|loc
operator|+
literal|12
argument_list|)
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|ppc_stub_plt_call
case|:
comment|/* Do the best we can for shared libraries built without 	 exporting ".foo" for each "foo".  This can happen when symbol 	 versioning scripts strip all bar a subset of symbols.  */
if|if
condition|(
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* Point the symbol at the stub.  There may be multiple stubs, 	     we don't really care;  The main thing is to make this sym 	     defined somewhere.  */
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|stub_entry
operator|->
name|stub_sec
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
block|}
comment|/* Now build the stub.  */
name|off
operator|=
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
name|off
operator|+=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|TOC_BASE_OFF
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
literal|0x80000000
operator|>
literal|0xffffffff
operator|||
operator|(
name|off
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"linkage table error against `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
name|p
operator|=
name|build_plt_stub
argument_list|(
name|stub_bfd
argument_list|,
name|loc
argument_list|,
operator|(
name|int
operator|)
name|off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|p
operator|-
name|loc
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
name|stub_sec
operator|->
name|_cooked_size
operator|+=
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* As above, but don't actually build the stub.  Just bump offset so    we know stub section sizes, and select plt_branch stubs where    long_branch stubs won't do.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_size_one_stub
parameter_list|(
name|gen_entry
parameter_list|,
name|in_arg
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
decl_stmt|;
name|PTR
name|in_arg
decl_stmt|;
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|ppc_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|htab
operator|=
operator|(
expr|struct
name|ppc_link_hash_table
operator|*
operator|)
name|in_arg
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
condition|)
block|{
name|off
operator|=
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
name|off
operator|+=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|TOC_BASE_OFF
operator|)
expr_stmt|;
name|size
operator|=
literal|28
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
operator|(
name|int
operator|)
name|off
operator|+
literal|16
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
operator|(
name|int
operator|)
name|off
argument_list|)
condition|)
name|size
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* ppc_stub_long_branch or ppc_stub_plt_branch.  */
name|stub_entry
operator|->
name|stub_type
operator|=
name|ppc_stub_long_branch
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|off
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|off
operator|-=
operator|(
name|stub_entry
operator|->
name|stub_sec
operator|->
name|_raw_size
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|>=
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
literal|26
argument_list|)
condition|)
block|{
name|struct
name|ppc_branch_hash_entry
modifier|*
name|br_entry
decl_stmt|;
name|br_entry
operator|=
name|ppc_branch_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|branch_hash_table
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|br_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"can't build branch stub `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|br_entry
operator|->
name|iter
operator|!=
name|htab
operator|->
name|stub_iteration
condition|)
block|{
name|br_entry
operator|->
name|iter
operator|=
name|htab
operator|->
name|stub_iteration
expr_stmt|;
name|br_entry
operator|->
name|offset
operator|=
name|htab
operator|->
name|sbrlt
operator|->
name|_raw_size
expr_stmt|;
name|htab
operator|->
name|sbrlt
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
block|}
name|stub_entry
operator|->
name|stub_type
operator|=
name|ppc_stub_plt_branch
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
block|}
block|}
name|stub_entry
operator|->
name|stub_sec
operator|->
name|_raw_size
operator|+=
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set up various things so that we can make a list of input sections    for each output section included in the link.  Returns -1 on error,    0 when no stubs will be needed, and 1 on success.  */
end_comment

begin_function
name|int
name|ppc64_elf_setup_section_lists
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|int
name|top_id
decl_stmt|,
name|top_index
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|,
modifier|*
modifier|*
name|list
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|root
operator|.
name|creator
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
operator|||
name|htab
operator|->
name|sbrlt
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Find the top input section id.  */
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|top_id
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|top_id
operator|<
name|section
operator|->
name|id
condition|)
name|top_id
operator|=
name|section
operator|->
name|id
expr_stmt|;
block|}
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|map_stub
argument_list|)
operator|*
operator|(
name|top_id
operator|+
literal|1
operator|)
expr_stmt|;
name|htab
operator|->
name|stub_group
operator|=
operator|(
expr|struct
name|map_stub
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|stub_group
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* We can't use output_bfd->section_count here to find the top output      section index as some sections may have been removed, and      _bfd_strip_section_from_output doesn't renumber the indices.  */
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
operator|,
name|top_index
operator|=
literal|0
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|top_index
operator|<
name|section
operator|->
name|index
condition|)
name|top_index
operator|=
name|section
operator|->
name|index
expr_stmt|;
block|}
name|htab
operator|->
name|top_index
operator|=
name|top_index
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|*
operator|(
name|top_index
operator|+
literal|1
operator|)
expr_stmt|;
name|input_list
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|htab
operator|->
name|input_list
operator|=
name|input_list
expr_stmt|;
if|if
condition|(
name|input_list
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* For sections we aren't interested in, mark their entries with a      value we can check later.  */
name|list
operator|=
name|input_list
operator|+
name|top_index
expr_stmt|;
do|do
operator|*
name|list
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
do|while
condition|(
name|list
operator|--
operator|!=
name|input_list
condition|)
do|;
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|input_list
index|[
name|section
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The linker repeatedly calls this function for each input section,    in the order that input sections are linked into output sections.    Build lists of input sections to determine groupings between which    we may insert linker stubs.  */
end_comment

begin_function
name|void
name|ppc64_elf_next_input_section
parameter_list|(
name|info
parameter_list|,
name|isec
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|isec
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|isec
operator|->
name|output_section
operator|->
name|index
operator|<=
name|htab
operator|->
name|top_index
condition|)
block|{
name|asection
modifier|*
modifier|*
name|list
init|=
name|htab
operator|->
name|input_list
operator|+
name|isec
operator|->
name|output_section
operator|->
name|index
decl_stmt|;
if|if
condition|(
operator|*
name|list
operator|!=
name|bfd_abs_section_ptr
condition|)
block|{
comment|/* Steal the link_sec pointer for our list.  */
define|#
directive|define
name|PREV_SEC
parameter_list|(
name|sec
parameter_list|)
value|(htab->stub_group[(sec)->id].link_sec)
comment|/* This happens to make the list in reverse order, 	     which is what we want.  */
name|PREV_SEC
argument_list|(
name|isec
argument_list|)
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|isec
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* See whether we can group stub sections together.  Grouping stub    sections may result in fewer stubs.  More importantly, we need to    put all .init* and .fini* stubs at the beginning of the .init or    .fini output sections respectively, because glibc splits the    _init and _fini functions into multiple parts.  Putting a stub in    the middle of a function is not a good idea.  */
end_comment

begin_function
specifier|static
name|void
name|group_sections
parameter_list|(
name|htab
parameter_list|,
name|stub_group_size
parameter_list|,
name|stubs_always_before_branch
parameter_list|)
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_size_type
name|stub_group_size
decl_stmt|;
name|boolean
name|stubs_always_before_branch
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|list
init|=
name|htab
operator|->
name|input_list
operator|+
name|htab
operator|->
name|top_index
decl_stmt|;
do|do
block|{
name|asection
modifier|*
name|tail
init|=
operator|*
name|list
decl_stmt|;
if|if
condition|(
name|tail
operator|==
name|bfd_abs_section_ptr
condition|)
continue|continue;
while|while
condition|(
name|tail
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|curr
decl_stmt|;
name|asection
modifier|*
name|prev
decl_stmt|;
name|bfd_size_type
name|total
decl_stmt|;
name|curr
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|tail
operator|->
name|_cooked_size
condition|)
name|total
operator|=
name|tail
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|total
operator|=
name|tail
operator|->
name|_raw_size
expr_stmt|;
while|while
condition|(
operator|(
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|curr
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|total
operator|+=
name|curr
operator|->
name|output_offset
operator|-
name|prev
operator|->
name|output_offset
operator|)
operator|<
name|stub_group_size
operator|)
condition|)
name|curr
operator|=
name|prev
expr_stmt|;
comment|/* OK, the size from the start of CURR to the end is less 	     than stub_group_size and thus can be handled by one stub 	     section.  (or the tail section is itself larger than 	     stub_group_size, in which case we may be toast.)  We 	     should really be keeping track of the total size of stubs 	     added here, as stubs contribute to the final output 	     section size.  That's a little tricky, and this way will 	     only break if stubs added make the total size more than 	     2^25, ie. for the default stub_group_size, if stubs total 	     more than 2834432 bytes, or over 100000 plt call stubs.  */
do|do
block|{
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Set up this stub group.  */
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|link_sec
operator|=
name|curr
expr_stmt|;
block|}
do|while
condition|(
name|tail
operator|!=
name|curr
operator|&&
operator|(
name|tail
operator|=
name|prev
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* But wait, there's more!  Input sections up to stub_group_size 	     bytes before the stub section can be handled by it too.  */
if|if
condition|(
operator|!
name|stubs_always_before_branch
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|prev
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|total
operator|+=
name|tail
operator|->
name|output_offset
operator|-
name|prev
operator|->
name|output_offset
operator|)
operator|<
name|stub_group_size
operator|)
condition|)
block|{
name|tail
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|link_sec
operator|=
name|curr
expr_stmt|;
block|}
block|}
name|tail
operator|=
name|prev
expr_stmt|;
block|}
block|}
do|while
condition|(
name|list
operator|--
operator|!=
name|htab
operator|->
name|input_list
condition|)
do|;
name|free
argument_list|(
name|htab
operator|->
name|input_list
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PREV_SEC
block|}
end_function

begin_comment
comment|/* Determine and set the size of the stub section for a final link.     The basic idea here is to examine all the relocations looking for    PC-relative calls to a target that is unreachable with a "bl"    instruction.  */
end_comment

begin_decl_stmt
name|boolean
name|ppc64_elf_size_stubs
argument_list|(
name|output_bfd
argument_list|,
name|stub_bfd
argument_list|,
name|info
argument_list|,
name|group_size
argument_list|,
name|add_stub_section
argument_list|,
name|layout_sections_again
argument_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_signed_vma
name|group_size
decl_stmt|;
end_decl_stmt

begin_macro
name|asection
end_macro

begin_expr_stmt
operator|*
operator|(
operator|*
name|add_stub_section
operator|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*layout_sections_again
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|bfd_size_type
name|stub_group_size
decl_stmt|;
name|boolean
name|stubs_always_before_branch
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* Stash our params away.  */
name|htab
operator|->
name|stub_bfd
operator|=
name|stub_bfd
expr_stmt|;
name|htab
operator|->
name|add_stub_section
operator|=
name|add_stub_section
expr_stmt|;
name|htab
operator|->
name|layout_sections_again
operator|=
name|layout_sections_again
expr_stmt|;
name|stubs_always_before_branch
operator|=
name|group_size
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|group_size
operator|<
literal|0
condition|)
name|stub_group_size
operator|=
operator|-
name|group_size
expr_stmt|;
else|else
name|stub_group_size
operator|=
name|group_size
expr_stmt|;
if|if
condition|(
name|stub_group_size
operator|==
literal|1
condition|)
block|{
comment|/* Default values.  */
name|stub_group_size
operator|=
literal|30720000
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|has_14bit_branch
condition|)
name|stub_group_size
operator|=
literal|30000
expr_stmt|;
block|}
name|group_sections
argument_list|(
name|htab
argument_list|,
name|stub_group_size
argument_list|,
name|stubs_always_before_branch
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|unsigned
name|int
name|bfd_indx
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|boolean
name|stub_changed
decl_stmt|;
name|htab
operator|->
name|stub_iteration
operator|+=
literal|1
expr_stmt|;
name|stub_changed
operator|=
name|false
expr_stmt|;
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_indx
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
init|=
name|NULL
decl_stmt|;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
comment|/* Walk over each section attached to the input bfd.  */
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|,
modifier|*
name|irelaend
decl_stmt|,
modifier|*
name|irela
decl_stmt|;
comment|/* If there aren't any relocs, then there's nothing more 		 to do.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this section is a link-once section that will be 		 discarded, then don't create any stubs.  */
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|section
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|output_bfd
condition|)
continue|continue;
comment|/* Get the relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf64_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_local
goto|;
comment|/* Now examine each relocation.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|,
name|r_indx
decl_stmt|;
name|enum
name|ppc_stub_type
name|stub_type
decl_stmt|;
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|bfd_vma
name|destination
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|char
modifier|*
name|stub_name
decl_stmt|;
specifier|const
name|asection
modifier|*
name|id_sec
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_indx
operator|=
name|ELF64_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|R_PPC_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
comment|/* Only look for stubs on branch instructions.  */
if|if
condition|(
name|r_type
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|R_PPC64_REL24
operator|&&
name|r_type
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|R_PPC64_REL14
operator|&&
name|r_type
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|R_PPC64_REL14_BRTAKEN
operator|&&
name|r_type
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|R_PPC64_REL14_BRNTAKEN
condition|)
continue|continue;
comment|/* Now determine the call target, its name, value, 		     section.  */
name|sym_sec
operator|=
name|NULL
expr_stmt|;
name|sym_value
operator|=
literal|0
expr_stmt|;
name|destination
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_indx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* It's a local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
block|{
name|local_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
name|local_syms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_internal
goto|;
block|}
name|sym
operator|=
name|local_syms
operator|+
name|r_indx
expr_stmt|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|input_bfd
argument_list|)
index|[
name|sym
operator|->
name|st_shndx
index|]
expr_stmt|;
name|sym_sec
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
name|sym_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|irela
operator|->
name|r_addend
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's an external symbol.  */
name|int
name|e_indx
decl_stmt|;
name|e_indx
operator|=
name|r_indx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|e_indx
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hash
operator|=
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|)
expr_stmt|;
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_sec
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sym_value
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|irela
operator|->
name|r_addend
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
empty_stmt|;
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
block|}
comment|/* Determine what (if any) linker stub is needed.  */
name|stub_type
operator|=
name|ppc_type_of_stub
argument_list|(
name|section
argument_list|,
name|irela
argument_list|,
operator|&
name|hash
argument_list|,
name|destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_type
operator|==
name|ppc_stub_none
condition|)
continue|continue;
comment|/* Support for grouping stub sections.  */
name|id_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
comment|/* Get the name of this stub.  */
name|stub_name
operator|=
name|ppc_stub_name
argument_list|(
name|id_sec
argument_list|,
name|sym_sec
argument_list|,
name|hash
argument_list|,
name|irela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_name
condition|)
goto|goto
name|error_ret_free_internal
goto|;
name|stub_entry
operator|=
name|ppc_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|!=
name|NULL
condition|)
block|{
comment|/* The proper stub has already been created.  */
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stub_entry
operator|=
name|ppc_add_stub
argument_list|(
name|stub_name
argument_list|,
name|section
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
name|error_ret_free_internal
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|error_ret_free_local
label|:
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
operator|)
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|stub_entry
operator|->
name|target_value
operator|=
name|sym_value
expr_stmt|;
name|stub_entry
operator|->
name|target_section
operator|=
name|sym_sec
expr_stmt|;
name|stub_entry
operator|->
name|stub_type
operator|=
name|stub_type
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|=
name|hash
expr_stmt|;
name|stub_changed
operator|=
name|true
expr_stmt|;
block|}
comment|/* We're done with the internal relocs, free them.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|stub_changed
condition|)
break|break;
comment|/* OK, we've added some stubs.  Find out the new size of the 	 stub sections.  */
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
block|{
name|stub_sec
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|stub_sec
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
block|}
name|htab
operator|->
name|sbrlt
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|sbrlt
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|ppc_size_one_stub
argument_list|,
name|htab
argument_list|)
expr_stmt|;
comment|/* Ask the linker to do its stuff.  */
call|(
modifier|*
name|htab
operator|->
name|layout_sections_again
call|)
argument_list|()
expr_stmt|;
block|}
comment|/* It would be nice to strip .branch_lt from the output if the      section is empty, but it's too late.  If we strip sections here,      the dynamic symbol table is corrupted since the section symbol      for the stripped section isn't written.  */
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Called after we have determined section placement.  If sections    move, we'll be called again.  Provide a value for TOCstart.  */
end_comment

begin_function
name|bfd_vma
name|ppc64_elf_toc
parameter_list|(
name|obfd
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* The TOC consists of sections .got, .toc, .tocbss, .plt in that      order.  The TOC starts where the first of these sections starts.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".toc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".tocbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* This may happen for 	 o  references to TOC base (SYM@toc / TOC[tc0]) without a 	 .toc directive 	 o  bad linker script 	 o --gc-sections and empty TOC sections  	 FIXME: Warn user?  */
comment|/* Look for a likely section.  We probably won't even be 	 using TOCstart.  */
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
name|SEC_ALLOC
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
name|SEC_ALLOC
condition|)
break|break;
block|}
name|TOCstart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|TOCstart
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
return|return
name|TOCstart
return|;
block|}
end_function

begin_comment
comment|/* Build all the stubs associated with the current output file.    The stubs are kept in a hash table attached to the main linker    hash table.  This function is called via gldelf64ppc_finish.  */
end_comment

begin_function
name|boolean
name|ppc64_elf_build_stubs
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|bfd_vma
name|plt_r2
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Allocate memory to hold the linker stubs.  */
name|size
operator|=
name|stub_sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|stub_sec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|stub_sec
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|indx
decl_stmt|;
comment|/* Build the .glink plt call stub.  */
name|plt_r2
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|TOC_BASE_OFF
operator|)
expr_stmt|;
name|p
operator|=
name|htab
operator|->
name|sglink
operator|->
name|contents
expr_stmt|;
name|p
operator|=
name|build_plt_stub
argument_list|(
name|htab
operator|->
name|sglink
operator|->
name|owner
argument_list|,
name|p
argument_list|,
operator|(
name|int
operator|)
name|plt_r2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|htab
operator|->
name|sglink
operator|->
name|contents
operator|+
name|GLINK_CALL_STUB_SIZE
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|sglink
operator|->
name|owner
argument_list|,
name|NOP
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Build the .glink lazy link call stubs.  */
name|indx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|htab
operator|->
name|sglink
operator|->
name|contents
operator|+
name|htab
operator|->
name|sglink
operator|->
name|_raw_size
condition|)
block|{
if|if
condition|(
name|indx
operator|<
literal|0x8000
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|sglink
operator|->
name|owner
argument_list|,
name|LI_R0_0
operator||
name|indx
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|sglink
operator|->
name|owner
argument_list|,
name|LIS_R0_0
operator||
name|PPC_HI
argument_list|(
name|indx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|sglink
operator|->
name|owner
argument_list|,
name|ORI_R0_R0_0
operator||
name|PPC_LO
argument_list|(
name|indx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|sglink
operator|->
name|owner
argument_list|,
name|B_DOT
operator||
operator|(
operator|(
name|htab
operator|->
name|sglink
operator|->
name|contents
operator|-
name|p
operator|)
operator|&
literal|0x3fffffc
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|htab
operator|->
name|sglink
operator|->
name|_cooked_size
operator|=
name|p
operator|-
name|htab
operator|->
name|sglink
operator|->
name|contents
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|sbrlt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|sbrlt
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|sbrlt
operator|->
name|owner
argument_list|,
name|htab
operator|->
name|sbrlt
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sbrlt
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
comment|/* Build the stubs as directed by the stub hash table.  */
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|ppc_build_one_stub
argument_list|,
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|stub_sec
operator|->
name|_raw_size
operator|!=
name|stub_sec
operator|->
name|_cooked_size
condition|)
break|break;
block|}
if|if
condition|(
name|stub_sec
operator|!=
name|NULL
operator|||
name|htab
operator|->
name|sglink
operator|->
name|_raw_size
operator|!=
name|htab
operator|->
name|sglink
operator|->
name|_cooked_size
condition|)
block|{
name|htab
operator|->
name|stub_error
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stubs don't match calculated size"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|htab
operator|->
name|stub_error
return|;
block|}
end_function

begin_comment
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjust the section contents as    necessary, and (if using Rela relocs and generating a    relocateable output file) adjusting the reloc addend as    necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocateable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|bfd_vma
name|TOCstart
decl_stmt|;
name|boolean
name|ret
init|=
name|true
decl_stmt|;
name|boolean
name|is_opd
decl_stmt|;
comment|/* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
name|boolean
name|is_power4
init|=
name|false
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
comment|/* Initialize howto table if needed.  */
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
name|ppc_howto_init
argument_list|()
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|TOCstart
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|is_opd
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|tdata
operator|!=
name|NULL
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|boolean
name|unresolved_reloc
decl_stmt|;
name|boolean
name|warned
decl_stmt|;
name|long
name|insn
decl_stmt|;
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|bfd_vma
name|max_br_offset
decl_stmt|;
name|bfd_vma
name|from
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|offset
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|r
operator|=
name|bfd_reloc_other
expr_stmt|;
name|sym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
literal|0
expr_stmt|;
name|sec
operator|=
operator|(
name|asection
operator|*
operator|)
literal|0
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
literal|0
expr_stmt|;
name|sym_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
name|warned
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_TOC
condition|)
block|{
comment|/* Relocation value is TOC base.  Symbol is ignored.  */
name|relocation
operator|=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* It's a local symbol.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
literal|"<local symbol>"
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
comment|/* rel may have changed, update our copy of addend.  */
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|long
modifier|*
name|opd_sym_adjust
decl_stmt|;
name|opd_sym_adjust
operator|=
operator|(
name|long
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tdata
expr_stmt|;
if|if
condition|(
name|opd_sym_adjust
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|st_value
operator|%
literal|24
operator|==
literal|0
condition|)
name|relocation
operator|+=
name|opd_sym_adjust
index|[
name|sym
operator|->
name|st_value
operator|/
literal|24
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's a global symbol.  */
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
comment|/* Set a flag that will be cleared later if we find a 		   relocation value for this symbol.  output_section 		   is typically NULL for symbols satisfied by a shared 		   library.  */
name|unresolved_reloc
operator|=
name|true
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|allow_shlib_undefined
operator|)
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* First handle relocations that tweak non-addend part of insn.  */
name|insn
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
comment|/* Branch taken prediction relocations.  */
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
name|insn
operator|=
literal|0x01
operator|<<
literal|21
expr_stmt|;
comment|/* 'y' or 't' bit, lowest bit of BO field.  */
comment|/* Fall thru.  */
comment|/* Branch not taken prediction relocations.  */
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
name|insn
operator||=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
operator|&
operator|~
operator|(
literal|0x01
operator|<<
literal|21
operator|)
expr_stmt|;
if|if
condition|(
name|is_power4
condition|)
block|{
comment|/* Set 'a' bit.  This is 0b00010 in BO field for branch 		 on CR(BI) insns (BO == 001at or 011at), and 0b01000 		 for branch on CTR insns (BO == 1a00t or 1a01t).  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x04
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x02
operator|<<
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x10
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x08
operator|<<
literal|21
expr_stmt|;
else|else
break|break;
block|}
else|else
block|{
name|from
operator|=
operator|(
name|offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Invert 'y' bit if not the default.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|relocation
operator|+
name|addend
operator|-
name|from
argument_list|)
operator|<
literal|0
condition|)
name|insn
operator|^=
literal|0x01
operator|<<
literal|21
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_PPC64_REL24
case|:
comment|/* A REL24 branching to a linkage function is followed by a 	     nop.  We replace the nop with a ld in order to restore 	     the TOC base pointer.  Only calls to shared objects need 	     to alter the TOC base.  These are recognized by their 	     need for a PLT entry.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|fdh
operator|=
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|oh
operator|)
operator|!=
name|NULL
operator|&&
name|fdh
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|stub_entry
operator|=
name|ppc_get_stub_entry
argument_list|(
name|input_section
argument_list|,
name|sec
argument_list|,
name|fdh
argument_list|,
name|rel
argument_list|,
name|htab
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|can_plt_call
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|offset
operator|+
literal|8
operator|<=
name|input_section
operator|->
name|_cooked_size
condition|)
block|{
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NOP
operator|||
name|insn
operator|==
name|CROR_151515
operator|||
name|insn
operator|==
name|CROR_313131
condition|)
block|{
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|LD_R2_40R1
argument_list|,
name|contents
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|can_plt_call
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|can_plt_call
condition|)
block|{
comment|/* If this is a plain branch rather than a branch 		     and link, don't require a nop.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|can_plt_call
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|can_plt_call
condition|)
block|{
name|relocation
operator|=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|relocation
operator|==
literal|0
operator|&&
name|addend
operator|==
literal|0
condition|)
block|{
comment|/* Tweak calls to undefined weak functions to point at a 		 blr.  We can thus call a weak function without first 		 checking whether the function is defined.  We have a 		 blr at the end of .sfpr.  */
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|-
literal|4
operator|+
name|htab
operator|->
name|sfpr
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|sfpr
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|from
operator|=
operator|(
name|offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* But let's not be silly about it.  If the blr isn't in 		 reach, just go to the next instruction.  */
if|if
condition|(
name|relocation
operator|-
name|from
operator|+
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|>=
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|||
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|relocation
operator|=
name|from
operator|+
literal|4
expr_stmt|;
block|}
break|break;
block|}
comment|/* Set `addend'.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d for symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
case|case
name|R_PPC64_NONE
case|:
case|case
name|R_PPC_GNU_VTINHERIT
case|:
case|case
name|R_PPC_GNU_VTENTRY
case|:
continue|continue;
comment|/* GOT16 relocations.  Like an ADDR16 using the symbol's 	     address in the GOT as relocation value instead of the 	     symbols value itself.  Also, create a GOT entry for the 	     symbol and put the symbol value there.  */
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
block|{
comment|/* Relocation is to the entry for this symbol in the global 	       offset table.  */
name|bfd_vma
name|off
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 		       -Bsymbolic link and the symbol is defined 		       locally, or the symbol was forced to be local 		       because of a version file.  We must initialize 		       this entry in the global offset table.  Since the 		       offset must always be a multiple of 8, we use the 		       least significant bit to record whether we have 		       initialized it already.  		       When doing a dynamic link, we create a .rel.got 		       relocation entry to initialize the value.  This 		       is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 8.  We use 		   the least significant bit to record whether we have 		   already processed this entry.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* We need to generate a R_PPC64_RELATIVE reloc 			   for the dynamic linker.  */
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|relocation
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
comment|/* TOC base (r2) is TOC start plus 0x8000.  */
name|addend
operator|-=
name|TOC_BASE_OFF
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
comment|/* Resolve a PLT reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|htab
operator|->
name|splt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
break|break;
block|}
name|relocation
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
break|break;
comment|/* TOC16 relocs.  We want the offset relative to the TOC base, 	     which is the address of the start of the TOC plus 0x8000. 	     The TOC consists of sections .got, .toc, .tocbss, and .plt, 	     in this order.  */
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
name|addend
operator|-=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
break|break;
comment|/* Relocate against the beginning of the section.  */
case|case
name|R_PPC64_SECTOFF
case|:
case|case
name|R_PPC64_SECTOFF_LO
case|:
case|case
name|R_PPC64_SECTOFF_HI
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
if|if
condition|(
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
literal|0
condition|)
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL24
case|:
break|break;
comment|/* Relocations that may need to be propagated if this is a 	     dynamic object.  */
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL64
case|:
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR30
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_ADDR64
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
comment|/* r_symndx will be zero only for relocs against symbols 	     from removed linkonce sections, or sections discarded by 	     a linker script.  */
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
break|break;
comment|/* Fall thru.  */
case|case
name|R_PPC64_TOC
case|:
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|NO_OPD_RELOCS
operator|&&
name|is_opd
condition|)
break|break;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* When generating a dynamic object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
name|skip
operator|=
name|false
expr_stmt|;
name|relocate
operator|=
name|false
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|true
operator|,
name|relocate
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|is_opd
operator|&&
operator|(
operator|!
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This symbol is local, or marked to become local, 		     or this is an opd section reloc which must point 		     at a local function.  */
name|outrel
operator|.
name|r_addend
operator|+=
name|relocation
expr_stmt|;
name|relocate
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_ADDR64
operator|||
name|r_type
operator|==
name|R_PPC64_TOC
condition|)
block|{
if|if
condition|(
name|is_opd
operator|&&
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Lie about opd entries.  This case occurs 			     when building shared libraries and we 			     reference a function in another shared 			     lib.  The same thing happens for a weak 			     definition in an application that's 			     overridden by a strong definition in a 			     shared lib.  (I believe this is a generic 			     bug in binutils handling of weak syms.) 			     In these cases we won't use the opd 			     entry in this lib.  */
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
comment|/* We are turning this relocation into one 			     against a section symbol, so subtract out 			     the output section's address but not the 			     offset of the input section in the output 			     section.  */
name|outrel
operator|.
name|r_addend
operator|-=
name|osec
operator|->
name|vma
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an external symbol, it will 		 be computed at runtime, so there's no need to do 		 anything now.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
break|break;
case|case
name|R_PPC64_COPY
case|:
case|case
name|R_PPC64_GLOB_DAT
case|:
case|case
name|R_PPC64_JMP_SLOT
case|:
case|case
name|R_PPC64_RELATIVE
case|:
comment|/* We shouldn't ever see these dynamic relocs in relocatable 	     files.  */
comment|/* Fall thru */
case|case
name|R_PPC64_PLTGOT16
case|:
case|case
name|R_PPC64_PLTGOT16_DS
case|:
case|case
name|R_PPC64_PLTGOT16_HA
case|:
case|case
name|R_PPC64_PLTGOT16_HI
case|:
case|case
name|R_PPC64_PLTGOT16_LO
case|:
case|case
name|R_PPC64_PLTGOT16_LO_DS
case|:
case|case
name|R_PPC64_PLTREL32
case|:
case|case
name|R_PPC64_PLTREL64
case|:
comment|/* These ones haven't been implemented yet.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Relocation %s is not supported for symbol %s."
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
comment|/* Do any further special processing.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
comment|/* It's just possible that this symbol is a weak symbol 	     that's not actually defined anywhere. In that case, 	     'sec' would be NULL, and we should leave the symbol 	     alone (it will be set to zero elsewhere in the link).  */
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
comment|/* Add 0x10000 if sign bit in 0:15 is set.  */
name|addend
operator|+=
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|)
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
case|case
name|R_PPC64_PLT16_LO_DS
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
case|case
name|R_PPC64_PLTGOT16_DS
case|:
case|case
name|R_PPC64_PLTGOT16_LO_DS
case|:
if|if
condition|(
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: error: relocation %s not a multiple of 4"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
name|max_br_offset
operator|=
literal|1
operator|<<
literal|15
expr_stmt|;
goto|goto
name|branch_check
goto|;
case|case
name|R_PPC64_REL24
case|:
name|max_br_offset
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
name|branch_check
label|:
comment|/* If the branch is out of reach, then redirect the 	     call to the local stub for this function.  */
name|from
operator|=
operator|(
name|offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|relocation
operator|+
name|addend
operator|-
name|from
operator|+
name|max_br_offset
operator|>=
literal|2
operator|*
name|max_br_offset
operator|&&
operator|(
name|stub_entry
operator|=
name|ppc_get_stub_entry
argument_list|(
name|input_section
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
name|htab
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Munge up the value and addend so that we call the stub 		 rather than the procedure directly.  */
name|relocation
operator|=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): unresolvable relocation against symbol `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|pc_relative
condition|)
block|{
comment|/* Assume this is a call protected by other code that 		     detects the symbol is undefined.  If this is the case, 		     we can safely ignore the overflow.  If not, the 		     program is hosed anyway, and a little warning isn't 		     going to help.  */
continue|continue;
block|}
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
if|if
condition|(
name|warned
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): reloc against `%s': error %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  */
if|if
condition|(
name|htab
operator|->
name|splt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|srelplt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sglink
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a JMP_SLOT reloc to inform the dynamic linker to 	 fill in the PLT entry.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelplt
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it 	 up.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
operator|||
name|htab
operator|->
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a static link, or it is a -Bsymbolic link and the 	 symbol is defined locally or was forced to be local because 	 of a version file, we just want to emit a RELATIVE reloc. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_GLOB_DAT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|||
name|htab
operator|->
name|srelbss
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelbss
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelbss
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Used to decide how to sort relocs in an optimal manner for the    dynamic linker, before writing them out.  */
end_comment

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|ppc64_elf_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_PPC64_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_PPC64_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|Elf64_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf64_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
continue|continue;
case|case
name|DT_PPC64_GLINK
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|htab
operator|->
name|sglink
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sglink
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|DT_PPC64_OPD
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_PPC64_OPDSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|htab
operator|->
name|srelplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|srelplt
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* Don't count procedure linkage table relocs in the 		 overall reloc count.  */
if|if
condition|(
name|htab
operator|->
name|srelplt
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|htab
operator|->
name|srelplt
operator|->
name|_raw_size
expr_stmt|;
break|break;
block|}
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|sgot
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|sgot
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Fill in the first entry in the global offset table. 	 We use it to hold the link-time TOCbase.  */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|TOC_BASE_OFF
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* Set .got entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Set .plt entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_powerpcle_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-powerpcle"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_powerpc_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-powerpc"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_powerpc
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PPC64
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|ppc64_elf_info_to_howto
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|EM_CYGNUS_POWERPC
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_CYGNUS_POWERPC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EM_PPC_OLD
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT2
value|EM_PPC_OLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_backend_want_got_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_alignment
value|3
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_not_loaded
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_symbol_offset
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|8
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|PLT_INITIAL_ENTRY_SIZE
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
value|ppc64_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_merge_private_bfd_data
value|ppc64_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
value|ppc64_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_free
value|ppc64_elf_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|ppc64_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|ppc64_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|ppc64_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|ppc64_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|ppc64_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|ppc64_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|ppc64_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|ppc64_elf_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
value|ppc64_elf_func_desc_adjust
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|ppc64_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|ppc64_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|ppc64_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|ppc64_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|ppc64_elf_finish_dynamic_sections
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

