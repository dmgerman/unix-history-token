begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* PowerPC64-specific support for 64-bit ELF.    Copyright 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Written by Linus Nordberg, Swox AB<info@swox.com>,    based on elf32-ppc.c by Ian Lance Taylor.    Largely rewritten by Alan Modra<amodra@bigpond.net.au>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* The 64-bit PowerPC ELF ABI may be found at    http://www.linuxbase.org/spec/ELF/ppc64/PPC-elf64abi.txt, and    http://www.linuxbase.org/spec/ELF/ppc64/spec/book1.html  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc64.h"
end_include

begin_include
include|#
directive|include
file|"elf64-ppc.h"
end_include

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_ha_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_brtaken_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_ha_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_ha_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc64_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_unhandled_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_powerpcle_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-powerpcle"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_powerpc_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-powerpc"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_powerpc
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PPC64
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|ppc64_elf_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_alignment
value|3
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_not_loaded
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_symbol_offset
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|8
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf64_mkobject
value|ppc64_elf_mkobject
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
value|ppc64_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_merge_private_bfd_data
value|ppc64_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf64_new_section_hook
value|ppc64_elf_new_section_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
value|ppc64_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_free
value|ppc64_elf_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|ppc64_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|ppc64_elf_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|ppc64_elf_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|ppc64_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|ppc64_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|ppc64_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|ppc64_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|ppc64_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|ppc64_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|ppc64_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|ppc64_elf_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
value|ppc64_elf_func_desc_adjust
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|ppc64_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|ppc64_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|ppc64_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|ppc64_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|ppc64_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
value|ppc64_elf_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|ppc64_elf_special_sections
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|24
end_define

begin_comment
comment|/* The initial size of the plt reserved for the dynamic linker.  */
end_comment

begin_define
define|#
directive|define
name|PLT_INITIAL_ENTRY_SIZE
value|PLT_ENTRY_SIZE
end_define

begin_comment
comment|/* TOC base pointers offset from start of TOC.  */
end_comment

begin_define
define|#
directive|define
name|TOC_BASE_OFF
value|0x8000
end_define

begin_comment
comment|/* Offset of tp and dtp pointers from start of TLS block.  */
end_comment

begin_define
define|#
directive|define
name|TP_OFFSET
value|0x7000
end_define

begin_define
define|#
directive|define
name|DTP_OFFSET
value|0x8000
end_define

begin_comment
comment|/* .plt call stub instructions.  The normal stub is like this, but    sometimes the .plt entry crosses a 64k boundary and we need to    insert an addis to adjust r12.  */
end_comment

begin_define
define|#
directive|define
name|PLT_CALL_STUB_SIZE
value|(7*4)
end_define

begin_define
define|#
directive|define
name|ADDIS_R12_R2
value|0x3d820000
end_define

begin_comment
comment|/* addis %r12,%r2,xxx@ha     */
end_comment

begin_define
define|#
directive|define
name|STD_R2_40R1
value|0xf8410028
end_define

begin_comment
comment|/* std	 %r2,40(%r1)	     */
end_comment

begin_define
define|#
directive|define
name|LD_R11_0R12
value|0xe96c0000
end_define

begin_comment
comment|/* ld	 %r11,xxx+0@l(%r12)  */
end_comment

begin_define
define|#
directive|define
name|LD_R2_0R12
value|0xe84c0000
end_define

begin_comment
comment|/* ld	 %r2,xxx+8@l(%r12)   */
end_comment

begin_define
define|#
directive|define
name|MTCTR_R11
value|0x7d6903a6
end_define

begin_comment
comment|/* mtctr %r11		     */
end_comment

begin_comment
comment|/* ld	 %r11,xxx+16@l(%r12) */
end_comment

begin_define
define|#
directive|define
name|BCTR
value|0x4e800420
end_define

begin_comment
comment|/* bctr			     */
end_comment

begin_define
define|#
directive|define
name|ADDIS_R2_R2
value|0x3c420000
end_define

begin_comment
comment|/* addis %r2,%r2,off@ha  */
end_comment

begin_define
define|#
directive|define
name|ADDI_R2_R2
value|0x38420000
end_define

begin_comment
comment|/* addi  %r2,%r2,off@l   */
end_comment

begin_define
define|#
directive|define
name|LD_R2_40R1
value|0xe8410028
end_define

begin_comment
comment|/* ld    %r2,40(%r1)     */
end_comment

begin_comment
comment|/* glink call stub instructions.  We enter with the index in R0, and the    address of glink entry in CTR.  From that, we can calculate PLT0.  */
end_comment

begin_define
define|#
directive|define
name|GLINK_CALL_STUB_SIZE
value|(16*4)
end_define

begin_define
define|#
directive|define
name|MFCTR_R12
value|0x7d8902a6
end_define

begin_comment
comment|/* mfctr  %r12			*/
end_comment

begin_define
define|#
directive|define
name|SLDI_R11_R0_3
value|0x780b1f24
end_define

begin_comment
comment|/* sldi	  %r11,%r0,3		*/
end_comment

begin_define
define|#
directive|define
name|ADDIC_R2_R0_32K
value|0x34408000
end_define

begin_comment
comment|/* addic. %r2,%r0,-32768	*/
end_comment

begin_define
define|#
directive|define
name|SUB_R12_R12_R11
value|0x7d8b6050
end_define

begin_comment
comment|/* sub	  %r12,%r12,%r11	*/
end_comment

begin_define
define|#
directive|define
name|SRADI_R2_R2_63
value|0x7c42fe76
end_define

begin_comment
comment|/* sradi  %r2,%r2,63		*/
end_comment

begin_define
define|#
directive|define
name|SLDI_R11_R0_2
value|0x780b1764
end_define

begin_comment
comment|/* sldi	  %r11,%r0,2		*/
end_comment

begin_define
define|#
directive|define
name|AND_R2_R2_R11
value|0x7c425838
end_define

begin_comment
comment|/* and	  %r2,%r2,%r11		*/
end_comment

begin_comment
comment|/* sub	  %r12,%r12,%r11	*/
end_comment

begin_define
define|#
directive|define
name|ADD_R12_R12_R2
value|0x7d8c1214
end_define

begin_comment
comment|/* add	  %r12,%r12,%r2		*/
end_comment

begin_define
define|#
directive|define
name|ADDIS_R12_R12
value|0x3d8c0000
end_define

begin_comment
comment|/* addis  %r12,%r12,xxx@ha	*/
end_comment

begin_comment
comment|/* ld	  %r11,xxx@l(%r12)	*/
end_comment

begin_define
define|#
directive|define
name|ADDI_R12_R12
value|0x398c0000
end_define

begin_comment
comment|/* addi	  %r12,%r12,xxx@l	*/
end_comment

begin_comment
comment|/* ld	  %r2,8(%r12)		*/
end_comment

begin_comment
comment|/* mtctr  %r11			*/
end_comment

begin_comment
comment|/* ld	  %r11,16(%r12)		*/
end_comment

begin_comment
comment|/* bctr				*/
end_comment

begin_comment
comment|/* Pad with this.  */
end_comment

begin_define
define|#
directive|define
name|NOP
value|0x60000000
end_define

begin_comment
comment|/* Some other nops.  */
end_comment

begin_define
define|#
directive|define
name|CROR_151515
value|0x4def7b82
end_define

begin_define
define|#
directive|define
name|CROR_313131
value|0x4ffffb82
end_define

begin_comment
comment|/* .glink entries for the first 32k functions are two instructions.  */
end_comment

begin_define
define|#
directive|define
name|LI_R0_0
value|0x38000000
end_define

begin_comment
comment|/* li    %r0,0		*/
end_comment

begin_define
define|#
directive|define
name|B_DOT
value|0x48000000
end_define

begin_comment
comment|/* b     .		*/
end_comment

begin_comment
comment|/* After that, we need two instructions to load the index, followed by    a branch.  */
end_comment

begin_define
define|#
directive|define
name|LIS_R0_0
value|0x3c000000
end_define

begin_comment
comment|/* lis   %r0,0		*/
end_comment

begin_define
define|#
directive|define
name|ORI_R0_R0_0
value|0x60000000
end_define

begin_comment
comment|/* ori	 %r0,%r0,0	*/
end_comment

begin_comment
comment|/* Instructions to save and restore floating point regs.  */
end_comment

begin_define
define|#
directive|define
name|STFD_FR0_0R1
value|0xd8010000
end_define

begin_comment
comment|/* stfd  %fr0,0(%r1)	*/
end_comment

begin_define
define|#
directive|define
name|LFD_FR0_0R1
value|0xc8010000
end_define

begin_comment
comment|/* lfd   %fr0,0(%r1)	*/
end_comment

begin_define
define|#
directive|define
name|BLR
value|0x4e800020
end_define

begin_comment
comment|/* blr			*/
end_comment

begin_comment
comment|/* Since .opd is an array of descriptors and each entry will end up    with identical R_PPC64_RELATIVE relocs, there is really no need to    propagate .opd relocs;  The dynamic linker should be taught to    relocate .opd without reloc entries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPD_RELOCS
end_ifndef

begin_define
define|#
directive|define
name|NO_OPD_RELOCS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_define
define|#
directive|define
name|ONES
parameter_list|(
name|n
parameter_list|)
value|(((bfd_vma) 1<< ((n) - 1)<< 1) - 1)
end_define

begin_comment
comment|/* Relocation HOWTO's.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_PPC64_max
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ppc64_elf_howto_raw
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_PPC64_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 26 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relocation without overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Bits 16-31 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Bits 16-31 of an address, plus 1 if the contents of the low 16      bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is expected to be taken.  The lower two      bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14_BRTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is not expected to be taken.  The lower      two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14_BRNTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 26 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is expected to be taken.  The lower two bits must be      zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14_BRTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is not expected to be taken.  The lower two bits must      be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_brtaken_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14_BRNTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000fffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but referring to the GOT table entry for the      symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HI, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HA, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This is used only by the dynamic linker.  The symbol should exist      both in the object being run and in some shared library.  The      dynamic linker copies the data addressed by the symbol from the      shared library into the object, because the object being      run has to have the data at some particular address.  */
name|HOWTO
argument_list|(
name|R_PPC64_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* this one is variable size */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_COPY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR64, but used when setting global offset table      entries.  */
name|HOWTO
argument_list|(
name|R_PPC64_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GLOB_DAT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Created by the link editor.  Marks a procedure linkage table      entry for a symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_JMP_SLOT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used only by the dynamic linker.  When the object is run, this      doubleword64 is set to the load address of the object, plus the      addend.  */
name|HOWTO
argument_list|(
name|R_PPC64_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_RELATIVE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR32, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
comment|/* FIXME: Verify.  Was complain_overflow_bitfield.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit relocation to the symbol's procedure linkage table.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative relocation to the symbol's procedure linkage table.      FIXME: R_PPC64_PLTREL32 not supported.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HI, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HA, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF, but no overflow warning.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half adjusted section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_REL24 without touching the two least significant bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL30
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|30
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL30"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocs in the 64-bit PowerPC ELF ABI, not in the 32-bit ABI.  */
comment|/* A standard 64-bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 32-47 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHER
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHER"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 32-47 of an address, plus 1 if the contents of the low      16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHERA
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHERA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 48-63 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHEST
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHEST"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 48-63 of an address, plus 1 if the contents of the low      16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHESTA
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHESTA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like ADDR64, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relocation to the symbol's procedure linkage table.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit PC relative relocation to the symbol's procedure linkage      table.  */
comment|/* FIXME: R_PPC64_PLTREL64 not supported.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTREL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTREL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation.  */
comment|/* R_PPC64_TOC16	  47	   half16*	S + A - .TOC.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation without overflow.  */
comment|/* R_PPC64_TOC16_LO	  48	   half16	 #lo (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation, high 16 bits.  */
comment|/* R_PPC64_TOC16_HI	  49	   half16	 #hi (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation, high 16 bits, plus 1 if the      contents of the low 16 bits, treated as a signed number, is      negative.  */
comment|/* R_PPC64_TOC16_HA	  50	   half16	 #ha (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relocation; insert value of TOC base (.TOC.).  */
comment|/* R_PPC64_TOC		  51	   doubleword64	 .TOC.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc64_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16, but also informs the link editor that the      value to relocate may (!) refer to a PLT entry which the link      editor (a) may replace with the symbol value.  If the link editor      is unable to fully resolve the symbol, it may (b) create a PLT      entry and store the address to the new PLT entry in the GOT.      This permits lazy resolution of function symbols at run time.      The link editor may also skip all of this and just (c) emit a      R_PPC64_GLOB_DAT to tie the symbol to the GOT entry.  */
comment|/* FIXME: R_PPC64_PLTGOT16 not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16, but without overflow.  */
comment|/* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address.  */
comment|/* FIXME: R_PPC64_PLTGOT16_HI not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address, plus      1 if the contents of the low 16 bits, treated as a signed number,      is negative.  */
comment|/* FIXME: R_PPC64_PLTGOT16_HA not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_sectoff_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_TOC16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_TOC16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_toc_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16, but for instructions with a DS field.  */
comment|/* FIXME: R_PPC64_PLTGOT16_DS not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16_LO, but for instructions with a DS field.  */
comment|/* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Marker reloc for TLS.  */
name|HOWTO
argument_list|(
name|R_PPC64_TLS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TLS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes the load module index of the load module that contains the      definition of its TLS sym.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPMOD64
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPMOD64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes a dtv-relative displacement, the difference between the value      of sym+add and the base address of the thread-local storage block that      contains the definition of sym, minus 0x8000.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL64
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit dtprel reloc.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HI, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HIGHER
argument_list|,
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HIGHER"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HIGHER, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HIGHERA
argument_list|,
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HIGHERA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HIGHER, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HIGHEST
argument_list|,
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HIGHEST"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HIGHEST, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_HIGHESTA
argument_list|,
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_HIGHESTA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16, but for insns with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_DS, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_DTPREL16_LO_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_DTPREL16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes a tp-relative displacement, the difference between the value of      sym+add and the value of the thread pointer (r13).  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL64
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|ONES
argument_list|(
literal|64
argument_list|)
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit tprel reloc.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HI, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HIGHER
argument_list|,
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HIGHER"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HIGHER, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HIGHERA
argument_list|,
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HIGHERA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HIGHER, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HIGHEST
argument_list|,
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HIGHEST"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HIGHEST, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_HIGHESTA
argument_list|,
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_HIGHESTA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16, but for insns with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_DS, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_TPREL16_LO_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TPREL16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates two contiguous entries in the GOT to hold a tls_index structure,      with values (sym+add)@dtpmod and (sym+add)@dtprel, and computes the offset      to the first entry relative to the TOC base (r2).  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSGD16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSGD16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSGD16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSGD16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSGD16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSGD16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSGD16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSGD16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates two contiguous entries in the GOT to hold a tls_index structure,      with values (sym+add)@dtpmod and zero, and computes the offset to the      first entry relative to the TOC base (r2).  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSLD16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSLD16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSLD16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSLD16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSLD16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSLD16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TLSLD16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TLSLD16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates an entry in the GOT with value (sym+add)@dtprel, and computes      the offset to the entry relative to the TOC base (r2).  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_DTPREL16_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_DTPREL16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_DS, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_DTPREL16_LO_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_DTPREL16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_LO_DS, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_DTPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_DTPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_DTPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_DTPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates an entry in the GOT with value (sym+add)@tprel, and computes the      offset to the entry relative to the TOC base (r2).  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TPREL16_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TPREL16_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_DS, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TPREL16_LO_DS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TPREL16_LO_DS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_LO_DS, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT_TPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT_TPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_PPC64_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_PPC64_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the ppc64_elf_howto_table, so that linear accesses can    be done.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_howto_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ppc64_elf_howto_raw
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ppc64_elf_howto_table
index|[
name|type
index|]
operator|=
operator|&
name|ppc64_elf_howto_raw
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r
init|=
name|R_PPC64_NONE
decl_stmt|;
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
comment|/* Initialize howto table if needed.  */
name|ppc_howto_init
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_NONE
case|:
name|r
operator|=
name|R_PPC64_NONE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|r
operator|=
name|R_PPC64_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA26
case|:
name|r
operator|=
name|R_PPC64_ADDR24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|r
operator|=
name|R_PPC64_ADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|r
operator|=
name|R_PPC64_ADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16
case|:
name|r
operator|=
name|R_PPC64_ADDR14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRTAKEN
case|:
name|r
operator|=
name|R_PPC64_ADDR14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRNTAKEN
case|:
name|r
operator|=
name|R_PPC64_ADDR14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B26
case|:
name|r
operator|=
name|R_PPC64_REL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16
case|:
name|r
operator|=
name|R_PPC64_REL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRTAKEN
case|:
name|r
operator|=
name|R_PPC64_REL14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRNTAKEN
case|:
name|r
operator|=
name|R_PPC64_REL14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_GOTOFF
case|:
name|r
operator|=
name|R_PPC64_GOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_GOTOFF
case|:
name|r
operator|=
name|R_PPC64_GOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_GOTOFF
case|:
name|r
operator|=
name|R_PPC64_GOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_GOTOFF
case|:
name|r
operator|=
name|R_PPC64_GOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_COPY
case|:
name|r
operator|=
name|R_PPC64_COPY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GLOB_DAT
case|:
name|r
operator|=
name|R_PPC64_GLOB_DAT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|r
operator|=
name|R_PPC64_REL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
name|r
operator|=
name|R_PPC64_PLTREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_BASEREL
case|:
name|r
operator|=
name|R_PPC64_SECTOFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_BASEREL
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_BASEREL
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_BASEREL
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CTOR
case|:
name|r
operator|=
name|R_PPC64_ADDR64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
name|r
operator|=
name|R_PPC64_ADDR64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHER
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HIGHER
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHER_S
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HIGHERA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHEST
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HIGHEST
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHEST_S
case|:
name|r
operator|=
name|R_PPC64_ADDR16_HIGHESTA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PCREL
case|:
name|r
operator|=
name|R_PPC64_REL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PLTOFF
case|:
name|r
operator|=
name|R_PPC64_PLT64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PLT_PCREL
case|:
name|r
operator|=
name|R_PPC64_PLTREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
name|r
operator|=
name|R_PPC64_TOC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_LO
case|:
name|r
operator|=
name|R_PPC64_TOC16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_HI
case|:
name|r
operator|=
name|R_PPC64_TOC16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_HA
case|:
name|r
operator|=
name|R_PPC64_TOC16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC
case|:
name|r
operator|=
name|R_PPC64_TOC
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_LO
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_HI
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_HA
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_ADDR16_DS
case|:
name|r
operator|=
name|R_PPC64_ADDR16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_ADDR16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_ADDR16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_GOT16_DS
case|:
name|r
operator|=
name|R_PPC64_GOT16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_GOT16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_GOT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLT16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_PLT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_SECTOFF_DS
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_SECTOFF_LO_DS
case|:
name|r
operator|=
name|R_PPC64_SECTOFF_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_DS
case|:
name|r
operator|=
name|R_PPC64_TOC16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_TOC16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_DS
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_PLTGOT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TLS
case|:
name|r
operator|=
name|R_PPC64_TLS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPMOD
case|:
name|r
operator|=
name|R_PPC64_DTPMOD64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16
case|:
name|r
operator|=
name|R_PPC64_TPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_LO
case|:
name|r
operator|=
name|R_PPC64_TPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_HI
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_HA
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL
case|:
name|r
operator|=
name|R_PPC64_TPREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16
case|:
name|r
operator|=
name|R_PPC64_DTPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_LO
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_HI
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_HA
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL
case|:
name|r
operator|=
name|R_PPC64_DTPREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSGD16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_LO
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSGD16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_HI
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSGD16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_HA
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSGD16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSLD16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_LO
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSLD16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_HI
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSLD16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_HA
case|:
name|r
operator|=
name|R_PPC64_GOT_TLSLD16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16
case|:
name|r
operator|=
name|R_PPC64_GOT_TPREL16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_LO
case|:
name|r
operator|=
name|R_PPC64_GOT_TPREL16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_HI
case|:
name|r
operator|=
name|R_PPC64_GOT_TPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_HA
case|:
name|r
operator|=
name|R_PPC64_GOT_TPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16
case|:
name|r
operator|=
name|R_PPC64_GOT_DTPREL16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_LO
case|:
name|r
operator|=
name|R_PPC64_GOT_DTPREL16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_HI
case|:
name|r
operator|=
name|R_PPC64_GOT_DTPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_HA
case|:
name|r
operator|=
name|R_PPC64_GOT_DTPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_DS
case|:
name|r
operator|=
name|R_PPC64_TPREL16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_TPREL16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_HIGHER
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HIGHER
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_HIGHERA
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HIGHERA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_HIGHEST
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HIGHEST
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TPREL16_HIGHESTA
case|:
name|r
operator|=
name|R_PPC64_TPREL16_HIGHESTA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_DS
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_LO_DS
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_HIGHER
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HIGHER
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_HIGHERA
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HIGHERA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_HIGHEST
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HIGHEST
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_DTPREL16_HIGHESTA
case|:
name|r
operator|=
name|R_PPC64_DTPREL16_HIGHESTA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|r
operator|=
name|R_PPC64_GNU_VTINHERIT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|r
operator|=
name|R_PPC64_GNU_VTENTRY
expr_stmt|;
break|break;
block|}
return|return
name|ppc64_elf_howto_table
index|[
name|r
index|]
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Set the howto pointer for a PowerPC ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|type
decl_stmt|;
comment|/* Initialize howto table if needed.  */
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
name|ppc_howto_init
argument_list|()
expr_stmt|;
name|type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|ppc64_elf_howto_table
index|[
name|type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the R_PPC64_ADDR16_HA and similar relocs.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_ha_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
comment|/* Adjust the addend for sign extension of the low 16 bits.      We won't actually be using the low 16 bits, so trashing them      doesn't matter.  */
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_brtaken_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|long
name|insn
decl_stmt|;
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|bfd_size_type
name|octets
decl_stmt|;
comment|/* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
name|bfd_boolean
name|is_power4
init|=
name|FALSE
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|octets
operator|=
name|reloc_entry
operator|->
name|address
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
name|insn
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
literal|21
operator|)
expr_stmt|;
name|r_type
operator|=
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_ADDR14_BRTAKEN
operator|||
name|r_type
operator|==
name|R_PPC64_REL14_BRTAKEN
condition|)
name|insn
operator||=
literal|0x01
operator|<<
literal|21
expr_stmt|;
comment|/* 'y' or 't' bit, lowest bit of BO field.  */
if|if
condition|(
name|is_power4
condition|)
block|{
comment|/* Set 'a' bit.  This is 0b00010 in BO field for branch 	 on CR(BI) insns (BO == 001at or 011at), and 0b01000 	 for branch on CTR insns (BO == 1a00t or 1a01t).  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x04
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x02
operator|<<
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x10
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x08
operator|<<
literal|21
expr_stmt|;
else|else
return|return
name|bfd_reloc_continue
return|;
block|}
else|else
block|{
name|bfd_vma
name|target
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|from
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|target
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|target
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|target
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|target
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|from
operator|=
operator|(
name|reloc_entry
operator|->
name|address
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Invert 'y' bit if not the default.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|target
operator|-
name|from
argument_list|)
operator|<
literal|0
condition|)
name|insn
operator|^=
literal|0x01
operator|<<
literal|21
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
comment|/* Subtract the symbol section base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_sectoff_ha_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
comment|/* Subtract the symbol section base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* Adjust the addend for sign extension of the low 16 bits.  */
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|TOCstart
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOCstart
operator|==
literal|0
condition|)
name|TOCstart
operator|=
name|ppc64_elf_toc
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
comment|/* Subtract the TOC base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc_ha_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|TOCstart
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOCstart
operator|==
literal|0
condition|)
name|TOCstart
operator|=
name|ppc64_elf_toc
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
comment|/* Subtract the TOC base address.  */
name|reloc_entry
operator|->
name|addend
operator|-=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
comment|/* Adjust the addend for sign extension of the low 16 bits.  */
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_toc64_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|TOCstart
decl_stmt|;
name|bfd_size_type
name|octets
decl_stmt|;
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|TOCstart
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOCstart
operator|==
literal|0
condition|)
name|TOCstart
operator|=
name|ppc64_elf_toc
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|octets
operator|=
name|reloc_entry
operator|->
name|address
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|TOCstart
operator|+
name|TOC_BASE_OFF
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|octets
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_unhandled_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
if|if
condition|(
name|error_message
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"generic linker can't handle %s"
argument_list|,
name|reloc_entry
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|error_message
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|bfd_reloc_dangerous
return|;
block|}
end_function

begin_struct
struct|struct
name|ppc64_elf_obj_tdata
block|{
name|struct
name|elf_obj_tdata
name|elf
decl_stmt|;
comment|/* Shortcuts to dynamic linker sections.  */
name|asection
modifier|*
name|got
decl_stmt|;
name|asection
modifier|*
name|relgot
decl_stmt|;
comment|/* TLS local dynamic got entry handling.  Suppose for multiple GOT      sections means we potentially need one of these for each input bfd.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|tlsld_got
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ppc64_elf_tdata
parameter_list|(
name|bfd
parameter_list|)
define|\
value|((struct ppc64_elf_obj_tdata *) (bfd)->tdata.any)
end_define

begin_define
define|#
directive|define
name|ppc64_tlsld_got
parameter_list|(
name|bfd
parameter_list|)
define|\
value|(&ppc64_elf_tdata (bfd)->tlsld_got)
end_define

begin_comment
comment|/* Override the generic function because we store some extras.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppc64_elf_obj_tdata
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Fix bad default arch selected for a 64 bit input bfd when the    default is 32 bit.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|arch_info
operator|->
name|the_default
operator|&&
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|32
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdr
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|i_ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
block|{
comment|/* Relies on arch after 32 bit default being 64 bit default.  */
name|abfd
operator|->
name|arch_info
operator|=
name|abfd
operator|->
name|arch_info
operator|->
name|next
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|size_t
name|offset
decl_stmt|,
name|raw_size
decl_stmt|;
if|if
condition|(
name|note
operator|->
name|descsz
operator|!=
literal|504
condition|)
return|return
name|FALSE
return|;
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|112
expr_stmt|;
name|raw_size
operator|=
literal|384
expr_stmt|;
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|raw_size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
if|if
condition|(
name|note
operator|->
name|descsz
operator|!=
literal|136
condition|)
return|return
name|FALSE
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|40
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|56
argument_list|,
literal|80
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
comment|/* Check if we have the same endianess.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|&&
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
operator|&&
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|ibfd
argument_list|)
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled for a big endian system "
literal|"and target is little endian"
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled for a little endian system "
literal|"and target is big endian"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|msg
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add extra PPC sections.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
specifier|const
name|ppc64_elf_special_sections
index|[]
init|=
block|{
block|{
literal|".sdata"
block|,
literal|6
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".sbss"
block|,
literal|5
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".plt"
block|,
literal|4
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
literal|0
block|}
block|,
block|{
literal|".toc"
block|,
literal|4
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".toc1"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".tocbss"
block|,
literal|7
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|_ppc64_elf_section_data
block|{
name|struct
name|bfd_elf_section_data
name|elf
decl_stmt|;
comment|/* An array with one entry for each opd function descriptor.  */
union|union
block|{
comment|/* Points to the function code section for local opd entries.  */
name|asection
modifier|*
modifier|*
name|func_sec
decl_stmt|;
comment|/* After editing .opd, adjust references to opd local syms.  */
name|long
modifier|*
name|adjust
decl_stmt|;
block|}
name|opd
union|;
comment|/* An array for toc sections, indexed by offset/8.      Specifies the relocation symbol index used at a given toc offset.  */
name|unsigned
modifier|*
name|t_symndx
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ppc64_elf_section_data
parameter_list|(
name|sec
parameter_list|)
define|\
value|((struct _ppc64_elf_section_data *) elf_section_data (sec))
end_define

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|_ppc64_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are specific to the ELF linker, while    functions above are used generally.  Those named ppc64_elf_* are    called by the main ELF linker code.  They appear in this file more    or less in the order in which they are called.  eg.    ppc64_elf_check_relocs is called early in the link process,    ppc64_elf_finish_dynamic_sections is one of the last functions    called.     PowerPC64-ELF uses a similar scheme to PowerPC64-XCOFF in that    functions have both a function code symbol and a function descriptor    symbol.  A call to foo in a relocatable object file looks like:     .		.text    .	x:    .		bl	.foo    .		nop     The function definition in another object file might be:     .		.section .opd    .	foo:	.quad	.foo    .		.quad	.TOC.@tocbase    .		.quad	0    .    .		.text    .	.foo:	blr     When the linker resolves the call during a static link, the branch    unsurprisingly just goes to .foo and the .opd information is unused.    If the function definition is in a shared library, things are a little    different:  The call goes via a plt call stub, the opd information gets    copied to the plt, and the linker patches the nop.     .	x:    .		bl	.foo_stub    .		ld	2,40(1)    .    .    .	.foo_stub:    .		addis	12,2,Lfoo@toc@ha	# in practice, the call stub    .		addi	12,12,Lfoo@toc@l	# is slightly optimized, but    .		std	2,40(1)			# this is the general idea    .		ld	11,0(12)    .		ld	2,8(12)    .		mtctr	11    .		ld	11,16(12)    .		bctr    .    .		.section .plt    .	Lfoo:	reloc (R_PPC64_JMP_SLOT, foo)     The "reloc ()" notation is supposed to indicate that the linker emits    an R_PPC64_JMP_SLOT reloc against foo.  The dynamic linker does the opd    copying.     What are the difficulties here?  Well, firstly, the relocations    examined by the linker in check_relocs are against the function code    sym .foo, while the dynamic relocation in the plt is emitted against    the function descriptor symbol, foo.  Somewhere along the line, we need    to carefully copy dynamic link information from one symbol to the other.    Secondly, the generic part of the elf linker will make .foo a dynamic    symbol as is normal for most other backends.  We need foo dynamic    instead, at least for an application final link.  However, when    creating a shared library containing foo, we need to have both symbols    dynamic so that references to .foo are satisfied during the early    stages of linking.  Otherwise the linker might decide to pull in a    definition from some other object, eg. a static library.  */
end_comment

begin_comment
comment|/* The linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_dyn_relocs
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Track GOT entries needed for a given symbol.  We might need more    than one got entry per symbol.  */
end_comment

begin_struct
struct|struct
name|got_entry
block|{
name|struct
name|got_entry
modifier|*
name|next
decl_stmt|;
comment|/* The symbol addend that we'll be placing in the GOT.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* Unlike other ELF targets, we use separate GOT entries for the same      symbol referenced from different input files.  This is to support      automatic multiple TOC/GOT sections, where the TOC base can vary      from one input file to another.       Point to the BFD owning this GOT entry.  */
name|bfd
modifier|*
name|owner
decl_stmt|;
comment|/* Zero for non-tls entries, or TLS_TLS and one of TLS_GD, TLS_LD,      TLS_TPREL or TLS_DTPREL for tls entries.  */
name|char
name|tls_type
decl_stmt|;
comment|/* Reference count until size_dynamic_sections, GOT offset thereafter.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|got
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The same for PLT.  */
end_comment

begin_struct
struct|struct
name|plt_entry
block|{
name|struct
name|plt_entry
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|plt
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Of those relocs that might be copied as dynamic relocs, this macro    selects those that must be copied when linking a shared library,    even when the symbol is local.  */
end_comment

begin_define
define|#
directive|define
name|MUST_BE_DYN_RELOC
parameter_list|(
name|RTYPE
parameter_list|)
define|\
value|((RTYPE) != R_PPC64_REL32			\&& (RTYPE) != R_PPC64_REL64			\&& (RTYPE) != R_PPC64_REL30)
end_define

begin_comment
comment|/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid    copying dynamic variables from a shared lib into an app's dynbss    section, and instead use a dynamic relocation to point into the    shared lib.  With code that gcc generates, it's vital that this be    enabled;  In the PowerPC64 ABI, the address of a function is actually    the address of a function descriptor, which resides in the .opd    section.  gcc uses the descriptor directly rather than going via the    GOT as some other ABI's do, which means that initialized function    pointers must reference the descriptor.  Thus, a function pointer    initialized to the address of a function in a shared library will    either require a copy reloc, or a dynamic reloc.  Using a copy reloc    redefines the function descriptor symbol to point to the copy.  This    presents a problem as a plt entry for that function is also    initialized from the function descriptor symbol and the copy reloc    may not be initialized first.  */
end_comment

begin_define
define|#
directive|define
name|ELIMINATE_COPY_RELOCS
value|1
end_define

begin_comment
comment|/* Section name for stubs is the associated section name plus this    string.  */
end_comment

begin_define
define|#
directive|define
name|STUB_SUFFIX
value|".stub"
end_define

begin_comment
comment|/* Linker stubs.    ppc_stub_long_branch:    Used when a 14 bit branch (or even a 24 bit branch) can't reach its    destination, but a 24 bit branch in a stub section will reach.    .	b	dest     ppc_stub_plt_branch:    Similar to the above, but a 24 bit branch in the stub section won't    reach its destination.    .	addis	%r12,%r2,xxx@toc@ha    .	ld	%r11,xxx@toc@l(%r12)    .	mtctr	%r11    .	bctr     ppc_stub_plt_call:    Used to call a function in a shared library.    .	addis	%r12,%r2,xxx@toc@ha    .	std	%r2,40(%r1)    .	ld	%r11,xxx+0@toc@l(%r12)    .	ld	%r2,xxx+8@toc@l(%r12)    .	mtctr	%r11    .	ld	%r11,xxx+16@toc@l(%r12)    .	bctr     ppc_stub_long_branch and ppc_stub_plt_branch may also have additional    code to adjust the value and save r2 to support multiple toc sections.    A ppc_stub_long_branch with an r2 offset looks like:    .	std	%r2,40(%r1)    .	addis	%r2,%r2,off@ha    .	addi	%r2,%r2,off@l    .	b	dest     A ppc_stub_plt_branch with an r2 offset looks like:    .	std	%r2,40(%r1)    .	addis	%r12,%r2,xxx@toc@ha    .	ld	%r11,xxx@toc@l(%r12)    .	addis	%r2,%r2,off@ha    .	addi	%r2,%r2,off@l    .	mtctr	%r11    .	bctr */
end_comment

begin_enum
enum|enum
name|ppc_stub_type
block|{
name|ppc_stub_none
block|,
name|ppc_stub_long_branch
block|,
name|ppc_stub_long_branch_r2off
block|,
name|ppc_stub_plt_branch
block|,
name|ppc_stub_plt_branch_r2off
block|,
name|ppc_stub_plt_call
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ppc_stub_hash_entry
block|{
comment|/* Base hash table entry structure.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
name|enum
name|ppc_stub_type
name|stub_type
decl_stmt|;
comment|/* The stub section.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
comment|/* Offset within stub_sec of the beginning of this stub.  */
name|bfd_vma
name|stub_offset
decl_stmt|;
comment|/* Given the symbol's value and its section we can determine its final      value when building the stubs (so the stub knows where to jump.  */
name|bfd_vma
name|target_value
decl_stmt|;
name|asection
modifier|*
name|target_section
decl_stmt|;
comment|/* The symbol table entry, if any, that this was derived from.  */
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* And the reloc addend that this was derived from.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* Where this stub is being called from, or, in the case of combined      stub sections, the first input section in the group.  */
name|asection
modifier|*
name|id_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ppc_branch_hash_entry
block|{
comment|/* Base hash table entry structure.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Offset within .branch_lt.  */
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Generation marker.  */
name|unsigned
name|int
name|iter
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ppc_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
comment|/* A pointer to the most recently used stub hash entry against this      symbol.  */
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_cache
decl_stmt|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|ppc_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
comment|/* Link between function code and descriptor symbols.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|oh
decl_stmt|;
comment|/* Flag function code and descriptor symbols.  */
name|unsigned
name|int
name|is_func
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_func_descriptor
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_entry
range|:
literal|1
decl_stmt|;
comment|/* Whether global opd sym has been adjusted or not.  */
name|unsigned
name|int
name|adjust_done
range|:
literal|1
decl_stmt|;
comment|/* Contexts in which symbol is used in the GOT (or TOC).      TLS_GD .. TLS_EXPLICIT bits are or'd into the mask as the      corresponding relocs are encountered during check_relocs.      tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to      indicate the corresponding GOT entry type is not needed.      tls_optimize may also set TLS_TPRELGD when a GD reloc turns into      a TPREL one.  We use a separate flag rather than setting TPREL      just for convenience in distinguishing the two cases.  */
define|#
directive|define
name|TLS_GD
value|1
comment|/* GD reloc. */
define|#
directive|define
name|TLS_LD
value|2
comment|/* LD reloc. */
define|#
directive|define
name|TLS_TPREL
value|4
comment|/* TPREL reloc, => IE. */
define|#
directive|define
name|TLS_DTPREL
value|8
comment|/* DTPREL reloc, => LD. */
define|#
directive|define
name|TLS_TLS
value|16
comment|/* Any TLS reloc.  */
define|#
directive|define
name|TLS_EXPLICIT
value|32
comment|/* Marks TOC section TLS relocs. */
define|#
directive|define
name|TLS_TPRELGD
value|64
comment|/* TPREL reloc resulting from GD->IE. */
name|char
name|tls_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ppc64 ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* The stub hash table.  */
name|struct
name|bfd_hash_table
name|stub_hash_table
decl_stmt|;
comment|/* Another hash table for plt_branch stubs.  */
name|struct
name|bfd_hash_table
name|branch_hash_table
decl_stmt|;
comment|/* Linker stub bfd.  */
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
comment|/* Linker call-backs.  */
name|asection
modifier|*
function_decl|(
modifier|*
name|add_stub_section
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|layout_sections_again
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Array to keep track of which stub sections have been created, and      information on stub grouping.  */
struct|struct
name|map_stub
block|{
comment|/* This is the section to which stubs in the group will be attached.  */
name|asection
modifier|*
name|link_sec
decl_stmt|;
comment|/* The stub section.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
comment|/* Along with elf_gp, specifies the TOC pointer used in this group.  */
name|bfd_vma
name|toc_off
decl_stmt|;
block|}
modifier|*
name|stub_group
struct|;
comment|/* Support for multiple toc sections.  */
name|unsigned
name|int
name|no_multi_toc
decl_stmt|;
name|unsigned
name|int
name|multi_toc_needed
decl_stmt|;
comment|/* Temp used when calculating TOC pointers.  */
name|bfd_vma
name|toc_curr
decl_stmt|;
comment|/* Highest input section id.  */
name|int
name|top_id
decl_stmt|;
comment|/* Highest output section index.  */
name|int
name|top_index
decl_stmt|;
comment|/* List of input sections for each output section.  */
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|got
decl_stmt|;
name|asection
modifier|*
name|plt
decl_stmt|;
name|asection
modifier|*
name|relplt
decl_stmt|;
name|asection
modifier|*
name|dynbss
decl_stmt|;
name|asection
modifier|*
name|relbss
decl_stmt|;
name|asection
modifier|*
name|glink
decl_stmt|;
name|asection
modifier|*
name|sfpr
decl_stmt|;
name|asection
modifier|*
name|brlt
decl_stmt|;
name|asection
modifier|*
name|relbrlt
decl_stmt|;
comment|/* Shortcut to .__tls_get_addr.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|tls_get_addr
decl_stmt|;
comment|/* Statistics.  */
name|unsigned
name|long
name|stub_count
index|[
name|ppc_stub_plt_call
index|]
decl_stmt|;
comment|/* Set if we should emit symbols for stubs.  */
name|unsigned
name|int
name|emit_stub_syms
decl_stmt|;
comment|/* Set on error.  */
name|unsigned
name|int
name|stub_error
decl_stmt|;
comment|/* Flag set when small branches are detected.  Used to      select suitable defaults for the stub group size.  */
name|unsigned
name|int
name|has_14bit_branch
decl_stmt|;
comment|/* Set if we detect a reference undefined weak symbol.  */
name|unsigned
name|int
name|have_undefweak
decl_stmt|;
comment|/* Incremented every time we size stubs.  */
name|unsigned
name|int
name|stub_iteration
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the ppc64 ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|ppc_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct ppc_link_hash_table *) ((p)->hash))
end_define

begin_define
define|#
directive|define
name|ppc_stub_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct ppc_stub_hash_entry *) \    bfd_hash_lookup ((table), (string), (create), (copy)))
end_define

begin_define
define|#
directive|define
name|ppc_branch_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct ppc_branch_hash_entry *) \    bfd_hash_lookup ((table), (string), (create), (copy)))
end_define

begin_comment
comment|/* Create an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stub_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_stub_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|eh
operator|=
operator|(
expr|struct
name|ppc_stub_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|stub_type
operator|=
name|ppc_stub_none
expr_stmt|;
name|eh
operator|->
name|stub_sec
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_value
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_section
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|h
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|id_sec
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in the branch hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|branch_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_branch_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_branch_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|eh
operator|=
operator|(
expr|struct
name|ppc_branch_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|iter
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in a ppc64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
init|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
name|eh
operator|->
name|stub_cache
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|oh
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|is_func
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|is_func_descriptor
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|is_entry
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|adjust_done
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|tls_mask
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create a ppc64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc64_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_table
argument_list|)
decl_stmt|;
name|htab
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|htab
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Init the stub hash table too.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_hash_newfunc
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* And the branch hash table.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|branch_hash_table
argument_list|,
name|branch_hash_newfunc
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Initializing two fields of the union is just cosmetic.  We really      only care about glist, but when compiled on a 32-bit host the      bfd_vma fields are larger.  Setting the bfd_vma to zero makes      debugger inspection of these fields look nicer.  */
name|htab
operator|->
name|elf
operator|.
name|init_refcount
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_refcount
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_offset
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|init_offset
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|htab
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Free the derived linker hash table.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_link_hash_table_free
parameter_list|(
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|ret
init|=
operator|(
expr|struct
name|ppc_link_hash_table
operator|*
operator|)
name|hash
decl_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ret
operator|->
name|stub_hash_table
argument_list|)
expr_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ret
operator|->
name|branch_hash_table
argument_list|)
expr_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Satisfy the ELF linker by filling in some fields in our fake bfd.  */
end_comment

begin_function
name|void
name|ppc64_elf_init_stub_bfd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELFCLASS64
expr_stmt|;
comment|/* Always hook our dynamic sections into the first bfd, which is the    linker created stub bfd.  This ensures that the GOT header is at    the start of the output TOC section.  */
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_bfd
operator|=
name|abfd
expr_stmt|;
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a name for an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ppc_stub_name
parameter_list|(
specifier|const
name|asection
modifier|*
name|input_section
parameter_list|,
specifier|const
name|asection
modifier|*
name|sym_sec
parameter_list|,
specifier|const
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
comment|/* rel->r_addend is actually 64 bit, but who uses more than +/- 2^31      offsets from a sym as a branch target?  In fact, we could      probably assume the addend is always zero.  */
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
operator|)
operator|==
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%08x.%s+%x"
argument_list|,
name|input_section
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%08x.%x:%x+%x"
argument_list|,
name|input_section
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
name|sym_sec
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stub_name
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in the stub hash.  Stub entries are cached because    creating the stub name takes a bit of time.  */
end_comment

begin_function
specifier|static
name|struct
name|ppc_stub_hash_entry
modifier|*
name|ppc_get_stub_entry
parameter_list|(
specifier|const
name|asection
modifier|*
name|input_section
parameter_list|,
specifier|const
name|asection
modifier|*
name|sym_sec
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|hash
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
init|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|hash
decl_stmt|;
specifier|const
name|asection
modifier|*
name|id_sec
decl_stmt|;
comment|/* If this input section is part of a group of sections sharing one      stub section, then use the id of the first section in the group.      Stub names need to include a section id, as there may well be      more than one stub used to reach say, printf, and we need to      distinguish between them.  */
name|id_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|stub_cache
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|stub_cache
operator|->
name|h
operator|==
name|h
operator|&&
name|h
operator|->
name|stub_cache
operator|->
name|id_sec
operator|==
name|id_sec
condition|)
block|{
name|stub_entry
operator|=
name|h
operator|->
name|stub_cache
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|stub_name
operator|=
name|ppc_stub_name
argument_list|(
name|id_sec
argument_list|,
name|sym_sec
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|stub_entry
operator|=
name|ppc_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|stub_cache
operator|=
name|stub_entry
expr_stmt|;
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
block|}
return|return
name|stub_entry
return|;
block|}
end_function

begin_comment
comment|/* Add a new stub entry to the stub hash.  Not all fields of the new    stub entry are initialised.  */
end_comment

begin_function
specifier|static
name|struct
name|ppc_stub_hash_entry
modifier|*
name|ppc_add_stub
parameter_list|(
specifier|const
name|char
modifier|*
name|stub_name
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|asection
modifier|*
name|link_sec
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|link_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
name|stub_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|stub_sec
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
block|{
name|stub_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|link_sec
operator|->
name|id
index|]
operator|.
name|stub_sec
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
block|{
name|size_t
name|namelen
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
name|char
modifier|*
name|s_name
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|link_sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|namelen
operator|+
sizeof|sizeof
argument_list|(
name|STUB_SUFFIX
argument_list|)
expr_stmt|;
name|s_name
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|s_name
argument_list|,
name|link_sec
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s_name
operator|+
name|namelen
argument_list|,
name|STUB_SUFFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|STUB_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|stub_sec
operator|=
call|(
modifier|*
name|htab
operator|->
name|add_stub_section
call|)
argument_list|(
name|s_name
argument_list|,
name|link_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|htab
operator|->
name|stub_group
index|[
name|link_sec
operator|->
name|id
index|]
operator|.
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
block|}
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
block|}
comment|/* Enter this entry into the linker stub hash table.  */
name|stub_entry
operator|=
name|ppc_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: cannot create stub entry %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|section
operator|->
name|owner
argument_list|)
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|stub_entry
operator|->
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
name|stub_entry
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|stub_entry
operator|->
name|id_sec
operator|=
name|link_sec
expr_stmt|;
return|return
name|stub_entry
return|;
block|}
end_function

begin_comment
comment|/* Create sections for linker generated code.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|create_linkage_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Create .sfpr for code to save and restore fp regs.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|sfpr
operator|=
name|bfd_make_section_anyway
argument_list|(
name|dynobj
argument_list|,
literal|".sfpr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sfpr
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sfpr
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create .glink for lazy dynamic linking support.  */
name|htab
operator|->
name|glink
operator|=
name|bfd_make_section_anyway
argument_list|(
name|dynobj
argument_list|,
literal|".glink"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|glink
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|glink
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|glink
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create .branch_lt for plt_branch stubs.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|brlt
operator|=
name|bfd_make_section_anyway
argument_list|(
name|dynobj
argument_list|,
literal|".branch_lt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|brlt
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|brlt
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|brlt
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|relbrlt
operator|=
name|bfd_make_section_anyway
argument_list|(
name|dynobj
argument_list|,
literal|".rela.branch_lt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|relbrlt
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|relbrlt
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|relbrlt
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create .got and .rela.got sections in ABFD, and .got in dynobj if    not already done.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|create_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|got
decl_stmt|,
modifier|*
name|relgot
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|got
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|got
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|got
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|got
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|got
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|got
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|relgot
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relgot
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|relgot
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|relgot
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ppc64_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
operator|=
name|got
expr_stmt|;
name|ppc64_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|relgot
operator|=
name|relgot
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create the dynamic sections, and set up shortcuts.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|got
condition|)
name|htab
operator|->
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|relplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|dynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|relbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|got
operator|||
operator|!
name|htab
operator|->
name|plt
operator|||
operator|!
name|htab
operator|->
name|relplt
operator|||
operator|!
name|htab
operator|->
name|dynbss
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|htab
operator|->
name|relbss
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_copy_indirect_symbol
parameter_list|(
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|flagword
name|mask
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
comment|/* Copy over any dynamic relocs we may have on the indirect sym.  */
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add reloc counts against the weak sym to the strong sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|edir
operator|->
name|is_func
operator||=
name|eind
operator|->
name|is_func
expr_stmt|;
name|edir
operator|->
name|is_func_descriptor
operator||=
name|eind
operator|->
name|is_func_descriptor
expr_stmt|;
name|edir
operator|->
name|is_entry
operator||=
name|eind
operator|->
name|is_entry
expr_stmt|;
name|edir
operator|->
name|tls_mask
operator||=
name|eind
operator|->
name|tls_mask
expr_stmt|;
name|mask
operator|=
operator|(
name|ELF_LINK_HASH_REF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_NON_GOT_REF
operator||
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
expr_stmt|;
comment|/* If called to transfer flags for a weakdef during processing      of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.      We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
operator|&&
name|eind
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
operator|&&
operator|(
name|edir
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
operator|)
operator|!=
literal|0
condition|)
name|mask
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator||=
name|eind
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|mask
expr_stmt|;
comment|/* If we were called to copy over info for a weak sym, that's all.  */
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return;
comment|/* Copy over got entries that we may have already seen to the      symbol which just became indirect.  */
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|got_entry
modifier|*
modifier|*
name|entp
decl_stmt|;
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|entp
operator|=
operator|&
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
init|;
operator|(
name|ent
operator|=
operator|*
name|entp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|got_entry
modifier|*
name|dent
decl_stmt|;
for|for
control|(
name|dent
operator|=
name|edir
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
init|;
name|dent
operator|!=
name|NULL
condition|;
name|dent
operator|=
name|dent
operator|->
name|next
control|)
if|if
condition|(
name|dent
operator|->
name|addend
operator|==
name|ent
operator|->
name|addend
operator|&&
name|dent
operator|->
name|owner
operator|==
name|ent
operator|->
name|owner
operator|&&
name|dent
operator|->
name|tls_type
operator|==
name|ent
operator|->
name|tls_type
condition|)
block|{
name|dent
operator|->
name|got
operator|.
name|refcount
operator|+=
name|ent
operator|->
name|got
operator|.
name|refcount
expr_stmt|;
operator|*
name|entp
operator|=
name|ent
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dent
operator|==
name|NULL
condition|)
name|entp
operator|=
operator|&
name|ent
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|entp
operator|=
name|edir
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
expr_stmt|;
block|}
name|edir
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|=
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* And plt entries.  */
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|plt_entry
modifier|*
modifier|*
name|entp
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|entp
operator|=
operator|&
name|eind
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
operator|(
name|ent
operator|=
operator|*
name|entp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|plt_entry
modifier|*
name|dent
decl_stmt|;
for|for
control|(
name|dent
operator|=
name|edir
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|dent
operator|!=
name|NULL
condition|;
name|dent
operator|=
name|dent
operator|->
name|next
control|)
if|if
condition|(
name|dent
operator|->
name|addend
operator|==
name|ent
operator|->
name|addend
condition|)
block|{
name|dent
operator|->
name|plt
operator|.
name|refcount
operator|+=
name|ent
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
operator|*
name|entp
operator|=
name|ent
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dent
operator|==
name|NULL
condition|)
name|entp
operator|=
operator|&
name|ent
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|entp
operator|=
name|edir
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
expr_stmt|;
block|}
name|edir
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|=
name|eind
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|edir
operator|->
name|elf
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|edir
operator|->
name|elf
operator|.
name|dynindx
operator|=
name|eind
operator|->
name|elf
operator|.
name|dynindx
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|dynstr_index
operator|=
name|eind
operator|->
name|elf
operator|.
name|dynstr_index
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|dynstr_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|BFD_ASSERT
argument_list|(
name|eind
operator|->
name|elf
operator|.
name|dynindx
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set a flag, used by ppc64_elf_gc_mark_hook, on the entry symbol and    symbols undefined on the command-line.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_mark_entry_syms
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|bfd_sym_chain
modifier|*
name|sym
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|info
operator|->
name|gc_sym_list
init|;
name|sym
condition|;
name|sym
operator|=
name|sym
operator|->
name|next
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|sym
operator|->
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_entry
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Hack symbols defined in .opd sections to be function type.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|ibfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|isym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|flagword
modifier|*
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|sec
parameter_list|,
name|bfd_vma
modifier|*
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|ibfd
argument_list|,
operator|*
name|sec
argument_list|)
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
name|isym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|update_local_sym_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|bfd_vma
name|r_addend
parameter_list|,
name|int
name|tls_type
parameter_list|)
block|{
name|struct
name|got_entry
modifier|*
modifier|*
name|local_got_ents
init|=
name|elf_local_got_ents
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|local_got_tls_masks
decl_stmt|;
if|if
condition|(
name|local_got_ents
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
init|=
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
operator|*
name|local_got_ents
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|local_got_tls_masks
argument_list|)
expr_stmt|;
name|local_got_ents
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_ents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_ents
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_ents
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tls_type
operator|&
name|TLS_EXPLICIT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|local_got_ents
index|[
name|r_symndx
index|]
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|r_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|abfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
decl_stmt|;
name|ent
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ent
operator|->
name|next
operator|=
name|local_got_ents
index|[
name|r_symndx
index|]
expr_stmt|;
name|ent
operator|->
name|addend
operator|=
name|r_addend
expr_stmt|;
name|ent
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|ent
operator|->
name|tls_type
operator|=
name|tls_type
expr_stmt|;
name|ent
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|local_got_ents
index|[
name|r_symndx
index|]
operator|=
name|ent
expr_stmt|;
block|}
name|ent
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
name|local_got_tls_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_ents
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|local_got_tls_masks
index|[
name|r_symndx
index|]
operator||=
name|tls_type
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|update_plt_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|eh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|addend
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
decl_stmt|;
name|ent
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ent
operator|->
name|next
operator|=
name|eh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
expr_stmt|;
name|ent
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|=
name|ent
expr_stmt|;
block|}
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|eh
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find the function descriptor hash entry from the given function code    hash entry FH.  Link the entries via their OH fields.  */
end_comment

begin_function
specifier|static
name|struct
name|ppc_link_hash_entry
modifier|*
name|get_fdh
parameter_list|(
name|struct
name|ppc_link_hash_entry
modifier|*
name|fh
parameter_list|,
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
init|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fh
operator|->
name|oh
decl_stmt|;
if|if
condition|(
name|fdh
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|fd_name
init|=
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
decl_stmt|;
name|fdh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|fd_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|!=
name|NULL
condition|)
block|{
name|fdh
operator|->
name|is_func_descriptor
operator|=
literal|1
expr_stmt|;
name|fdh
operator|->
name|oh
operator|=
operator|&
name|fh
operator|->
name|elf
expr_stmt|;
name|fh
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
name|fh
operator|->
name|oh
operator|=
operator|&
name|fdh
operator|->
name|elf
expr_stmt|;
block|}
block|}
return|return
name|fdh
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    calculate needed space in the global offset table, procedure    linkage table, and dynamic reloc sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|asection
modifier|*
modifier|*
name|opd_sym_map
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* Don't do anything special with non-loaded, non-alloced sections.      In particular, any relocs in such sections should not affect GOT      and PLT reference counting (ie. we don't allow them to create GOT      or PLT entries), there's no possibility or desire to optimize TLS      relocs, and there's not much point in propagating relocs to shared      libs that the dynamic linker won't relocate.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
operator|(
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|opd_sym_map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Garbage collection needs some extra help with .opd sections. 	 We don't want to necessarily keep everything referenced by 	 relocs in .opd, as that would keep all functions.  Instead, 	 if we reference an .opd symbol (a function descriptor), we 	 want to keep the function code symbol's section.  This is 	 easy for global symbols, but for local syms we need to keep 	 information about the associated function section.  Later, if 	 edit_opd deletes entries, we'll use this array to adjust 	 local syms in .opd.  */
union|union
name|opd_info
block|{
name|asection
modifier|*
name|func_section
decl_stmt|;
name|long
name|entry_adjust
decl_stmt|;
block|}
union|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
name|sec
operator|->
name|_raw_size
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|opd_info
argument_list|)
operator|/
literal|24
expr_stmt|;
name|opd_sym_map
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_sym_map
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|opd
operator|.
name|func_sec
operator|=
name|opd_sym_map
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|==
name|NULL
operator|&&
operator|!
name|create_linkage_sections
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|int
name|tls_type
init|=
literal|0
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
name|ppc64_tlsld_got
argument_list|(
name|abfd
argument_list|)
operator|->
name|refcount
operator|+=
literal|1
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_HI
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC64_GOT_DTPREL16_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
name|dogottls
label|:
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
comment|/* Fall thru */
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
comment|/* This symbol requires a global offset table entry.  */
name|sec
operator|->
name|has_gp_reloc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ppc64_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
operator|==
name|NULL
operator|&&
operator|!
name|create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|abfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
decl_stmt|;
name|ent
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ent
operator|->
name|next
operator|=
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
expr_stmt|;
name|ent
operator|->
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|ent
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|ent
operator|->
name|tls_type
operator|=
name|tls_type
expr_stmt|;
name|ent
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|glist
operator|=
name|ent
expr_stmt|;
block|}
name|ent
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|eh
operator|->
name|tls_mask
operator||=
name|tls_type
expr_stmt|;
block|}
elseif|else
comment|/* This is a global offset table entry for a local symbol.  */
if|if
condition|(
operator|!
name|update_local_sym_info
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|tls_type
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol, 	     because this might be a case of linking PIC code without 	     linking in any dynamic objects, in which case we don't 	     need to generate a procedure linkage table after all.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* It does not make sense to have a procedure linkage 		 table entry for a local symbol.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|update_plt_info
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* The following relocations don't need to propagate the 	     relocation if linking a shared object since they are 	     section relative.  */
case|case
name|R_PPC64_SECTOFF
case|:
case|case
name|R_PPC64_SECTOFF_LO
case|:
case|case
name|R_PPC64_SECTOFF_HI
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_DTPREL16
case|:
case|case
name|R_PPC64_DTPREL16_LO
case|:
case|case
name|R_PPC64_DTPREL16_HI
case|:
case|case
name|R_PPC64_DTPREL16_HA
case|:
case|case
name|R_PPC64_DTPREL16_DS
case|:
case|case
name|R_PPC64_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_DTPREL16_HIGHER
case|:
case|case
name|R_PPC64_DTPREL16_HIGHERA
case|:
case|case
name|R_PPC64_DTPREL16_HIGHEST
case|:
case|case
name|R_PPC64_DTPREL16_HIGHESTA
case|:
break|break;
comment|/* Nor do these.  */
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
name|sec
operator|->
name|has_gp_reloc
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_PPC64_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
name|htab
operator|->
name|has_14bit_branch
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* We may need a .plt entry if the function this reloc 		 refers to is in a shared lib.  */
if|if
condition|(
operator|!
name|update_plt_info
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|==
name|htab
operator|->
name|tls_get_addr
condition|)
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|".__tls_get_addr"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|15
index|]
operator|==
literal|0
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|15
index|]
operator|==
literal|'@'
operator|)
condition|)
block|{
name|htab
operator|->
name|tls_get_addr
operator|=
name|h
expr_stmt|;
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_PPC64_TPREL64
case|:
name|tls_type
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
goto|goto
name|dotlstoc
goto|;
case|case
name|R_PPC64_DTPMOD64
case|:
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|rel_end
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|==
name|rel
operator|->
name|r_offset
operator|+
literal|8
condition|)
name|tls_type
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
else|else
name|tls_type
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dotlstoc
goto|;
case|case
name|R_PPC64_DTPREL64
case|:
name|tls_type
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
name|relocs
operator|&&
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_DTPMOD64
argument_list|)
operator|&&
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_offset
operator|==
name|rel
operator|->
name|r_offset
operator|-
literal|8
condition|)
comment|/* This is the second reloc of a dtpmod, dtprel pair. 	       Don't mark with TLS_DTPREL.  */
goto|goto
name|dodyn
goto|;
name|dotlstoc
label|:
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|eh
operator|->
name|tls_mask
operator||=
name|tls_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|update_local_sym_info
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|tls_type
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|t_symndx
operator|==
name|NULL
condition|)
block|{
comment|/* One extra to simplify get_tls_mask.  */
name|bfd_size_type
name|amt
init|=
name|sec
operator|->
name|_raw_size
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|/
literal|8
operator|+
literal|1
decl_stmt|;
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|t_symndx
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|t_symndx
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|t_symndx
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
index|]
operator|=
name|r_symndx
expr_stmt|;
comment|/* Mark the second slot of a GD or LD entry. 	     -1 to indicate GD and -2 to indicate LD.  */
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|t_symndx
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
operator|+
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_EXPLICIT
operator||
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|t_symndx
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|8
operator|+
literal|1
index|]
operator|=
operator|-
literal|2
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC64_TPREL16
case|:
case|case
name|R_PPC64_TPREL16_LO
case|:
case|case
name|R_PPC64_TPREL16_HI
case|:
case|case
name|R_PPC64_TPREL16_HA
case|:
case|case
name|R_PPC64_TPREL16_DS
case|:
case|case
name|R_PPC64_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_TPREL16_HIGHER
case|:
case|case
name|R_PPC64_TPREL16_HIGHERA
case|:
case|case
name|R_PPC64_TPREL16_HIGHEST
case|:
case|case
name|R_PPC64_TPREL16_HIGHESTA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
goto|goto
name|dodyn
goto|;
block|}
break|break;
case|case
name|R_PPC64_ADDR64
case|:
if|if
condition|(
name|opd_sym_map
operator|!=
name|NULL
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|get_fdh
argument_list|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|opd_sym_map
operator|!=
name|NULL
operator|&&
name|h
operator|==
name|NULL
operator|&&
name|rel
operator|+
literal|1
operator|<
name|rel_end
operator|&&
name|ELF64_R_TYPE
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
name|s
operator|!=
name|sec
condition|)
name|opd_sym_map
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|24
index|]
operator|=
name|s
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|R_PPC64_REL30
case|:
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL64
case|:
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
case|case
name|R_PPC64_TOC
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
comment|/* We may need a copy reloc.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
comment|/* Don't propagate .opd relocs.  */
if|if
condition|(
name|NO_OPD_RELOCS
operator|&&
name|opd_sym_map
operator|!=
name|NULL
condition|)
break|break;
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  In case of a weak definition, 	     DEF_REGULAR may be cleared later by a strong definition in 	     a shared library.  We account for that possibility below by 	     storing information in the dyn_relocs field of the hash 	     table entry.  A similar situation occurs when creating 	     shared libraries and symbol visibility changes render the 	     symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
name|dodyn
label|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* We must copy these reloc types into the output file. 		 Create a reloc section in dynobj and make room for 		 this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad relocation section name `%s\'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|p
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|ppc64_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|asection
modifier|*
name|rsec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
case|case
name|R_PPC64_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|fdh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Function descriptor syms cause the associated 		 function code sym section to be marked.  */
if|if
condition|(
name|fdh
operator|->
name|is_func_descriptor
condition|)
name|rsec
operator|=
name|fdh
operator|->
name|oh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
comment|/* Function entry syms return NULL if they are in .opd 		 and are not ._start (or others undefined on the ld 		 command line).  Thus we avoid marking all function 		 sections, as all functions are referenced in .opd.  */
elseif|else
if|if
condition|(
operator|(
name|fdh
operator|->
name|oh
operator|!=
name|NULL
operator|&&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|->
name|oh
operator|)
operator|->
name|is_entry
operator|)
operator|||
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|opd
operator|.
name|func_sec
operator|==
name|NULL
condition|)
name|rsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|rsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
name|asection
modifier|*
modifier|*
name|opd_sym_section
decl_stmt|;
name|rsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|opd_sym_section
operator|=
name|ppc64_elf_section_data
argument_list|(
name|rsec
argument_list|)
operator|->
name|opd
operator|.
name|func_sec
expr_stmt|;
if|if
condition|(
name|opd_sym_section
operator|!=
name|NULL
condition|)
name|rsec
operator|=
name|opd_sym_section
index|[
name|sym
operator|->
name|st_value
operator|/
literal|24
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|opd
operator|.
name|func_sec
operator|!=
name|NULL
condition|)
name|rsec
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|rsec
return|;
block|}
end_function

begin_comment
comment|/* Update the .got, .plt. and dynamic reloc reference counts for the    section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|got_entry
modifier|*
modifier|*
name|local_got_ents
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_ents
operator|=
name|elf_local_got_ents
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|char
name|tls_type
init|=
literal|0
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
comment|/* Everything must go for SEC.  */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
name|ppc64_tlsld_got
argument_list|(
name|abfd
argument_list|)
operator|->
name|refcount
operator|-=
literal|1
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_HI
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_DTPREL16_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
name|dogot
label|:
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|ent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
expr_stmt|;
else|else
name|ent
operator|=
name|local_got_ents
index|[
name|r_symndx
index|]
expr_stmt|;
for|for
control|(
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|abfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called via elf_link_hash_traverse to transfer dynamic linking    information on function code symbol entries to their corresponding    function descriptor symbol entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|func_desc_adjust
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fh
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|bfd_boolean
name|force_local
decl_stmt|;
name|fh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|fh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
name|inf
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* If this is a function code symbol, transfer dynamic linking      information to the function descriptor symbol.  */
if|if
condition|(
operator|!
name|fh
operator|->
name|is_func
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
operator|(
name|fh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
condition|)
name|htab
operator|->
name|have_undefweak
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|fh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
operator|||
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
comment|/* Find the corresponding function descriptor symbol.  Create it      as undefined if necessary.  */
name|fdh
operator|=
name|get_fdh
argument_list|(
name|fh
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|!=
name|NULL
condition|)
while|while
condition|(
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|fdh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|fdh
operator|==
name|NULL
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|newsym
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|abfd
operator|=
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
name|newsym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|newsym
operator|->
name|name
operator|=
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
expr_stmt|;
name|newsym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|newsym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|newsym
operator|->
name|flags
operator|=
name|BSF_OBJECT
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|newsym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
name|bh
operator|=
operator|&
name|fdh
operator|->
name|elf
operator|.
name|root
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|newsym
operator|->
name|name
argument_list|,
name|newsym
operator|->
name|flags
argument_list|,
name|newsym
operator|->
name|section
argument_list|,
name|newsym
operator|->
name|value
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
name|fdh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|size
operator|=
literal|24
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
block|}
if|if
condition|(
name|fdh
operator|!=
name|NULL
operator|&&
operator|(
name|fdh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|fdh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|fdh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|fdh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fdh
operator|->
name|elf
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|fdh
operator|->
name|elf
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fdh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator||=
operator|(
name|fh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_NON_GOT_REF
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|fh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
block|{
name|fdh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|=
name|fh
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
name|fdh
operator|->
name|is_func_descriptor
operator|=
literal|1
expr_stmt|;
name|fdh
operator|->
name|oh
operator|=
operator|&
name|fh
operator|->
name|elf
expr_stmt|;
name|fh
operator|->
name|oh
operator|=
operator|&
name|fdh
operator|->
name|elf
expr_stmt|;
block|}
comment|/* Now that the info is on the function descriptor, clear the      function code sym info.  Any function code syms for which we      don't have a definition in a regular file, we force local.      This prevents a shared library from exporting syms that have      been imported from another library.  Function code syms that      are really in the library we must leave global to prevent the      linker dragging in a definition from a static library.  */
name|force_local
operator|=
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
name|fh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|||
name|fdh
operator|==
name|NULL
operator|||
operator|(
name|fdh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|||
operator|(
name|fdh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|fh
operator|->
name|elf
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MIN_SAVE_FPR
value|14
end_define

begin_define
define|#
directive|define
name|MAX_SAVE_FPR
value|31
end_define

begin_comment
comment|/* Called near the start of bfd_elf_size_dynamic_sections.  We use    this hook to a) provide some gcc support functions, and b) transfer    dynamic linking information gathered so far on function code symbol    entries, to their corresponding function descriptor symbol entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_func_desc_adjust
parameter_list|(
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|unsigned
name|int
name|lowest_savef
init|=
name|MAX_SAVE_FPR
operator|+
literal|2
decl_stmt|;
name|unsigned
name|int
name|lowest_restf
init|=
name|MAX_SAVE_FPR
operator|+
literal|2
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|char
name|sym
index|[
literal|10
index|]
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|==
name|NULL
condition|)
comment|/* We don't have any relocs.  */
return|return
name|TRUE
return|;
comment|/* First provide any missing ._savef* and ._restf* functions.  */
name|memcpy
argument_list|(
name|sym
argument_list|,
literal|"._savef14"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_SAVE_FPR
init|;
name|i
operator|<=
name|MAX_SAVE_FPR
condition|;
name|i
operator|++
control|)
block|{
name|sym
index|[
literal|7
index|]
operator|=
name|i
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
name|sym
index|[
literal|8
index|]
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|sym
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lowest_savef
operator|>
name|i
condition|)
name|lowest_savef
operator|=
name|i
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|sfpr
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
operator|(
name|i
operator|-
name|lowest_savef
operator|)
operator|*
literal|4
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|sym
argument_list|,
literal|"._restf14"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_SAVE_FPR
init|;
name|i
operator|<=
name|MAX_SAVE_FPR
condition|;
name|i
operator|++
control|)
block|{
name|sym
index|[
literal|7
index|]
operator|=
name|i
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
name|sym
index|[
literal|8
index|]
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|sym
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lowest_restf
operator|>
name|i
condition|)
name|lowest_restf
operator|=
name|i
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|sfpr
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
operator|(
operator|(
name|MAX_SAVE_FPR
operator|+
literal|2
operator|-
name|lowest_savef
operator|)
operator|*
literal|4
operator|+
operator|(
name|i
operator|-
name|lowest_restf
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|func_desc_adjust
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|=
operator|(
operator|(
name|MAX_SAVE_FPR
operator|+
literal|2
operator|-
name|lowest_savef
operator|)
operator|*
literal|4
operator|+
operator|(
name|MAX_SAVE_FPR
operator|+
literal|2
operator|-
name|lowest_restf
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|htab
operator|->
name|have_undefweak
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|htab
operator|->
name|sfpr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|=
literal|4
expr_stmt|;
block|}
name|p
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|sfpr
operator|->
name|contents
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowest_savef
init|;
name|i
operator|<=
name|MAX_SAVE_FPR
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|fpr
init|=
name|i
operator|<<
literal|21
decl_stmt|;
name|unsigned
name|int
name|stackoff
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
name|MAX_SAVE_FPR
operator|+
literal|1
operator|-
name|i
operator|)
operator|*
literal|8
decl_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|STFD_FR0_0R1
operator|+
name|fpr
operator|+
name|stackoff
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|lowest_savef
operator|<=
name|MAX_SAVE_FPR
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|lowest_restf
init|;
name|i
operator|<=
name|MAX_SAVE_FPR
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|fpr
init|=
name|i
operator|<<
literal|21
decl_stmt|;
name|unsigned
name|int
name|stackoff
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
operator|(
name|MAX_SAVE_FPR
operator|+
literal|1
operator|-
name|i
operator|)
operator|*
literal|8
decl_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|LFD_FR0_0R1
operator|+
name|fpr
operator|+
name|stackoff
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|lowest_restf
operator|<=
name|MAX_SAVE_FPR
operator|||
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|==
literal|4
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|BLR
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Deal with function syms.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clear procedure linkage table information for any symbol that 	 won't need a .plt entry.  */
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
operator|||
name|ent
operator|==
name|NULL
operator|||
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator|=
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|~
name|ELF_LINK_NON_GOT_REF
operator|)
operator||
operator|(
name|h
operator|->
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in read-only sections, then 	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|plist
operator|!=
name|NULL
condition|)
block|{
comment|/* We should never get here, but unfortunately there are versions 	 of gcc out there that improperly (for this ABI) put initialized 	 function pointers, vtable refs and suchlike in read-only 	 sections.  Allow them to proceed, but warn that this might 	 break at runtime.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"copy reloc against `%s' requires lazy plt linking; "
literal|"avoid setting LD_BIND_NOW=1 or upgrade gcc"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
comment|/* We must generate a R_PPC64_COPY reloc to tell the dynamic linker      to copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|relbss
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|4
condition|)
name|power_of_two
operator|=
literal|4
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|=
name|htab
operator|->
name|dynbss
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* If given a function descriptor symbol, hide both the function code    sym and the descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_hide_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_boolean
name|force_local
parameter_list|)
block|{
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|fh
init|=
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|oh
decl_stmt|;
if|if
condition|(
name|fh
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* We aren't supposed to use alloca in BFD because on 	     systems which do not have alloca the version in libiberty 	     calls xmalloc, which might cause the program to crash 	     when it runs out of memory.  This function doesn't have a 	     return status, so there's no way to gracefully return an 	     error.  So cheat.  We know that string[-1] can be safely 	     dereferenced;  It's either a string in an ELF string 	     table, or allocated in an objalloc structure.  */
name|p
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|-
literal|1
expr_stmt|;
name|save
operator|=
operator|*
name|p
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|p
operator|=
literal|'.'
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|p
operator|=
name|save
expr_stmt|;
comment|/* Unfortunately, if it so happens that the string we were 	     looking for was allocated immediately before this string, 	     then we overwrote the string terminator.  That's the only 	     reason the lookup should fail.  */
if|if
condition|(
name|fh
operator|==
name|NULL
condition|)
block|{
name|q
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|>=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|&&
operator|*
name|q
operator|==
operator|*
name|p
condition|)
operator|--
name|q
operator|,
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|q
operator|<
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|&&
operator|*
name|p
operator|==
literal|'.'
condition|)
name|fh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fh
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|oh
operator|=
name|fh
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fh
operator|)
operator|->
name|oh
operator|=
name|h
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fh
operator|!=
name|NULL
condition|)
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|fh
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|get_sym_h
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hp
parameter_list|,
name|Elf_Internal_Sym
modifier|*
modifier|*
name|symp
parameter_list|,
name|asection
modifier|*
modifier|*
name|symsecp
parameter_list|,
name|char
modifier|*
modifier|*
name|tls_maskp
parameter_list|,
name|Elf_Internal_Sym
modifier|*
modifier|*
name|locsymsp
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
init|=
name|elf_sym_hashes
argument_list|(
name|ibfd
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
operator|*
name|hp
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|symp
operator|!=
name|NULL
condition|)
operator|*
name|symp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symsecp
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|symsec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|symsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
operator|*
name|symsecp
operator|=
name|symsec
expr_stmt|;
block|}
if|if
condition|(
name|tls_maskp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
operator|*
name|tls_maskp
operator|=
operator|&
name|eh
operator|->
name|tls_mask
expr_stmt|;
block|}
block|}
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|locsyms
init|=
operator|*
name|locsymsp
decl_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
block|{
name|locsyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
name|locsyms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|locsymsp
operator|=
name|locsyms
expr_stmt|;
block|}
name|sym
operator|=
name|locsyms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
operator|*
name|hp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symp
operator|!=
name|NULL
condition|)
operator|*
name|symp
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|symsecp
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|symsec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|)
operator|||
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
name|symsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|ibfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|symsecp
operator|=
name|symsec
expr_stmt|;
block|}
if|if
condition|(
name|tls_maskp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|got_entry
modifier|*
modifier|*
name|lgot_ents
decl_stmt|;
name|char
modifier|*
name|tls_mask
decl_stmt|;
name|tls_mask
operator|=
name|NULL
expr_stmt|;
name|lgot_ents
operator|=
name|elf_local_got_ents
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lgot_ents
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|lgot_masks
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lgot_ents
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
decl_stmt|;
name|tls_mask
operator|=
operator|&
name|lgot_masks
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
operator|*
name|tls_maskp
operator|=
name|tls_mask
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Returns TLS_MASKP for the given REL symbol.  Function return is 0 on    error, 2 on a toc GD type suitable for optimization, 3 on a toc LD    type suitable for optimization, and 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|get_tls_mask
parameter_list|(
name|char
modifier|*
modifier|*
name|tls_maskp
parameter_list|,
name|unsigned
name|long
modifier|*
name|toc_symndx
parameter_list|,
name|Elf_Internal_Sym
modifier|*
modifier|*
name|locsymsp
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|next_r
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|tls_maskp
argument_list|,
name|locsymsp
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|*
name|tls_maskp
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|tls_maskp
operator|!=
literal|0
operator|)
operator|||
name|sec
operator|==
name|NULL
operator|||
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|t_symndx
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Look inside a TOC section too.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
name|off
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
else|else
name|off
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|off
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|t_symndx
index|[
name|off
operator|/
literal|8
index|]
expr_stmt|;
name|next_r
operator|=
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|t_symndx
index|[
name|off
operator|/
literal|8
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|tls_maskp
argument_list|,
name|locsymsp
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|toc_symndx
operator|!=
name|NULL
condition|)
operator|*
name|toc_symndx
operator|=
name|r_symndx
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|==
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|)
operator|)
operator|&&
operator|(
name|next_r
operator|==
operator|-
literal|1
operator|||
name|next_r
operator|==
operator|-
literal|2
operator|)
condition|)
return|return
literal|1
operator|-
name|next_r
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Adjust all global syms defined in opd sections.  In gcc generated    code these will already have been done, but I suppose we have to    cater for all sorts of hand written assembly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|adjust_opd_syms
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|long
modifier|*
name|opd_adjust
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
return|return
name|TRUE
return|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|adjust_done
condition|)
return|return
name|TRUE
return|;
name|sym_sec
operator|=
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sym_sec
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|opd_adjust
operator|=
name|ppc64_elf_section_data
argument_list|(
name|sym_sec
argument_list|)
operator|->
name|opd
operator|.
name|adjust
operator|)
operator|!=
name|NULL
condition|)
block|{
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+=
name|opd_adjust
index|[
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|/
literal|24
index|]
expr_stmt|;
name|eh
operator|->
name|adjust_done
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Remove unused Official Procedure Descriptor entries.  Currently we    only remove those associated with functions in discarded link-once    sections, or weakly defined functions that have been overridden.  It    would be possible to remove many more entries for statically linked    applications.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_edit_opd
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd_boolean
name|some_edited
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|long
modifier|*
name|adjust
decl_stmt|;
name|bfd_boolean
name|need_edit
decl_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
continue|continue;
name|amt
operator|=
name|sec
operator|->
name|_raw_size
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
literal|24
expr_stmt|;
name|adjust
operator|=
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|opd
operator|.
name|adjust
expr_stmt|;
if|if
condition|(
name|adjust
operator|==
name|NULL
condition|)
block|{
comment|/* Must be a ld -r link.  ie. check_relocs hasn't been 	     called.  */
name|adjust
operator|=
name|bfd_zalloc
argument_list|(
name|obfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|opd
operator|.
name|adjust
operator|=
name|adjust
expr_stmt|;
block|}
name|memset
argument_list|(
name|adjust
argument_list|,
literal|0
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
continue|continue;
comment|/* Look through the section relocs.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|local_syms
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
comment|/* Read the relocations.  */
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* First run through the relocs to check they are sane, and to 	 determine whether we need to edit this opd section.  */
name|need_edit
operator|=
name|FALSE
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
comment|/* .opd contains a regular array of 24 byte entries.  We're 	     only interested in the reloc pointing to a function entry 	     point.  */
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|!=
name|offset
operator|||
name|rel
operator|+
literal|1
operator|>=
name|relend
operator|||
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_offset
operator|!=
name|offset
operator|+
literal|8
condition|)
block|{
comment|/* If someone messes with .opd alignment then after a 		 "ld -r" we might have padding in the middle of .opd. 		 Also, there's nothing to prevent someone putting 		 something silly in .opd with the assembler.  No .opd 		 optimization for them!  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: .opd is not a regular array of opd entries"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|need_edit
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|)
operator|!=
name|R_PPC64_ADDR64
operator|||
operator|(
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
operator|(
name|rel
operator|+
literal|1
operator|)
operator|->
name|r_info
argument_list|)
operator|)
operator|!=
name|R_PPC64_TOC
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unexpected reloc type %u in .opd section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|need_edit
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
name|sym_name
operator|=
name|bfd_elf_local_sym_name
argument_list|(
name|ibfd
argument_list|,
name|sym
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: undefined sym `%s' in .opd section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|need_edit
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* opd entries are always for functions defined in the 	     current input bfd.  If the symbol isn't defined in the 	     input bfd, then we won't be using the function in this 	     bfd;  It must be defined in a linkonce section in another 	     bfd, or is weak.  It's also possible that we are 	     discarding the function due to a linker script /DISCARD/, 	     which we test for via the output_section.  */
if|if
condition|(
name|sym_sec
operator|->
name|owner
operator|!=
name|ibfd
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
name|need_edit
operator|=
name|TRUE
expr_stmt|;
name|offset
operator|+=
literal|24
expr_stmt|;
name|rel
operator|+=
literal|2
expr_stmt|;
comment|/* Allow for the possibility of a reloc on the third word.  */
if|if
condition|(
name|rel
operator|<
name|relend
operator|&&
name|rel
operator|->
name|r_offset
operator|==
name|offset
operator|-
literal|8
condition|)
name|rel
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_edit
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|write_rel
decl_stmt|;
name|bfd_byte
modifier|*
name|rptr
decl_stmt|,
modifier|*
name|wptr
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|;
comment|/* This seems a waste of time as input .opd sections are all 	     zeros as generated by gcc, but I suppose there's no reason 	     this will always be so.  We might start putting something in 	     the third word of .opd entries.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_IN_MEMORY
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|loc
init|=
name|bfd_alloc
argument_list|(
name|ibfd
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
operator|||
operator|!
name|bfd_get_section_contents
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|loc
argument_list|,
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
block|{
name|error_ret
label|:
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sec
operator|->
name|contents
operator|=
name|loc
expr_stmt|;
name|sec
operator|->
name|flags
operator||=
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|relstart
expr_stmt|;
name|wptr
operator|=
name|sec
operator|->
name|contents
expr_stmt|;
name|rptr
operator|=
name|sec
operator|->
name|contents
expr_stmt|;
name|write_rel
operator|=
name|relstart
expr_stmt|;
name|skip
operator|=
name|FALSE
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|==
name|offset
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|fdh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|fdh
operator|=
name|get_fdh
argument_list|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|skip
operator|=
operator|(
name|sym_sec
operator|->
name|owner
operator|!=
name|ibfd
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|sym_sec
operator|->
name|owner
operator|==
name|ibfd
condition|)
block|{
comment|/* Arrange for the function descriptor sym 			     to be dropped.  */
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|sym_sec
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We'll be keeping this opd entry.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Redefine the function descriptor symbol to 			     this location in the opd section.  It is 			     necessary to update the value here rather 			     than using an array of adjustments as we do 			     for local symbols, because various places 			     in the generic ELF code use the value 			     stored in u.def.value.  */
name|fdh
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|wptr
operator|-
name|sec
operator|->
name|contents
expr_stmt|;
name|fdh
operator|->
name|adjust_done
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Local syms are a bit tricky.  We could 			 tweak them as they can be cached, but 			 we'd need to look through the local syms 			 for the function descriptor sym which we 			 don't have at the moment.  So keep an 			 array of adjustments.  */
name|adjust
index|[
name|rel
operator|->
name|r_offset
operator|/
literal|24
index|]
operator|=
name|wptr
operator|-
name|rptr
expr_stmt|;
if|if
condition|(
name|wptr
operator|!=
name|rptr
condition|)
name|memcpy
argument_list|(
name|wptr
argument_list|,
name|rptr
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|wptr
operator|+=
literal|24
expr_stmt|;
block|}
name|rptr
operator|+=
literal|24
expr_stmt|;
name|offset
operator|+=
literal|24
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* We won't be needing dynamic relocs here.  */
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|pp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
elseif|else
if|if
condition|(
name|sym_sec
operator|!=
name|NULL
condition|)
name|pp
operator|=
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|sym_sec
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
else|else
name|pp
operator|=
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We need to adjust any reloc offsets to point to the 		     new opd entries.  While we're at it, we may as well 		     remove redundant relocs.  */
name|rel
operator|->
name|r_offset
operator|+=
name|wptr
operator|-
name|rptr
expr_stmt|;
if|if
condition|(
name|write_rel
operator|!=
name|rel
condition|)
name|memcpy
argument_list|(
name|write_rel
argument_list|,
name|rel
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rel
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|write_rel
expr_stmt|;
block|}
block|}
name|sec
operator|->
name|_cooked_size
operator|=
name|wptr
operator|-
name|sec
operator|->
name|contents
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
name|write_rel
operator|-
name|relstart
expr_stmt|;
comment|/* Fudge the size too, as this is used later in 	     elf_bfd_final_link if we are emitting relocs.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_size
operator|=
name|sec
operator|->
name|reloc_count
operator|*
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|some_edited
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
block|}
if|if
condition|(
name|some_edited
condition|)
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|adjust_opd_syms
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */
end_comment

begin_function
name|asection
modifier|*
name|ppc64_elf_tls_setup
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|tls_get_addr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|htab
operator|->
name|tls_get_addr
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|htab
operator|->
name|tls_get_addr
operator|=
name|h
expr_stmt|;
block|}
return|return
name|_bfd_elf_tls_setup
argument_list|(
name|obfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Run through all the TLS relocs looking for optimization    opportunities.  The linker has been hacked (see ppc64elf.em) to do    a preliminary section layout so that we know the TLS segment    offsets.  We can't optimize earlier because some optimizations need    to know the tp offset, and we need to optimize before allocating    dynamic relocations.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_tls_optimize
parameter_list|(
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|locsyms
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|sec
operator|->
name|has_tls_reloc
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|int
name|expecting_tls_get_addr
decl_stmt|;
comment|/* Read the relocations.  */
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|char
modifier|*
name|tls_mask
decl_stmt|;
name|char
name|tls_set
decl_stmt|,
name|tls_clear
decl_stmt|,
name|tls_type
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_boolean
name|ok_tprel
decl_stmt|,
name|is_local
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
operator|&
name|tls_mask
argument_list|,
operator|&
name|locsyms
argument_list|,
name|r_symndx
argument_list|,
name|ibfd
argument_list|)
condition|)
block|{
name|err_free_rel
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|locsyms
operator|!=
name|NULL
operator|&&
operator|(
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
operator|)
condition|)
name|free
argument_list|(
name|locsyms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
continue|continue;
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sym_sec
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|long
modifier|*
name|adjust
decl_stmt|;
name|adjust
operator|=
name|ppc64_elf_section_data
argument_list|(
name|sym_sec
argument_list|)
operator|->
name|opd
operator|.
name|adjust
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
name|NULL
condition|)
name|value
operator|+=
name|adjust
index|[
name|value
operator|/
literal|24
index|]
expr_stmt|;
block|}
block|}
name|ok_tprel
operator|=
name|FALSE
expr_stmt|;
name|is_local
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
condition|)
block|{
name|is_local
operator|=
name|TRUE
expr_stmt|;
name|value
operator|+=
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|+=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
expr_stmt|;
name|ok_tprel
operator|=
operator|(
name|value
operator|+
name|TP_OFFSET
operator|+
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|<
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
comment|/* These relocs should never be against a symbol 		       defined in a shared lib.  Leave them alone if 		       that turns out to be the case.  */
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|refcount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|is_local
condition|)
continue|continue;
comment|/* LD -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
name|tls_clear
operator|=
name|TLS_LD
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
name|expecting_tls_get_addr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
if|if
condition|(
name|ok_tprel
condition|)
comment|/* GD -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
else|else
comment|/* GD -> IE */
name|tls_set
operator|=
name|TLS_TLS
operator||
name|TLS_TPRELGD
expr_stmt|;
name|tls_clear
operator|=
name|TLS_GD
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
name|expecting_tls_get_addr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_HI
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ok_tprel
condition|)
block|{
comment|/* IE -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
name|tls_clear
operator|=
name|TLS_TPREL
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|==
name|htab
operator|->
name|tls_get_addr
condition|)
block|{
if|if
condition|(
operator|!
name|expecting_tls_get_addr
operator|&&
name|rel
operator|!=
name|relstart
operator|&&
operator|(
operator|(
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC16
operator|)
operator|||
operator|(
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_TOC16_LO
operator|)
operator|)
condition|)
block|{
comment|/* Check for toc tls entries.  */
name|char
modifier|*
name|toc_tls
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|get_tls_mask
argument_list|(
operator|&
name|toc_tls
argument_list|,
name|NULL
argument_list|,
operator|&
name|locsyms
argument_list|,
name|rel
operator|-
literal|1
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
goto|goto
name|err_free_rel
goto|;
if|if
condition|(
name|toc_tls
operator|!=
name|NULL
condition|)
name|expecting_tls_get_addr
operator|=
name|retval
operator|>
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|expecting_tls_get_addr
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|R_PPC64_TPREL64
case|:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ok_tprel
condition|)
block|{
comment|/* IE -> LE */
name|tls_set
operator|=
name|TLS_EXPLICIT
expr_stmt|;
name|tls_clear
operator|=
name|TLS_TPREL
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
case|case
name|R_PPC64_DTPMOD64
case|:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
operator|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
operator|)
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|==
name|rel
operator|->
name|r_offset
operator|+
literal|8
condition|)
block|{
if|if
condition|(
name|ok_tprel
condition|)
comment|/* GD -> LE */
name|tls_set
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_GD
expr_stmt|;
else|else
comment|/* GD -> IE */
name|tls_set
operator|=
name|TLS_EXPLICIT
operator||
name|TLS_GD
operator||
name|TLS_TPRELGD
expr_stmt|;
name|tls_clear
operator|=
name|TLS_GD
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|is_local
condition|)
continue|continue;
comment|/* LD -> LE */
name|tls_set
operator|=
name|TLS_EXPLICIT
expr_stmt|;
name|tls_clear
operator|=
name|TLS_LD
expr_stmt|;
block|}
break|break;
default|default:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|tls_set
operator|&
name|TLS_EXPLICIT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
comment|/* Adjust got entry for this reloc.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|ent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
expr_stmt|;
else|else
name|ent
operator|=
name|elf_local_got_ents
argument_list|(
name|ibfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
for|for
control|(
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|ibfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tls_set
operator|==
literal|0
condition|)
block|{
comment|/* We managed to get rid of a got entry.  */
if|if
condition|(
name|ent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
comment|/* Adjust dynamic relocs.  */
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
comment|/* If we got rid of a DTPMOD/DTPREL reloc 			     pair then we'll lose one or two dyn 			     relocs.  */
if|if
condition|(
name|tls_set
operator|==
operator|(
name|TLS_EXPLICIT
operator||
name|TLS_GD
operator|)
condition|)
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|tls_mask
operator||=
name|tls_set
expr_stmt|;
operator|*
name|tls_mask
operator|&=
operator|~
name|tls_clear
expr_stmt|;
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locsyms
operator|!=
name|NULL
operator|&&
operator|(
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|locsyms
argument_list|)
expr_stmt|;
else|else
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|got_entry
modifier|*
name|gent
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|pent
decl_stmt|;
name|bfd_boolean
name|doneone
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|pent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|pent
operator|!=
name|NULL
condition|;
name|pent
operator|=
name|pent
operator|->
name|next
control|)
if|if
condition|(
name|pent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
argument_list|)
expr_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	       first entry.  */
name|s
operator|=
name|htab
operator|->
name|plt
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_INITIAL_ENTRY_SIZE
expr_stmt|;
name|pent
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make room for this entry.  */
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Make room for the .glink code.  */
name|s
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|GLINK_CALL_STUB_SIZE
expr_stmt|;
comment|/* We need bigger stubs past index 32767.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|>=
name|GLINK_CALL_STUB_SIZE
operator|+
literal|32768
operator|*
literal|2
operator|*
literal|4
condition|)
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|2
operator|*
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|doneone
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|pent
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|doneone
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Run through the TLS GD got entries first if we're changing them      to TPREL.  */
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_TPRELGD
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|gent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
init|;
name|gent
operator|!=
name|NULL
condition|;
name|gent
operator|=
name|gent
operator|->
name|next
control|)
if|if
condition|(
name|gent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
operator|&&
operator|(
name|gent
operator|->
name|tls_type
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This was a GD entry that has been converted to TPREL.  If 	     there happens to be a TPREL entry we can use that one.  */
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
operator|&&
operator|(
name|ent
operator|->
name|tls_type
operator|&
name|TLS_TPREL
operator|)
operator|!=
literal|0
operator|&&
name|ent
operator|->
name|addend
operator|==
name|gent
operator|->
name|addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|gent
operator|->
name|owner
condition|)
block|{
name|gent
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If not, then we'll be using our own TPREL entry.  */
if|if
condition|(
name|gent
operator|->
name|got
operator|.
name|refcount
operator|!=
literal|0
condition|)
name|gent
operator|->
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
block|}
for|for
control|(
name|gent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
init|;
name|gent
operator|!=
name|NULL
condition|;
name|gent
operator|=
name|gent
operator|->
name|next
control|)
if|if
condition|(
name|gent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	   Undefined weak syms won't yet be marked as dynamic, 	   nor will all TLS symbols.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|gent
operator|->
name|tls_type
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
condition|)
block|{
name|gent
operator|->
name|got
operator|.
name|offset
operator|=
name|ppc64_tlsld_got
argument_list|(
name|gent
operator|->
name|owner
argument_list|)
operator|->
name|offset
expr_stmt|;
continue|continue;
block|}
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|gent
operator|->
name|owner
argument_list|)
operator|->
name|got
expr_stmt|;
name|gent
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
operator|(
name|gent
operator|->
name|tls_type
operator|&
name|eh
operator|->
name|tls_mask
operator|&
operator|(
name|TLS_GD
operator||
name|TLS_LD
operator|)
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
operator|)
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
name|ppc64_elf_tdata
argument_list|(
name|gent
operator|->
name|owner
argument_list|)
operator|->
name|relgot
operator|->
name|_raw_size
operator|+=
operator|(
name|gent
operator|->
name|tls_type
operator|&
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_GD
condition|?
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|gent
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for relocs that have become local due to symbol visibility      changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Relocs that use pc_count are those that appear on a call insn, 	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be 	 generated via assembly.  We want calls to protected symbols to 	 resolve directly to the function rather than going via the plt. 	 If people want function pointer comparisons to work as expected 	 then they should avoid writing weird assembly.  */
if|if
condition|(
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also discard relocs on undefined weak syms with non-default 	 visibility.  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|readonly_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|struct
name|got_entry
modifier|*
modifier|*
name|lgot_ents
decl_stmt|;
name|struct
name|got_entry
modifier|*
modifier|*
name|end_lgot_ents
decl_stmt|;
name|char
modifier|*
name|lgot_masks
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
if|if
condition|(
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|got
expr_stmt|;
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|16
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|srel
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|relgot
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|lgot_ents
operator|=
name|elf_local_got_ents
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lgot_ents
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_lgot_ents
operator|=
name|lgot_ents
operator|+
name|locsymcount
expr_stmt|;
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
name|end_lgot_ents
expr_stmt|;
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|got
expr_stmt|;
name|srel
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|relgot
expr_stmt|;
for|for
control|(
init|;
name|lgot_ents
operator|<
name|end_lgot_ents
condition|;
operator|++
name|lgot_ents
operator|,
operator|++
name|lgot_masks
control|)
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
operator|*
name|lgot_ents
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ent
operator|->
name|tls_type
operator|&
operator|*
name|lgot_masks
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|16
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
name|ent
operator|->
name|got
operator|.
name|offset
operator|=
name|ppc64_tlsld_got
argument_list|(
name|ibfd
argument_list|)
operator|->
name|offset
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|(
name|ent
operator|->
name|tls_type
operator|&
operator|*
name|lgot_masks
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|_raw_size
operator|+=
literal|16
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|ent
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* We now have determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Reset _cooked_size since prelim layout will set it wrongly, 	 and a non-zero _cooked_size sticks.  */
name|s
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|brlt
operator|||
name|s
operator|==
name|htab
operator|->
name|relbrlt
condition|)
comment|/* These haven't been allocated yet;  don't strip.  */
continue|continue;
elseif|else
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|got
operator|||
name|s
operator|==
name|htab
operator|->
name|plt
operator|||
name|s
operator|==
name|htab
operator|->
name|glink
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 		 output file.  This is mostly to handle .rela.bss and 		 .rela.plt.  We must create both sections in 		 create_dynamic_sections, because they must be created 		 before the linker maps input sections to output 		 sections.  The linker does that before 		 adjust_dynamic_symbol is called, and it is that 		 function which decides whether anything needs to go 		 into these sections.  */
block|}
else|else
block|{
if|if
condition|(
name|s
operator|!=
name|htab
operator|->
name|relplt
condition|)
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* .plt is in the bss section.  We don't initialise it.  */
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|plt
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  We use bfd_zalloc 	 here in case unused entries are not reclaimed before the 	 section's contents are written out.  This should not happen, 	 but this way if it does we get a R_PPC64_NONE reloc in .rela 	 sections instead of garbage. 	 We also rely on the section contents being zero when writing 	 the GOT.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|got
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|!=
name|htab
operator|->
name|got
condition|)
block|{
name|s
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|ibfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|relgot
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|ibfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|relocs
operator|=
name|TRUE
expr_stmt|;
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in ppc64_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|plt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_GLINK
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|NO_OPD_RELOCS
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_OPD
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_OPDSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If any dynamic relocs apply to a read-only section, 	     then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|readonly_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Determine the type of stub needed, if any, for a call.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|ppc_stub_type
name|ppc_type_of_stub
parameter_list|(
name|asection
modifier|*
name|input_sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|ppc_link_hash_entry
modifier|*
modifier|*
name|hash
parameter_list|,
name|bfd_vma
name|destination
parameter_list|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|h
init|=
operator|*
name|hash
decl_stmt|;
name|bfd_vma
name|location
decl_stmt|;
name|bfd_vma
name|branch_offset
decl_stmt|;
name|bfd_vma
name|max_branch_offset
decl_stmt|;
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|oh
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|oh
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|oh
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
operator|*
name|hash
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|oh
expr_stmt|;
return|return
name|ppc_stub_plt_call
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|==
name|NULL
condition|)
return|return
name|ppc_stub_none
return|;
block|}
comment|/* Determine where the call point is.  */
name|location
operator|=
operator|(
name|input_sec
operator|->
name|output_offset
operator|+
name|input_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|branch_offset
operator|=
name|destination
operator|-
name|location
expr_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Determine if a long branch stub is needed.  */
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_PPC64_REL24
condition|)
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|15
expr_stmt|;
if|if
condition|(
name|branch_offset
operator|+
name|max_branch_offset
operator|>=
literal|2
operator|*
name|max_branch_offset
condition|)
comment|/* We need a stub.  Figure out whether a long_branch or plt_branch        is needed later.  */
return|return
name|ppc_stub_long_branch
return|;
return|return
name|ppc_stub_none
return|;
block|}
end_function

begin_comment
comment|/* Build a .plt call stub.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_byte
modifier|*
name|build_plt_stub
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
define|#
directive|define
name|PPC_LO
parameter_list|(
name|v
parameter_list|)
value|((v)& 0xffff)
define|#
directive|define
name|PPC_HI
parameter_list|(
name|v
parameter_list|)
value|(((v)>> 16)& 0xffff)
define|#
directive|define
name|PPC_HA
parameter_list|(
name|v
parameter_list|)
value|PPC_HI ((v) + 0x8000)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R2
operator||
name|PPC_HA
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|STD_R2_40R1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|offset
operator|+
literal|8
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|offset
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R12
operator||
literal|1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R2_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|offset
operator|+
literal|8
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|offset
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R12
operator||
literal|1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|MTCTR_R11
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|BCTR
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ppc_build_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|ppc_branch_hash_entry
modifier|*
name|br_entry
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|ppc_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|info
operator|=
name|in_arg
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Make a note of the offset within the stubs for this entry.  */
name|stub_entry
operator|->
name|stub_offset
operator|=
name|stub_entry
operator|->
name|stub_sec
operator|->
name|_cooked_size
expr_stmt|;
name|loc
operator|=
name|stub_entry
operator|->
name|stub_sec
operator|->
name|contents
operator|+
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
name|htab
operator|->
name|stub_count
index|[
name|stub_entry
operator|->
name|stub_type
operator|-
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|stub_entry
operator|->
name|stub_type
condition|)
block|{
case|case
name|ppc_stub_long_branch
case|:
case|case
name|ppc_stub_long_branch_r2off
case|:
comment|/* Branches are relative.  This is where we are going to.  */
name|off
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* And this is where we are coming from.  */
name|off
operator|-=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|!=
name|ppc_stub_long_branch_r2off
condition|)
name|size
operator|=
literal|4
expr_stmt|;
else|else
block|{
name|bfd_vma
name|r2off
decl_stmt|;
name|r2off
operator|=
operator|(
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|target_section
operator|->
name|id
index|]
operator|.
name|toc_off
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|STD_R2_40R1
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDIS_R2_R2
operator||
name|PPC_HA
argument_list|(
name|r2off
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDI_R2_R2
operator||
name|PPC_LO
argument_list|(
name|r2off
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|off
operator|-=
literal|12
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|B_DOT
operator||
operator|(
name|off
operator|&
literal|0x3fffffc
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|+
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|<
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
literal|26
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ppc_stub_plt_branch
case|:
case|case
name|ppc_stub_plt_branch_r2off
case|:
name|br_entry
operator|=
name|ppc_branch_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|branch_hash_table
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|br_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"can't find branch stub `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|off
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|htab
operator|->
name|brlt
operator|->
name|owner
argument_list|,
name|off
argument_list|,
name|htab
operator|->
name|brlt
operator|->
name|contents
operator|+
name|br_entry
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Create a reloc for the branch lookup table entry.  */
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|rl
decl_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|br_entry
operator|->
name|offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|off
expr_stmt|;
name|rl
operator|=
name|htab
operator|->
name|relbrlt
operator|->
name|contents
expr_stmt|;
name|rl
operator|+=
name|htab
operator|->
name|relbrlt
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|htab
operator|->
name|relbrlt
operator|->
name|owner
argument_list|,
operator|&
name|rela
argument_list|,
name|rl
argument_list|)
expr_stmt|;
block|}
name|off
operator|=
operator|(
name|br_entry
operator|->
name|offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|brlt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|brlt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
literal|0x80008000
operator|>
literal|0xffffffff
operator|||
operator|(
name|off
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"linkage table error against `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|indx
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|!=
name|ppc_stub_plt_branch_r2off
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDIS_R12_R2
operator||
name|PPC_HA
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|r2off
decl_stmt|;
name|r2off
operator|=
operator|(
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|target_section
operator|->
name|id
index|]
operator|.
name|toc_off
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|STD_R2_40R1
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDIS_R12_R2
operator||
name|PPC_HA
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|indx
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDIS_R2_R2
operator||
name|PPC_HA
argument_list|(
name|r2off
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|ADDI_R2_R2
operator||
name|PPC_LO
argument_list|(
name|r2off
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|size
operator|=
literal|28
expr_stmt|;
block|}
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|MTCTR_R11
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|BCTR
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ppc_stub_plt_call
case|:
comment|/* Do the best we can for shared libraries built without 	 exporting ".foo" for each "foo".  This can happen when symbol 	 versioning scripts strip all bar a subset of symbols.  */
if|if
condition|(
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* Point the symbol at the stub.  There may be multiple stubs, 	     we don't really care;  The main thing is to make this sym 	     defined somewhere.  Maybe defining the symbol in the stub 	     section is a silly idea.  If we didn't do this, htab->top_id 	     could disappear.  */
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|stub_entry
operator|->
name|stub_sec
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
block|}
comment|/* Now build the stub.  */
name|off
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|stub_entry
operator|->
name|addend
condition|)
block|{
name|off
operator|=
name|ent
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
name|off
operator|+=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
literal|0x80008000
operator|>
literal|0xffffffff
operator|||
operator|(
name|off
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"linkage table error against `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p
operator|=
name|build_plt_stub
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|loc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|size
operator|=
name|p
operator|-
name|loc
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|stub_entry
operator|->
name|stub_sec
operator|->
name|_cooked_size
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|emit_stub_syms
operator|&&
operator|!
operator|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
operator|&&
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|stub_entry
operator|->
name|stub_sec
operator|&&
name|stub_entry
operator|->
name|h
operator|->
name|oh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|stub_entry
operator|->
name|stub_offset
operator|)
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|stub_entry
operator|->
name|stub_sec
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|=
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_FORCED_LOCAL
operator|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* As above, but don't actually build the stub.  Just bump offset so    we know stub section sizes, and select plt_branch stubs where    long_branch stubs won't do.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_size_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|ppc_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|info
operator|=
name|in_arg
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|off
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|stub_entry
operator|->
name|addend
condition|)
block|{
name|off
operator|=
name|ent
operator|->
name|plt
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|+=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|htab
operator|->
name|stub_group
index|[
name|stub_entry
operator|->
name|id_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
expr_stmt|;
name|size
operator|=
name|PLT_CALL_STUB_SIZE
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|off
operator|+
literal|16
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|off
argument_list|)
condition|)
name|size
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* ppc_stub_long_branch or ppc_stub_plt_branch, or their r2off 	 variants.  */
name|off
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|off
operator|-=
operator|(
name|stub_entry
operator|->
name|stub_sec
operator|->
name|_raw_size
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Reset the stub type from the plt variant in case we now 	 can reach with a shorter stub.  */
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|>=
name|ppc_stub_plt_branch
condition|)
name|stub_entry
operator|->
name|stub_type
operator|+=
name|ppc_stub_long_branch
operator|-
name|ppc_stub_plt_branch
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_long_branch_r2off
condition|)
block|{
name|off
operator|-=
literal|12
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
block|}
comment|/* If the branch offset if too big, use a ppc_stub_plt_branch.  */
if|if
condition|(
name|off
operator|+
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|>=
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
literal|26
argument_list|)
condition|)
block|{
name|struct
name|ppc_branch_hash_entry
modifier|*
name|br_entry
decl_stmt|;
name|br_entry
operator|=
name|ppc_branch_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|branch_hash_table
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|br_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"can't build branch stub `%s'"
argument_list|)
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
operator|+
literal|9
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|br_entry
operator|->
name|iter
operator|!=
name|htab
operator|->
name|stub_iteration
condition|)
block|{
name|br_entry
operator|->
name|iter
operator|=
name|htab
operator|->
name|stub_iteration
expr_stmt|;
name|br_entry
operator|->
name|offset
operator|=
name|htab
operator|->
name|brlt
operator|->
name|_raw_size
expr_stmt|;
name|htab
operator|->
name|brlt
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|relbrlt
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
name|stub_entry
operator|->
name|stub_type
operator|+=
name|ppc_stub_plt_branch
operator|-
name|ppc_stub_long_branch
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|!=
name|ppc_stub_plt_branch
condition|)
name|size
operator|=
literal|28
expr_stmt|;
block|}
block|}
name|stub_entry
operator|->
name|stub_sec
operator|->
name|_raw_size
operator|+=
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set up various things so that we can make a list of input sections    for each output section included in the link.  Returns -1 on error,    0 when no stubs will be needed, and 1 on success.  */
end_comment

begin_function
name|int
name|ppc64_elf_setup_section_lists
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|int
name|top_id
decl_stmt|,
name|top_index
decl_stmt|,
name|id
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|brlt
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Find the top input section id.  */
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|top_id
operator|=
literal|3
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|top_id
operator|<
name|section
operator|->
name|id
condition|)
name|top_id
operator|=
name|section
operator|->
name|id
expr_stmt|;
block|}
block|}
name|htab
operator|->
name|top_id
operator|=
name|top_id
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|map_stub
argument_list|)
operator|*
operator|(
name|top_id
operator|+
literal|1
operator|)
expr_stmt|;
name|htab
operator|->
name|stub_group
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|stub_group
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set toc_off for com, und, abs and ind sections.  */
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
literal|3
condition|;
name|id
operator|++
control|)
name|htab
operator|->
name|stub_group
index|[
name|id
index|]
operator|.
name|toc_off
operator|=
name|TOC_BASE_OFF
expr_stmt|;
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|=
name|htab
operator|->
name|toc_curr
operator|=
name|ppc64_elf_toc
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* We can't use output_bfd->section_count here to find the top output      section index as some sections may have been removed, and      _bfd_strip_section_from_output doesn't renumber the indices.  */
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
operator|,
name|top_index
operator|=
literal|0
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|top_index
operator|<
name|section
operator|->
name|index
condition|)
name|top_index
operator|=
name|section
operator|->
name|index
expr_stmt|;
block|}
name|htab
operator|->
name|top_index
operator|=
name|top_index
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|*
operator|(
name|top_index
operator|+
literal|1
operator|)
expr_stmt|;
name|input_list
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|htab
operator|->
name|input_list
operator|=
name|input_list
expr_stmt|;
if|if
condition|(
name|input_list
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The linker repeatedly calls this function for each TOC input section    and linker generated GOT section.  Group input bfds such that the toc    within a group is less than 64k in size.  Will break with cute linker    scripts that play games with dot in the output toc section.  */
end_comment

begin_function
name|void
name|ppc64_elf_next_toc_section
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|no_multi_toc
condition|)
block|{
name|bfd_vma
name|addr
init|=
name|isec
operator|->
name|output_offset
operator|+
name|isec
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
name|bfd_vma
name|off
init|=
name|addr
operator|-
name|htab
operator|->
name|toc_curr
decl_stmt|;
if|if
condition|(
name|off
operator|+
name|isec
operator|->
name|_raw_size
operator|>
literal|0x10000
condition|)
block|{
name|htab
operator|->
name|toc_curr
operator|=
name|addr
expr_stmt|;
name|htab
operator|->
name|multi_toc_needed
operator|=
literal|1
expr_stmt|;
block|}
name|elf_gp
argument_list|(
name|isec
operator|->
name|owner
argument_list|)
operator|=
operator|(
name|htab
operator|->
name|toc_curr
operator|-
name|elf_gp
argument_list|(
name|isec
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|+
name|TOC_BASE_OFF
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after the last call to the above function.  */
end_comment

begin_function
name|void
name|ppc64_elf_reinit_toc
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* toc_curr tracks the TOC offset used for code sections below in      ppc64_elf_next_input_section.  Start off at 0x8000.  */
name|htab
operator|->
name|toc_curr
operator|=
name|TOC_BASE_OFF
expr_stmt|;
block|}
end_function

begin_comment
comment|/* No toc references were found in ISEC.  If the code in ISEC makes no    calls, then there's no need to use toc adjusting stubs when branching    into ISEC.  Actually, indirect calls from ISEC are OK as they will    load r2.  */
end_comment

begin_function
specifier|static
name|int
name|toc_adjusting_stub_needed
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|branch_ok
decl_stmt|;
comment|/* We know none of our code bearing sections will need toc stubs.  */
if|if
condition|(
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isec
operator|->
name|_raw_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Hack for linux kernel.  .fixup contains branches, but only back to      the function that hit an exception.  */
name|branch_ok
operator|=
name|strcmp
argument_list|(
name|isec
operator|->
name|name
argument_list|,
literal|".fixup"
argument_list|)
operator|==
literal|0
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|isec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|isec
operator|->
name|owner
argument_list|,
name|isec
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|isec
operator|->
name|_raw_size
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|info
operator|->
name|keep_memory
condition|)
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
comment|/* Code scan, because we don't necessarily have relocs on calls to      static functions.  */
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isec
operator|->
name|_raw_size
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|unsigned
name|long
name|insn
init|=
name|bfd_get_32
argument_list|(
name|isec
operator|->
name|owner
argument_list|,
name|contents
operator|+
name|i
argument_list|)
decl_stmt|;
comment|/* Is this a branch?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator|)
operator|==
operator|(
literal|18
operator|<<
literal|26
operator|)
comment|/* If branch and link, it's a function call.  */
operator|&&
operator|(
operator|(
name|insn
operator|&
literal|1
operator|)
operator|!=
literal|0
comment|/* Sibling calls use a plain branch.  I don't know a way 		 of deciding whether a branch is really a sibling call.  */
operator|||
operator|!
name|branch_ok
operator|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* The linker repeatedly calls this function for each input section,    in the order that input sections are linked into output sections.    Build lists of input sections to determine groupings between which    we may insert linker stubs.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_next_input_section
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|isec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
operator|&&
name|isec
operator|->
name|output_section
operator|->
name|index
operator|<=
name|htab
operator|->
name|top_index
condition|)
block|{
name|asection
modifier|*
modifier|*
name|list
init|=
name|htab
operator|->
name|input_list
operator|+
name|isec
operator|->
name|output_section
operator|->
name|index
decl_stmt|;
comment|/* Steal the link_sec pointer for our list.  */
define|#
directive|define
name|PREV_SEC
parameter_list|(
name|sec
parameter_list|)
value|(htab->stub_group[(sec)->id].link_sec)
comment|/* This happens to make the list in reverse order, 	 which is what we want.  */
name|PREV_SEC
argument_list|(
name|isec
argument_list|)
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|isec
expr_stmt|;
block|}
comment|/* If a code section has a function that uses the TOC then we need      to use the right TOC (obviously).  Also, make sure that .opd gets      the correct TOC value for R_PPC64_TOC relocs that don't have or      can't find their function symbol (shouldn't ever happen now).  */
if|if
condition|(
name|isec
operator|->
name|has_gp_reloc
operator|||
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|elf_gp
argument_list|(
name|isec
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
name|htab
operator|->
name|toc_curr
operator|=
name|elf_gp
argument_list|(
name|isec
operator|->
name|owner
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ret
operator|=
name|toc_adjusting_stub_needed
argument_list|(
name|info
argument_list|,
name|isec
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
else|else
name|isec
operator|->
name|has_gp_reloc
operator|=
name|ret
expr_stmt|;
comment|/* Functions that don't use the TOC can belong in any TOC group.      Use the last TOC base.  This happens to make _init and _fini      pasting work.  */
name|htab
operator|->
name|stub_group
index|[
name|isec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|=
name|htab
operator|->
name|toc_curr
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* See whether we can group stub sections together.  Grouping stub    sections may result in fewer stubs.  More importantly, we need to    put all .init* and .fini* stubs at the beginning of the .init or    .fini output sections respectively, because glibc splits the    _init and _fini functions into multiple parts.  Putting a stub in    the middle of a function is not a good idea.  */
end_comment

begin_function
specifier|static
name|void
name|group_sections
parameter_list|(
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
parameter_list|,
name|bfd_size_type
name|stub_group_size
parameter_list|,
name|bfd_boolean
name|stubs_always_before_branch
parameter_list|)
block|{
name|asection
modifier|*
modifier|*
name|list
init|=
name|htab
operator|->
name|input_list
operator|+
name|htab
operator|->
name|top_index
decl_stmt|;
do|do
block|{
name|asection
modifier|*
name|tail
init|=
operator|*
name|list
decl_stmt|;
while|while
condition|(
name|tail
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|curr
decl_stmt|;
name|asection
modifier|*
name|prev
decl_stmt|;
name|bfd_size_type
name|total
decl_stmt|;
name|bfd_boolean
name|big_sec
decl_stmt|;
name|bfd_vma
name|curr_toc
decl_stmt|;
name|curr
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|tail
operator|->
name|_cooked_size
condition|)
name|total
operator|=
name|tail
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|total
operator|=
name|tail
operator|->
name|_raw_size
expr_stmt|;
name|big_sec
operator|=
name|total
operator|>=
name|stub_group_size
expr_stmt|;
name|curr_toc
operator|=
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|toc_off
expr_stmt|;
while|while
condition|(
operator|(
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|curr
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|total
operator|+=
name|curr
operator|->
name|output_offset
operator|-
name|prev
operator|->
name|output_offset
operator|)
operator|<
name|stub_group_size
operator|)
operator|&&
name|htab
operator|->
name|stub_group
index|[
name|prev
operator|->
name|id
index|]
operator|.
name|toc_off
operator|==
name|curr_toc
condition|)
name|curr
operator|=
name|prev
expr_stmt|;
comment|/* OK, the size from the start of CURR to the end is less 	     than stub_group_size and thus can be handled by one stub 	     section.  (or the tail section is itself larger than 	     stub_group_size, in which case we may be toast.)  We 	     should really be keeping track of the total size of stubs 	     added here, as stubs contribute to the final output 	     section size.  That's a little tricky, and this way will 	     only break if stubs added make the total size more than 	     2^25, ie. for the default stub_group_size, if stubs total 	     more than 2097152 bytes, or nearly 75000 plt call stubs.  */
do|do
block|{
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Set up this stub group.  */
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|link_sec
operator|=
name|curr
expr_stmt|;
block|}
do|while
condition|(
name|tail
operator|!=
name|curr
operator|&&
operator|(
name|tail
operator|=
name|prev
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* But wait, there's more!  Input sections up to stub_group_size 	     bytes before the stub section can be handled by it too. 	     Don't do this if we have a really large section after the 	     stubs, as adding more stubs increases the chance that 	     branches may not reach into the stub section.  */
if|if
condition|(
operator|!
name|stubs_always_before_branch
operator|&&
operator|!
name|big_sec
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|prev
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|total
operator|+=
name|tail
operator|->
name|output_offset
operator|-
name|prev
operator|->
name|output_offset
operator|)
operator|<
name|stub_group_size
operator|)
operator|&&
name|htab
operator|->
name|stub_group
index|[
name|prev
operator|->
name|id
index|]
operator|.
name|toc_off
operator|==
name|curr_toc
condition|)
block|{
name|tail
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|link_sec
operator|=
name|curr
expr_stmt|;
block|}
block|}
name|tail
operator|=
name|prev
expr_stmt|;
block|}
block|}
do|while
condition|(
name|list
operator|--
operator|!=
name|htab
operator|->
name|input_list
condition|)
do|;
name|free
argument_list|(
name|htab
operator|->
name|input_list
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PREV_SEC
block|}
end_function

begin_comment
comment|/* Determine and set the size of the stub section for a final link.     The basic idea here is to examine all the relocations looking for    PC-relative calls to a target that is unreachable with a "bl"    instruction.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_size_stubs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_signed_vma
name|group_size
parameter_list|,
name|asection
modifier|*
function_decl|(
modifier|*
name|add_stub_section
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|layout_sections_again
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|bfd_size_type
name|stub_group_size
decl_stmt|;
name|bfd_boolean
name|stubs_always_before_branch
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* Stash our params away.  */
name|htab
operator|->
name|add_stub_section
operator|=
name|add_stub_section
expr_stmt|;
name|htab
operator|->
name|layout_sections_again
operator|=
name|layout_sections_again
expr_stmt|;
name|stubs_always_before_branch
operator|=
name|group_size
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|group_size
operator|<
literal|0
condition|)
name|stub_group_size
operator|=
operator|-
name|group_size
expr_stmt|;
else|else
name|stub_group_size
operator|=
name|group_size
expr_stmt|;
if|if
condition|(
name|stub_group_size
operator|==
literal|1
condition|)
block|{
comment|/* Default values.  */
if|if
condition|(
name|stubs_always_before_branch
condition|)
block|{
name|stub_group_size
operator|=
literal|0x1e00000
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|has_14bit_branch
condition|)
name|stub_group_size
operator|=
literal|0x7800
expr_stmt|;
block|}
else|else
block|{
name|stub_group_size
operator|=
literal|0x1c00000
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|has_14bit_branch
condition|)
name|stub_group_size
operator|=
literal|0x7000
expr_stmt|;
block|}
block|}
name|group_sections
argument_list|(
name|htab
argument_list|,
name|stub_group_size
argument_list|,
name|stubs_always_before_branch
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|unsigned
name|int
name|bfd_indx
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|bfd_boolean
name|stub_changed
decl_stmt|;
name|htab
operator|->
name|stub_iteration
operator|+=
literal|1
expr_stmt|;
name|stub_changed
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_indx
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
init|=
name|NULL
decl_stmt|;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
comment|/* Walk over each section attached to the input bfd.  */
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|,
modifier|*
name|irelaend
decl_stmt|,
modifier|*
name|irela
decl_stmt|;
comment|/* If there aren't any relocs, then there's nothing more 		 to do.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this section is a link-once section that will be 		 discarded, then don't create any stubs.  */
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|section
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|output_bfd
condition|)
continue|continue;
comment|/* Get the relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_local
goto|;
comment|/* Now examine each relocation.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|int
name|r_indx
decl_stmt|;
name|enum
name|ppc_stub_type
name|stub_type
decl_stmt|;
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|bfd_vma
name|destination
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|stub_name
decl_stmt|;
specifier|const
name|asection
modifier|*
name|id_sec
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_indx
operator|=
name|ELF64_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>=
name|R_PPC64_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
comment|/* Only look for stubs on branch instructions.  */
if|if
condition|(
name|r_type
operator|!=
name|R_PPC64_REL24
operator|&&
name|r_type
operator|!=
name|R_PPC64_REL14
operator|&&
name|r_type
operator|!=
name|R_PPC64_REL14_BRTAKEN
operator|&&
name|r_type
operator|!=
name|R_PPC64_REL14_BRNTAKEN
condition|)
continue|continue;
comment|/* Now determine the call target, its name, value, 		     section.  */
name|destination
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|r_indx
argument_list|,
name|input_bfd
argument_list|)
condition|)
goto|goto
name|error_ret_free_internal
goto|;
name|hash
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
block|{
comment|/* It's a local symbol.  */
name|sym_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|irela
operator|->
name|r_addend
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's an external symbol.  */
name|sym_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_value
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|irela
operator|->
name|r_addend
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
empty_stmt|;
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
block|}
comment|/* Determine what (if any) linker stub is needed.  */
name|stub_type
operator|=
name|ppc_type_of_stub
argument_list|(
name|section
argument_list|,
name|irela
argument_list|,
operator|&
name|hash
argument_list|,
name|destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_type
operator|!=
name|ppc_stub_plt_call
condition|)
block|{
comment|/* Check whether we need a TOC adjusting stub. 			 Since the linker pastes together pieces from 			 different object files when creating the 			 _init and _fini functions, it may be that a 			 call to what looks like a local sym is in 			 fact a call needing a TOC adjustment.  */
if|if
condition|(
name|sym_sec
operator|!=
name|NULL
operator|&&
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
operator|(
name|htab
operator|->
name|stub_group
index|[
name|sym_sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|!=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
operator|&&
name|sym_sec
operator|->
name|has_gp_reloc
operator|&&
name|section
operator|->
name|has_gp_reloc
condition|)
name|stub_type
operator|=
name|ppc_stub_long_branch_r2off
expr_stmt|;
block|}
if|if
condition|(
name|stub_type
operator|==
name|ppc_stub_none
condition|)
continue|continue;
comment|/* __tls_get_addr calls might be eliminated.  */
if|if
condition|(
name|stub_type
operator|!=
name|ppc_stub_plt_call
operator|&&
name|hash
operator|!=
name|NULL
operator|&&
operator|&
name|hash
operator|->
name|elf
operator|==
name|htab
operator|->
name|tls_get_addr
operator|&&
name|section
operator|->
name|has_tls_reloc
operator|&&
name|irela
operator|!=
name|internal_relocs
condition|)
block|{
comment|/* Get tls info.  */
name|char
modifier|*
name|tls_mask
decl_stmt|;
if|if
condition|(
operator|!
name|get_tls_mask
argument_list|(
operator|&
name|tls_mask
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_syms
argument_list|,
name|irela
operator|-
literal|1
argument_list|,
name|input_bfd
argument_list|)
condition|)
goto|goto
name|error_ret_free_internal
goto|;
if|if
condition|(
operator|*
name|tls_mask
operator|!=
literal|0
condition|)
continue|continue;
block|}
comment|/* Support for grouping stub sections.  */
name|id_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
comment|/* Get the name of this stub.  */
name|stub_name
operator|=
name|ppc_stub_name
argument_list|(
name|id_sec
argument_list|,
name|sym_sec
argument_list|,
name|hash
argument_list|,
name|irela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_name
condition|)
goto|goto
name|error_ret_free_internal
goto|;
name|stub_entry
operator|=
name|ppc_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|!=
name|NULL
condition|)
block|{
comment|/* The proper stub has already been created.  */
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stub_entry
operator|=
name|ppc_add_stub
argument_list|(
name|stub_name
argument_list|,
name|section
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
name|error_ret_free_internal
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|error_ret_free_local
label|:
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
operator|)
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|stub_entry
operator|->
name|stub_type
operator|=
name|stub_type
expr_stmt|;
name|stub_entry
operator|->
name|target_value
operator|=
name|sym_value
expr_stmt|;
name|stub_entry
operator|->
name|target_section
operator|=
name|sym_sec
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|=
name|hash
expr_stmt|;
name|stub_entry
operator|->
name|addend
operator|=
name|irela
operator|->
name|r_addend
expr_stmt|;
name|stub_changed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We're done with the internal relocs, free them.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|stub_changed
condition|)
break|break;
comment|/* OK, we've added some stubs.  Find out the new size of the 	 stub sections.  */
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|stub_sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
name|stub_sec
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|stub_sec
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
block|}
name|htab
operator|->
name|brlt
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|brlt
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|htab
operator|->
name|relbrlt
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|relbrlt
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|ppc_size_one_stub
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Ask the linker to do its stuff.  */
call|(
modifier|*
name|htab
operator|->
name|layout_sections_again
call|)
argument_list|()
expr_stmt|;
block|}
comment|/* It would be nice to strip .branch_lt from the output if the      section is empty, but it's too late.  If we strip sections here,      the dynamic symbol table is corrupted since the section symbol      for the stripped section isn't written.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called after we have determined section placement.  If sections    move, we'll be called again.  Provide a value for TOCstart.  */
end_comment

begin_function
name|bfd_vma
name|ppc64_elf_toc
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* The TOC consists of sections .got, .toc, .tocbss, .plt in that      order.  The TOC starts where the first of these sections starts.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".toc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".tocbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* This may happen for 	 o  references to TOC base (SYM@toc / TOC[tc0]) without a 	 .toc directive 	 o  bad linker script 	 o --gc-sections and empty TOC sections  	 FIXME: Warn user?  */
comment|/* Look for a likely section.  We probably won't even be 	 using TOCstart.  */
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
name|SEC_ALLOC
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
name|SEC_ALLOC
condition|)
break|break;
block|}
name|TOCstart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|TOCstart
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
return|return
name|TOCstart
return|;
block|}
end_function

begin_comment
comment|/* Build all the stubs associated with the current output file.    The stubs are kept in a hash table attached to the main linker    hash table.  This function is called via gldelf64ppc_finish.  */
end_comment

begin_function
name|bfd_boolean
name|ppc64_elf_build_stubs
parameter_list|(
name|bfd_boolean
name|emit_stub_syms
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|char
modifier|*
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|int
name|stub_sec_count
init|=
literal|0
decl_stmt|;
name|htab
operator|->
name|emit_stub_syms
operator|=
name|emit_stub_syms
expr_stmt|;
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|stub_sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Allocate memory to hold the linker stubs.  */
name|size
operator|=
name|stub_sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|stub_sec
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|stub_sec
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|indx
decl_stmt|;
name|bfd_vma
name|plt0
decl_stmt|;
comment|/* Build the .glink plt call stub.  */
name|plt0
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|-
operator|(
name|htab
operator|->
name|glink
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_offset
operator|+
name|GLINK_CALL_STUB_SIZE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|plt0
operator|+
literal|0x80008000
operator|>
literal|0xffffffff
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|".glink and .plt too far apart"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|emit_stub_syms
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
literal|"__glink"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|=
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_FORCED_LOCAL
operator|)
expr_stmt|;
block|}
block|}
name|p
operator|=
name|htab
operator|->
name|glink
operator|->
name|contents
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|MFCTR_R12
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|SLDI_R11_R0_3
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|ADDIC_R2_R0_32K
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|SUB_R12_R12_R11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|SRADI_R2_R2_63
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|SLDI_R11_R0_2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|AND_R2_R2_R11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|SUB_R12_R12_R11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|ADD_R12_R12_R2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|ADDIS_R12_R12
operator||
name|PPC_HA
argument_list|(
name|plt0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|plt0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|ADDI_R12_R12
operator||
name|PPC_LO
argument_list|(
name|plt0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LD_R2_0R12
operator||
literal|8
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|MTCTR_R11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LD_R11_0R12
operator||
literal|16
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|BCTR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* Build the .glink lazy link call stubs.  */
name|indx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|htab
operator|->
name|glink
operator|->
name|contents
operator|+
name|htab
operator|->
name|glink
operator|->
name|_raw_size
condition|)
block|{
if|if
condition|(
name|indx
operator|<
literal|0x8000
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LI_R0_0
operator||
name|indx
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|LIS_R0_0
operator||
name|PPC_HI
argument_list|(
name|indx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|ORI_R0_R0_0
operator||
name|PPC_LO
argument_list|(
name|indx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|glink
operator|->
name|owner
argument_list|,
name|B_DOT
operator||
operator|(
operator|(
name|htab
operator|->
name|glink
operator|->
name|contents
operator|-
name|p
operator|)
operator|&
literal|0x3fffffc
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|htab
operator|->
name|glink
operator|->
name|_cooked_size
operator|=
name|p
operator|-
name|htab
operator|->
name|glink
operator|->
name|contents
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|brlt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|brlt
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|brlt
operator|->
name|owner
argument_list|,
name|htab
operator|->
name|brlt
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|brlt
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|htab
operator|->
name|relbrlt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|relbrlt
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|relbrlt
operator|->
name|owner
argument_list|,
name|htab
operator|->
name|relbrlt
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|relbrlt
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Build the stubs as directed by the stub hash table.  */
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|ppc_build_one_stub
argument_list|,
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|stub_sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
name|stub_sec_count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|->
name|_raw_size
operator|!=
name|stub_sec
operator|->
name|_cooked_size
condition|)
break|break;
block|}
if|if
condition|(
name|stub_sec
operator|!=
name|NULL
operator|||
name|htab
operator|->
name|glink
operator|->
name|_raw_size
operator|!=
name|htab
operator|->
name|glink
operator|->
name|_cooked_size
condition|)
block|{
name|htab
operator|->
name|stub_error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stubs don't match calculated size"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|stub_error
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|stats
operator|!=
name|NULL
condition|)
block|{
operator|*
name|stats
operator|=
name|bfd_malloc
argument_list|(
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|stats
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sprintf
argument_list|(
operator|*
name|stats
argument_list|,
name|_
argument_list|(
literal|"linker stubs in %u groups\n"
literal|"  branch       %lu\n"
literal|"  toc adjust   %lu\n"
literal|"  long branch  %lu\n"
literal|"  long toc adj %lu\n"
literal|"  plt call     %lu"
argument_list|)
argument_list|,
name|stub_sec_count
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_long_branch
operator|-
literal|1
index|]
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_long_branch_r2off
operator|-
literal|1
index|]
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_plt_branch
operator|-
literal|1
index|]
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_plt_branch_r2off
operator|-
literal|1
index|]
argument_list|,
name|htab
operator|->
name|stub_count
index|[
name|ppc_stub_plt_call
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjust the section contents as    necessary, and (if using Rela relocs and generating a    relocatable output file) adjusting the reloc addend as    necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|struct
name|got_entry
modifier|*
modifier|*
name|local_got_ents
decl_stmt|;
name|bfd_vma
name|TOCstart
decl_stmt|;
name|bfd_boolean
name|ret
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|is_opd
decl_stmt|;
comment|/* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
name|bfd_boolean
name|is_power4
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* Initialize howto table if needed.  */
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
name|ppc_howto_init
argument_list|()
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|local_got_ents
operator|=
name|elf_local_got_ents
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|TOCstart
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|is_opd
operator|=
name|ppc64_elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|opd
operator|.
name|adjust
operator|!=
name|NULL
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|,
name|toc_symndx
decl_stmt|;
name|char
name|tls_mask
decl_stmt|,
name|tls_gd
decl_stmt|,
name|tls_type
decl_stmt|;
name|char
name|sym_type
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_boolean
name|warned
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|ppc_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|bfd_vma
name|max_br_offset
decl_stmt|;
name|bfd_vma
name|from
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* For old style R_PPC64_TOC relocs with a zero symbol, use the 	 symbol of the previous ADDR64 reloc.  The symbol gives us the 	 proper TOC base to use.  */
if|if
condition|(
name|rel
operator|->
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_TOC
argument_list|)
operator|&&
name|rel
operator|!=
name|relocs
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_PPC64_ADDR64
operator|&&
name|is_opd
condition|)
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
index|[
operator|-
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym_name
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|warned
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* It's a local symbol.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_local_sym_name
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|sym_type
operator|=
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|long
modifier|*
name|opd_sym_adjust
decl_stmt|;
name|opd_sym_adjust
operator|=
name|ppc64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|opd
operator|.
name|adjust
expr_stmt|;
if|if
condition|(
name|opd_sym_adjust
operator|!=
name|NULL
condition|)
name|relocation
operator|+=
name|opd_sym_adjust
index|[
name|sym
operator|->
name|st_value
operator|/
literal|24
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|sym_type
operator|=
name|h
operator|->
name|type
expr_stmt|;
block|}
comment|/* TLS optimizations.  Replace instruction sequences and relocs 	 based on information we collected in tls_optimize.  We edit 	 RELOCS so that --emit-relocs will output something sensible 	 for the final instruction stream.  */
name|tls_mask
operator|=
literal|0
expr_stmt|;
name|tls_gd
operator|=
literal|0
expr_stmt|;
name|toc_symndx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_PPC64_TLS_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|tls_mask
operator|=
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|tls_mask
expr_stmt|;
elseif|else
if|if
condition|(
name|local_got_ents
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|lgot_masks
decl_stmt|;
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_ents
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|tls_mask
operator|=
name|lgot_masks
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
if|if
condition|(
name|tls_mask
operator|==
literal|0
operator|&&
name|r_type
operator|==
name|R_PPC64_TLS
condition|)
block|{
comment|/* Check for toc tls entries.  */
name|char
modifier|*
name|toc_tls
decl_stmt|;
if|if
condition|(
operator|!
name|get_tls_mask
argument_list|(
operator|&
name|toc_tls
argument_list|,
operator|&
name|toc_symndx
argument_list|,
operator|&
name|local_syms
argument_list|,
name|rel
argument_list|,
name|input_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|toc_tls
condition|)
name|tls_mask
operator|=
operator|*
name|toc_tls
expr_stmt|;
block|}
block|}
comment|/* Check that tls relocs are used with tls syms, and non-tls 	 relocs are used with non-tls syms.  */
if|if
condition|(
name|r_symndx
operator|!=
literal|0
operator|&&
name|r_type
operator|!=
name|R_PPC64_NONE
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|IS_PPC64_TLS_RELOC
argument_list|(
name|r_type
argument_list|)
operator|!=
operator|(
name|sym_type
operator|==
name|STT_TLS
operator|)
condition|)
block|{
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_TLS
operator|&&
name|tls_mask
operator|!=
literal|0
condition|)
comment|/* R_PPC64_TLS is OK against a symbol in the TOC.  */
empty_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|sym_type
operator|==
name|STT_TLS
condition|?
name|_
argument_list|(
literal|"%s(%s+0x%lx): %s used with TLS symbol %s"
argument_list|)
else|:
name|_
argument_list|(
literal|"%s(%s+0x%lx): %s used with non-TLS symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure reloc mapping code below stays sane.  */
if|if
condition|(
name|R_PPC64_TOC16_LO_DS
operator|!=
name|R_PPC64_TOC16_DS
operator|+
literal|1
operator|||
name|R_PPC64_TOC16_LO
operator|!=
name|R_PPC64_TOC16
operator|+
literal|1
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_LO
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TLSGD16_LO
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_HI
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TLSGD16_HI
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_HA
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TLSGD16_HA
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TPREL16_DS
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_LO
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TPREL16_LO_DS
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_HI
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TPREL16_HI
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC64_GOT_TLSLD16_HA
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC64_GOT_TPREL16_HA
operator|&
literal|3
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
block|{
comment|/* Check for toc tls entries.  */
name|char
modifier|*
name|toc_tls
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|get_tls_mask
argument_list|(
operator|&
name|toc_tls
argument_list|,
operator|&
name|toc_symndx
argument_list|,
operator|&
name|local_syms
argument_list|,
name|rel
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|toc_tls
condition|)
block|{
name|tls_mask
operator|=
operator|*
name|toc_tls
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_TOC16_DS
operator|||
name|r_type
operator|==
name|R_PPC64_TOC16_LO_DS
condition|)
block|{
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
operator|(
name|TLS_DTPREL
operator||
name|TLS_TPREL
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|toctprel
goto|;
block|}
else|else
block|{
comment|/* If we found a GD reloc pair, then we might be 		       doing a GD->IE transition.  */
if|if
condition|(
name|retval
operator|==
literal|2
condition|)
block|{
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_get_addr_check
goto|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_get_addr_check
goto|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|toctprel
label|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|insn
operator|&=
literal|31
operator|<<
literal|21
expr_stmt|;
name|insn
operator||=
literal|0x3c0d0000
expr_stmt|;
comment|/* addis 0,13,0 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_TPREL16_HA
expr_stmt|;
if|if
condition|(
name|toc_symndx
operator|!=
literal|0
condition|)
block|{
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|toc_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
comment|/* We changed the symbol.  Start over in order to 		     get h, sym, sec etc. right.  */
name|rel
operator|--
expr_stmt|;
continue|continue;
block|}
else|else
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_TLS
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|rtra
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator||
operator|(
literal|31
operator|<<
literal|11
operator|)
operator|)
operator|)
operator|==
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|13
operator|<<
literal|11
operator|)
operator|)
condition|)
name|rtra
operator|=
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator||
operator|(
literal|31
operator|<<
literal|16
operator|)
operator|)
operator|)
operator|==
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|13
operator|<<
literal|16
operator|)
operator|)
condition|)
name|rtra
operator|=
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|21
operator|)
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|11
operator|)
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
operator|==
literal|266
operator|<<
literal|1
condition|)
comment|/* add -> addi.  */
name|insn
operator|=
literal|14
operator|<<
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|23
operator|<<
literal|1
operator|&&
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|<
literal|14
operator|<<
literal|6
operator|||
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|>=
literal|16
operator|<<
literal|6
operator|&&
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|<
literal|24
operator|<<
literal|6
operator|)
operator|)
condition|)
comment|/* load and store indexed -> dform.  */
name|insn
operator|=
operator|(
literal|32
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|31
operator|)
operator|)
operator|<<
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|21
operator|<<
literal|1
operator|&&
operator|(
name|insn
operator|&
operator|(
literal|0x1a
operator|<<
literal|6
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
name|insn
operator|=
operator|(
operator|(
operator|(
literal|58
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|4
operator|)
operator|)
operator|<<
literal|26
operator|)
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|21
operator|<<
literal|1
operator|&&
operator|(
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
operator|==
literal|341
operator|<<
literal|1
condition|)
comment|/* lwax -> lwa.  */
name|insn
operator|=
operator|(
literal|58
operator|<<
literal|26
operator|)
operator||
literal|2
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|insn
operator||=
name|rtra
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Was PPC64_TLS which sits on insn boundary, now 		 PPC64_TPREL16_LO which is at insn+2.  */
name|rel
operator|->
name|r_offset
operator|+=
literal|2
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_TPREL16_LO
expr_stmt|;
if|if
condition|(
name|toc_symndx
operator|!=
literal|0
condition|)
block|{
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|toc_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
comment|/* We changed the symbol.  Start over in order to 		     get h, sym, sec etc. right.  */
name|rel
operator|--
expr_stmt|;
continue|continue;
block|}
else|else
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_gdld_hi
goto|;
break|break;
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|tls_gdld_hi
label|:
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|tls_gd
operator|)
operator|!=
literal|0
condition|)
name|r_type
operator|=
operator|(
operator|(
operator|(
name|r_type
operator|-
operator|(
name|R_PPC64_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
name|R_PPC64_GOT_TPREL16_DS
operator|)
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_offset
operator|-=
literal|2
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_NONE
expr_stmt|;
block|}
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_get_addr_check
goto|;
break|break;
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|tls_get_addr_check
label|:
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
condition|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type2
decl_stmt|;
name|unsigned
name|long
name|r_symndx2
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h2
decl_stmt|;
name|bfd_vma
name|insn1
decl_stmt|,
name|insn2
decl_stmt|,
name|insn3
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
comment|/* The next instruction should be a call to 		     __tls_get_addr.  Peek at the reloc to be sure.  */
name|r_type2
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx2
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx2
operator|<
name|symtab_hdr
operator|->
name|sh_info
operator|||
operator|(
name|r_type2
operator|!=
name|R_PPC64_REL14
operator|&&
name|r_type2
operator|!=
name|R_PPC64_REL14_BRTAKEN
operator|&&
name|r_type2
operator|!=
name|R_PPC64_REL14_BRNTAKEN
operator|&&
name|r_type2
operator|!=
name|R_PPC64_REL24
operator|)
condition|)
break|break;
name|h2
operator|=
name|sym_hashes
index|[
name|r_symndx2
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h2
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h2
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h2
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h2
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h2
operator|==
name|NULL
operator|||
name|h2
operator|!=
name|htab
operator|->
name|tls_get_addr
condition|)
break|break;
comment|/* OK, it checks out.  Replace the call.  */
name|offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
expr_stmt|;
name|insn1
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|insn3
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|tls_gd
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* IE */
name|insn1
operator|&=
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
name|insn1
operator||=
literal|58
operator|<<
literal|26
expr_stmt|;
comment|/* ld */
name|insn2
operator|=
literal|0x7c636a14
expr_stmt|;
comment|/* add 3,3,13 */
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx2
argument_list|,
name|R_PPC64_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_EXPLICIT
operator|)
operator|==
literal|0
condition|)
name|r_type
operator|=
operator|(
operator|(
operator|(
name|r_type
operator|-
operator|(
name|R_PPC64_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
name|R_PPC64_GOT_TPREL16_DS
operator|)
expr_stmt|;
else|else
name|r_type
operator|+=
name|R_PPC64_TOC16_DS
operator|-
name|R_PPC64_TOC16
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* LE */
name|insn1
operator|=
literal|0x3c6d0000
expr_stmt|;
comment|/* addis 3,13,0 */
name|insn2
operator|=
literal|0x38630000
expr_stmt|;
comment|/* addi 3,3,0 */
if|if
condition|(
name|tls_gd
operator|==
literal|0
condition|)
block|{
comment|/* Was an LD reloc.  */
name|r_symndx
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_addend
operator|=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toc_symndx
operator|!=
literal|0
condition|)
name|r_symndx
operator|=
name|toc_symndx
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_TPREL16_HA
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_TPREL16_LO
argument_list|)
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|insn3
operator|==
name|NOP
operator|||
name|insn3
operator|==
name|CROR_151515
operator|||
name|insn3
operator|==
name|CROR_313131
condition|)
block|{
name|insn3
operator|=
name|insn2
expr_stmt|;
name|insn2
operator|=
name|NOP
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn2
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn3
argument_list|,
name|contents
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_gd
operator|==
literal|0
operator|||
name|toc_symndx
operator|!=
literal|0
condition|)
block|{
comment|/* We changed the symbol.  Start over in order 			 to get h, sym, sec etc. right.  */
name|rel
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
block|}
break|break;
case|case
name|R_PPC64_DTPMOD64
case|:
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|==
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|==
name|rel
operator|->
name|r_offset
operator|+
literal|8
condition|)
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
block|{
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC64_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_TPRELGD
operator|)
operator|!=
literal|0
condition|)
name|r_type
operator|=
name|R_PPC64_TPREL64
expr_stmt|;
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
literal|1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_NONE
expr_stmt|;
block|}
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
literal|1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC64_NONE
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_PPC64_TPREL64
case|:
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|r_type
operator|=
name|R_PPC64_NONE
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Handle other relocations that tweak non-addend part of insn.  */
name|insn
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
comment|/* Branch taken prediction relocations.  */
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
name|insn
operator|=
literal|0x01
operator|<<
literal|21
expr_stmt|;
comment|/* 'y' or 't' bit, lowest bit of BO field.  */
comment|/* Fall thru.  */
comment|/* Branch not taken prediction relocations.  */
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
name|insn
operator||=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
operator|&
operator|~
operator|(
literal|0x01
operator|<<
literal|21
operator|)
expr_stmt|;
if|if
condition|(
name|is_power4
condition|)
block|{
comment|/* Set 'a' bit.  This is 0b00010 in BO field for branch 		 on CR(BI) insns (BO == 001at or 011at), and 0b01000 		 for branch on CTR insns (BO == 1a00t or 1a01t).  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x04
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x02
operator|<<
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x10
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x08
operator|<<
literal|21
expr_stmt|;
else|else
break|break;
block|}
else|else
block|{
name|from
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Invert 'y' bit if not the default.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|-
name|from
argument_list|)
operator|<
literal|0
condition|)
name|insn
operator|^=
literal|0x01
operator|<<
literal|21
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_PPC64_REL24
case|:
comment|/* Calls to functions with a different TOC, such as calls to 	     shared objects, need to alter the TOC pointer.  This is 	     done using a linkage stub.  A REL24 branching to these 	     linkage stubs needs to be followed by a nop, as the nop 	     will be replaced with an instruction to restore the TOC 	     base pointer.  */
if|if
condition|(
operator|(
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|fdh
operator|=
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|oh
operator|)
operator|!=
name|NULL
operator|&&
name|fdh
operator|->
name|plt
operator|.
name|plist
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|fdh
operator|=
name|h
operator|,
name|sec
operator|)
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
operator|(
name|htab
operator|->
name|stub_group
index|[
name|sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|!=
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
operator|)
operator|)
operator|&&
operator|(
name|stub_entry
operator|=
name|ppc_get_stub_entry
argument_list|(
name|input_section
argument_list|,
name|sec
argument_list|,
name|fdh
argument_list|,
name|rel
argument_list|,
name|htab
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
operator|||
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_branch_r2off
operator|||
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_long_branch_r2off
operator|)
condition|)
block|{
name|bfd_boolean
name|can_plt_call
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|+
literal|8
operator|<=
name|input_section
operator|->
name|_cooked_size
condition|)
block|{
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NOP
operator|||
name|insn
operator|==
name|CROR_151515
operator|||
name|insn
operator|==
name|CROR_313131
condition|)
block|{
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|LD_R2_40R1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|can_plt_call
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|can_plt_call
condition|)
block|{
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
condition|)
block|{
comment|/* If this is a plain branch rather than a branch 			 and link, don't require a nop.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|can_plt_call
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|".__libc_start_main"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Allow crt1 branch to go via a toc adjusting stub.  */
name|can_plt_call
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): automatic multiple TOCs "
literal|"not supported using your crt files; "
literal|"recompile with -mminimal-toc or upgrade gcc"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): sibling call optimization to `%s' "
literal|"does not allow automatic multiple TOCs; "
literal|"recompile with -mminimal-toc or "
literal|"-fno-optimize-sibling-calls, "
literal|"or make `%s' extern"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|sym_name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|can_plt_call
condition|)
block|{
name|relocation
operator|=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|ppc_stub_plt_call
condition|)
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|relocation
operator|==
literal|0
operator|&&
name|rel
operator|->
name|r_addend
operator|==
literal|0
condition|)
block|{
comment|/* Tweak calls to undefined weak functions to point at a 		 blr.  We can thus call a weak function without first 		 checking whether the function is defined.  We have a 		 blr at the end of .sfpr.  */
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|-
literal|4
operator|+
name|htab
operator|->
name|sfpr
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|sfpr
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|from
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* But let's not be silly about it.  If the blr isn't in 		 reach, just go to the next instruction.  */
if|if
condition|(
name|relocation
operator|-
name|from
operator|+
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|>=
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|||
name|htab
operator|->
name|sfpr
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|relocation
operator|=
name|from
operator|+
literal|4
expr_stmt|;
block|}
break|break;
block|}
comment|/* Set `addend'.  */
name|tls_type
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d for symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
case|case
name|R_PPC64_NONE
case|:
case|case
name|R_PPC64_TLS
case|:
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
case|case
name|R_PPC64_GNU_VTENTRY
case|:
continue|continue;
comment|/* GOT16 relocations.  Like an ADDR16 using the symbol's 	     address in the GOT as relocation value instead of the 	     symbol's value itself.  Also, create a GOT entry for the 	     symbol and put the symbol value there.  */
case|case
name|R_PPC64_GOT_TLSGD16
case|:
case|case
name|R_PPC64_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_TLSLD16
case|:
case|case
name|R_PPC64_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_HI
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT_DTPREL16_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
name|dogot
label|:
block|{
comment|/* Relocation is to the entry for this symbol in the global 	       offset table.  */
name|asection
modifier|*
name|got
decl_stmt|;
name|bfd_vma
modifier|*
name|offp
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|unsigned
name|long
name|indx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|)
condition|)
name|offp
operator|=
operator|&
name|ppc64_tlsld_got
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|offset
expr_stmt|;
else|else
block|{
name|struct
name|got_entry
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
init|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
decl_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
comment|/* This is actually a static link, or it is a 			 -Bsymbolic link and the symbol is defined 			 locally, or the symbol was forced to be local 			 because of a version file.  */
empty_stmt|;
else|else
block|{
name|indx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
name|ent
operator|=
name|h
operator|->
name|got
operator|.
name|glist
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_ents
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ent
operator|=
name|local_got_ents
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
for|for
control|(
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|owner
operator|==
name|input_bfd
operator|&&
name|ent
operator|->
name|tls_type
operator|==
name|tls_type
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offp
operator|=
operator|&
name|ent
operator|->
name|got
operator|.
name|offset
expr_stmt|;
block|}
name|got
operator|=
name|ppc64_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|got
expr_stmt|;
if|if
condition|(
name|got
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The offset must always be a multiple of 8.  We use the 	       least significant bit to record whether we have already 	       processed this entry.  */
name|off
operator|=
operator|*
name|offp
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
comment|/* Generate relocs for the dynamic linker, except in 		   the case of TLSLD where we'll use one entry per 		   module.  */
name|asection
modifier|*
name|relgot
init|=
name|ppc64_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|relgot
decl_stmt|;
operator|*
name|offp
operator|=
name|off
operator||
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|indx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|got
operator|->
name|output_section
operator|->
name|vma
operator|+
name|got
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|tls_type
operator|&
operator|(
name|TLS_LD
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_DTPMOD64
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|loc
operator|=
name|relgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|relgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
literal|8
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_DTPREL
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_DTPREL64
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_TPREL
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_TPREL64
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
comment|/* Write the .got section contents for the sake 			   of prelink.  */
name|loc
operator|=
name|got
operator|->
name|contents
operator|+
name|off
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|outrel
operator|.
name|r_addend
operator|+
name|relocation
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
else|else
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC64_GLOB_DAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
operator|&&
name|tls_type
operator|!=
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_addend
operator|+=
name|relocation
expr_stmt|;
if|if
condition|(
name|tls_type
operator|&
operator|(
name|TLS_GD
operator||
name|TLS_DTPREL
operator||
name|TLS_TPREL
operator|)
condition|)
name|outrel
operator|.
name|r_addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
expr_stmt|;
block|}
name|loc
operator|=
name|relgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|relgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Init the .got section contents here if we're not 		   emitting a reloc.  */
else|else
block|{
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
name|relocation
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_type
operator|!=
literal|0
condition|)
block|{
name|relocation
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_TPREL
operator|)
condition|)
name|relocation
operator|+=
name|DTP_OFFSET
operator|-
name|TP_OFFSET
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|got
operator|->
name|contents
operator|+
name|off
operator|+
literal|8
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|got
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|relocation
operator|=
name|got
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
comment|/* TOC base (r2) is TOC start plus 0x8000.  */
name|addend
operator|=
operator|-
name|TOC_BASE_OFF
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
comment|/* Resolve a PLT reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
comment|/* It's possible that we didn't make a PLT entry for this 	     symbol.  This happens when statically linking PIC code, 	     or when using -Bsymbolic.  Go find a match if there is a 	     PLT entry.  */
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
operator|&&
name|ent
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|relocation
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_PPC64_TOC
case|:
comment|/* Relocation value is TOC base.  */
name|relocation
operator|=
name|TOCstart
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
name|relocation
operator|+=
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|toc_off
expr_stmt|;
elseif|else
if|if
condition|(
name|unresolved_reloc
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|id
operator|<=
name|htab
operator|->
name|top_id
condition|)
name|relocation
operator|+=
name|htab
operator|->
name|stub_group
index|[
name|sec
operator|->
name|id
index|]
operator|.
name|toc_off
expr_stmt|;
else|else
name|unresolved_reloc
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|dodyn2
goto|;
comment|/* TOC16 relocs.  We want the offset relative to the TOC base, 	     which is the address of the start of the TOC plus 0x8000. 	     The TOC consists of sections .got, .toc, .tocbss, and .plt, 	     in this order.  */
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
name|addend
operator|-=
name|TOCstart
operator|+
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|toc_off
expr_stmt|;
break|break;
comment|/* Relocate against the beginning of the section.  */
case|case
name|R_PPC64_SECTOFF
case|:
case|case
name|R_PPC64_SECTOFF_LO
case|:
case|case
name|R_PPC64_SECTOFF_HI
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL24
case|:
break|break;
case|case
name|R_PPC64_TPREL16
case|:
case|case
name|R_PPC64_TPREL16_LO
case|:
case|case
name|R_PPC64_TPREL16_HI
case|:
case|case
name|R_PPC64_TPREL16_HA
case|:
case|case
name|R_PPC64_TPREL16_DS
case|:
case|case
name|R_PPC64_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_TPREL16_HIGHER
case|:
case|case
name|R_PPC64_TPREL16_HIGHERA
case|:
case|case
name|R_PPC64_TPREL16_HIGHEST
case|:
case|case
name|R_PPC64_TPREL16_HIGHESTA
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|TP_OFFSET
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
comment|/* The TPREL16 relocs shouldn't really be used in shared 	       libs as they will result in DT_TEXTREL being set, but 	       support them anyway.  */
goto|goto
name|dodyn
goto|;
break|break;
case|case
name|R_PPC64_DTPREL16
case|:
case|case
name|R_PPC64_DTPREL16_LO
case|:
case|case
name|R_PPC64_DTPREL16_HI
case|:
case|case
name|R_PPC64_DTPREL16_HA
case|:
case|case
name|R_PPC64_DTPREL16_DS
case|:
case|case
name|R_PPC64_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_DTPREL16_HIGHER
case|:
case|case
name|R_PPC64_DTPREL16_HIGHERA
case|:
case|case
name|R_PPC64_DTPREL16_HIGHEST
case|:
case|case
name|R_PPC64_DTPREL16_HIGHESTA
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
break|break;
case|case
name|R_PPC64_DTPMOD64
case|:
name|relocation
operator|=
literal|1
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC64_TPREL64
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|TP_OFFSET
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC64_DTPREL64
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
comment|/* Fall thru */
comment|/* Relocations that may need to be propagated if this is a 	     dynamic object.  */
case|case
name|R_PPC64_REL30
case|:
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL64
case|:
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_ADDR64
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
comment|/* r_symndx will be zero only for relocs against symbols 	     from removed linkonce sections, or sections discarded by 	     a linker script.  */
name|dodyn
label|:
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
break|break;
comment|/* Fall thru.  */
name|dodyn2
label|:
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|NO_OPD_RELOCS
operator|&&
name|is_opd
condition|)
break|break;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|out_off
decl_stmt|;
comment|/* When generating a dynamic object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
name|skip
operator|=
name|FALSE
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|out_off
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_off
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|out_off
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|out_off
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|out_off
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
comment|/* Optimize unaligned reloc use.  */
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_PPC64_ADDR64
operator|&&
operator|(
name|out_off
operator|&
literal|7
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_PPC64_UADDR64
operator|&&
operator|(
name|out_off
operator|&
literal|7
operator|)
operator|==
literal|0
operator|)
condition|)
name|r_type
operator|^=
name|R_PPC64_ADDR64
operator|^
name|R_PPC64_UADDR64
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_PPC64_ADDR32
operator|&&
operator|(
name|out_off
operator|&
literal|3
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_PPC64_UADDR32
operator|&&
operator|(
name|out_off
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
condition|)
name|r_type
operator|^=
name|R_PPC64_ADDR32
operator|^
name|R_PPC64_UADDR32
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_PPC64_ADDR16
operator|&&
operator|(
name|out_off
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_PPC64_UADDR16
operator|&&
operator|(
name|out_off
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
name|r_type
operator|^=
name|R_PPC64_ADDR16
operator|^
name|R_PPC64_UADDR16
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|&&
operator|!
name|is_opd
operator|&&
name|r_type
operator|!=
name|R_PPC64_TOC
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This symbol is local, or marked to become local, 		     or this is an opd section reloc which must point 		     at a local function.  */
name|outrel
operator|.
name|r_addend
operator|+=
name|relocation
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_ADDR64
operator|||
name|r_type
operator|==
name|R_PPC64_TOC
condition|)
block|{
if|if
condition|(
name|is_opd
operator|&&
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Lie about opd entries.  This case occurs 			     when building shared libraries and we 			     reference a function in another shared 			     lib.  The same thing happens for a weak 			     definition in an application that's 			     overridden by a strong definition in a 			     shared lib.  (I believe this is a generic 			     bug in binutils handling of weak syms.) 			     In these cases we won't use the opd 			     entry in this lib.  */
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
comment|/* We need to relocate .opd contents for ld.so. 			 Prelink also wants simple and consistent rules 			 for relocs.  This make all RELATIVE relocs have 			 *r_offset equal to r_addend.  */
name|relocate
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
comment|/* We are turning this relocation into one 			     against a section symbol, so subtract out 			     the output section's address but not the 			     offset of the input section in the output 			     section.  */
name|outrel
operator|.
name|r_addend
operator|-=
name|osec
operator|->
name|vma
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an external symbol, it will 		 be computed at runtime, so there's no need to do 		 anything now.  However, for the sake of prelink ensure 		 that the section contents are a known value.  */
if|if
condition|(
operator|!
name|relocate
condition|)
block|{
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
comment|/* The value chosen here is quite arbitrary as ld.so 		     ignores section contents except for the special 		     case of .opd where the contents might be accessed 		     before relocation.  Choose zero, as that won't 		     cause reloc overflow.  */
name|relocation
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
comment|/* Use *r_offset == r_addend for R_PPC64_ADDR64 relocs 		     to improve backward compatibility with older 		     versions of ld.  */
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_ADDR64
condition|)
name|addend
operator|=
name|outrel
operator|.
name|r_addend
expr_stmt|;
comment|/* Adjust pc_relative relocs to have zero in *r_offset.  */
elseif|else
if|if
condition|(
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|pc_relative
condition|)
name|addend
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_PPC64_COPY
case|:
case|case
name|R_PPC64_GLOB_DAT
case|:
case|case
name|R_PPC64_JMP_SLOT
case|:
case|case
name|R_PPC64_RELATIVE
case|:
comment|/* We shouldn't ever see these dynamic relocs in relocatable 	     files.  */
comment|/* Fall through.  */
case|case
name|R_PPC64_PLTGOT16
case|:
case|case
name|R_PPC64_PLTGOT16_DS
case|:
case|case
name|R_PPC64_PLTGOT16_HA
case|:
case|case
name|R_PPC64_PLTGOT16_HI
case|:
case|case
name|R_PPC64_PLTGOT16_LO
case|:
case|case
name|R_PPC64_PLTGOT16_LO_DS
case|:
case|case
name|R_PPC64_PLTREL32
case|:
case|case
name|R_PPC64_PLTREL64
case|:
comment|/* These ones haven't been implemented yet.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: relocation %s is not supported for symbol %s."
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* Do any further special processing.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_PLTGOT16_HA
case|:
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
case|case
name|R_PPC64_TPREL16_HA
case|:
case|case
name|R_PPC64_DTPREL16_HA
case|:
case|case
name|R_PPC64_GOT_TLSGD16_HA
case|:
case|case
name|R_PPC64_GOT_TLSLD16_HA
case|:
case|case
name|R_PPC64_GOT_TPREL16_HA
case|:
case|case
name|R_PPC64_GOT_DTPREL16_HA
case|:
case|case
name|R_PPC64_TPREL16_HIGHER
case|:
case|case
name|R_PPC64_TPREL16_HIGHERA
case|:
case|case
name|R_PPC64_TPREL16_HIGHEST
case|:
case|case
name|R_PPC64_TPREL16_HIGHESTA
case|:
case|case
name|R_PPC64_DTPREL16_HIGHER
case|:
case|case
name|R_PPC64_DTPREL16_HIGHERA
case|:
case|case
name|R_PPC64_DTPREL16_HIGHEST
case|:
case|case
name|R_PPC64_DTPREL16_HIGHESTA
case|:
comment|/* It's just possible that this symbol is a weak symbol 	     that's not actually defined anywhere. In that case, 	     'sec' would be NULL, and we should leave the symbol 	     alone (it will be set to zero elsewhere in the link).  */
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
comment|/* Add 0x10000 if sign bit in 0:15 is set. 	       Bits 0:15 are not used.  */
name|addend
operator|+=
literal|0x8000
expr_stmt|;
break|break;
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
case|case
name|R_PPC64_PLT16_LO_DS
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
case|case
name|R_PPC64_PLTGOT16_DS
case|:
case|case
name|R_PPC64_PLTGOT16_LO_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_DS
case|:
case|case
name|R_PPC64_GOT_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_DS
case|:
case|case
name|R_PPC64_GOT_DTPREL16_LO_DS
case|:
case|case
name|R_PPC64_TPREL16_DS
case|:
case|case
name|R_PPC64_TPREL16_LO_DS
case|:
case|case
name|R_PPC64_DTPREL16_DS
case|:
case|case
name|R_PPC64_DTPREL16_LO_DS
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
operator|(
name|rel
operator|->
name|r_offset
operator|&
operator|~
literal|3
operator|)
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|3
expr_stmt|;
comment|/* If this reloc is against an lq insn, then the value must be 	     a multiple of 16.  This is somewhat of a hack, but the 	     "correct" way to do this by defining _DQ forms of all the 	     _DS relocs bloats all reloc switches in this file.  It 	     doesn't seem to make much sense to use any of these relocs 	     in data, so testing the insn should be safe.  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator|)
operator|==
operator|(
literal|56u
operator|<<
literal|26
operator|)
condition|)
name|mask
operator|=
literal|15
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|)
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: error: relocation %s not a multiple of %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|mask
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
name|max_br_offset
operator|=
literal|1
operator|<<
literal|15
expr_stmt|;
goto|goto
name|branch_check
goto|;
case|case
name|R_PPC64_REL24
case|:
name|max_br_offset
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
name|branch_check
label|:
comment|/* If the branch is out of reach or the TOC register needs 	     adjusting, then redirect the call to the local stub for 	     this function.  */
name|from
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|relocation
operator|+
name|addend
operator|-
name|from
operator|+
name|max_br_offset
operator|>=
literal|2
operator|*
name|max_br_offset
operator|||
operator|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|id
operator|<=
name|htab
operator|->
name|top_id
operator|&&
operator|(
name|htab
operator|->
name|stub_group
index|[
name|sec
operator|->
name|id
index|]
operator|.
name|toc_off
operator|!=
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|toc_off
operator|)
operator|)
operator|)
operator|&&
operator|(
name|stub_entry
operator|=
name|ppc_get_stub_entry
argument_list|(
name|input_section
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
name|htab
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Munge up the value and addend so that we call the stub 		 rather than the procedure directly.  */
name|relocation
operator|=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
if|if
condition|(
name|sym_name
operator|==
name|NULL
condition|)
name|sym_name
operator|=
literal|"(null)"
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
if|if
condition|(
name|warned
condition|)
continue|continue;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|pc_relative
condition|)
block|{
comment|/* Assume this is a call protected by other code that 		     detects the symbol is undefined.  If this is the case, 		     we can safely ignore the overflow.  If not, the 		     program is hosed anyway, and a little warning isn't 		     going to help.  */
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): %s reloc against `%s': error %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|ppc64_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|,
name|sym_name
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Adjust the value of any local symbols in opd sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|elfsym
parameter_list|,
name|asection
modifier|*
name|input_sec
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|long
modifier|*
name|adjust
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|||
name|input_sec
operator|==
name|NULL
operator|||
name|ppc64_elf_section_data
argument_list|(
name|input_sec
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|adjust
operator|=
name|ppc64_elf_section_data
argument_list|(
name|input_sec
argument_list|)
operator|->
name|opd
operator|.
name|adjust
operator|)
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|value
operator|=
name|elfsym
operator|->
name|st_value
operator|-
name|input_sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
name|value
operator|-=
name|input_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|elfsym
operator|->
name|st_value
operator|+=
name|adjust
index|[
name|value
operator|/
literal|24
index|]
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* This symbol has an entry in the procedure linkage 	       table.  Set it up.  */
if|if
condition|(
name|htab
operator|->
name|plt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|relplt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|glink
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a JMP_SLOT reloc to inform the dynamic linker to 	       fill in the PLT entry.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|ent
operator|->
name|addend
expr_stmt|;
name|loc
operator|=
name|htab
operator|->
name|relplt
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
operator|(
name|ent
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|||
name|htab
operator|->
name|relbss
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|htab
operator|->
name|relbss
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|relbss
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Used to decide how to sort relocs in an optimal manner for the    dynamic linker, before writing them out.  */
end_comment

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|ppc64_elf_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
name|enum
name|elf_ppc64_reloc_type
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_PPC64_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_PPC64_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc64_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|Elf64_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
operator|||
name|htab
operator|->
name|got
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf64_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
continue|continue;
case|case
name|DT_PPC64_GLINK
case|:
name|s
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
comment|/* We stupidly defined DT_PPC64_GLINK to be the start 		 of glink rather than the first entry point, which is 		 what ld.so needs, and now have a bigger stub to 		 support automatic multiple TOCs.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|+=
name|GLINK_CALL_STUB_SIZE
operator|-
literal|32
expr_stmt|;
break|break;
case|case
name|DT_PPC64_OPD
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_PPC64_OPDSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|s
operator|=
name|htab
operator|->
name|plt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|htab
operator|->
name|relplt
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* Don't count procedure linkage table relocs in the 		 overall reloc count.  */
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
comment|/* We may not be using the standard ELF linker script. 		 If .rela.plt is the first .rela section, we adjust 		 DT_RELA to not include it.  */
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|!=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|+=
name|s
operator|->
name|_raw_size
expr_stmt|;
break|break;
block|}
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|got
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|got
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Fill in the first entry in the global offset table. 	 We use it to hold the link-time TOCbase.  */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|TOC_BASE_OFF
argument_list|,
name|htab
operator|->
name|got
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* Set .got entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|got
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|plt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Set .plt entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|plt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
comment|/* We need to handle writing out multiple GOT sections ourselves,      since we didn't add them to DYNOBJ.  */
while|while
condition|(
operator|(
name|dynobj
operator|=
name|dynobj
operator|->
name|link_next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|dynobj
argument_list|)
operator|->
name|got
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
operator|&&
name|s
operator|->
name|output_section
operator|!=
name|bfd_abs_section_ptr
operator|&&
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|,
name|s
operator|->
name|contents
argument_list|,
name|s
operator|->
name|output_offset
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|ppc64_elf_tdata
argument_list|(
name|dynobj
argument_list|)
operator|->
name|relgot
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
operator|&&
name|s
operator|->
name|output_section
operator|!=
name|bfd_abs_section_ptr
operator|&&
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|,
name|s
operator|->
name|contents
argument_list|,
name|s
operator|->
name|output_offset
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

