begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* PowerPC64-specific support for 64-bit ELF.    Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Linus Nordberg, Swox AB<info@swox.com>,    based on elf32-ppc.c by Ian Lance Taylor.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is based on the 64-bit PowerPC ELF ABI.  It is also based    on the file elf32-ppc.c.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_include
include|#
directive|include
file|"elf64-ppc.h"
end_include

begin_define
define|#
directive|define
name|USE_RELA
end_define

begin_comment
comment|/* we want RELA relocations, not REL.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ppc_howto_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc64_elf_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|cache_ptr
operator|,
name|Elf64_Internal_Rela
operator|*
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_addr16_ha_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf64_Internal_Shdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc64_elf_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc64_elf_copy_indirect_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|ppc64_elf_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|Elf_Internal_Rela
operator|*
name|rel
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|Elf_Internal_Sym
operator|*
name|sym
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|sec
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|relocs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|func_desc_adjust
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_func_desc_adjust
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc64_elf_hide_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_dynrelocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|readonly_dynrelocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|ppc64_elf_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|build_plt_stub
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|build_one_stub
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf64_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
name|relocs
operator|,
name|Elf_Internal_Sym
operator|*
name|local_syms
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc64_elf_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mask to set RA in memory instructions.  */
end_comment

begin_define
define|#
directive|define
name|RA_REGISTER_MASK
value|0x001f0000
end_define

begin_comment
comment|/* Value to shift register by to insert RA.  */
end_comment

begin_define
define|#
directive|define
name|RA_REGISTER_SHIFT
value|16
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|24
end_define

begin_comment
comment|/* The initial size of the plt reserved for the dynamic linker.  */
end_comment

begin_define
define|#
directive|define
name|PLT_INITIAL_ENTRY_SIZE
value|PLT_ENTRY_SIZE
end_define

begin_comment
comment|/* TOC base pointers offset from start of TOC.  */
end_comment

begin_define
define|#
directive|define
name|TOC_BASE_OFF
value|(0x8000)
end_define

begin_comment
comment|/* .plt call stub instructions.  */
end_comment

begin_define
define|#
directive|define
name|ADDIS_R12_R2
value|0x3d820000
end_define

begin_comment
comment|/* addis %r12,%r2,xxx@ha     */
end_comment

begin_define
define|#
directive|define
name|STD_R2_40R1
value|0xf8410028
end_define

begin_comment
comment|/* std	 %r2,40(%r1)	     */
end_comment

begin_define
define|#
directive|define
name|LD_R11_0R12
value|0xe96c0000
end_define

begin_comment
comment|/* ld	 %r11,xxx+0@l(%r12)  */
end_comment

begin_define
define|#
directive|define
name|LD_R2_0R12
value|0xe84c0000
end_define

begin_comment
comment|/* ld	 %r2,xxx+8@l(%r12)   */
end_comment

begin_define
define|#
directive|define
name|MTCTR_R11
value|0x7d6903a6
end_define

begin_comment
comment|/* mtctr %r11		     */
end_comment

begin_comment
comment|/* ld	 %r11,xxx+16@l(%r12) */
end_comment

begin_define
define|#
directive|define
name|BCTR
value|0x4e800420
end_define

begin_comment
comment|/* bctr			     */
end_comment

begin_comment
comment|/* The normal stub is this size.  */
end_comment

begin_define
define|#
directive|define
name|PLT_CALL_STUB_SIZE
value|(7*4)
end_define

begin_comment
comment|/* But sometimes the .plt entry crosses a 64k boundary, and we need    to adjust the high word with this insn.  */
end_comment

begin_define
define|#
directive|define
name|ADDIS_R12_R12_1
value|0x3d8c0001
end_define

begin_comment
comment|/* addis %r12,%r12,1	*/
end_comment

begin_comment
comment|/* The .glink fixup call stub is the same as the .plt call stub, but    the first instruction restores r2, and the std is omitted.  */
end_comment

begin_define
define|#
directive|define
name|LD_R2_40R1
value|0xe8410028
end_define

begin_comment
comment|/* ld    %r2,40(%r1)	*/
end_comment

begin_comment
comment|/* Always allow this much space.  */
end_comment

begin_define
define|#
directive|define
name|GLINK_CALL_STUB_SIZE
value|(8*4)
end_define

begin_comment
comment|/* Pad with this.  */
end_comment

begin_define
define|#
directive|define
name|NOP
value|0x60000000
end_define

begin_comment
comment|/* .glink entries for the first 32k functions are two instructions. */
end_comment

begin_define
define|#
directive|define
name|LI_R0_0
value|0x38000000
end_define

begin_comment
comment|/* li    %r0,0		*/
end_comment

begin_define
define|#
directive|define
name|B_DOT
value|0x48000000
end_define

begin_comment
comment|/* b     .		*/
end_comment

begin_comment
comment|/* After that, we need two instructions to load the index, followed by    a branch.  */
end_comment

begin_define
define|#
directive|define
name|LIS_R0_0
value|0x3c000000
end_define

begin_comment
comment|/* lis   %r0,0		*/
end_comment

begin_define
define|#
directive|define
name|ORI_R0_R0_0
value|0x60000000
end_define

begin_comment
comment|/* ori	 %r0,%r0,0	*/
end_comment

begin_comment
comment|/* Since .opd is an array of descriptors and each entry will end up    with identical R_PPC64_RELATIVE relocs, there is really no need to    propagate .opd relocs;  The dynamic linker should be taught to    relocate .opd without reloc entries.  FIXME: .opd should be trimmed    of unused values.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPD_RELOCS
end_ifndef

begin_define
define|#
directive|define
name|NO_OPD_RELOCS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Relocation HOWTO's.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_PPC_max
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ppc64_elf_howto_raw
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_PPC64_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 26 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR24"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relocation without overflow.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Bits 16-31 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Bits 16-31 of an address, plus 1 if the contents of the low 16      bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is expected to be taken.  The lower two      bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14_BRTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is not expected to be taken.  The lower      two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR14_BRNTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 26 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL24"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is expected to be taken.  The lower two bits must be      zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14_BRTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is not expected to be taken.  The lower two bits must      be zero.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL14_BRNTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but referring to the GOT table entry for the      symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HI, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HA, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This is used only by the dynamic linker.  The symbol should exist      both in the object being run and in some shared library.  The      dynamic linker copies the data addressed by the symbol from the      shared library into the object, because the object being      run has to have the data at some particular address.  */
name|HOWTO
argument_list|(
name|R_PPC64_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_COPY"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR64, but used when setting global offset table      entries.  */
name|HOWTO
argument_list|(
name|R_PPC64_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GLOB_DAT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffffffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Created by the link editor.  Marks a procedure linkage table      entry for a symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_JMP_SLOT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used only by the dynamic linker.  When the object is run, this      doubleword64 is set to the load address of the object, plus the      addend.  */
name|HOWTO
argument_list|(
name|R_PPC64_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_RELATIVE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffffffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR32, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
comment|/* FIXME: Verify.  Was complain_overflow_bitfield. */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit relocation to the symbol's procedure linkage table.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative relocation to the symbol's procedure linkage table.      FIXME: R_PPC64_PLTREL32 not supported.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTREL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HI, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_HA, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit section relative relocation.  */
comment|/* FIXME: Verify R_PPC64_SECTOFF.  Seems strange with size=2 and      dst_mask=0.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit lower half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half adjusted section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_REL24 without touching the two least significant      bits.  */
comment|/* FIXME: Verify R_PPC64_ADDR30.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR30
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|30
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR30"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffffffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocs in the 64-bit PowerPC ELF ABI, not in the 32-bit ABI.  */
comment|/* A standard 64-bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffffffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 32-47 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHER
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHER"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 32-47 of an address, plus 1 if the contents of the low      16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHERA
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHERA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 48-63 of an address.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHEST
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHEST"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The bits 48-63 of an address, plus 1 if the contents of the low      16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_HIGHESTA
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_HIGHESTA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like ADDR64, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC64_UADDR64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_UADDR64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffffffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC64_REL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_REL64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffffffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relocation to the symbol's procedure linkage table. */
name|HOWTO
argument_list|(
name|R_PPC64_PLT64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit PC relative relocation to the symbol's procedure linkage      table.  */
comment|/* FIXME: R_PPC64_PLTREL64 not supported.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTREL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTREL64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation.  */
comment|/* R_PPC64_TOC16	  47	   half16*	S + A - .TOC.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation without overflow.  */
comment|/* R_PPC64_TOC16_LO	  48	   half16	 #lo (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation, high 16 bits.  */
comment|/* R_PPC64_TOC16_HI	  49	   half16	 #hi (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC-relative relocation, high 16 bits, plus 1 if the      contents of the low 16 bits, treated as a signed number, is      negative.  */
comment|/* R_PPC64_TOC16_HA	  50	   half16	 #ha (S + A - .TOC.)  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64-bit relocation; insert value of TOC base (.TOC.).  */
comment|/* R_PPC64_TOC		  51	   doubleword64	 .TOC.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0=byte, 1=short, 2=long, 4=64 bits) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffffffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16, but also informs the link editor that the      value to relocate may (!) refer to a PLT entry which the link      editor (a) may replace with the symbol value.  If the link editor      is unable to fully resolve the symbol, it may (b) create a PLT      entry and store the address to the new PLT entry in the GOT.      This permits lazy resolution of function symbols at run time.      The link editor may also skip all of this and just (c) emit a      R_PPC64_GLOB_DAT to tie the symbol to the GOT entry.  */
comment|/* FIXME: R_PPC64_PLTGOT16 not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16, but without overflow.  */
comment|/* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address.  */
comment|/* FIXME: R_PPC64_PLTGOT16_HI not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address, plus      1 if the contents of the low 16 bits, treated as a signed number,      is negative.  */
comment|/* FIXME: R_PPC64_PLTGOT16_HA not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc64_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_ADDR16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_ADDR16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_ADDR16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_GOT16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_GOT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GOT16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLT16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLT16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF, but for instructions with a DS field.  */
comment|/* FIXME: Verify R_PPC64_SECTOFF.  Seems strange with size=2 and      dst_mask=0.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_SECTOFF_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_SECTOFF_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_SECTOFF_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_TOC16, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_TOC16_LO, but for instructions with a DS field.  */
name|HOWTO
argument_list|(
name|R_PPC64_TOC16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_TOC16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16, but for instructions with a DS field.  */
comment|/* FIXME: R_PPC64_PLTGOT16_DS not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC64_PLTGOT16_LO, but for instructions with a DS field.  */
comment|/* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
name|HOWTO
argument_list|(
name|R_PPC64_PLTGOT16_LO_DS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC64_PLTGOT16_LO_DS"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_PPC64_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_PPC64_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC64_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the ppc64_elf_howto_table, so that linear accesses can    be done.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_howto_init
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_raw
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ppc64_elf_howto_raw
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ppc64_elf_howto_table
index|[
name|type
index|]
operator|=
operator|&
name|ppc64_elf_howto_raw
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc64_elf_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|enum
name|elf_ppc_reloc_type
name|ppc_reloc
init|=
name|R_PPC_NONE
decl_stmt|;
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
comment|/* Initialize howto table if needed.  */
name|ppc_howto_init
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|code
condition|)
block|{
default|default:
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
case|case
name|BFD_RELOC_NONE
case|:
name|ppc_reloc
operator|=
name|R_PPC64_NONE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA26
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRNTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B26
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRNTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_COPY
case|:
name|ppc_reloc
operator|=
name|R_PPC64_COPY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GLOB_DAT
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GLOB_DAT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CTOR
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHER
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HIGHER
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHER_S
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HIGHERA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHEST
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HIGHEST
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_HIGHEST_S
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_HIGHESTA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_REL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PLT_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_LO
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_HI
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_HA
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_LO
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_HI
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_HA
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_ADDR16_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_ADDR16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_ADDR16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_GOT16_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_GOT16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GOT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLT16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_SECTOFF_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_SECTOFF_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_SECTOFF_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_TOC16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_TOC16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC64_PLTGOT16_LO_DS
case|:
name|ppc_reloc
operator|=
name|R_PPC64_PLTGOT16_LO_DS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GNU_VTINHERIT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|ppc_reloc
operator|=
name|R_PPC64_GNU_VTENTRY
expr_stmt|;
break|break;
block|}
return|return
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|ppc_reloc
index|]
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Set the howto pointer for a PowerPC ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf64_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
comment|/* Initialize howto table if needed.  */
name|ppc_howto_init
argument_list|()
expr_stmt|;
name|type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc64_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|ppc64_elf_howto_table
index|[
name|type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the R_PPC_ADDR16_HA and similar relocs.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc64_elf_addr16_ha_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|+=
operator|(
name|relocation
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* Function to set whether a module needs the -mrelocatable bit set.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|old_flags
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|;
name|boolean
name|error
decl_stmt|;
comment|/* Check if we have the same endianess.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|&&
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|ibfd
argument_list|)
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled for a big endian system and target is little endian"
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled for a little endian system and target is big endian"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|msg
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* First call, no flags set.  */
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
comment|/* Compatible flags are ok.  */
empty_stmt|;
else|else
block|{
comment|/* Incompatible flags.  Warn about -mrelocatable mismatch. 	 Allow -mrelocatable-lib to be linked with either.  */
name|error
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_PPC_RELOCATABLE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|old_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: compiled with -mrelocatable and linked with modules compiled normally"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|new_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|old_flags
operator|&
name|EF_PPC_RELOCATABLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: compiled normally and linked with modules compiled with -mrelocatable"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The output is -mrelocatable-lib iff both the input files are.  */
if|if
condition|(
operator|!
operator|(
name|new_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_PPC_RELOCATABLE_LIB
expr_stmt|;
comment|/* The output is -mrelocatable iff it can't be -mrelocatable-lib,          but each input file is either -mrelocatable or -mrelocatable-lib.  */
if|if
condition|(
operator|!
operator|(
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|&&
operator|(
name|new_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_RELOCATABLE
operator|)
operator|)
operator|&&
operator|(
name|old_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_RELOCATABLE
operator|)
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_PPC_RELOCATABLE
expr_stmt|;
comment|/* Do not warn about eabi vs. V.4 mismatch, just or in the bit 	 if any module uses it.  */
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
operator|(
name|new_flags
operator|&
name|EF_PPC_EMB
operator|)
expr_stmt|;
name|new_flags
operator|&=
operator|~
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_EMB
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_EMB
operator|)
expr_stmt|;
comment|/* Warn about any other mismatches.  */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle a PowerPC specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf64_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
name|newsect
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXCLUDE
condition|)
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_ORDERED
condition|)
name|flags
operator||=
name|SEC_SORT_ENTRIES
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are specific to the ELF linker, while    functions above are used generally.  Those named ppc64_elf_* are    called by the main ELF linker code.  They appear in this file more    or less in the order in which they are called.  eg.    ppc64_elf_check_relocs is called early in the link process,    ppc64_elf_finish_dynamic_sections is one of the last functions    called.     PowerPC64-ELF uses a similar scheme to PowerPC64-XCOFF in that    functions have both a function code symbol and a function descriptor    symbol.  A call to foo in a relocatable object file looks like:     .		.text    .	x:    .		bl	.foo    .		nop     The function definition in another object file might be:     .		.section .opd    .	foo:	.quad	.foo    .		.quad	.TOC.@tocbase    .		.quad	0    .    .		.text    .	.foo:	blr     When the linker resolves the call during a static link, the branch    unsurprisingly just goes to .foo and the .opd information is unused.    If the function definition is in a shared library, things are a little    different:  The call goes via a plt call stub, the opd information gets    copied to the plt, and the linker patches the nop.     .	x:    .		bl	.foo_stub    .		ld	2,40(1)    .    .    .	.foo_stub:    .		addis	12,2,Lfoo@toc@ha	# in practice, the call stub    .		addi	12,12,Lfoo@toc@l	# is slightly optimised, but    .		std	2,40(1)			# this is the general idea    .		ld	11,0(12)    .		ld	2,8(12)    .		mtctr	11    .		ld	11,16(12)    .		bctr    .    .		.section .plt    .	Lfoo:	reloc (R_PPC64_JMP_SLOT, foo)     The "reloc ()" notation is supposed to indicate that the linker emits    an R_PPC64_JMP_SLOT reloc against foo.  The dynamic linker does the opd    copying.     What are the difficulties here?  Well, firstly, the relocations    examined by the linker in check_relocs are against the function code    sym .foo, while the dynamic relocation in the plt is emitted against    the function descriptor symbol, foo.  Somewhere along the line, we need    to carefully copy dynamic link information from one symbol to the other.    Secondly, the generic part of the elf linker will make .foo a dynamic    symbol as is normal for most other backends.  We need foo dynamic    instead, at least for an application final link.  However, when    creating a shared library containing foo, we need to have both symbols    dynamic so that references to .foo are satisfied during the early    stages of linking.  Otherwise the linker might decide to pull in a    definition from some other object, eg. a static library.  */
end_comment

begin_comment
comment|/* The linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_dyn_relocs
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Of those relocs that might be copied as dynamic relocs, this macro    selects between relative and absolute types.  */
end_comment

begin_define
define|#
directive|define
name|IS_ABSOLUTE_RELOC
parameter_list|(
name|RTYPE
parameter_list|)
define|\
value|((RTYPE) != R_PPC64_REL14			\&& (RTYPE) != R_PPC64_REL14_BRNTAKEN		\&& (RTYPE) != R_PPC64_REL14_BRTAKEN		\&& (RTYPE) != R_PPC64_REL24			\&& (RTYPE) != R_PPC64_REL32			\&& (RTYPE) != R_PPC64_REL64)
end_define

begin_comment
comment|/* ppc64 ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|ppc_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|ppc_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
comment|/* Flag function code and descriptor symbols.  */
name|unsigned
name|int
name|is_func
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_func_descriptor
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ppc64 ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelbss
decl_stmt|;
name|asection
modifier|*
name|sstub
decl_stmt|;
name|asection
modifier|*
name|sglink
decl_stmt|;
comment|/* Set on error.  */
name|int
name|plt_overflow
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the ppc64 ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|ppc_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct ppc_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Create an entry in a ppc64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
init|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|is_func
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|is_func_descriptor
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create a ppc64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc64_elf_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_link_hash_table
argument_list|)
decl_stmt|;
name|htab
operator|=
operator|(
expr|struct
name|ppc_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|htab
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|htab
operator|->
name|sgot
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|sstub
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|sglink
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|plt_overflow
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|htab
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Create .got and .rela.got sections in DYNOBJ, and set up    shortcuts to them in our hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|create_got_section
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|srelgot
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create the .stub and .glink sections as well as the ordinary    dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_create_dynamic_sections
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|&&
operator|!
name|create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|htab
operator|->
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|splt
operator|||
operator|!
name|htab
operator|->
name|srelplt
operator|||
operator|!
name|htab
operator|->
name|sdynbss
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|htab
operator|->
name|srelbss
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create .stub and .glink for global linkage functions.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|sstub
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".stub"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sstub
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sstub
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sstub
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
name|htab
operator|->
name|sglink
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".glink"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sglink
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sglink
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sglink
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_copy_indirect_symbol
parameter_list|(
name|dir
parameter_list|,
name|ind
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
decl_stmt|,
decl|*
name|ind
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add reloc counts against the weak sym to the strong sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|edir
operator|->
name|is_func
operator||=
name|eind
operator|->
name|is_func
expr_stmt|;
name|edir
operator|->
name|is_func_descriptor
operator||=
name|eind
operator|->
name|is_func_descriptor
expr_stmt|;
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    calculate needed space in the global offset table, procedure    linkage table, and dynamic reloc sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|boolean
name|is_opd
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
operator|(
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|is_opd
operator|=
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
comment|/* GOT16 relocations */
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|create_got_section
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
comment|/* This symbol requires a procedure linkage table entry.  We              actually build the entry in adjust_dynamic_symbol,              because this might be a case of linking PIC code without              linking in any dynamic objects, in which case we don't              need to generate a procedure linkage table after all.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* It does not make sense to have a procedure linkage                  table entry for a local symbol.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* The following relocations don't need to propagate the 	     relocation if linking a shared object since they are 	     section relative.  */
case|case
name|R_PPC64_SECTOFF
case|:
case|case
name|R_PPC64_SECTOFF_LO
case|:
case|case
name|R_PPC64_SECTOFF_HI
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|_bfd_elf64_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_PPC64_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|_bfd_elf64_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* We may need a .plt entry if the function this reloc 		 refers to is in a shared lib.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_ADDR64
case|:
if|if
condition|(
name|is_opd
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|fdh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|!=
name|NULL
condition|)
block|{
comment|/* Ensure the function descriptor symbol string is 		     part of the code symbol string.  We aren't 		     changing the name here, just allowing some tricks 		     in ppc64_elf_hide_symbol.  */
name|fdh
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|)
operator|->
name|is_func_descriptor
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
case|case
name|R_PPC64_REL64
case|:
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR30
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
case|case
name|R_PPC64_TOC
case|:
comment|/* Don't propagate .opd relocs.  */
if|if
condition|(
name|NO_OPD_RELOCS
operator|&&
name|is_opd
condition|)
break|break;
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  In case of a weak definition, 	     DEF_REGULAR may be cleared later by a strong definition in 	     a shared library.  We account for that possibility below by 	     storing information in the relocs_copied field of the hash 	     table entry.  A similar situation occurs when creating 	     shared libraries and symbol visibility changes render the 	     symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* We must copy these reloc types into the output file. 		 Create a reloc section in dynobj and make room for 		 this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad relocation section name `%s\'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|p
operator|=
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|ppc64_elf_gc_mark_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GNU_VTINHERIT
case|:
case|case
name|R_PPC64_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
return|return
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the .got, .plt. and dynamic reloc reference counts for the    section being removed.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_REL24
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL64
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
name|p
operator|->
name|pc_count
operator|-=
literal|1
expr_stmt|;
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR30
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_ADDR64
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
case|case
name|R_PPC64_TOC
case|:
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Called via elf_link_hash_traverse to transfer dynamic linking    information on function code symbol entries to their corresponding    function descriptor symbol entries.  */
end_comment

begin_function
specifier|static
name|boolean
name|func_desc_adjust
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
return|return
name|true
return|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* If this is a function code symbol, transfer dynamic linking      information to the function descriptor symbol.  */
if|if
condition|(
operator|!
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|fdh
decl_stmt|;
name|boolean
name|force_local
decl_stmt|;
comment|/* Find the corresponding function descriptor symbol.  Create it 	 as undefined if necessary.  */
name|fdh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdh
operator|==
name|NULL
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|newsym
decl_stmt|;
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
name|newsym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|newsym
operator|->
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
expr_stmt|;
name|newsym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|newsym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|newsym
operator|->
name|flags
operator|=
name|BSF_OBJECT
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|newsym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|newsym
operator|->
name|name
argument_list|,
name|newsym
operator|->
name|flags
argument_list|,
name|newsym
operator|->
name|section
argument_list|,
name|newsym
operator|->
name|value
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|fdh
argument_list|)
operator|)
condition|)
block|{
return|return
name|false
return|;
block|}
name|fdh
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
block|}
if|if
condition|(
name|fdh
operator|!=
name|NULL
operator|&&
operator|(
name|fdh
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|fdh
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|fdh
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fdh
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|fdh
argument_list|)
condition|)
return|return
name|false
return|;
name|fdh
operator|->
name|elf_link_hash_flags
operator||=
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_NON_GOT_REF
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
block|{
name|fdh
operator|->
name|plt
operator|.
name|refcount
operator|=
name|h
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
name|fdh
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fdh
operator|)
operator|->
name|is_func_descriptor
operator|=
literal|1
expr_stmt|;
name|fdh
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Now that the info is on the function descriptor, clear the 	 function code sym info.  Any function code syms for which we 	 don't have a definition in a regular file, we force local. 	 This prevents a shared library from exporting syms that have 	 been imported from another library.  Function code syms that 	 are really in the library we must leave global to prevent the 	 linker dragging in a definition from a static library.  */
name|force_local
operator|=
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Called near the start of bfd_elf_size_dynamic_sections.  We use    this hook to transfer dynamic linking information gathered so far    on function code symbol entries, to their corresponding function    descriptor symbol entries.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_func_desc_adjust
parameter_list|(
name|obfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|func_desc_adjust
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Deal with function syms.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clear procedure linkage table information for any symbol that 	 won't need a .plt entry.  */
if|if
condition|(
operator|!
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
operator|||
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|true
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in read-only sections, then      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
comment|/* We must generate a R_PPC_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|srelbss
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|4
condition|)
name|power_of_two
operator|=
literal|4
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|=
name|htab
operator|->
name|sdynbss
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If given a function descriptor symbol, hide both the function code    sym and the descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|ppc64_elf_hide_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|,
name|force_local
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|force_local
decl_stmt|;
block|{
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|fh
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|-
literal|1
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|!=
name|NULL
condition|)
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|fh
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is the condition under which ppc64_elf_finish_dynamic_symbol    will be called from elflink.h.  If elflink.h doesn't call our    finish_dynamic_symbol routine, we'll need to do something about    initializing any .plt and .got entries in ppc64_elf_relocate_section.  */
end_comment

begin_define
define|#
directive|define
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
parameter_list|(
name|DYN
parameter_list|,
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|((DYN)								\&& ((INFO)->shared							\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) == 0)	\&& ((H)->dynindx != -1						\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) != 0))
end_define

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_dynrelocs
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
return|return
name|true
return|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
comment|/* If this is the first .plt entry, make room for the special 	     first entry.  */
name|s
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_INITIAL_ENTRY_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make room for this entry.  */
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Make room for the .stub and .glink code.  */
name|s
operator|=
name|htab
operator|->
name|sstub
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_CALL_STUB_SIZE
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sglink
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|GLINK_CALL_STUB_SIZE
expr_stmt|;
comment|/* We need bigger stubs past index 32767.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|>=
name|GLINK_CALL_STUB_SIZE
operator|+
literal|32768
operator|*
literal|2
operator|*
literal|4
condition|)
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|2
operator|*
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|boolean
name|dyn
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for relocs that have become local due to symbol visibility      changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
operator|||
name|info
operator|->
name|symbolic
operator|)
condition|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|readonly_dynrelocs
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|ppc_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
operator|(
operator|(
expr|struct
name|ppc_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
control|)
block|{
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* We now have determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|bfd_vma
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|splt
operator|||
name|s
operator|==
name|htab
operator|->
name|sgot
operator|||
name|s
operator|==
name|htab
operator|->
name|sstub
operator|||
name|s
operator|==
name|htab
operator|->
name|sglink
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 		 output file.  This is mostly to handle .rela.bss and 		 .rela.plt.  We must create both sections in 		 create_dynamic_sections, because they must be created 		 before the linker maps input sections to output 		 sections.  The linker does that before 		 adjust_dynamic_symbol is called, and it is that 		 function which decides whether anything needs to go 		 into these sections.  */
block|}
else|else
block|{
if|if
condition|(
name|s
operator|!=
name|htab
operator|->
name|srelplt
condition|)
name|relocs
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  We use bfd_zalloc 	 here in case unused entries are not reclaimed before the 	 section's contents are written out.  This should not happen, 	 but this way if it does, we get a R_PPC64_NONE reloc instead 	 of garbage.  */
name|size
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|sstub
condition|)
block|{
comment|/* .stub may grow.  Allocate enough for the maximum growth.  */
name|size
operator|+=
operator|(
name|size
operator|+
literal|65536
operator|+
literal|65535
operator|)
operator|/
literal|65536
operator|*
literal|4
expr_stmt|;
block|}
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in ppc64_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_GLINK
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|NO_OPD_RELOCS
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_OPD
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC64_OPDSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If any dynamic relocs apply to a read-only section, 	     then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|readonly_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Called after we have seen all the input files/sections, but before    final symbol resolution and section placement has been determined.     We use this hook to provide a value for TOCstart, which we store in    the output bfd elf_gp.  */
end_comment

begin_function
name|boolean
name|ppc64_elf_set_toc
parameter_list|(
name|obfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_vma
name|TOCstart
decl_stmt|;
comment|/* The TOC consists of sections .got, .toc, .tocbss, .plt in that 	 order.  The TOC starts where the first of these sections starts.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".toc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".tocbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|obfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* This may happen for 	     o  references to TOC base (SYM@toc / TOC[tc0]) without a 	     .toc directive 	     o  bad linker script 	     o --gc-sections and empty TOC sections  	     FIXME: Warn user?  */
comment|/* Look for a likely section.  We probably won't even be 	     using TOCstart.  */
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
operator|)
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
name|SEC_ALLOC
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
for|for
control|(
name|s
operator|=
name|obfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
name|SEC_ALLOC
condition|)
break|break;
block|}
name|TOCstart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|TOCstart
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
name|elf_gp
argument_list|(
name|obfd
argument_list|)
operator|=
name|TOCstart
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* PowerPC64 .plt entries are 24 bytes long, which doesn't divide    evenly into 64k.  Sometimes with a large enough .plt, we'll need to    use offsets differing in the high 16 bits when accessing a .plt    entry from a .plt call stub.  This function adjusts the size of    .stub to accommodate the extra stub instruction needed in such    cases.  */
end_comment

begin_function
name|boolean
name|ppc64_elf_size_stubs
parameter_list|(
name|obfd
parameter_list|,
name|info
parameter_list|,
name|changed
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|int
modifier|*
name|changed
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|bfd_vma
name|plt_offset
decl_stmt|,
name|next_64k
decl_stmt|;
name|long
name|base
decl_stmt|,
name|num
decl_stmt|,
name|extra
decl_stmt|;
comment|/* .plt and .stub should be both present, or both absent.  */
if|if
condition|(
operator|(
name|htab
operator|->
name|splt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|==
literal|0
operator|)
operator|!=
operator|(
name|htab
operator|->
name|sstub
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sstub
operator|->
name|_raw_size
operator|==
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If no .plt, then nothing to do.  */
if|if
condition|(
name|htab
operator|->
name|splt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|plt_offset
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|-
name|elf_gp
argument_list|(
name|obfd
argument_list|)
operator|)
expr_stmt|;
name|next_64k
operator|=
operator|(
name|plt_offset
operator|+
literal|65535
operator|)
operator|&
operator|-
literal|65536
expr_stmt|;
comment|/* If the .plt doesn't have any entries crossing a 64k boundary,      then there is no need for bigger stubs.  */
if|if
condition|(
name|plt_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|<=
name|next_64k
condition|)
return|return
name|true
return|;
comment|/* OK, so we have at least one transition.  Since .plt entries are      24 bytes long, we'll strike it lucky every 3*64k, with the 64k      boundary between .plt entries.  */
name|base
operator|=
name|next_64k
operator|/
literal|65536
expr_stmt|;
name|num
operator|=
operator|(
name|plt_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|-
name|next_64k
operator|)
operator|/
literal|65536
expr_stmt|;
name|extra
operator|=
operator|(
name|base
operator|%
literal|3
operator|+
name|num
operator|+
literal|1
operator|)
operator|*
literal|2
operator|/
literal|3
expr_stmt|;
comment|/* Allow one extra instruction for each EXTRA.  The change in .stub      may change the location of .toc and .plt.  .toc and .plt ought to      move as a group, but someone might be playing with eg. .plt      alignment, so don't allow .stub size to decrease.  */
if|if
condition|(
name|htab
operator|->
name|sstub
operator|->
name|_cooked_size
operator|<
name|htab
operator|->
name|sstub
operator|->
name|_raw_size
operator|+
name|extra
operator|*
literal|4
condition|)
block|{
name|htab
operator|->
name|sstub
operator|->
name|_cooked_size
operator|=
name|htab
operator|->
name|sstub
operator|->
name|_raw_size
operator|+
name|extra
operator|*
literal|4
expr_stmt|;
operator|*
name|changed
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Build a .plt call stub.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|build_plt_stub
parameter_list|(
name|obfd
parameter_list|,
name|p
parameter_list|,
name|offset
parameter_list|,
name|glink
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|glink
decl_stmt|;
block|{
define|#
directive|define
name|PPC_LO
parameter_list|(
name|v
parameter_list|)
value|((v)& 0xffff)
define|#
directive|define
name|PPC_HI
parameter_list|(
name|v
parameter_list|)
value|(((v)>> 16)& 0xffff)
define|#
directive|define
name|PPC_HA
parameter_list|(
name|v
parameter_list|)
value|PPC_HI ((v) + 0x8000)
if|if
condition|(
name|glink
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R2_40R1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R2
operator||
name|PPC_HA
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|glink
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|STD_R2_40R1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|offset
operator|+
literal|8
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|offset
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R12_1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R2_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|offset
operator|+
literal|8
argument_list|)
operator|!=
name|PPC_HA
argument_list|(
name|offset
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|ADDIS_R12_R12_1
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|MTCTR_R11
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|LD_R11_0R12
operator||
name|PPC_LO
argument_list|(
name|offset
argument_list|)
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|obfd
argument_list|,
name|BCTR
argument_list|,
name|p
argument_list|)
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Build the stubs for one function call.  */
end_comment

begin_function
specifier|static
name|boolean
name|build_one_stub
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
return|return
name|true
return|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|fh
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_vma
name|plt_r2
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|fh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|-
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|fh
operator|)
operator|->
name|is_func
argument_list|)
expr_stmt|;
comment|/* Build the .plt call stub.  */
name|plt_r2
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|-
name|TOC_BASE_OFF
operator|)
expr_stmt|;
if|if
condition|(
name|plt_r2
operator|+
literal|0x80000000
operator|>
literal|0xffffffff
operator|||
operator|(
name|plt_r2
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"linkage table error against `%s'"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt_overflow
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sstub
expr_stmt|;
comment|/* Steal plt.offset to store the stub offset.  */
name|fh
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|_cooked_size
expr_stmt|;
name|p
operator|=
name|build_plt_stub
argument_list|(
name|s
operator|->
name|owner
argument_list|,
name|p
argument_list|,
operator|(
name|int
operator|)
name|plt_r2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|_cooked_size
operator|=
name|p
operator|-
name|s
operator|->
name|contents
expr_stmt|;
comment|/* Build the .glink lazy link call stub.  */
name|s
operator|=
name|htab
operator|->
name|sglink
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|_cooked_size
expr_stmt|;
name|indx
operator|=
name|s
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|indx
operator|<
literal|0x8000
condition|)
block|{
name|bfd_put_32
argument_list|(
name|s
operator|->
name|owner
argument_list|,
name|LI_R0_0
operator||
name|indx
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|s
operator|->
name|owner
argument_list|,
name|LIS_R0_0
operator||
name|PPC_HI
argument_list|(
name|indx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|s
operator|->
name|owner
argument_list|,
name|ORI_R0_R0_0
operator||
name|PPC_LO
argument_list|(
name|indx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|s
operator|->
name|owner
argument_list|,
name|B_DOT
operator||
operator|(
operator|(
name|s
operator|->
name|contents
operator|-
name|p
operator|)
operator|&
literal|0x3fffffc
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|s
operator|->
name|_cooked_size
operator|=
name|p
operator|-
name|s
operator|->
name|contents
expr_stmt|;
name|s
operator|->
name|reloc_count
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|ppc64_elf_build_stubs
parameter_list|(
name|obfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
init|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|bfd_vma
name|old_stub_size
decl_stmt|;
name|bfd_vma
name|plt_r2
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
comment|/* If no .plt stubs, then nothing to do.  */
if|if
condition|(
name|htab
operator|->
name|sstub
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sstub
operator|->
name|_raw_size
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|old_stub_size
operator|=
name|htab
operator|->
name|sstub
operator|->
name|_cooked_size
expr_stmt|;
name|htab
operator|->
name|sstub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
comment|/* Build the .glink plt call stub.  */
name|plt_r2
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|-
name|elf_gp
argument_list|(
name|obfd
argument_list|)
operator|-
name|TOC_BASE_OFF
operator|)
expr_stmt|;
name|p
operator|=
name|htab
operator|->
name|sglink
operator|->
name|contents
expr_stmt|;
name|p
operator|=
name|build_plt_stub
argument_list|(
name|htab
operator|->
name|sglink
operator|->
name|owner
argument_list|,
name|p
argument_list|,
operator|(
name|int
operator|)
name|plt_r2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|-
name|htab
operator|->
name|sglink
operator|->
name|contents
operator|<
name|GLINK_CALL_STUB_SIZE
condition|)
block|{
name|bfd_put_32
argument_list|(
name|htab
operator|->
name|sglink
operator|->
name|owner
argument_list|,
name|NOP
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|htab
operator|->
name|sglink
operator|->
name|_cooked_size
operator|=
name|p
operator|-
name|htab
operator|->
name|sglink
operator|->
name|contents
expr_stmt|;
comment|/* Use reloc_count to count entries.  */
name|htab
operator|->
name|sglink
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|build_one_stub
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sglink
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_overflow
condition|)
return|return
name|false
return|;
if|if
condition|(
name|old_stub_size
operator|!=
name|htab
operator|->
name|sstub
operator|->
name|_cooked_size
operator|||
name|htab
operator|->
name|sglink
operator|->
name|_raw_size
operator|!=
name|htab
operator|->
name|sglink
operator|->
name|_cooked_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stub section size doesn't match calculated size"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set up any other section flags and such that may be necessary.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|shdr
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf64_Internal_Shdr
modifier|*
name|shdr
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
condition|)
name|shdr
operator|->
name|sh_flags
operator||=
name|SHF_EXCLUDE
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_SORT_ENTRIES
operator|)
operator|!=
literal|0
condition|)
name|shdr
operator|->
name|sh_type
operator|=
name|SHT_ORDERED
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjust the section contents as    necessary, and (if using Rela relocs and generating a    relocateable output file) adjusting the reloc addend as    necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocateable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|bfd_vma
name|TOCstart
decl_stmt|;
name|boolean
name|ret
init|=
name|true
decl_stmt|;
name|boolean
name|is_opd
decl_stmt|;
comment|/* Initialize howto table if needed.  */
if|if
condition|(
operator|!
name|ppc64_elf_howto_table
index|[
name|R_PPC64_ADDR32
index|]
condition|)
name|ppc_howto_init
argument_list|()
expr_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|TOCstart
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|is_opd
operator|=
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|boolean
name|unresolved_reloc
decl_stmt|;
name|boolean
name|has_nop
decl_stmt|;
name|long
name|insn
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* This is a final link.  */
name|offset
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|r
operator|=
name|bfd_reloc_other
expr_stmt|;
name|sym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
literal|0
expr_stmt|;
name|sec
operator|=
operator|(
name|asection
operator|*
operator|)
literal|0
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
literal|0
expr_stmt|;
name|sym_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_TOC
condition|)
block|{
comment|/* Relocation value is TOC base.  Symbol is ignored.  */
name|relocation
operator|=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* It's a local symbol.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
literal|"<local symbol>"
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a global symbol.  */
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
comment|/* Set a flag that will be cleared later if we find a 		   relocation value for this symbol.  output_section 		   is typically NULL for symbols satisfied by a shared 		   library.  */
name|unresolved_reloc
operator|=
name|true
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|allow_shlib_undefined
operator|)
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* First handle relocations that tweak non-addend part of insn.  */
name|insn
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
comment|/* Branch taken prediction relocations.  */
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
name|insn
operator|=
literal|0x01
operator|<<
literal|21
expr_stmt|;
comment|/* Set 't' bit, lowest bit of BO field. */
comment|/* Fall thru. */
comment|/* Branch not taken prediction relocations.  */
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
name|insn
operator||=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
operator|&
operator|~
operator|(
literal|0x01
operator|<<
literal|21
operator|)
expr_stmt|;
comment|/* Set 'a' bit.  This is 0b00010 in BO field for branch on CR(BI) 	     insns (BO == 001at or 011at), and 0b01000 for branch on CTR 	     insns (BO == 1a00t or 1a01t).  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x04
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x02
operator|<<
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|0x14
operator|<<
literal|21
operator|)
operator|)
operator|==
operator|(
literal|0x10
operator|<<
literal|21
operator|)
condition|)
name|insn
operator||=
literal|0x08
operator|<<
literal|21
expr_stmt|;
else|else
break|break;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_PPC64_REL24
case|:
case|case
name|R_PPC64_ADDR24
case|:
comment|/* An ADDR24 or REL24 branching to a linkage function may be 	     followed by a nop that we have to replace with a ld in 	     order to restore the TOC base pointer.  Only calls to 	     shared objects need to alter the TOC base.  These are 	     recognized by their need for a PLT entry.  */
name|has_nop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|htab
operator|->
name|sstub
operator|!=
name|NULL
condition|)
block|{
comment|/* plt.offset here is the offset into the stub section.  */
name|relocation
operator|=
operator|(
name|htab
operator|->
name|sstub
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sstub
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
comment|/* Make sure that there really is an instruction after                  the branch that we can decode.  */
if|if
condition|(
name|offset
operator|+
literal|8
operator|<=
name|input_section
operator|->
name|_cooked_size
condition|)
block|{
name|bfd_byte
modifier|*
name|pnext
decl_stmt|;
name|pnext
operator|=
name|contents
operator|+
name|offset
operator|+
literal|4
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|pnext
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0x60000000
comment|/* nop (ori  r0,r0,0) */
operator|||
name|insn
operator|==
literal|0x4def7b82
comment|/* cror 15,15,15 */
operator|||
name|insn
operator|==
literal|0x4ffffb82
condition|)
comment|/* cror 31,31,31 */
block|{
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0xe8410028
argument_list|,
comment|/* ld r2,40(r1) */
name|pnext
argument_list|)
expr_stmt|;
name|has_nop
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|r_type
operator|==
name|R_PPC64_REL24
operator|&&
name|addend
operator|==
literal|0
operator|&&
name|relocation
operator|==
literal|0
condition|)
block|{
comment|/* Tweak calls to undefined weak functions to behave as 		 if the "called" function immediately returns.  We can 		 thus call to a weak function without first checking 		 whether the function is defined.  */
name|relocation
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|has_nop
condition|)
name|relocation
operator|=
literal|8
expr_stmt|;
block|}
break|break;
block|}
comment|/* Set `addend'.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d for symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
case|case
name|R_PPC64_NONE
case|:
case|case
name|R_PPC_GNU_VTINHERIT
case|:
case|case
name|R_PPC_GNU_VTENTRY
case|:
continue|continue;
comment|/* GOT16 relocations.  Like an ADDR16 using the symbol's 	     address in the GOT as relocation value instead of the 	     symbols value itself.  Also, create a GOT entry for the 	     symbol and put the symbol value there.  */
case|case
name|R_PPC64_GOT16
case|:
case|case
name|R_PPC64_GOT16_LO
case|:
case|case
name|R_PPC64_GOT16_HI
case|:
case|case
name|R_PPC64_GOT16_HA
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
block|{
comment|/* Relocation is to the entry for this symbol in the global 	       offset table.  */
name|bfd_vma
name|off
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 		       -Bsymbolic link and the symbol is defined 		       locally, or the symbol was forced to be local 		       because of a version file.  We must initialize 		       this entry in the global offset table.  Since the 		       offset must always be a multiple of 8, we use the 		       least significant bit to record whether we have 		       initialized it already.  		       When doing a dynamic link, we create a .rel.got 		       relocation entry to initialize the value.  This 		       is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 8.  We use 		   the least significant bit to record whether we have 		   already processed this entry.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* We need to generate a R_PPC64_RELATIVE reloc 			   for the dynamic linker.  */
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|relocation
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
comment|/* TOC base (r2) is TOC start plus 0x8000.  */
name|addend
operator|-=
name|TOC_BASE_OFF
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_PLT16_HI
case|:
case|case
name|R_PPC64_PLT16_LO
case|:
case|case
name|R_PPC64_PLT32
case|:
case|case
name|R_PPC64_PLT64
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
comment|/* Resolve a PLT reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|htab
operator|->
name|splt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
break|break;
block|}
name|relocation
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
break|break;
comment|/* TOC16 relocs.  We want the offset relative to the TOC base, 	     which is the address of the start of the TOC plus 0x8000. 	     The TOC consists of sections .got, .toc, .tocbss, and .plt, 	     in this order.  */
case|case
name|R_PPC64_TOC16
case|:
case|case
name|R_PPC64_TOC16_LO
case|:
case|case
name|R_PPC64_TOC16_HI
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
name|addend
operator|-=
name|TOCstart
operator|+
name|TOC_BASE_OFF
expr_stmt|;
break|break;
comment|/* Relocate against the beginning of the section.  */
case|case
name|R_PPC64_SECTOFF
case|:
case|case
name|R_PPC64_SECTOFF_LO
case|:
case|case
name|R_PPC64_SECTOFF_HI
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
if|if
condition|(
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
literal|0
condition|)
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|R_PPC64_REL24
case|:
break|break;
comment|/* Relocations that may need to be propagated if this is a 	     dynamic object.  */
case|case
name|R_PPC64_REL14
case|:
case|case
name|R_PPC64_REL14_BRNTAKEN
case|:
case|case
name|R_PPC64_REL14_BRTAKEN
case|:
case|case
name|R_PPC64_REL32
case|:
case|case
name|R_PPC64_REL64
case|:
case|case
name|R_PPC64_ADDR14
case|:
case|case
name|R_PPC64_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC64_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC64_ADDR16
case|:
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HI
case|:
case|case
name|R_PPC64_ADDR16_HIGHER
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHEST
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_ADDR16_LO
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_ADDR24
case|:
case|case
name|R_PPC64_ADDR30
case|:
case|case
name|R_PPC64_ADDR32
case|:
case|case
name|R_PPC64_ADDR64
case|:
case|case
name|R_PPC64_UADDR16
case|:
case|case
name|R_PPC64_UADDR32
case|:
case|case
name|R_PPC64_UADDR64
case|:
comment|/* r_symndx will be zero only for relocs against symbols 	     from removed linkonce sections, or sections discarded by 	     a linker script.  */
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
break|break;
comment|/* Fall thru.  */
case|case
name|R_PPC64_TOC
case|:
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|NO_OPD_RELOCS
operator|&&
name|is_opd
condition|)
break|break;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* When generating a dynamic object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
name|skip
operator|=
name|false
expr_stmt|;
name|relocate
operator|=
name|false
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|true
operator|,
name|relocate
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|is_opd
operator|&&
operator|(
operator|!
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This symbol is local, or marked to become local, 		     or this is an opd section reloc which must point 		     at a local function.  */
name|outrel
operator|.
name|r_addend
operator|+=
name|relocation
expr_stmt|;
name|relocate
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC64_ADDR64
operator|||
name|r_type
operator|==
name|R_PPC64_TOC
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
comment|/* We are turning this relocation into one 			     against a section symbol, so subtract out 			     the output section's address but not the 			     offset of the input section in the output 			     section.  */
name|outrel
operator|.
name|r_addend
operator|-=
name|osec
operator|->
name|vma
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an external symbol, it will 		 be computed at runtime, so there's no need to do 		 anything now.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
break|break;
case|case
name|R_PPC64_COPY
case|:
case|case
name|R_PPC64_GLOB_DAT
case|:
case|case
name|R_PPC64_JMP_SLOT
case|:
case|case
name|R_PPC64_RELATIVE
case|:
comment|/* We shouldn't ever see these dynamic relocs in relocatable 	     files.  */
comment|/* Fall thru */
case|case
name|R_PPC64_PLTGOT16
case|:
case|case
name|R_PPC64_PLTGOT16_DS
case|:
case|case
name|R_PPC64_PLTGOT16_HA
case|:
case|case
name|R_PPC64_PLTGOT16_HI
case|:
case|case
name|R_PPC64_PLTGOT16_LO
case|:
case|case
name|R_PPC64_PLTGOT16_LO_DS
case|:
case|case
name|R_PPC64_PLTREL32
case|:
case|case
name|R_PPC64_PLTREL64
case|:
comment|/* These ones haven't been implemented yet.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Relocation %s is not supported for symbol %s."
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
comment|/* Do any further special processing.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC64_ADDR16_HA
case|:
case|case
name|R_PPC64_ADDR16_HIGHERA
case|:
case|case
name|R_PPC64_ADDR16_HIGHESTA
case|:
case|case
name|R_PPC64_PLT16_HA
case|:
case|case
name|R_PPC64_TOC16_HA
case|:
case|case
name|R_PPC64_SECTOFF_HA
case|:
comment|/* It's just possible that this symbol is a weak symbol 	     that's not actually defined anywhere. In that case, 	     'sec' would be NULL, and we should leave the symbol 	     alone (it will be set to zero elsewhere in the link).  */
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
comment|/* Add 0x10000 if sign bit in 0:15 is set.  */
name|addend
operator|+=
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|)
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC64_ADDR16_DS
case|:
case|case
name|R_PPC64_ADDR16_LO_DS
case|:
case|case
name|R_PPC64_GOT16_DS
case|:
case|case
name|R_PPC64_GOT16_LO_DS
case|:
case|case
name|R_PPC64_PLT16_LO_DS
case|:
case|case
name|R_PPC64_SECTOFF_DS
case|:
case|case
name|R_PPC64_SECTOFF_LO_DS
case|:
case|case
name|R_PPC64_TOC16_DS
case|:
case|case
name|R_PPC64_TOC16_LO_DS
case|:
case|case
name|R_PPC64_PLTGOT16_DS
case|:
case|case
name|R_PPC64_PLTGOT16_LO_DS
case|:
if|if
condition|(
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: error: relocation %s not a multiple of 4"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* FIXME: Why do we allow debugging sections to escape this error? 	 More importantly, why do we not emit dynamic relocs above in 	 debugging sections (which are ! SEC_ALLOC)?  If we had 	 emitted the dynamic reloc, we could remove the fudge here.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): unresolvable relocation against symbol `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|pc_relative
condition|)
block|{
comment|/* Assume this is a call protected by other code that 		     detects the symbol is undefined.  If this is the case, 		     we can safely ignore the overflow.  If not, the 		     program is hosed anyway, and a little warning isn't 		     going to help.  */
continue|continue;
block|}
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|ppc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
name|ret
operator|=
name|false
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
operator|(
expr|struct
name|ppc_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_func_descriptor
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set          it up.  */
if|if
condition|(
name|htab
operator|->
name|splt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|srelplt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sglink
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a JMP_SLOT reloc to inform the dynamic linker to 	 fill in the PLT entry.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelplt
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it          up.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
operator|||
name|htab
operator|->
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a static link, or it is a -Bsymbolic link and the 	 symbol is defined locally or was forced to be local because 	 of a version file, we just want to emit a RELATIVE reloc. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC64_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_GLOB_DAT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|||
name|htab
operator|->
name|srelbss
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC64_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelbss
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelbss
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Used to decide how to sort relocs in an optimal manner for the    dynamic linker, before writing them out.  */
end_comment

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|ppc64_elf_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC64_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_PPC64_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_PPC64_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc64_elf_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ppc_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|htab
operator|=
name|ppc_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|Elf64_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf64_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
continue|continue;
case|case
name|DT_PPC64_GLINK
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|htab
operator|->
name|sglink
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sglink
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|DT_PPC64_OPD
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_PPC64_OPDSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|htab
operator|->
name|srelplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|srelplt
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* Don't count procedure linkage table relocs in the 		 overall reloc count.  */
if|if
condition|(
name|htab
operator|->
name|srelplt
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|htab
operator|->
name|srelplt
operator|->
name|_raw_size
expr_stmt|;
break|break;
block|}
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|sgot
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|sgot
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Fill in the first entry in the global offset table. 	 We use it to hold the link-time TOCbase.  */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|TOC_BASE_OFF
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* Set .got entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Set .plt entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_powerpcle_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-powerpcle"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_powerpc_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-powerpc"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_powerpc
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PPC64
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|ppc64_elf_info_to_howto
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|EM_CYGNUS_POWERPC
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_CYGNUS_POWERPC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EM_PPC_OLD
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT2
value|EM_PPC_OLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_backend_want_got_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_alignment
value|3
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_not_loaded
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_symbol_offset
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|8
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|PLT_INITIAL_ENTRY_SIZE
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
value|ppc64_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_set_private_flags
value|ppc64_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_merge_private_bfd_data
value|ppc64_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
value|ppc64_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|ppc64_elf_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|ppc64_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|ppc64_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|ppc64_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|ppc64_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|ppc64_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|ppc64_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|ppc64_elf_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
value|ppc64_elf_func_desc_adjust
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|ppc64_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|ppc64_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|ppc64_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|ppc64_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|ppc64_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|ppc64_elf_finish_dynamic_sections
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

