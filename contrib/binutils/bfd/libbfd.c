begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Assorted BFD support routines, only used internally.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.    Written by Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETPAGESIZE
end_ifndef

begin_define
define|#
directive|define
name|getpagesize
parameter_list|()
value|2048
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SECTION 	Implementation details  SUBSECTION 	Internal functions  DESCRIPTION 	These routines are used within BFD. 	They are not intended for export, but are documented here for 	completeness. */
end_comment

begin_comment
comment|/* A routine which is used in target vectors for unsupported    operations.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_false
parameter_list|(
name|bfd
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* A routine which is used in target vectors for supported operations    which do not actually do anything.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_true
parameter_list|(
name|bfd
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A routine which is used in target vectors for unsupported    operations which return a pointer value.  */
end_comment

begin_function
name|void
modifier|*
name|bfd_nullvoidptr
parameter_list|(
name|bfd
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|bfd_0
parameter_list|(
name|bfd
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|bfd_0u
parameter_list|(
name|bfd
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|long
name|bfd_0l
parameter_list|(
name|bfd
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A routine which is used in target vectors for unsupported    operations which return -1 on error.  */
end_comment

begin_function
name|long
name|_bfd_n1
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|bfd_void
parameter_list|(
name|bfd
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
name|bfd_boolean
name|_bfd_nocore_core_file_matches_executable_p
parameter_list|(
name|bfd
modifier|*
name|ignore_core_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|ignore_exec_bfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Routine to handle core_file_failing_command entry point for targets    without core file support.  */
end_comment

begin_function
name|char
modifier|*
name|_bfd_nocore_core_file_failing_command
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Routine to handle core_file_failing_signal entry point for targets    without core file support.  */
end_comment

begin_function
name|int
name|_bfd_nocore_core_file_failing_signal
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|bfd_target
modifier|*
name|_bfd_dummy_target
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate memory using malloc.  */
end_comment

begin_function
name|void
modifier|*
name|bfd_malloc
parameter_list|(
name|bfd_size_type
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|size
operator|!=
operator|(
name|size_t
operator|)
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ptr
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
operator|&&
operator|(
name|size_t
operator|)
name|size
operator|!=
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory using malloc, nmemb * size with overflow checking.  */
end_comment

begin_function
name|void
modifier|*
name|bfd_malloc2
parameter_list|(
name|bfd_size_type
name|nmemb
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|nmemb
operator||
name|size
operator|)
operator|>=
name|HALF_BFD_SIZE_TYPE
operator|&&
name|size
operator|!=
literal|0
operator|&&
name|nmemb
operator|>
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0
operator|/
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|size
operator|*=
name|nmemb
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|(
name|size_t
operator|)
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ptr
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
operator|&&
operator|(
name|size_t
operator|)
name|size
operator|!=
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Reallocate memory using realloc.  */
end_comment

begin_function
name|void
modifier|*
name|bfd_realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|size
operator|!=
operator|(
name|size_t
operator|)
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|ret
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|&&
operator|(
name|size_t
operator|)
name|size
operator|!=
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Reallocate memory using realloc, nmemb * size with overflow checking.  */
end_comment

begin_function
name|void
modifier|*
name|bfd_realloc2
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|bfd_size_type
name|nmemb
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|nmemb
operator||
name|size
operator|)
operator|>=
name|HALF_BFD_SIZE_TYPE
operator|&&
name|size
operator|!=
literal|0
operator|&&
name|nmemb
operator|>
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0
operator|/
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|size
operator|*=
name|nmemb
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|(
name|size_t
operator|)
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|ret
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|&&
operator|(
name|size_t
operator|)
name|size
operator|!=
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory using malloc and clear it.  */
end_comment

begin_function
name|void
modifier|*
name|bfd_zmalloc
parameter_list|(
name|bfd_size_type
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|size
operator|!=
operator|(
name|size_t
operator|)
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ptr
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory using malloc (nmemb * size) with overflow checking    and clear it.  */
end_comment

begin_function
name|void
modifier|*
name|bfd_zmalloc2
parameter_list|(
name|bfd_size_type
name|nmemb
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|nmemb
operator||
name|size
operator|)
operator|>=
name|HALF_BFD_SIZE_TYPE
operator|&&
name|size
operator|!=
literal|0
operator|&&
name|nmemb
operator|>
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0
operator|/
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|size
operator|*=
name|nmemb
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|(
name|size_t
operator|)
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ptr
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_write_bigendian_4byte_int  SYNOPSIS 	bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);  DESCRIPTION 	Write a 4 byte integer @var{i} to the output BFD @var{abfd}, in big 	endian order regardless of what else is going on.  This is useful in 	archives.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_write_bigendian_4byte_int
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|)
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|i
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|bfd_bwrite
argument_list|(
name|buffer
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|==
literal|4
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** The do-it-yourself (byte) sex-change kit */
end_comment

begin_comment
comment|/* The middle letter e.g. get<b>short indicates Big or Little endian    target machine.  It doesn't matter what the byte order of the host    machine is; these routines work for either.  */
end_comment

begin_comment
comment|/* FIXME: Should these take a count argument?    Answer (gnu@cygnus.com):  No, but perhaps they should be inline                              functions in swap.h #ifdef __GNUC__.                              Gprof them later and find out.  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_put_size FUNCTION 	bfd_get_size  DESCRIPTION 	These macros as used for reading and writing raw data in 	sections; each access (except for bytes) is vectored through 	the target format of the BFD and mangled accordingly. The 	mangling performs any necessary endian translations and 	removes alignment restrictions.  Note that types accepted and 	returned by these macros are identical so they can be swapped 	around in macros---for example, @file{libaout.h} defines<<GET_WORD>> 	to either<<bfd_get_32>> or<<bfd_get_64>>.  	In the put routines, @var{val} must be a<<bfd_vma>>.  If we are on a 	system without prototypes, the caller is responsible for making 	sure that is true, with a cast if necessary.  We don't cast 	them in the macro definitions because that would prevent<<lint>> 	or<<gcc -Wall>> from detecting sins such as passing a pointer. 	To detect calling these with less than a<<bfd_vma>>, use<<gcc -Wconversion>> on a host with 64 bit<<bfd_vma>>'s.  . .{* Byte swapping macros for user section data.  *} . .#define bfd_put_8(abfd, val, ptr) \ .  ((void) (*((unsigned char *) (ptr)) = (val)& 0xff)) .#define bfd_put_signed_8 \ .  bfd_put_8 .#define bfd_get_8(abfd, ptr) \ .  (*(unsigned char *) (ptr)& 0xff) .#define bfd_get_signed_8(abfd, ptr) \ .  (((*(unsigned char *) (ptr)& 0xff) ^ 0x80) - 0x80) . .#define bfd_put_16(abfd, val, ptr) \ .  BFD_SEND (abfd, bfd_putx16, ((val),(ptr))) .#define bfd_put_signed_16 \ .  bfd_put_16 .#define bfd_get_16(abfd, ptr) \ .  BFD_SEND (abfd, bfd_getx16, (ptr)) .#define bfd_get_signed_16(abfd, ptr) \ .  BFD_SEND (abfd, bfd_getx_signed_16, (ptr)) . .#define bfd_put_32(abfd, val, ptr) \ .  BFD_SEND (abfd, bfd_putx32, ((val),(ptr))) .#define bfd_put_signed_32 \ .  bfd_put_32 .#define bfd_get_32(abfd, ptr) \ .  BFD_SEND (abfd, bfd_getx32, (ptr)) .#define bfd_get_signed_32(abfd, ptr) \ .  BFD_SEND (abfd, bfd_getx_signed_32, (ptr)) . .#define bfd_put_64(abfd, val, ptr) \ .  BFD_SEND (abfd, bfd_putx64, ((val), (ptr))) .#define bfd_put_signed_64 \ .  bfd_put_64 .#define bfd_get_64(abfd, ptr) \ .  BFD_SEND (abfd, bfd_getx64, (ptr)) .#define bfd_get_signed_64(abfd, ptr) \ .  BFD_SEND (abfd, bfd_getx_signed_64, (ptr)) . .#define bfd_get(bits, abfd, ptr)			\ .  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)	\ .   : (bits) == 16 ? bfd_get_16 (abfd, ptr)		\ .   : (bits) == 32 ? bfd_get_32 (abfd, ptr)		\ .   : (bits) == 64 ? bfd_get_64 (abfd, ptr)		\ .   : (abort (), (bfd_vma) - 1)) . .#define bfd_put(bits, abfd, val, ptr)			\ .  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)		\ .   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)		\ .   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)		\ .   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)		\ .   : (abort (), (void) 0)) . */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_h_put_size 	bfd_h_get_size  DESCRIPTION 	These macros have the same function as their<<bfd_get_x>> 	brethren, except that they are used for removing information 	for the header records of object files. Believe it or not, 	some object files keep their header records in big endian 	order and their data in little endian order. . .{* Byte swapping macros for file header data.  *} . .#define bfd_h_put_8(abfd, val, ptr) \ .  bfd_put_8 (abfd, val, ptr) .#define bfd_h_put_signed_8(abfd, val, ptr) \ .  bfd_put_8 (abfd, val, ptr) .#define bfd_h_get_8(abfd, ptr) \ .  bfd_get_8 (abfd, ptr) .#define bfd_h_get_signed_8(abfd, ptr) \ .  bfd_get_signed_8 (abfd, ptr) . .#define bfd_h_put_16(abfd, val, ptr) \ .  BFD_SEND (abfd, bfd_h_putx16, (val, ptr)) .#define bfd_h_put_signed_16 \ .  bfd_h_put_16 .#define bfd_h_get_16(abfd, ptr) \ .  BFD_SEND (abfd, bfd_h_getx16, (ptr)) .#define bfd_h_get_signed_16(abfd, ptr) \ .  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr)) . .#define bfd_h_put_32(abfd, val, ptr) \ .  BFD_SEND (abfd, bfd_h_putx32, (val, ptr)) .#define bfd_h_put_signed_32 \ .  bfd_h_put_32 .#define bfd_h_get_32(abfd, ptr) \ .  BFD_SEND (abfd, bfd_h_getx32, (ptr)) .#define bfd_h_get_signed_32(abfd, ptr) \ .  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr)) . .#define bfd_h_put_64(abfd, val, ptr) \ .  BFD_SEND (abfd, bfd_h_putx64, (val, ptr)) .#define bfd_h_put_signed_64 \ .  bfd_h_put_64 .#define bfd_h_get_64(abfd, ptr) \ .  BFD_SEND (abfd, bfd_h_getx64, (ptr)) .#define bfd_h_get_signed_64(abfd, ptr) \ .  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr)) . .{* Aliases for the above, which should eventually go away.  *} . .#define H_PUT_64  bfd_h_put_64 .#define H_PUT_32  bfd_h_put_32 .#define H_PUT_16  bfd_h_put_16 .#define H_PUT_8   bfd_h_put_8 .#define H_PUT_S64 bfd_h_put_signed_64 .#define H_PUT_S32 bfd_h_put_signed_32 .#define H_PUT_S16 bfd_h_put_signed_16 .#define H_PUT_S8  bfd_h_put_signed_8 .#define H_GET_64  bfd_h_get_64 .#define H_GET_32  bfd_h_get_32 .#define H_GET_16  bfd_h_get_16 .#define H_GET_8   bfd_h_get_8 .#define H_GET_S64 bfd_h_get_signed_64 .#define H_GET_S32 bfd_h_get_signed_32 .#define H_GET_S16 bfd_h_get_signed_16 .#define H_GET_S8  bfd_h_get_signed_8 . .*/
end_comment

begin_comment
comment|/* Sign extension to bfd_signed_vma.  */
end_comment

begin_define
define|#
directive|define
name|COERCE16
parameter_list|(
name|x
parameter_list|)
value|(((bfd_signed_vma) (x) ^ 0x8000) - 0x8000)
end_define

begin_define
define|#
directive|define
name|COERCE32
parameter_list|(
name|x
parameter_list|)
value|(((bfd_signed_vma) (x) ^ 0x80000000) - 0x80000000)
end_define

begin_define
define|#
directive|define
name|EIGHT_GAZILLION
value|((bfd_int64_t) 1<< 63)
end_define

begin_define
define|#
directive|define
name|COERCE64
parameter_list|(
name|x
parameter_list|)
define|\
value|(((bfd_int64_t) (x) ^ EIGHT_GAZILLION) - EIGHT_GAZILLION)
end_define

begin_function
name|bfd_vma
name|bfd_getb16
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
return|return
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
return|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getl16
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
return|return
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getb_signed_16
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
return|return
name|COERCE16
argument_list|(
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getl_signed_16
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
return|return
name|COERCE16
argument_list|(
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|bfd_putb16
parameter_list|(
name|bfd_vma
name|data
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_putl16
parameter_list|(
name|bfd_vma
name|data
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getb32
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|unsigned
name|long
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|24
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|3
index|]
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getl32
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|unsigned
name|long
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getb_signed_32
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|unsigned
name|long
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|24
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|3
index|]
expr_stmt|;
return|return
name|COERCE32
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getl_signed_32
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|unsigned
name|long
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|v
operator||=
operator|(
name|unsigned
name|long
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
return|return
name|COERCE32
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_uint64_t
name|bfd_getb64
parameter_list|(
specifier|const
name|void
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|bfd_uint64_t
name|v
decl_stmt|;
name|v
operator|=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|2
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|3
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|5
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|6
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|7
index|]
expr_stmt|;
return|return
name|v
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bfd_uint64_t
name|bfd_getl64
parameter_list|(
specifier|const
name|void
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|bfd_uint64_t
name|v
decl_stmt|;
name|v
operator|=
name|addr
index|[
literal|7
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|6
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|5
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|3
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|2
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|0
index|]
expr_stmt|;
return|return
name|v
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bfd_int64_t
name|bfd_getb_signed_64
parameter_list|(
specifier|const
name|void
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|bfd_uint64_t
name|v
decl_stmt|;
name|v
operator|=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|2
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|3
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|5
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|6
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|7
index|]
expr_stmt|;
return|return
name|COERCE64
argument_list|(
name|v
argument_list|)
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bfd_int64_t
name|bfd_getl_signed_64
parameter_list|(
specifier|const
name|void
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|bfd_uint64_t
name|v
decl_stmt|;
name|v
operator|=
name|addr
index|[
literal|7
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|6
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|5
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|3
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|2
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|v
operator|<<=
literal|8
expr_stmt|;
name|v
operator||=
name|addr
index|[
literal|0
index|]
expr_stmt|;
return|return
name|COERCE64
argument_list|(
name|v
argument_list|)
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|bfd_putb32
parameter_list|(
name|bfd_vma
name|data
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|data
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|data
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_putl32
parameter_list|(
name|bfd_vma
name|data
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
operator|(
name|data
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
operator|(
name|data
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_putb64
parameter_list|(
name|bfd_uint64_t
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|7
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|6
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|5
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|4
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|3
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|2
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|6
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|1
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|7
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|0
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|bfd_putl64
parameter_list|(
name|bfd_uint64_t
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|addr
index|[
literal|7
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|7
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|6
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|6
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|5
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|4
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|3
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|2
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|1
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|data
operator|>>
operator|(
literal|0
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|bfd_put_bits
parameter_list|(
name|bfd_uint64_t
name|data
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|int
name|bits
parameter_list|,
name|bfd_boolean
name|big_p
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|bytes
decl_stmt|;
if|if
condition|(
name|bits
operator|%
literal|8
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bytes
operator|=
name|bits
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bytes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
name|big_p
condition|?
name|bytes
operator|-
name|i
operator|-
literal|1
else|:
name|i
decl_stmt|;
name|addr
index|[
name|index
index|]
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|data
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bfd_uint64_t
name|bfd_get_bits
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|int
name|bits
parameter_list|,
name|bfd_boolean
name|big_p
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|bfd_uint64_t
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|bytes
decl_stmt|;
if|if
condition|(
name|bits
operator|%
literal|8
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
name|bytes
operator|=
name|bits
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bytes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
name|big_p
condition|?
name|i
else|:
name|bytes
operator|-
name|i
operator|-
literal|1
decl_stmt|;
name|data
operator|=
operator|(
name|data
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
name|index
index|]
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Default implementation */
end_comment

begin_function
name|bfd_boolean
name|_bfd_generic_get_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|sz
operator|=
name|section
operator|->
name|rawsize
condition|?
name|section
operator|->
name|rawsize
else|:
name|section
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|count
operator|>
name|sz
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_generic_get_section_contents_in_window
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|sec_ptr
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_window
modifier|*
name|w
name|ATTRIBUTE_UNUSED
parameter_list|,
name|file_ptr
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_size_type
name|count
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_MMAP
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|_bfd_get_section_contents
operator|!=
name|_bfd_generic_get_section_contents
condition|)
block|{
comment|/* We don't know what changes the bfd's get_section_contents 	 method may have to make.  So punt trying to map the file 	 window, and let get_section_contents do its thing.  */
comment|/* @@ FIXME : If the internal window has a refcount of 1 and was 	 allocated with malloc instead of mmap, just reuse it.  */
name|bfd_free_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|i
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bfd_window_internal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|i
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|w
operator|->
name|i
operator|->
name|data
operator|=
name|bfd_malloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|i
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|w
operator|->
name|i
argument_list|)
expr_stmt|;
name|w
operator|->
name|i
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|w
operator|->
name|i
operator|->
name|mapped
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|i
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|size
operator|=
name|w
operator|->
name|i
operator|->
name|size
operator|=
name|count
expr_stmt|;
name|w
operator|->
name|data
operator|=
name|w
operator|->
name|i
operator|->
name|data
expr_stmt|;
return|return
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|w
operator|->
name|data
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
name|sz
operator|=
name|section
operator|->
name|rawsize
condition|?
name|section
operator|->
name|rawsize
else|:
name|section
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|count
operator|>
name|sz
operator|||
operator|!
name|bfd_get_file_window
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|count
argument_list|,
name|w
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This generic function can only be used in implementations where creating    NEW sections is disallowed.  It is useful in patching existing sections    in read-write files, though.  See other set_section_contents functions    to see why it doesn't work for new sections.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_generic_set_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_log2  SYNOPSIS 	unsigned int bfd_log2 (bfd_vma x);  DESCRIPTION 	Return the log base 2 of the value supplied, rounded up.  E.g., an 	@var{x} of 1025 returns 11.  A @var{x} of 0 returns 0. */
end_comment

begin_function
name|unsigned
name|int
name|bfd_log2
parameter_list|(
name|bfd_vma
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|x
operator|=
operator|(
name|x
operator|>>
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|++
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_generic_is_local_label_name
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|locals_prefix
init|=
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'_'
operator|)
condition|?
literal|'L'
else|:
literal|'.'
decl_stmt|;
return|return
name|name
index|[
literal|0
index|]
operator|==
name|locals_prefix
return|;
block|}
end_function

begin_comment
comment|/*  Can be used from / for bfd_merge_private_bfd_data to check that     endianness matches between input and output file.  Returns     TRUE for a match, otherwise returns FALSE and emits an error.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_generic_verify_endian_match
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|&&
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
operator|&&
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|ibfd
argument_list|)
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%B: compiled for a big endian system and target is little endian"
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"%B: compiled for a little endian system and target is big endian"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|msg
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Give a warning at runtime if someone compiles code which calls    old routines.  */
end_comment

begin_function
name|void
name|warn_deprecated
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
comment|/* Poor man's tracking of functions we've already warned about.  */
specifier|static
name|size_t
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|~
operator|(
name|size_t
operator|)
name|func
operator|&
operator|~
name|mask
condition|)
block|{
comment|/* Note: separate sentences in order to allow 	 for translation into other languages.  */
if|if
condition|(
name|func
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Deprecated %s called at %s line %d in %s\n"
argument_list|)
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Deprecated %s called\n"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|mask
operator||=
operator|~
operator|(
name|size_t
operator|)
name|func
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for reading uleb128 encoded data.  */
end_comment

begin_function
name|bfd_vma
name|read_unsigned_leb128
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|bfd_vma
name|result
decl_stmt|;
name|unsigned
name|int
name|num_read
decl_stmt|;
name|unsigned
name|int
name|shift
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Helper function for reading sleb128 encoded data.  */
end_comment

begin_function
name|bfd_signed_vma
name|read_signed_leb128
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|bfd_vma
name|result
decl_stmt|;
name|unsigned
name|int
name|shift
decl_stmt|;
name|unsigned
name|int
name|num_read
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
if|if
condition|(
name|shift
operator|<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|result
argument_list|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
condition|)
name|result
operator||=
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_generic_find_line
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_generic_init_private_section_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|isec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|osec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

end_unit

