begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Assorted BFD support routines, only used internally.    Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETPAGESIZE
end_ifndef

begin_define
define|#
directive|define
name|getpagesize
parameter_list|()
value|2048
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|real_read
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|size_t
operator|,
name|size_t
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SECTION 	Internal functions  DESCRIPTION 	These routines are used within BFD. 	They are not intended for export, but are documented here for 	completeness. */
end_comment

begin_comment
comment|/* A routine which is used in target vectors for unsupported    operations.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|bfd_false
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A routine which is used in target vectors for supported operations    which do not actually do anything.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|bfd_true
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A routine which is used in target vectors for unsupported    operations which return a pointer value.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|PTR
name|bfd_nullvoidptr
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|bfd_0
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|unsigned
name|int
name|bfd_0u
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGUSED*/
end_comment

begin_function
name|long
name|bfd_0l
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A routine which is used in target vectors for unsupported    operations which return -1 on error.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|long
name|_bfd_n1
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|bfd_void
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|_bfd_nocore_core_file_matches_executable_p
parameter_list|(
name|ignore_core_bfd
parameter_list|,
name|ignore_exec_bfd
parameter_list|)
name|bfd
modifier|*
name|ignore_core_bfd
decl_stmt|;
name|bfd
modifier|*
name|ignore_exec_bfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Routine to handle core_file_failing_command entry point for targets    without core file support.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|_bfd_nocore_core_file_failing_command
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Routine to handle core_file_failing_signal entry point for targets    without core file support.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|_bfd_nocore_core_file_failing_signal
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|_bfd_dummy_target
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate memory using malloc.  */
end_comment

begin_function
name|PTR
name|bfd_malloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Reallocate memory using realloc.  */
end_comment

begin_function
name|PTR
name|bfd_realloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|ret
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|ret
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory using malloc and clear it.  */
end_comment

begin_function
name|PTR
name|bfd_zmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Some IO code */
end_comment

begin_comment
comment|/* Note that archive entries don't have streams; they share their parent's.    This allows someone to play with the iostream behind BFD's back.     Also, note that the origin pointer points to the beginning of a file's    contents (0 for non-archive elements).  For archive entries this is the    first octet in the file, NOT the beginning of the archive header. */
end_comment

begin_function
specifier|static
name|int
name|real_read
parameter_list|(
name|where
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|file
parameter_list|)
name|PTR
name|where
decl_stmt|;
name|size_t
name|a
decl_stmt|;
name|size_t
name|b
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|fread
argument_list|(
name|where
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return value is amount read (FIXME: how are errors and end of file dealt    with?  We never call bfd_set_error, which is probably a mistake).  */
end_comment

begin_function
name|bfd_size_type
name|bfd_read
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|nitems
parameter_list|,
name|abfd
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|nitems
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|nread
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
name|bfd_size_type
name|get
decl_stmt|;
name|bim
operator|=
operator|(
expr|struct
name|bfd_in_memory
operator|*
operator|)
name|abfd
operator|->
name|iostream
expr_stmt|;
name|get
operator|=
name|size
operator|*
name|nitems
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|where
operator|+
name|get
operator|>
name|bim
operator|->
name|size
condition|)
block|{
name|get
operator|=
name|bim
operator|->
name|size
operator|-
name|abfd
operator|->
name|where
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|bim
operator|->
name|buffer
operator|+
name|abfd
operator|->
name|where
argument_list|,
name|get
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|where
operator|+=
name|get
expr_stmt|;
return|return
name|get
return|;
block|}
name|nread
operator|=
name|real_read
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|size
operator|*
name|nitems
argument_list|)
argument_list|,
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nread
expr_stmt|;
comment|/* Set bfd_error if we did not read as much data as we expected.       If the read failed due to an error set the bfd_error_system_call,      else set bfd_error_file_truncated.       A BFD backend may wish to override bfd_error_file_truncated to      provide something more useful (eg. no_symbols or wrong_format).  */
if|if
condition|(
name|nread
operator|<
call|(
name|int
call|)
argument_list|(
name|size
operator|*
name|nitems
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
else|else
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
block|}
return|return
name|nread
return|;
block|}
end_function

begin_comment
comment|/* The window support stuff should probably be broken out into    another file....  */
end_comment

begin_comment
comment|/* The idea behind the next and refcount fields is that one mapped    region can suffice for multiple read-only windows or multiple    non-overlapping read-write windows.  It's not implemented yet    though.  */
end_comment

begin_struct
struct|struct
name|_bfd_window_internal
block|{
name|struct
name|_bfd_window_internal
modifier|*
name|next
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|int
name|refcount
range|:
literal|31
decl_stmt|;
comment|/* should be enough... */
name|unsigned
name|mapped
range|:
literal|1
decl_stmt|;
comment|/* 1 = mmap, 0 = malloc */
block|}
struct|;
end_struct

begin_function
name|void
name|bfd_init_window
parameter_list|(
name|windowp
parameter_list|)
name|bfd_window
modifier|*
name|windowp
decl_stmt|;
block|{
name|windowp
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|windowp
operator|->
name|i
operator|=
literal|0
expr_stmt|;
name|windowp
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Currently, if USE_MMAP is undefined, none if the window stuff is    used.  Okay, so it's mis-named.  At least the command-line option    "--without-mmap" is more obvious than "--without-windows" or some    such.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MMAP
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_MPROTECT
end_undef

begin_comment
comment|/* code's not tested yet */
end_comment

begin_if
if|#
directive|if
name|HAVE_MMAP
operator|||
name|HAVE_MPROTECT
operator|||
name|HAVE_MADVISE
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FILE
end_ifndef

begin_define
define|#
directive|define
name|MAP_FILE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|debug_windows
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bfd_free_window
parameter_list|(
name|windowp
parameter_list|)
name|bfd_window
modifier|*
name|windowp
decl_stmt|;
block|{
name|bfd_window_internal
modifier|*
name|i
init|=
name|windowp
operator|->
name|i
decl_stmt|;
name|windowp
operator|->
name|i
operator|=
literal|0
expr_stmt|;
name|windowp
operator|->
name|data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return;
name|i
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|debug_windows
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"freeing window @%p<%p,%lx,%p>\n"
argument_list|,
name|windowp
argument_list|,
name|windowp
operator|->
name|data
argument_list|,
name|windowp
operator|->
name|size
argument_list|,
name|windowp
operator|->
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|refcount
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|i
operator|->
name|mapped
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_MMAP
name|munmap
argument_list|(
name|i
operator|->
name|data
argument_list|,
name|i
operator|->
name|size
argument_list|)
expr_stmt|;
goto|goto
name|no_free
goto|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|HAVE_MPROTECT
name|mprotect
argument_list|(
name|i
operator|->
name|data
argument_list|,
name|i
operator|->
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|i
operator|->
name|data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP
name|no_free
label|:
endif|#
directive|endif
name|i
operator|->
name|data
operator|=
literal|0
expr_stmt|;
comment|/* There should be no more references to i at this point.  */
name|free
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ok_to_map
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|boolean
name|bfd_get_file_window
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|,
name|windowp
parameter_list|,
name|writable
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_window
modifier|*
name|windowp
decl_stmt|;
name|boolean
name|writable
decl_stmt|;
block|{
specifier|static
name|size_t
name|pagesize
decl_stmt|;
name|bfd_window_internal
modifier|*
name|i
init|=
name|windowp
operator|->
name|i
decl_stmt|;
name|size_t
name|size_to_alloc
init|=
name|size
decl_stmt|;
if|if
condition|(
name|debug_windows
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bfd_get_file_window (%p, %6ld, %6ld, %p<%p,%lx,%p>, %d)"
argument_list|,
name|abfd
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|,
name|windowp
argument_list|,
name|windowp
operator|->
name|data
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|windowp
operator|->
name|size
argument_list|,
name|windowp
operator|->
name|i
argument_list|,
name|writable
argument_list|)
expr_stmt|;
comment|/* Make sure we know the page size, so we can be friendly to mmap.  */
if|if
condition|(
name|pagesize
operator|==
literal|0
condition|)
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
if|if
condition|(
name|pagesize
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|windowp
operator|->
name|i
operator|=
name|i
operator|=
operator|(
name|bfd_window_internal
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bfd_window_internal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|i
operator|->
name|data
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_MMAP
if|if
condition|(
name|ok_to_map
operator|&&
operator|(
name|i
operator|->
name|data
operator|==
literal|0
operator|||
name|i
operator|->
name|mapped
operator|==
literal|1
operator|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|==
literal|0
condition|)
block|{
name|file_ptr
name|file_offset
decl_stmt|,
name|offset2
decl_stmt|;
name|size_t
name|real_size
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* Find the real file and the real offset into it.  */
while|while
condition|(
name|abfd
operator|->
name|my_archive
operator|!=
name|NULL
condition|)
block|{
name|offset
operator|+=
name|abfd
operator|->
name|origin
expr_stmt|;
name|abfd
operator|=
name|abfd
operator|->
name|my_archive
expr_stmt|;
block|}
name|f
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fileno
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Compute offsets and size for mmap and for the user's data.  */
name|offset2
operator|=
name|offset
operator|%
name|pagesize
expr_stmt|;
if|if
condition|(
name|offset2
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|file_offset
operator|=
name|offset
operator|-
name|offset2
expr_stmt|;
name|real_size
operator|=
name|offset
operator|+
name|size
operator|-
name|file_offset
expr_stmt|;
name|real_size
operator|=
name|real_size
operator|+
name|pagesize
operator|-
literal|1
expr_stmt|;
name|real_size
operator|-=
name|real_size
operator|%
name|pagesize
expr_stmt|;
comment|/* If we're re-using a memory region, make sure it's big enough.  */
if|if
condition|(
name|i
operator|->
name|data
operator|&&
name|i
operator|->
name|size
operator|<
name|size
condition|)
block|{
name|munmap
argument_list|(
name|i
operator|->
name|data
argument_list|,
name|i
operator|->
name|size
argument_list|)
expr_stmt|;
name|i
operator|->
name|data
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|->
name|data
operator|=
name|mmap
argument_list|(
name|i
operator|->
name|data
argument_list|,
name|real_size
argument_list|,
name|writable
condition|?
name|PROT_WRITE
operator||
name|PROT_READ
else|:
name|PROT_READ
argument_list|,
operator|(
name|writable
condition|?
name|MAP_FILE
operator||
name|MAP_PRIVATE
else|:
name|MAP_FILE
operator||
name|MAP_SHARED
operator|)
argument_list|,
name|fd
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|data
operator|==
operator|(
name|PTR
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* An error happened.  Report it, or try using malloc, or 	     something.  */
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|i
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|windowp
operator|->
name|data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_windows
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\tmmap failed!\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|debug_windows
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\tmapped %ld at %p, offset is %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|real_size
argument_list|,
name|i
operator|->
name|data
argument_list|,
operator|(
name|long
operator|)
name|offset2
argument_list|)
expr_stmt|;
name|i
operator|->
name|size
operator|=
name|real_size
expr_stmt|;
name|windowp
operator|->
name|data
operator|=
call|(
name|PTR
call|)
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|)
name|i
operator|->
name|data
operator|+
name|offset2
argument_list|)
expr_stmt|;
name|windowp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|i
operator|->
name|mapped
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|debug_windows
condition|)
block|{
if|if
condition|(
name|ok_to_map
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not mapping: data=%lx mapped=%d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|i
operator|->
name|data
argument_list|,
operator|(
name|int
operator|)
name|i
operator|->
name|mapped
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not mapping: env var not set\n"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|ok_to_map
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MPROTECT
if|if
condition|(
operator|!
name|writable
condition|)
block|{
name|size_to_alloc
operator|+=
name|pagesize
operator|-
literal|1
expr_stmt|;
name|size_to_alloc
operator|-=
name|size_to_alloc
operator|%
name|pagesize
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|debug_windows
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t%s(%6ld)"
argument_list|,
name|i
operator|->
name|data
condition|?
literal|"realloc"
else|:
literal|" malloc"
argument_list|,
operator|(
name|long
operator|)
name|size_to_alloc
argument_list|)
expr_stmt|;
name|i
operator|->
name|data
operator|=
operator|(
name|PTR
operator|)
name|bfd_realloc
argument_list|(
name|i
operator|->
name|data
argument_list|,
name|size_to_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_windows
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-> %p\n"
argument_list|,
name|i
operator|->
name|data
argument_list|)
expr_stmt|;
name|i
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|size_to_alloc
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|i
operator|->
name|size
operator|=
name|bfd_read
argument_list|(
name|i
operator|->
name|data
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|size
operator|!=
name|size
condition|)
return|return
name|false
return|;
name|i
operator|->
name|mapped
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MPROTECT
if|if
condition|(
operator|!
name|writable
condition|)
block|{
if|if
condition|(
name|debug_windows
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmprotect (%p, %ld, PROT_READ)\n"
argument_list|,
name|i
operator|->
name|data
argument_list|,
operator|(
name|long
operator|)
name|i
operator|->
name|size
argument_list|)
expr_stmt|;
name|mprotect
argument_list|(
name|i
operator|->
name|data
argument_list|,
name|i
operator|->
name|size
argument_list|,
name|PROT_READ
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|windowp
operator|->
name|data
operator|=
name|i
operator|->
name|data
expr_stmt|;
name|windowp
operator|->
name|size
operator|=
name|i
operator|->
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MMAP */
end_comment

begin_escape
end_escape

begin_function
name|bfd_size_type
name|bfd_write
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|nitems
parameter_list|,
name|abfd
parameter_list|)
name|CONST
name|PTR
name|ptr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|nitems
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|long
name|nwrote
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nwrote
operator|=
name|fwrite
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|size
operator|*
name|nitems
argument_list|)
argument_list|,
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwrote
operator|>
literal|0
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nwrote
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_size_type
operator|)
name|nwrote
operator|!=
name|size
operator|*
name|nitems
condition|)
block|{
ifdef|#
directive|ifdef
name|ENOSPC
if|if
condition|(
name|nwrote
operator|>=
literal|0
condition|)
name|errno
operator|=
name|ENOSPC
expr_stmt|;
endif|#
directive|endif
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
block|}
return|return
name|nwrote
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_write_bigendian_4byte_int  SYNOPSIS 	void bfd_write_bigendian_4byte_int(bfd *abfd,  int i);  DESCRIPTION 	Write a 4 byte integer @var{i} to the output BFD @var{abfd}, in big 	endian order regardless of what else is going on.  This is useful in 	archives.  */
end_comment

begin_function
name|void
name|bfd_write_bigendian_4byte_int
parameter_list|(
name|abfd
parameter_list|,
name|i
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|bfd_putb32
argument_list|(
name|i
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|long
name|bfd_tell
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|file_ptr
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
return|return
name|abfd
operator|->
name|where
return|;
name|ptr
operator|=
name|ftell
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|ptr
operator|-=
name|abfd
operator|->
name|origin
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|int
name|bfd_flush
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|fflush
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 0 for success, negative value for failure (in which case    bfd_get_error can retrieve the error code).  */
end_comment

begin_function
name|int
name|bfd_stat
parameter_list|(
name|abfd
parameter_list|,
name|statbuf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|statbuf
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|f
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|result
operator|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns 0 for success, nonzero for failure (in which case bfd_get_error    can retrieve the error code).  */
end_comment

begin_function
name|int
name|bfd_seek
parameter_list|(
name|abfd
parameter_list|,
name|position
parameter_list|,
name|direction
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|file_ptr
name|position
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|file_ptr
name|file_position
decl_stmt|;
comment|/* For the time being, a BFD may not seek to it's end.  The problem      is that we don't easily have a way to recognize the end of an      element in an archive. */
name|BFD_ASSERT
argument_list|(
name|direction
operator|==
name|SEEK_SET
operator|||
name|direction
operator|==
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_CUR
operator|&&
name|position
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
condition|)
name|abfd
operator|->
name|where
operator|=
name|position
expr_stmt|;
else|else
name|abfd
operator|->
name|where
operator|+=
name|position
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_archive
operator|&&
name|abfd
operator|->
name|my_archive
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Explanation for this code: I'm only about 95+% sure that the above 	 conditions are sufficient and that all i/o calls are properly 	 adjusting the `where' field.  So this is sort of an `assert' 	 that the `where' field is correct.  If we can go a while without 	 tripping the abort, we can probably safely disable this code, 	 so that the real optimizations happen.  */
block|file_ptr where_am_i_now;       where_am_i_now = ftell (bfd_cache_lookup (abfd));       if (abfd->my_archive) 	where_am_i_now -= abfd->origin;       if (where_am_i_now != abfd->where) 	abort ();
endif|#
directive|endif
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
name|position
operator|==
name|abfd
operator|->
name|where
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* We need something smarter to optimize access to archives. 	 Currently, anything inside an archive is read via the file 	 handle for the archive.  Which means that a bfd_seek on one 	 component affects the `current position' in the archive, as 	 well as in any other component.  	 It might be sufficient to put a spike through the cache 	 abstraction, and look to the archive for the file position, 	 but I think we should try for something cleaner.  	 In the meantime, no optimization for archives.  */
block|}
name|f
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|file_position
operator|=
name|position
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
name|abfd
operator|->
name|my_archive
operator|!=
name|NULL
condition|)
name|file_position
operator|+=
name|abfd
operator|->
name|origin
expr_stmt|;
name|result
operator|=
name|fseek
argument_list|(
name|f
argument_list|,
name|file_position
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
comment|/* Force redetermination of `where' field.  */
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust `where' field.  */
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
condition|)
name|abfd
operator|->
name|where
operator|=
name|position
expr_stmt|;
else|else
name|abfd
operator|->
name|where
operator|+=
name|position
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** The do-it-yourself (byte) sex-change kit */
end_comment

begin_comment
comment|/* The middle letter e.g. get<b>short indicates Big or Little endian    target machine.  It doesn't matter what the byte order of the host    machine is; these routines work for either.  */
end_comment

begin_comment
comment|/* FIXME: Should these take a count argument?    Answer (gnu@cygnus.com):  No, but perhaps they should be inline                              functions in swap.h #ifdef __GNUC__.                               Gprof them later and find out.  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_put_size FUNCTION 	bfd_get_size  DESCRIPTION 	These macros as used for reading and writing raw data in 	sections; each access (except for bytes) is vectored through 	the target format of the BFD and mangled accordingly. The 	mangling performs any necessary endian translations and 	removes alignment restrictions.  Note that types accepted and 	returned by these macros are identical so they can be swapped 	around in macros---for example, @file{libaout.h} defines<<GET_WORD>> 	to either<<bfd_get_32>> or<<bfd_get_64>>.  	In the put routines, @var{val} must be a<<bfd_vma>>.  If we are on a 	system without prototypes, the caller is responsible for making 	sure that is true, with a cast if necessary.  We don't cast 	them in the macro definitions because that would prevent<<lint>> 	or<<gcc -Wall>> from detecting sins such as passing a pointer. 	To detect calling these with less than a<<bfd_vma>>, use<<gcc -Wconversion>> on a host with 64 bit<<bfd_vma>>'s.  . .{* Byte swapping macros for user section data.  *} . .#define bfd_put_8(abfd, val, ptr) \ .                (*((unsigned char *)(ptr)) = (unsigned char)(val)) .#define bfd_put_signed_8 \ .		bfd_put_8 .#define bfd_get_8(abfd, ptr) \ .                (*(unsigned char *)(ptr)) .#define bfd_get_signed_8(abfd, ptr) \ .		((*(unsigned char *)(ptr) ^ 0x80) - 0x80) . .#define bfd_put_16(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_putx16, ((val),(ptr))) .#define bfd_put_signed_16 \ .		 bfd_put_16 .#define bfd_get_16(abfd, ptr) \ .                BFD_SEND(abfd, bfd_getx16, (ptr)) .#define bfd_get_signed_16(abfd, ptr) \ .         	 BFD_SEND (abfd, bfd_getx_signed_16, (ptr)) . .#define bfd_put_32(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_putx32, ((val),(ptr))) .#define bfd_put_signed_32 \ .		 bfd_put_32 .#define bfd_get_32(abfd, ptr) \ .                BFD_SEND(abfd, bfd_getx32, (ptr)) .#define bfd_get_signed_32(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_getx_signed_32, (ptr)) . .#define bfd_put_64(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_putx64, ((val), (ptr))) .#define bfd_put_signed_64 \ .		 bfd_put_64 .#define bfd_get_64(abfd, ptr) \ .                BFD_SEND(abfd, bfd_getx64, (ptr)) .#define bfd_get_signed_64(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_getx_signed_64, (ptr)) . */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_h_put_size 	bfd_h_get_size  DESCRIPTION 	These macros have the same function as their<<bfd_get_x>> 	bretheren, except that they are used for removing information 	for the header records of object files. Believe it or not, 	some object files keep their header records in big endian 	order and their data in little endian order. . .{* Byte swapping macros for file header data.  *} . .#define bfd_h_put_8(abfd, val, ptr) \ .		bfd_put_8 (abfd, val, ptr) .#define bfd_h_put_signed_8(abfd, val, ptr) \ .		bfd_put_8 (abfd, val, ptr) .#define bfd_h_get_8(abfd, ptr) \ .		bfd_get_8 (abfd, ptr) .#define bfd_h_get_signed_8(abfd, ptr) \ .		bfd_get_signed_8 (abfd, ptr) . .#define bfd_h_put_16(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_h_putx16,(val,ptr)) .#define bfd_h_put_signed_16 \ .		 bfd_h_put_16 .#define bfd_h_get_16(abfd, ptr) \ .                BFD_SEND(abfd, bfd_h_getx16,(ptr)) .#define bfd_h_get_signed_16(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr)) . .#define bfd_h_put_32(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_h_putx32,(val,ptr)) .#define bfd_h_put_signed_32 \ .		 bfd_h_put_32 .#define bfd_h_get_32(abfd, ptr) \ .                BFD_SEND(abfd, bfd_h_getx32,(ptr)) .#define bfd_h_get_signed_32(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr)) . .#define bfd_h_put_64(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_h_putx64,(val, ptr)) .#define bfd_h_put_signed_64 \ .		 bfd_h_put_64 .#define bfd_h_get_64(abfd, ptr) \ .                BFD_SEND(abfd, bfd_h_getx64,(ptr)) .#define bfd_h_get_signed_64(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr)) . */
end_comment

begin_comment
comment|/* Sign extension to bfd_signed_vma.  */
end_comment

begin_define
define|#
directive|define
name|COERCE16
parameter_list|(
name|x
parameter_list|)
value|(((bfd_signed_vma) (x) ^ 0x8000) - 0x8000)
end_define

begin_define
define|#
directive|define
name|COERCE32
parameter_list|(
name|x
parameter_list|)
value|(((bfd_signed_vma) (x) ^ 0x80000000) - 0x80000000)
end_define

begin_define
define|#
directive|define
name|EIGHT_GAZILLION
value|(((BFD_HOST_64_BIT)0x80000000)<< 32)
end_define

begin_define
define|#
directive|define
name|COERCE64
parameter_list|(
name|x
parameter_list|)
define|\
value|(((bfd_signed_vma) (x) ^ EIGHT_GAZILLION) - EIGHT_GAZILLION)
end_define

begin_function
name|bfd_vma
name|bfd_getb16
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
return|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getl16
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getb_signed_16
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE16
argument_list|(
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getl_signed_16
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE16
argument_list|(
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|bfd_putb16
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_putl16
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getb32
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|3
index|]
return|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getl32
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getb_signed_32
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE32
argument_list|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|3
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getl_signed_32
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE32
argument_list|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getb64
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|3
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|high
operator|<<
literal|32
operator||
name|low
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getl64
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|4
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|high
operator|<<
literal|32
operator||
name|low
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getb_signed_64
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|3
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|COERCE64
argument_list|(
name|high
operator|<<
literal|32
operator||
name|low
argument_list|)
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getl_signed_64
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|4
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|COERCE64
argument_list|(
name|high
operator|<<
literal|32
operator||
name|low
argument_list|)
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|bfd_putb32
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_putl32
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_putb64
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|7
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|6
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|5
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|4
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|3
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|2
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|6
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|1
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|7
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|0
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|bfd_putl64
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|addr
index|[
literal|7
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|7
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|6
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|6
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|5
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|4
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|3
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|2
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|1
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|0
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Default implementation */
end_comment

begin_function
name|boolean
name|_bfd_generic_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|>
name|section
operator|->
name|_raw_size
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* on error */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|boolean
name|_bfd_generic_get_section_contents_in_window
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|w
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|bfd_window
modifier|*
name|w
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|USE_MMAP
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|_bfd_get_section_contents
operator|!=
name|_bfd_generic_get_section_contents
condition|)
block|{
comment|/* We don't know what changes the bfd's get_section_contents 	 method may have to make.  So punt trying to map the file 	 window, and let get_section_contents do its thing.  */
comment|/* @@ FIXME : If the internal window has a refcount of 1 and was 	 allocated with malloc instead of mmap, just reuse it.  */
name|bfd_free_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|i
operator|=
operator|(
name|bfd_window_internal
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bfd_window_internal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|i
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|w
operator|->
name|i
operator|->
name|data
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|i
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|w
operator|->
name|i
argument_list|)
expr_stmt|;
name|w
operator|->
name|i
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
name|w
operator|->
name|i
operator|->
name|mapped
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|i
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|size
operator|=
name|w
operator|->
name|i
operator|->
name|size
operator|=
name|count
expr_stmt|;
name|w
operator|->
name|data
operator|=
name|w
operator|->
name|i
operator|->
name|data
expr_stmt|;
return|return
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|w
operator|->
name|data
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|>
name|section
operator|->
name|_raw_size
operator|||
operator|(
name|bfd_get_file_window
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|count
argument_list|,
name|w
argument_list|,
name|true
argument_list|)
operator|==
name|false
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This generic function can only be used in implementations where creating    NEW sections is disallowed.  It is useful in patching existing sections    in read-write files, though.  See other set_section_contents functions    to see why it doesn't work for new sections.  */
end_comment

begin_function
name|boolean
name|_bfd_generic_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_write
argument_list|(
name|location
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_log2  SYNOPSIS 	unsigned int bfd_log2(bfd_vma x);  DESCRIPTION 	Return the log base 2 of the value supplied, rounded up.  E.g., an 	@var{x} of 1025 returns 11. */
end_comment

begin_function
name|unsigned
name|bfd_log2
parameter_list|(
name|x
parameter_list|)
name|bfd_vma
name|x
decl_stmt|;
block|{
name|unsigned
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
name|result
argument_list|)
operator|<
name|x
condition|)
name|result
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|boolean
name|bfd_generic_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|locals_prefix
init|=
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'_'
operator|)
condition|?
literal|'L'
else|:
literal|'.'
decl_stmt|;
return|return
operator|(
name|name
index|[
literal|0
index|]
operator|==
name|locals_prefix
operator|)
return|;
block|}
end_function

end_unit

