begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic BFD support for file formats.    Copyright (C) 1990, 91, 92, 93, 94, 95, 1999 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* SECTION 	File formats  	A format is a BFD concept of high level file contents type. The 	formats supported by BFD are:  	o<<bfd_object>>  	The BFD may contain data, symbols, relocations and debug info.  	o<<bfd_archive>>  	The BFD contains other BFDs and an optional index.  	o<<bfd_core>>  	The BFD contains the result of an executable core dump.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* IMPORT from targets.c.  */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|size_t
name|_bfd_target_vector_entries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_check_format  SYNOPSIS 	boolean bfd_check_format(bfd *abfd, bfd_format format);  DESCRIPTION 	Verify if the file attached to the BFD @var{abfd} is compatible 	with the format @var{format} (i.e., one of<<bfd_object>>,<<bfd_archive>> or<<bfd_core>>).  	If the BFD has been set to a specific target before the 	call, only the named target and format combination is 	checked. If the target has not been set, or has been set to<<default>>, then all the known target backends is 	interrogated to determine a match.  If the default target 	matches, it is used.  If not, exactly one target must recognize 	the file, or an error results.  	The function returns<<true>> on success, otherwise<<false>> 	with one of the following error codes:  	o<<bfd_error_invalid_operation>> - 	if<<format>> is not one of<<bfd_object>>,<<bfd_archive>> or<<bfd_core>>.  	o<<bfd_error_system_call>> - 	if an error occured during a read - even some file mismatches 	can cause bfd_error_system_calls.  	o<<file_not_recognised>> - 	none of the backends recognised the file format.  	o<<bfd_error_file_ambiguously_recognized>> - 	more than one backend recognised the file format. */
end_comment

begin_function
name|boolean
name|bfd_check_format
parameter_list|(
name|abfd
parameter_list|,
name|format
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_format
name|format
decl_stmt|;
block|{
return|return
name|bfd_check_format_matches
argument_list|(
name|abfd
argument_list|,
name|format
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_check_format_matches  SYNOPSIS 	boolean bfd_check_format_matches(bfd *abfd, bfd_format format, char ***matching);  DESCRIPTION 	Like<<bfd_check_format>>, except when it returns false with<<bfd_errno>> set to<<bfd_error_file_ambiguously_recognized>>.  In that 	case, if @var{matching} is not NULL, it will be filled in with 	a NULL-terminated list of the names of the formats that matched, 	allocated with<<malloc>>. 	Then the user may choose a format and try again.  	When done with the list that @var{matching} points to, the caller 	should free it. */
end_comment

begin_function
name|boolean
name|bfd_check_format_matches
parameter_list|(
name|abfd
parameter_list|,
name|format
parameter_list|,
name|matching
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_format
name|format
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|matching
decl_stmt|;
block|{
specifier|extern
specifier|const
name|bfd_target
name|binary_vec
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|target
decl_stmt|,
modifier|*
name|save_targ
decl_stmt|,
modifier|*
name|right_targ
decl_stmt|;
name|char
modifier|*
modifier|*
name|matching_vector
init|=
name|NULL
decl_stmt|;
name|int
name|match_count
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
operator|||
operator|(
call|(
name|int
call|)
argument_list|(
name|abfd
operator|->
name|format
argument_list|)
operator|<
operator|(
name|int
operator|)
name|bfd_unknown
operator|)
operator|||
operator|(
call|(
name|int
call|)
argument_list|(
name|abfd
operator|->
name|format
argument_list|)
operator|>=
operator|(
name|int
operator|)
name|bfd_type_end
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_unknown
condition|)
return|return
operator|(
name|abfd
operator|->
name|format
operator|==
name|format
operator|)
condition|?
name|true
else|:
name|false
return|;
comment|/* Since the target type was defaulted, check them      all in the hope that one will be uniquely recognized.  */
name|save_targ
operator|=
name|abfd
operator|->
name|xvec
expr_stmt|;
name|match_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|matching
condition|)
block|{
name|matching_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|_bfd_target_vector_entries
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matching_vector
condition|)
return|return
name|false
return|;
name|matching_vector
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|matching
operator|=
name|matching_vector
expr_stmt|;
block|}
name|right_targ
operator|=
literal|0
expr_stmt|;
comment|/* Presume the answer is yes.  */
name|abfd
operator|->
name|format
operator|=
name|format
expr_stmt|;
comment|/* If the target type was explicitly specified, just check that target.  */
if|if
condition|(
operator|!
name|abfd
operator|->
name|target_defaulted
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
comment|/* rewind! */
return|return
name|false
return|;
name|right_targ
operator|=
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_check_format
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|right_targ
condition|)
block|{
name|abfd
operator|->
name|xvec
operator|=
name|right_targ
expr_stmt|;
comment|/* Set the target as returned.  */
if|if
condition|(
name|matching
condition|)
name|free
argument_list|(
name|matching_vector
argument_list|)
expr_stmt|;
return|return
name|true
return|;
comment|/* File position has moved, BTW.  */
block|}
comment|/* For a long time the code has dropped through to check all 	 targets if the specified target was wrong.  I don't know why, 	 and I'm reluctant to change it.  However, in the case of an 	 archive, it can cause problems.  If the specified target does 	 not permit archives (e.g., the binary target), then we should 	 not allow some other target to recognize it as an archive, but 	 should instead allow the specified target to recognize it as an 	 object.  When I first made this change, it broke the PE target, 	 because the specified pei-i386 target did not recognize the 	 actual pe-i386 archive.  Since there may be other problems of 	 this sort, I changed this test to check only for the binary 	 target.  */
if|if
condition|(
name|format
operator|==
name|bfd_archive
operator|&&
name|save_targ
operator|==
operator|&
name|binary_vec
condition|)
block|{
name|abfd
operator|->
name|xvec
operator|=
name|save_targ
expr_stmt|;
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
if|if
condition|(
name|matching
condition|)
name|free
argument_list|(
name|matching_vector
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_file_not_recognized
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
for|for
control|(
name|target
operator|=
name|bfd_target_vector
init|;
operator|*
name|target
operator|!=
name|NULL
condition|;
name|target
operator|++
control|)
block|{
specifier|const
name|bfd_target
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|*
name|target
operator|==
operator|&
name|binary_vec
condition|)
continue|continue;
name|abfd
operator|->
name|xvec
operator|=
operator|*
name|target
expr_stmt|;
comment|/* Change BFD's target temporarily */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* If _bfd_check_format neglects to set bfd_error, assume 	 bfd_error_wrong_format.  We didn't used to even pay any 	 attention to bfd_error, so I suspect that some 	 _bfd_check_format might have this problem.  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|temp
operator|=
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_check_format
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* This format checks out as ok!  */
name|right_targ
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|matching
condition|)
block|{
name|matching_vector
index|[
name|match_count
index|]
operator|=
name|temp
operator|->
name|name
expr_stmt|;
name|matching_vector
index|[
name|match_count
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|match_count
operator|++
expr_stmt|;
comment|/* If this is the default target, accept it, even if other 	     targets might match.  People who want those other targets 	     have to set the GNUTARGET variable.  */
if|if
condition|(
name|temp
operator|==
name|bfd_default_vector
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|matching
condition|)
block|{
name|matching_vector
index|[
literal|0
index|]
operator|=
name|temp
operator|->
name|name
expr_stmt|;
name|matching_vector
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|match_count
operator|=
literal|1
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|GNU960
comment|/* Big- and little-endian b.out archives look the same, but it 	     doesn't matter: there is no difference in their headers, and 	     member file byte orders will (I hope) be handled appropriately 	     by bfd.  Ditto for big and little coff archives.  And the 4 	     coff/b.out object formats are unambiguous.  So accept the 	     first match we find.  */
break|break;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_wrong_format
condition|)
block|{
name|abfd
operator|->
name|xvec
operator|=
name|save_targ
expr_stmt|;
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
if|if
condition|(
name|matching
operator|&&
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_file_ambiguously_recognized
condition|)
name|free
argument_list|(
name|matching_vector
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|match_count
operator|==
literal|1
condition|)
block|{
name|abfd
operator|->
name|xvec
operator|=
name|right_targ
expr_stmt|;
comment|/* Change BFD's target permanently.  */
if|if
condition|(
name|matching
condition|)
name|free
argument_list|(
name|matching_vector
argument_list|)
expr_stmt|;
return|return
name|true
return|;
comment|/* File position has moved, BTW.  */
block|}
name|abfd
operator|->
name|xvec
operator|=
name|save_targ
expr_stmt|;
comment|/* Restore original target type.  */
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
comment|/* Restore original format.  */
if|if
condition|(
name|match_count
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_not_recognized
argument_list|)
expr_stmt|;
if|if
condition|(
name|matching
condition|)
name|free
argument_list|(
name|matching_vector
argument_list|)
expr_stmt|;
block|}
else|else
name|bfd_set_error
argument_list|(
name|bfd_error_file_ambiguously_recognized
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_format  SYNOPSIS 	boolean bfd_set_format(bfd *abfd, bfd_format format);  DESCRIPTION 	This function sets the file format of the BFD @var{abfd} to the 	format @var{format}. If the target set in the BFD does not 	support the format requested, the format is invalid, or the BFD 	is not open for writing, then an error occurs. */
end_comment

begin_function
name|boolean
name|bfd_set_format
parameter_list|(
name|abfd
parameter_list|,
name|format
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_format
name|format
decl_stmt|;
block|{
if|if
condition|(
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
operator|||
operator|(
operator|(
name|int
operator|)
name|abfd
operator|->
name|format
operator|<
operator|(
name|int
operator|)
name|bfd_unknown
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|abfd
operator|->
name|format
operator|>=
operator|(
name|int
operator|)
name|bfd_type_end
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_unknown
condition|)
return|return
operator|(
name|abfd
operator|->
name|format
operator|==
name|format
operator|)
condition|?
name|true
else|:
name|false
return|;
comment|/* Presume the answer is yes.  */
name|abfd
operator|->
name|format
operator|=
name|format
expr_stmt|;
if|if
condition|(
operator|!
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_set_format
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
block|{
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_format_string  SYNOPSIS 	CONST char *bfd_format_string(bfd_format format);  DESCRIPTION 	Return a pointer to a const string<<invalid>>,<<object>>,<<archive>>,<<core>>, or<<unknown>>, 	depending upon the value of @var{format}. */
end_comment

begin_function
name|CONST
name|char
modifier|*
name|bfd_format_string
parameter_list|(
name|format
parameter_list|)
name|bfd_format
name|format
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|format
operator|<
operator|(
name|int
operator|)
name|bfd_unknown
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|format
operator|>=
operator|(
name|int
operator|)
name|bfd_type_end
operator|)
condition|)
return|return
literal|"invalid"
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
literal|"object"
return|;
comment|/* Linker/assember/compiler output.  */
case|case
name|bfd_archive
case|:
return|return
literal|"archive"
return|;
comment|/* Object archive file.  */
case|case
name|bfd_core
case|:
return|return
literal|"core"
return|;
comment|/* Core dump.  */
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

end_unit

