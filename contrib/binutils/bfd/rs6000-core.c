begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IBM RS/6000 "XCOFF" back-end for BFD.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,    2001, 2002    Free Software Foundation, Inc.    FIXME: Can someone provide a transliteration of this name into ASCII?    Using the following chars caused a compiler warning on HIUX (so I replaced    them with octal escapes), and isn't useful without an understanding of what    character set it is.    Written by Metin G. Ozisik, Mimi Ph\373\364ng-Th\345o V\365,      and John Gilmore.    Archive support from Damon A. Permezel.    Contributed by IBM Corporation and Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This port currently only handles reading object files, except when    compiled on an RS/6000 host.  -- no archive support, no core files.    In all cases, it does not support writing.     This is in a separate file from coff-rs6000.c, because it includes    system include files that conflict with coff/rs6000.h.  */
end_comment

begin_comment
comment|/* Internalcoff.h and coffcode.h modify themselves based on this flag.  */
end_comment

begin_define
define|#
directive|define
name|RS6000COFF_C
value|1
end_define

begin_comment
comment|/* The AIX 4.1 kernel is obviously compiled with -D_LONG_LONG, so    we have to define _LONG_LONG for older versions of gcc to get the    proper alignments in the user structure.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX41
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_LONG_LONG
argument_list|)
end_if

begin_define
define|#
directive|define
name|_LONG_LONG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE
end_ifdef

begin_comment
comment|/* AOUTHDR is defined by the above.  We need another defn of it, from the    system include files.  Punt the old one and get us a new name for the    typedef in the system include files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AOUTHDR
end_ifdef

begin_undef
undef|#
directive|undef
name|AOUTHDR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AOUTHDR
value|second_AOUTHDR
end_define

begin_undef
undef|#
directive|undef
name|SCNHDR
end_undef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*	Support for core file stuff..					    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_define
define|#
directive|define
name|__LDINFO_PTRACE32__
end_define

begin_comment
comment|/* for __ld_info32 */
end_comment

begin_define
define|#
directive|define
name|__LDINFO_PTRACE64__
end_define

begin_comment
comment|/* for __ld_info64 */
end_comment

begin_include
include|#
directive|include
file|<sys/ldr.h>
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_include
include|#
directive|include
file|<sys/systemcfg.h>
end_include

begin_define
define|#
directive|define
name|core_hdr
parameter_list|(
name|bfd
parameter_list|)
value|((CoreHdr *) bfd->tdata.any)
end_define

begin_comment
comment|/* AIX 4.1 changed the names and locations of a few items in the core file.    AIX 4.3 defined an entirely new structure, core_dumpx, but kept support for    the previous 4.1 structure, core_dump.     AIX_CORE_DUMPX_CORE is defined (by configure) on AIX 4.3+, and    CORE_VERSION_1 is defined (by AIX core.h) as 2 on AIX 4.3+ and as 1 on AIX    4.1 and 4.2.  AIX pre-4.1 (aka 3.x) either doesn't define CORE_VERSION_1    or else defines it as 0.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CORE_VERSION_1
argument_list|)
operator|&&
operator|!
name|CORE_VERSION_1
end_if

begin_undef
undef|#
directive|undef
name|CORE_VERSION_1
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following union and macros allow this module to compile on all AIX    versions and to handle both core_dumpx and core_dump on 4.3+.  CNEW_*()    and COLD_*() macros respectively retrieve core_dumpx and core_dump    values.  */
end_comment

begin_comment
comment|/* Union of 32-bit and 64-bit versions of ld_info.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
ifdef|#
directive|ifdef
name|__ld_info32
name|struct
name|__ld_info32
name|l32
decl_stmt|;
name|struct
name|__ld_info64
name|l64
decl_stmt|;
else|#
directive|else
name|struct
name|ld_info
name|l32
decl_stmt|;
name|struct
name|ld_info
name|l64
decl_stmt|;
endif|#
directive|endif
block|}
name|LdInfo
typedef|;
end_typedef

begin_comment
comment|/* Union of old and new core dump structures.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
name|struct
name|core_dumpx
name|new
decl_stmt|;
comment|/* new AIX 4.3+ core dump */
else|#
directive|else
name|struct
name|core_dump
name|new
decl_stmt|;
comment|/* for simpler coding */
endif|#
directive|endif
name|struct
name|core_dump
name|old
decl_stmt|;
comment|/* old AIX 4.2- core dump, still used on 				   4.3+ with appropriate SMIT config */
block|}
name|CoreHdr
typedef|;
end_typedef

begin_comment
comment|/* Union of old and new vm_info structures.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CORE_VERSION_1
end_ifdef

begin_typedef
typedef|typedef
union|union
block|{
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
name|struct
name|vm_infox
name|new
decl_stmt|;
else|#
directive|else
name|struct
name|vm_info
name|new
decl_stmt|;
endif|#
directive|endif
name|struct
name|vm_info
name|old
decl_stmt|;
block|}
name|VmInfo
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return whether CoreHdr C is in new or old format.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CORE_NEW
parameter_list|(
name|c
parameter_list|)
value|(!(c).old.c_entries)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CORE_NEW
parameter_list|(
name|c
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the c_stackorg field from struct core_dumpx C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CNEW_STACKORG
parameter_list|(
name|c
parameter_list|)
value|(c).c_stackorg
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_STACKORG
parameter_list|(
name|c
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the offset to the loader region from struct core_dump C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CNEW_LOADER
parameter_list|(
name|c
parameter_list|)
value|(c).c_loader
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_LOADER
parameter_list|(
name|c
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the offset to the loader region from struct core_dump C.  */
end_comment

begin_define
define|#
directive|define
name|COLD_LOADER
parameter_list|(
name|c
parameter_list|)
value|(c).c_tab
end_define

begin_comment
comment|/* Return the c_lsize field from struct core_dumpx C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CNEW_LSIZE
parameter_list|(
name|c
parameter_list|)
value|(c).c_lsize
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_LSIZE
parameter_list|(
name|c
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the c_dataorg field from struct core_dumpx C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CNEW_DATAORG
parameter_list|(
name|c
parameter_list|)
value|(c).c_dataorg
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_DATAORG
parameter_list|(
name|c
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the c_datasize field from struct core_dumpx C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CNEW_DATASIZE
parameter_list|(
name|c
parameter_list|)
value|(c).c_datasize
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_DATASIZE
parameter_list|(
name|c
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the c_impl field from struct core_dumpx C.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ST_C_IMPL
argument_list|)
operator|||
name|defined
argument_list|(
name|AIX_5_CORE
argument_list|)
end_if

begin_define
define|#
directive|define
name|CNEW_IMPL
parameter_list|(
name|c
parameter_list|)
value|(c).c_impl
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_IMPL
parameter_list|(
name|c
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the command string from struct core_dumpx C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CNEW_COMM
parameter_list|(
name|c
parameter_list|)
value|(c).c_u.U_proc.pi_comm
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_COMM
parameter_list|(
name|c
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the command string from struct core_dump C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CORE_VERSION_1
end_ifdef

begin_define
define|#
directive|define
name|COLD_COMM
parameter_list|(
name|c
parameter_list|)
value|(c).c_u.U_comm
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COLD_COMM
parameter_list|(
name|c
parameter_list|)
value|(c).c_u.u_comm
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the struct __context64 pointer from struct core_dumpx C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CNEW_CONTEXT64
parameter_list|(
name|c
parameter_list|)
value|(c).c_flt.hctx.r64
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_CONTEXT64
parameter_list|(
name|c
parameter_list|)
value|c
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the struct mstsave pointer from struct core_dumpx C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CNEW_MSTSAVE
parameter_list|(
name|c
parameter_list|)
value|(c).c_flt.hctx.r32
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_MSTSAVE
parameter_list|(
name|c
parameter_list|)
value|c
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the struct mstsave pointer from struct core_dump C.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CORE_VERSION_1
end_ifdef

begin_define
define|#
directive|define
name|COLD_MSTSAVE
parameter_list|(
name|c
parameter_list|)
value|(c).c_mst
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COLD_MSTSAVE
parameter_list|(
name|c
parameter_list|)
value|(c).c_u.u_save
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return whether struct core_dumpx is from a 64-bit process.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE_DUMPX_CORE
end_ifdef

begin_define
define|#
directive|define
name|CNEW_PROC64
parameter_list|(
name|c
parameter_list|)
value|IS_PROC64(&(c).c_u.U_proc)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CNEW_PROC64
parameter_list|(
name|c
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Magic end-of-stack addresses for old core dumps.  This is _very_ fragile,    but I don't see any easy way to get that info right now.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CORE_VERSION_1
end_ifdef

begin_define
define|#
directive|define
name|COLD_STACKEND
value|0x2ff23000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COLD_STACKEND
value|0x2ff80000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Size of the leading portion that old and new core dump structures have in    common.  */
end_comment

begin_define
define|#
directive|define
name|CORE_COMMONSZ
value|((int)&((struct core_dump *) 0)->c_entries \ 			 + sizeof (((struct core_dump *) 0)->c_entries))
end_define

begin_comment
comment|/* Try to read into CORE the header from the core file associated with ABFD.    Return success.  */
end_comment

begin_function
specifier|static
name|boolean
name|read_hdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|CoreHdr
modifier|*
name|core
parameter_list|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Read the leading portion that old and new core dump structures have in      common.  */
name|size
operator|=
name|CORE_COMMONSZ
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|core
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
return|return
name|false
return|;
comment|/* Read the trailing portion of the structure.  */
if|if
condition|(
name|CORE_NEW
argument_list|(
operator|*
name|core
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
name|core
operator|->
name|new
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
name|core
operator|->
name|old
argument_list|)
expr_stmt|;
name|size
operator|-=
name|CORE_COMMONSZ
expr_stmt|;
return|return
name|bfd_bread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|core
operator|+
name|CORE_COMMONSZ
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|==
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|make_bfd_asection
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|,
name|_raw_size
parameter_list|,
name|vma
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|_raw_size
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|asection
modifier|*
name|asect
decl_stmt|;
name|asect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|asect
condition|)
return|return
name|NULL
return|;
name|asect
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|asect
operator|->
name|_raw_size
operator|=
name|_raw_size
expr_stmt|;
name|asect
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
name|asect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|asect
operator|->
name|alignment_power
operator|=
literal|8
expr_stmt|;
return|return
name|asect
return|;
block|}
end_function

begin_comment
comment|/* Decide if a given bfd represents a `core' file or not. There really is no    magic number or anything like, in rs6000coff.  */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|rs6000coff_core_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|CoreHdr
name|core
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|tmpptr
decl_stmt|;
comment|/* Values from new and old core structures.  */
name|int
name|c_flag
decl_stmt|;
name|file_ptr
name|c_stack
decl_stmt|,
name|c_regoff
decl_stmt|,
name|c_loader
decl_stmt|;
name|bfd_size_type
name|c_size
decl_stmt|,
name|c_regsize
decl_stmt|,
name|c_lsize
decl_stmt|;
name|bfd_vma
name|c_stackend
decl_stmt|;
name|void
modifier|*
name|c_regptr
decl_stmt|;
name|int
name|proc64
decl_stmt|;
if|if
condition|(
operator|!
name|read_hdr
argument_list|(
name|abfd
argument_list|,
operator|&
name|core
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Copy fields from new or old core structure.  */
if|if
condition|(
name|CORE_NEW
argument_list|(
name|core
argument_list|)
condition|)
block|{
name|c_flag
operator|=
name|core
operator|.
name|new
operator|.
name|c_flag
expr_stmt|;
name|c_stack
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|.
name|new
operator|.
name|c_stack
expr_stmt|;
name|c_size
operator|=
name|core
operator|.
name|new
operator|.
name|c_size
expr_stmt|;
name|c_stackend
operator|=
name|CNEW_STACKORG
argument_list|(
name|core
operator|.
name|new
argument_list|)
operator|+
name|c_size
expr_stmt|;
name|c_lsize
operator|=
name|CNEW_LSIZE
argument_list|(
name|core
operator|.
name|new
argument_list|)
expr_stmt|;
name|c_loader
operator|=
name|CNEW_LOADER
argument_list|(
name|core
operator|.
name|new
argument_list|)
expr_stmt|;
name|proc64
operator|=
name|CNEW_PROC64
argument_list|(
name|core
operator|.
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c_flag
operator|=
name|core
operator|.
name|old
operator|.
name|c_flag
expr_stmt|;
name|c_stack
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|.
name|old
operator|.
name|c_stack
expr_stmt|;
name|c_size
operator|=
name|core
operator|.
name|old
operator|.
name|c_size
expr_stmt|;
name|c_stackend
operator|=
name|COLD_STACKEND
expr_stmt|;
name|c_lsize
operator|=
literal|0x7ffffff
expr_stmt|;
name|c_loader
operator|=
operator|(
name|file_ptr
operator|)
name|COLD_LOADER
argument_list|(
name|core
operator|.
name|old
argument_list|)
expr_stmt|;
name|proc64
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|proc64
condition|)
block|{
name|c_regsize
operator|=
sizeof|sizeof
argument_list|(
name|CNEW_CONTEXT64
argument_list|(
name|core
operator|.
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|c_regptr
operator|=
operator|&
name|CNEW_CONTEXT64
argument_list|(
name|core
operator|.
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CORE_NEW
argument_list|(
name|core
argument_list|)
condition|)
block|{
name|c_regsize
operator|=
sizeof|sizeof
argument_list|(
name|CNEW_MSTSAVE
argument_list|(
name|core
operator|.
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|c_regptr
operator|=
operator|&
name|CNEW_MSTSAVE
argument_list|(
name|core
operator|.
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c_regsize
operator|=
sizeof|sizeof
argument_list|(
name|COLD_MSTSAVE
argument_list|(
name|core
operator|.
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|c_regptr
operator|=
operator|&
name|COLD_MSTSAVE
argument_list|(
name|core
operator|.
name|old
argument_list|)
expr_stmt|;
block|}
name|c_regoff
operator|=
operator|(
name|char
operator|*
operator|)
name|c_regptr
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|core
expr_stmt|;
if|if
condition|(
name|bfd_stat
argument_list|(
name|abfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* If the core file ulimit is too small, the system will first      omit the data segment, then omit the stack, then decline to      dump core altogether (as far as I know UBLOCK_VALID and LE_VALID      are always set) (this is based on experimentation on AIX 3.2).      Now, the thing is that GDB users will be surprised      if segments just silently don't appear (well, maybe they would      think to check "info files", I don't know).       For the data segment, we have no choice but to keep going if it's      not there, since the default behavior is not to dump it (regardless      of the ulimit, it's based on SA_FULLDUMP).  But for the stack segment,      if it's not there, we refuse to have anything to do with this core      file.  The usefulness of a core dump without a stack segment is pretty      limited anyway.  */
if|if
condition|(
operator|!
operator|(
name|c_flag
operator|&
name|UBLOCK_VALID
operator|)
operator|||
operator|!
operator|(
name|c_flag
operator|&
name|LE_VALID
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|c_flag
operator|&
name|USTACK_VALID
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Don't check the core file size for a full core, AIX 4.1 includes      additional shared library sections in a full core.  */
if|if
condition|(
operator|!
operator|(
name|c_flag
operator|&
operator|(
name|FULL_CORE
operator||
name|CORE_TRUNC
operator|)
operator|)
condition|)
block|{
comment|/* If the size is wrong, it means we're misinterpreting something.  */
if|if
condition|(
name|c_stack
operator|+
operator|(
name|file_ptr
operator|)
name|c_size
operator|!=
name|statbuf
operator|.
name|st_size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Sanity check on the c_tab field.  */
if|if
condition|(
operator|!
name|CORE_NEW
argument_list|(
name|core
argument_list|)
operator|&&
operator|(
name|c_loader
operator|<
operator|(
name|file_ptr
operator|)
sizeof|sizeof
name|core
operator|.
name|old
operator|||
name|c_loader
operator|>=
name|statbuf
operator|.
name|st_size
operator|||
name|c_loader
operator|>=
name|c_stack
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Issue warning if the core file was truncated during writing.  */
if|if
condition|(
name|c_flag
operator|&
name|CORE_TRUNC
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning core file truncated"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate core file header.  */
name|size
operator|=
name|CORE_NEW
argument_list|(
name|core
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|core
operator|.
name|new
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|core
operator|.
name|old
argument_list|)
expr_stmt|;
name|tmpptr
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpptr
condition|)
return|return
name|NULL
return|;
comment|/* Copy core file header.  */
name|memcpy
argument_list|(
name|tmpptr
argument_list|,
operator|&
name|core
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|set_tdata
argument_list|(
name|abfd
argument_list|,
name|tmpptr
argument_list|)
expr_stmt|;
comment|/* Set architecture.  */
if|if
condition|(
name|CORE_NEW
argument_list|(
name|core
argument_list|)
condition|)
block|{
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|mach
decl_stmt|;
switch|switch
condition|(
name|CNEW_IMPL
argument_list|(
name|core
operator|.
name|new
argument_list|)
condition|)
block|{
case|case
name|POWER_RS1
case|:
case|case
name|POWER_RSC
case|:
case|case
name|POWER_RS2
case|:
name|arch
operator|=
name|bfd_arch_rs6000
expr_stmt|;
name|mach
operator|=
name|bfd_mach_rs6k
expr_stmt|;
break|break;
default|default:
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|mach
operator|=
name|bfd_mach_ppc
expr_stmt|;
break|break;
block|}
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|mach
argument_list|)
expr_stmt|;
block|}
comment|/* .stack section.  */
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".stack"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
argument_list|,
name|c_size
argument_list|,
name|c_stackend
operator|-
name|c_size
argument_list|,
name|c_stack
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* .reg section for all registers.  */
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
name|c_regsize
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|c_regoff
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* .ldinfo section.      To actually find out how long this section is in this particular      core dump would require going down the whole list of struct ld_info's.      See if we can just fake it.  */
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".ldinfo"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
name|c_lsize
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|c_loader
argument_list|)
condition|)
goto|goto
name|fail
goto|;
ifndef|#
directive|ifndef
name|CORE_VERSION_1
comment|/* .data section if present.      AIX 3 dumps the complete data section and sets FULL_CORE if the      ulimit is large enough, otherwise the data section is omitted.      AIX 4 sets FULL_CORE even if the core file is truncated, we have      to examine core.c_datasize below to find out the actual size of      the .data section.  */
if|if
condition|(
name|c_flag
operator|&
name|FULL_CORE
condition|)
block|{
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|core
operator|.
name|old
operator|.
name|c_u
operator|.
name|u_dsize
argument_list|,
operator|(
name|bfd_vma
operator|)
name|CDATA_ADDR
argument_list|(
name|core
operator|.
name|old
operator|.
name|c_u
operator|.
name|u_dsize
argument_list|)
argument_list|,
name|c_stack
operator|+
name|c_size
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CORE_VERSION_1
comment|/* AIX 4 adds data sections from loaded objects to the core file,      which can be found by examining ldinfo, and anonymously mmapped      regions.  */
block|{
name|LdInfo
name|ldinfo
decl_stmt|;
name|bfd_size_type
name|ldi_datasize
decl_stmt|;
name|file_ptr
name|ldi_core
decl_stmt|;
name|uint
name|ldi_next
decl_stmt|;
name|bfd_vma
name|ldi_dataorg
decl_stmt|;
comment|/* Fields from new and old core structures.  */
name|bfd_size_type
name|c_datasize
decl_stmt|,
name|c_vmregions
decl_stmt|;
name|file_ptr
name|c_data
decl_stmt|,
name|c_vmm
decl_stmt|;
if|if
condition|(
name|CORE_NEW
argument_list|(
name|core
argument_list|)
condition|)
block|{
name|c_datasize
operator|=
name|CNEW_DATASIZE
argument_list|(
name|core
operator|.
name|new
argument_list|)
expr_stmt|;
name|c_data
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|.
name|new
operator|.
name|c_data
expr_stmt|;
name|c_vmregions
operator|=
name|core
operator|.
name|new
operator|.
name|c_vmregions
expr_stmt|;
name|c_vmm
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|.
name|new
operator|.
name|c_vmm
expr_stmt|;
block|}
else|else
block|{
name|c_datasize
operator|=
name|core
operator|.
name|old
operator|.
name|c_datasize
expr_stmt|;
name|c_data
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|.
name|old
operator|.
name|c_data
expr_stmt|;
name|c_vmregions
operator|=
name|core
operator|.
name|old
operator|.
name|c_vmregions
expr_stmt|;
name|c_vmm
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|.
name|old
operator|.
name|c_vmm
expr_stmt|;
block|}
comment|/* .data section from executable.  */
if|if
condition|(
name|c_datasize
condition|)
block|{
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
argument_list|,
name|c_datasize
argument_list|,
operator|(
name|bfd_vma
operator|)
name|CDATA_ADDR
argument_list|(
name|c_datasize
argument_list|)
argument_list|,
name|c_data
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* .data sections from loaded objects.  */
if|if
condition|(
name|proc64
condition|)
name|size
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|LdInfo
operator|*
operator|)
literal|0
argument_list|)
operator|->
name|l64
operator|.
name|ldinfo_filename
expr_stmt|;
else|else
name|size
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|LdInfo
operator|*
operator|)
literal|0
argument_list|)
operator|->
name|l32
operator|.
name|ldinfo_filename
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|c_loader
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|ldinfo
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|proc64
condition|)
block|{
name|ldi_core
operator|=
name|ldinfo
operator|.
name|l64
operator|.
name|ldinfo_core
expr_stmt|;
name|ldi_datasize
operator|=
name|ldinfo
operator|.
name|l64
operator|.
name|ldinfo_datasize
expr_stmt|;
name|ldi_dataorg
operator|=
operator|(
name|bfd_vma
operator|)
name|ldinfo
operator|.
name|l64
operator|.
name|ldinfo_dataorg
expr_stmt|;
name|ldi_next
operator|=
name|ldinfo
operator|.
name|l64
operator|.
name|ldinfo_next
expr_stmt|;
block|}
else|else
block|{
name|ldi_core
operator|=
name|ldinfo
operator|.
name|l32
operator|.
name|ldinfo_core
expr_stmt|;
name|ldi_datasize
operator|=
name|ldinfo
operator|.
name|l32
operator|.
name|ldinfo_datasize
expr_stmt|;
name|ldi_dataorg
operator|=
operator|(
name|bfd_vma
operator|)
operator|(
name|long
operator|)
name|ldinfo
operator|.
name|l32
operator|.
name|ldinfo_dataorg
expr_stmt|;
name|ldi_next
operator|=
name|ldinfo
operator|.
name|l32
operator|.
name|ldinfo_next
expr_stmt|;
block|}
if|if
condition|(
name|ldi_core
condition|)
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
argument_list|,
name|ldi_datasize
argument_list|,
name|ldi_dataorg
argument_list|,
name|ldi_core
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|ldi_next
operator|==
literal|0
condition|)
break|break;
name|c_loader
operator|+=
name|ldi_next
expr_stmt|;
block|}
comment|/* .vmdata sections from anonymously mmapped regions.  */
if|if
condition|(
name|c_vmregions
condition|)
block|{
name|bfd_size_type
name|i
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|c_vmm
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c_vmregions
condition|;
name|i
operator|++
control|)
block|{
name|VmInfo
name|vminfo
decl_stmt|;
name|bfd_size_type
name|vminfo_size
decl_stmt|;
name|file_ptr
name|vminfo_offset
decl_stmt|;
name|bfd_vma
name|vminfo_addr
decl_stmt|;
name|size
operator|=
name|CORE_NEW
argument_list|(
name|core
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|vminfo
operator|.
name|new
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|vminfo
operator|.
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|vminfo
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|CORE_NEW
argument_list|(
name|core
argument_list|)
condition|)
block|{
name|vminfo_addr
operator|=
operator|(
name|bfd_vma
operator|)
name|vminfo
operator|.
name|new
operator|.
name|vminfo_addr
expr_stmt|;
name|vminfo_size
operator|=
name|vminfo
operator|.
name|new
operator|.
name|vminfo_size
expr_stmt|;
name|vminfo_offset
operator|=
name|vminfo
operator|.
name|new
operator|.
name|vminfo_offset
expr_stmt|;
block|}
else|else
block|{
name|vminfo_addr
operator|=
operator|(
name|bfd_vma
operator|)
operator|(
name|long
operator|)
name|vminfo
operator|.
name|old
operator|.
name|vminfo_addr
expr_stmt|;
name|vminfo_size
operator|=
name|vminfo
operator|.
name|old
operator|.
name|vminfo_size
expr_stmt|;
name|vminfo_offset
operator|=
name|vminfo
operator|.
name|old
operator|.
name|vminfo_offset
expr_stmt|;
block|}
if|if
condition|(
name|vminfo_offset
condition|)
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".vmdata"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
argument_list|,
name|vminfo_size
argument_list|,
name|vminfo_addr
argument_list|,
name|vminfo_offset
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
name|abfd
operator|->
name|xvec
return|;
comment|/* This is garbage for now.  */
name|fail
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|any
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|NULL
expr_stmt|;
name|bfd_section_list_clear
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return `true' if given core is from the given executable.  */
end_comment

begin_function
name|boolean
name|rs6000coff_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
block|{
name|CoreHdr
name|core
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|size_t
name|alloc
decl_stmt|;
specifier|const
name|char
modifier|*
name|str1
decl_stmt|,
modifier|*
name|str2
decl_stmt|;
name|boolean
name|ret
decl_stmt|;
name|file_ptr
name|c_loader
decl_stmt|;
if|if
condition|(
operator|!
name|read_hdr
argument_list|(
name|core_bfd
argument_list|,
operator|&
name|core
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|CORE_NEW
argument_list|(
name|core
argument_list|)
condition|)
name|c_loader
operator|=
name|CNEW_LOADER
argument_list|(
name|core
operator|.
name|new
argument_list|)
expr_stmt|;
else|else
name|c_loader
operator|=
operator|(
name|file_ptr
operator|)
name|COLD_LOADER
argument_list|(
name|core
operator|.
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|CORE_NEW
argument_list|(
name|core
argument_list|)
operator|&&
name|CNEW_PROC64
argument_list|(
name|core
operator|.
name|new
argument_list|)
condition|)
name|size
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|LdInfo
operator|*
operator|)
literal|0
argument_list|)
operator|->
name|l64
operator|.
name|ldinfo_filename
expr_stmt|;
else|else
name|size
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|LdInfo
operator|*
operator|)
literal|0
argument_list|)
operator|->
name|l32
operator|.
name|ldinfo_filename
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|core_bfd
argument_list|,
name|c_loader
operator|+
name|size
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|alloc
operator|=
literal|100
expr_stmt|;
name|path
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|s
operator|=
name|path
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|bfd_bread
argument_list|(
name|s
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|core_bfd
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
break|break;
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|path
operator|+
name|alloc
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|alloc
operator|*=
literal|2
expr_stmt|;
name|n
operator|=
name|bfd_realloc
argument_list|(
name|path
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|s
operator|=
name|n
operator|+
operator|(
name|path
operator|-
name|s
operator|)
expr_stmt|;
name|path
operator|=
name|n
expr_stmt|;
block|}
block|}
name|str1
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|str2
operator|=
name|strrchr
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* step over character '/' */
name|str1
operator|=
name|str1
operator|!=
name|NULL
condition|?
name|str1
operator|+
literal|1
else|:
name|path
expr_stmt|;
name|str2
operator|=
name|str2
operator|!=
name|NULL
condition|?
name|str2
operator|+
literal|1
else|:
name|exec_bfd
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|true
expr_stmt|;
else|else
name|ret
operator|=
name|false
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rs6000coff_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|CoreHdr
modifier|*
name|core
init|=
name|core_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|com
init|=
name|CORE_NEW
argument_list|(
operator|*
name|core
argument_list|)
condition|?
name|CNEW_COMM
argument_list|(
name|core
operator|->
name|new
argument_list|)
else|:
name|COLD_COMM
argument_list|(
name|core
operator|->
name|old
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|com
condition|)
return|return
name|com
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rs6000coff_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|CoreHdr
modifier|*
name|core
init|=
name|core_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
return|return
name|CORE_NEW
argument_list|(
operator|*
name|core
argument_list|)
condition|?
name|core
operator|->
name|new
operator|.
name|c_signo
else|:
name|core
operator|->
name|old
operator|.
name|c_signo
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AIX_CORE */
end_comment

end_unit

