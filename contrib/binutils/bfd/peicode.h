begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for the generic parts of PE/PEI, for BFD.    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Written by Cygnus Solutions.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Most of this hacked by  Steve Chamberlain, 			sac@cygnus.com  PE/PEI rearrangement (and code added): Donn Terry                                        Softway Systems, Inc. */
end_comment

begin_comment
comment|/* Hey look, some documentation [and in a place you expect to find it]!     The main reference for the pei format is "Microsoft Portable Executable    and Common Object File Format Specification 4.1".  Get it if you need to    do some serious hacking on this code.     Another reference:    "Peering Inside the PE: A Tour of the Win32 Portable Executable    File Format", MSJ 1994, Volume 9.     The *sole* difference between the pe format and the pei format is that the    latter has an MSDOS 2.0 .exe header on the front that prints the message    "This app must be run under Windows." (or some such).    (FIXME: Whether that statement is *really* true or not is unknown.    Are there more subtle differences between pe and pei formats?    For now assume there aren't.  If you find one, then for God sakes    document it here!)     The Microsoft docs use the word "image" instead of "executable" because    the former can also refer to a DLL (shared library).  Confusion can arise    because the `i' in `pei' also refers to "image".  The `pe' format can    also create images (i.e. executables), it's just that to run on a win32    system you need to use the pei format.     FIXME: Please add more docs here so the next poor fool that has to hack    on this code has a chance of getting something accomplished without    wasting too much time. */
end_comment

begin_include
include|#
directive|include
file|"libpei.h"
end_include

begin_expr_stmt
specifier|static
name|boolean
argument_list|(
argument|*pe_saved_coff_bfd_print_private_bfd_data
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
ifndef|#
directive|ifndef
name|coff_bfd_print_private_bfd_data
name|NULL
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|coff_bfd_print_private_bfd_data
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|coff_bfd_print_private_bfd_data
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|pe_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|coff_bfd_print_private_bfd_data
value|pe_print_private_bfd_data
end_define

begin_expr_stmt
specifier|static
name|boolean
argument_list|(
argument|*pe_saved_coff_bfd_copy_private_bfd_data
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
operator|=
ifndef|#
directive|ifndef
name|coff_bfd_copy_private_bfd_data
name|NULL
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|coff_bfd_copy_private_bfd_data
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|coff_bfd_copy_private_bfd_data
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|pe_bfd_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|coff_bfd_copy_private_bfd_data
value|pe_bfd_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|coff_mkobject
value|pe_mkobject
end_define

begin_define
define|#
directive|define
name|coff_mkobject_hook
value|pe_mkobject_hook
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_RELOCS
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|coff_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|coff_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|coff_swap_filehdr_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_swap_scnhdr_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|pe_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
name|pe_mkobject_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
end_ifdef

begin_comment
comment|/* This structure contains static variables used by the ILF code.  */
end_comment

begin_typedef
typedef|typedef
name|asection
modifier|*
name|asection_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
name|unsigned
name|short
name|magic
decl_stmt|;
name|arelent
modifier|*
name|reltab
decl_stmt|;
name|unsigned
name|int
name|relcount
decl_stmt|;
name|coff_symbol_type
modifier|*
name|sym_cache
decl_stmt|;
name|coff_symbol_type
modifier|*
name|sym_ptr
decl_stmt|;
name|unsigned
name|int
name|sym_index
decl_stmt|;
name|unsigned
name|int
modifier|*
name|sym_table
decl_stmt|;
name|unsigned
name|int
modifier|*
name|table_ptr
decl_stmt|;
name|combined_entry_type
modifier|*
name|native_syms
decl_stmt|;
name|combined_entry_type
modifier|*
name|native_ptr
decl_stmt|;
name|coff_symbol_type
modifier|*
modifier|*
name|sym_ptr_table
decl_stmt|;
name|coff_symbol_type
modifier|*
modifier|*
name|sym_ptr_ptr
decl_stmt|;
name|unsigned
name|int
name|sec_index
decl_stmt|;
name|char
modifier|*
name|string_table
decl_stmt|;
name|char
modifier|*
name|string_ptr
decl_stmt|;
name|char
modifier|*
name|end_string_ptr
decl_stmt|;
name|SYMENT
modifier|*
name|esym_table
decl_stmt|;
name|SYMENT
modifier|*
name|esym_ptr
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|int_reltab
decl_stmt|;
block|}
name|pe_ILF_vars
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|asection_ptr
name|pe_ILF_make_a_section
name|PARAMS
argument_list|(
operator|(
name|pe_ILF_vars
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pe_ILF_make_a_reloc
name|PARAMS
argument_list|(
operator|(
name|pe_ILF_vars
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_reloc_code_real_type
operator|,
name|asection_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pe_ILF_make_a_symbol
name|PARAMS
argument_list|(
operator|(
name|pe_ILF_vars
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|asection_ptr
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pe_ILF_save_relocs
name|PARAMS
argument_list|(
operator|(
name|pe_ILF_vars
operator|*
operator|,
name|asection_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pe_ILF_make_a_symbol_reloc
name|PARAMS
argument_list|(
operator|(
name|pe_ILF_vars
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_reloc_code_real_type
operator|,
expr|struct
name|symbol_cache_entry
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|pe_ILF_build_a_bfd
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|pe_ILF_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|pe_bfd_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF_IMAGE_WITH_PE */
end_comment

begin_comment
comment|/**********************************************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_RELOCS
end_ifndef

begin_function
specifier|static
name|void
name|coff_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|src
decl_stmt|;
name|PTR
name|dst
decl_stmt|;
block|{
name|RELOC
modifier|*
name|reloc_src
init|=
operator|(
name|RELOC
operator|*
operator|)
name|src
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|reloc_dst
init|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|dst
decl_stmt|;
name|reloc_dst
operator|->
name|r_vaddr
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|reloc_dst
operator|->
name|r_symndx
operator|=
name|H_GET_S32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|reloc_dst
operator|->
name|r_type
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SWAP_IN_RELOC_OFFSET
name|reloc_dst
operator|->
name|r_offset
operator|=
name|SWAP_IN_RELOC_OFFSET
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|coff_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|src
decl_stmt|;
name|PTR
name|dst
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|reloc_src
init|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|src
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|reloc_dst
init|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|dst
decl_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_vaddr
argument_list|,
name|reloc_dst
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_symndx
argument_list|,
name|reloc_dst
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_type
argument_list|,
name|reloc_dst
operator|->
name|r_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SWAP_OUT_RELOC_OFFSET
name|SWAP_OUT_RELOC_OFFSET
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_offset
argument_list|,
name|reloc_dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SWAP_OUT_RELOC_EXTRA
name|SWAP_OUT_RELOC_EXTRA
argument_list|(
name|abfd
argument_list|,
name|reloc_src
argument_list|,
name|reloc_dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|RELSZ
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_COFF_RELOCS */
end_comment

begin_function
specifier|static
name|void
name|coff_swap_filehdr_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|src
decl_stmt|;
name|PTR
name|dst
decl_stmt|;
block|{
name|FILHDR
modifier|*
name|filehdr_src
init|=
operator|(
name|FILHDR
operator|*
operator|)
name|src
decl_stmt|;
name|struct
name|internal_filehdr
modifier|*
name|filehdr_dst
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|dst
decl_stmt|;
name|filehdr_dst
operator|->
name|f_magic
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_src
operator|->
name|f_magic
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_nscns
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_src
operator|->
name|f_nscns
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_timdat
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_src
operator|->
name|f_timdat
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_nsyms
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_src
operator|->
name|f_nsyms
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_flags
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_src
operator|->
name|f_flags
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_symptr
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_src
operator|->
name|f_symptr
argument_list|)
expr_stmt|;
comment|/* Other people's tools sometimes generate headers with an nsyms but      a zero symptr.  */
if|if
condition|(
name|filehdr_dst
operator|->
name|f_nsyms
operator|!=
literal|0
operator|&&
name|filehdr_dst
operator|->
name|f_symptr
operator|==
literal|0
condition|)
block|{
name|filehdr_dst
operator|->
name|f_nsyms
operator|=
literal|0
expr_stmt|;
name|filehdr_dst
operator|->
name|f_flags
operator||=
name|F_LSYMS
expr_stmt|;
block|}
name|filehdr_dst
operator|->
name|f_opthdr
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_src
operator|->
name|f_opthdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
end_ifdef

begin_define
define|#
directive|define
name|coff_swap_filehdr_out
value|_bfd_XXi_only_swap_filehdr_out
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|coff_swap_filehdr_out
value|_bfd_pe_only_swap_filehdr_out
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|coff_swap_scnhdr_in
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext
decl_stmt|;
name|PTR
name|in
decl_stmt|;
block|{
name|SCNHDR
modifier|*
name|scnhdr_ext
init|=
operator|(
name|SCNHDR
operator|*
operator|)
name|ext
decl_stmt|;
name|struct
name|internal_scnhdr
modifier|*
name|scnhdr_int
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|in
decl_stmt|;
name|memcpy
argument_list|(
name|scnhdr_int
operator|->
name|s_name
argument_list|,
name|scnhdr_ext
operator|->
name|s_name
argument_list|,
sizeof|sizeof
argument_list|(
name|scnhdr_int
operator|->
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_vaddr
operator|=
name|GET_SCNHDR_VADDR
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_vaddr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_paddr
operator|=
name|GET_SCNHDR_PADDR
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_paddr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_size
operator|=
name|GET_SCNHDR_SIZE
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_size
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_scnptr
operator|=
name|GET_SCNHDR_SCNPTR
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_scnptr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_relptr
operator|=
name|GET_SCNHDR_RELPTR
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_relptr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_lnnoptr
operator|=
name|GET_SCNHDR_LNNOPTR
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_lnnoptr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_flags
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_flags
argument_list|)
expr_stmt|;
comment|/* MS handles overflow of line numbers by carrying into the reloc      field (it appears).  Since it's supposed to be zero for PE      *IMAGE* format, that's safe.  This is still a bit iffy.  */
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
name|scnhdr_int
operator|->
name|s_nlnno
operator|=
operator|(
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_nlnno
argument_list|)
operator|+
operator|(
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_nreloc
argument_list|)
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_nreloc
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|scnhdr_int
operator|->
name|s_nreloc
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_nlnno
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|scnhdr_ext
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scnhdr_int
operator|->
name|s_vaddr
operator|!=
literal|0
condition|)
block|{
name|scnhdr_int
operator|->
name|s_vaddr
operator|+=
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|scnhdr_int
operator|->
name|s_vaddr
operator|&=
literal|0xffffffff
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|COFF_NO_HACK_SCNHDR_SIZE
comment|/* If this section holds uninitialized data, use the virtual size      (stored in s_paddr) instead of the physical size.  */
if|if
condition|(
operator|(
name|scnhdr_int
operator|->
name|s_flags
operator|&
name|IMAGE_SCN_CNT_UNINITIALIZED_DATA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scnhdr_int
operator|->
name|s_paddr
operator|>
literal|0
operator|)
condition|)
block|{
name|scnhdr_int
operator|->
name|s_size
operator|=
name|scnhdr_int
operator|->
name|s_paddr
expr_stmt|;
comment|/* This code used to set scnhdr_int->s_paddr to 0.  However,          coff_set_alignment_hook stores s_paddr in virt_size, which          only works if it correctly holds the virtual size of the          section.  */
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|boolean
name|pe_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|pe_data_type
modifier|*
name|pe
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|pe_data_type
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|pe_obj_data
operator|=
operator|(
expr|struct
name|pe_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|pe_obj_data
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|pe
operator|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|pe
operator|->
name|coff
operator|.
name|pe
operator|=
literal|1
expr_stmt|;
comment|/* in_reloc_p is architecture dependent.  */
name|pe
operator|->
name|in_reloc_p
operator|=
name|in_reloc_p
expr_stmt|;
ifdef|#
directive|ifdef
name|PEI_FORCE_MINIMUM_ALIGNMENT
name|pe
operator|->
name|force_minimum_alignment
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PEI_TARGET_SUBSYSTEM
name|pe
operator|->
name|target_subsystem
operator|=
name|PEI_TARGET_SUBSYSTEM
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create the COFF backend specific information.  */
end_comment

begin_function
specifier|static
name|PTR
name|pe_mkobject_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|,
name|aouthdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
name|PTR
name|aouthdr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
name|pe_data_type
modifier|*
name|pe
decl_stmt|;
if|if
condition|(
name|pe_mkobject
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|NULL
return|;
name|pe
operator|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|pe
operator|->
name|coff
operator|.
name|sym_filepos
operator|=
name|internal_f
operator|->
name|f_symptr
expr_stmt|;
comment|/* These members communicate important constants about the symbol      table to GDB's symbol-reading code.  These `constants'      unfortunately vary among coff implementations...  */
name|pe
operator|->
name|coff
operator|.
name|local_n_btmask
operator|=
name|N_BTMASK
expr_stmt|;
name|pe
operator|->
name|coff
operator|.
name|local_n_btshft
operator|=
name|N_BTSHFT
expr_stmt|;
name|pe
operator|->
name|coff
operator|.
name|local_n_tmask
operator|=
name|N_TMASK
expr_stmt|;
name|pe
operator|->
name|coff
operator|.
name|local_n_tshift
operator|=
name|N_TSHIFT
expr_stmt|;
name|pe
operator|->
name|coff
operator|.
name|local_symesz
operator|=
name|SYMESZ
expr_stmt|;
name|pe
operator|->
name|coff
operator|.
name|local_auxesz
operator|=
name|AUXESZ
expr_stmt|;
name|pe
operator|->
name|coff
operator|.
name|local_linesz
operator|=
name|LINESZ
expr_stmt|;
name|pe
operator|->
name|coff
operator|.
name|timestamp
operator|=
name|internal_f
operator|->
name|f_timdat
expr_stmt|;
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|=
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_f
operator|->
name|f_nsyms
expr_stmt|;
name|pe
operator|->
name|real_flags
operator|=
name|internal_f
operator|->
name|f_flags
expr_stmt|;
if|if
condition|(
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_DLL
operator|)
operator|!=
literal|0
condition|)
name|pe
operator|->
name|dll
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|IMAGE_FILE_DEBUG_STRIPPED
operator|)
operator|==
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_DEBUG
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
if|if
condition|(
name|aouthdr
condition|)
name|pe
operator|->
name|pe_opthdr
operator|=
operator|(
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|aouthdr
operator|)
operator|->
name|pe
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARM
if|if
condition|(
operator|!
name|_bfd_coff_arm_set_private_flags
argument_list|(
name|abfd
argument_list|,
name|internal_f
operator|->
name|f_flags
argument_list|)
condition|)
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|PTR
operator|)
name|pe
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|pe_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|vfile
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|vfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|vfile
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_XX_print_private_bfd_data_common
argument_list|(
name|abfd
argument_list|,
name|vfile
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|pe_saved_coff_bfd_print_private_bfd_data
operator|!=
name|NULL
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|pe_saved_coff_bfd_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|vfile
argument_list|)
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy any private info we understand from the input bfd    to the output bfd.  */
end_comment

begin_function
specifier|static
name|boolean
name|pe_bfd_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|,
decl|*
name|obfd
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|_bfd_XX_bfd_copy_private_bfd_data_common
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|pe_saved_coff_bfd_copy_private_bfd_data
condition|)
return|return
name|pe_saved_coff_bfd_copy_private_bfd_data
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
return|;
return|return
name|true
return|;
block|}
end_block

begin_define
define|#
directive|define
name|coff_bfd_copy_private_section_data
define|\
value|_bfd_XX_bfd_copy_private_section_data
end_define

begin_define
define|#
directive|define
name|coff_get_symbol_info
value|_bfd_XX_get_symbol_info
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
end_ifdef

begin_escape
end_escape

begin_comment
comment|/* Code to handle Microsoft's Image Library Format.    Also known as LINK6 format.    Documentation about this format can be found at:     http://msdn.microsoft.com/library/specs/pecoff_section8.htm  */
end_comment

begin_comment
comment|/* The following constants specify the sizes of the various data    structures that we have to create in order to build a bfd describing    an ILF object file.  The final "+ 1" in the definitions of SIZEOF_IDATA6    and SIZEOF_IDATA7 below is to allow for the possibility that we might    need a padding byte in order to ensure 16 bit alignment for the section's    contents.     The value for SIZEOF_ILF_STRINGS is computed as follows:        There will be NUM_ILF_SECTIONS section symbols.  Allow 9 characters       per symbol for their names (longest section name is .idata$x).        There will be two symbols for the imported value, one the symbol name       and one with _imp__ prefixed.  Allowing for the terminating nul's this       is strlen (symbol_name) * 2 + 8 + 21 + strlen (source_dll).        The strings in the string table must start STRING__SIZE_SIZE bytes into       the table in order to for the string lookup code in coffgen/coffcode to       work.  */
end_comment

begin_define
define|#
directive|define
name|NUM_ILF_RELOCS
value|8
end_define

begin_define
define|#
directive|define
name|NUM_ILF_SECTIONS
value|6
end_define

begin_define
define|#
directive|define
name|NUM_ILF_SYMS
value|(2 + NUM_ILF_SECTIONS)
end_define

begin_define
define|#
directive|define
name|SIZEOF_ILF_SYMS
value|(NUM_ILF_SYMS * sizeof (* vars.sym_cache))
end_define

begin_define
define|#
directive|define
name|SIZEOF_ILF_SYM_TABLE
value|(NUM_ILF_SYMS * sizeof (* vars.sym_table))
end_define

begin_define
define|#
directive|define
name|SIZEOF_ILF_NATIVE_SYMS
value|(NUM_ILF_SYMS * sizeof (* vars.native_syms))
end_define

begin_define
define|#
directive|define
name|SIZEOF_ILF_SYM_PTR_TABLE
value|(NUM_ILF_SYMS * sizeof (* vars.sym_ptr_table))
end_define

begin_define
define|#
directive|define
name|SIZEOF_ILF_EXT_SYMS
value|(NUM_ILF_SYMS * sizeof (* vars.esym_table))
end_define

begin_define
define|#
directive|define
name|SIZEOF_ILF_RELOCS
value|(NUM_ILF_RELOCS * sizeof (* vars.reltab))
end_define

begin_define
define|#
directive|define
name|SIZEOF_ILF_INT_RELOCS
value|(NUM_ILF_RELOCS * sizeof (* vars.int_reltab))
end_define

begin_define
define|#
directive|define
name|SIZEOF_ILF_STRINGS
value|(strlen (symbol_name) * 2 + 8 \ 					+ 21 + strlen (source_dll) \ 					+ NUM_ILF_SECTIONS * 9 \ 					+ STRING_SIZE_SIZE)
end_define

begin_define
define|#
directive|define
name|SIZEOF_IDATA2
value|(5 * 4)
end_define

begin_define
define|#
directive|define
name|SIZEOF_IDATA4
value|(1 * 4)
end_define

begin_define
define|#
directive|define
name|SIZEOF_IDATA5
value|(1 * 4)
end_define

begin_define
define|#
directive|define
name|SIZEOF_IDATA6
value|(2 + strlen (symbol_name) + 1 + 1)
end_define

begin_define
define|#
directive|define
name|SIZEOF_IDATA7
value|(strlen (source_dll) + 1 + 1)
end_define

begin_define
define|#
directive|define
name|SIZEOF_ILF_SECTIONS
value|(NUM_ILF_SECTIONS * sizeof (struct coff_section_tdata))
end_define

begin_define
define|#
directive|define
name|ILF_DATA_SIZE
define|\
value|sizeof (* vars.bim)			\     + SIZEOF_ILF_SYMS				\     + SIZEOF_ILF_SYM_TABLE			\     + SIZEOF_ILF_NATIVE_SYMS			\     + SIZEOF_ILF_SYM_PTR_TABLE			\     + SIZEOF_ILF_EXT_SYMS			\     + SIZEOF_ILF_RELOCS				\     + SIZEOF_ILF_INT_RELOCS			\     + SIZEOF_ILF_STRINGS			\     + SIZEOF_IDATA2				\     + SIZEOF_IDATA4				\     + SIZEOF_IDATA5				\     + SIZEOF_IDATA6				\     + SIZEOF_IDATA7				\     + SIZEOF_ILF_SECTIONS			\     + MAX_TEXT_SECTION_SIZE
end_define

begin_comment
comment|/* Create an empty relocation against the given symbol.  */
end_comment

begin_function
specifier|static
name|void
name|pe_ILF_make_a_symbol_reloc
parameter_list|(
name|pe_ILF_vars
modifier|*
name|vars
parameter_list|,
name|bfd_vma
name|address
parameter_list|,
name|bfd_reloc_code_real_type
name|reloc
parameter_list|,
name|struct
name|symbol_cache_entry
modifier|*
modifier|*
name|sym
parameter_list|,
name|unsigned
name|int
name|sym_index
parameter_list|)
block|{
name|arelent
modifier|*
name|entry
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal
decl_stmt|;
name|entry
operator|=
name|vars
operator|->
name|reltab
operator|+
name|vars
operator|->
name|relcount
expr_stmt|;
name|internal
operator|=
name|vars
operator|->
name|int_reltab
operator|+
name|vars
operator|->
name|relcount
expr_stmt|;
name|entry
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|entry
operator|->
name|sym_ptr_ptr
operator|=
name|sym
expr_stmt|;
name|internal
operator|->
name|r_vaddr
operator|=
name|address
expr_stmt|;
name|internal
operator|->
name|r_symndx
operator|=
name|sym_index
expr_stmt|;
name|internal
operator|->
name|r_type
operator|=
name|entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|#
directive|if
literal|0
comment|/* These fields do not need to be initialised.  */
block|internal->r_size   = 0;   internal->r_extern = 0;   internal->r_offset = 0;
endif|#
directive|endif
name|vars
operator|->
name|relcount
operator|++
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|vars
operator|->
name|relcount
operator|<=
name|NUM_ILF_RELOCS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an empty relocation against the given section.  */
end_comment

begin_function
specifier|static
name|void
name|pe_ILF_make_a_reloc
parameter_list|(
name|pe_ILF_vars
modifier|*
name|vars
parameter_list|,
name|bfd_vma
name|address
parameter_list|,
name|bfd_reloc_code_real_type
name|reloc
parameter_list|,
name|asection_ptr
name|sec
parameter_list|)
block|{
name|pe_ILF_make_a_symbol_reloc
argument_list|(
name|vars
argument_list|,
name|address
argument_list|,
name|reloc
argument_list|,
name|sec
operator|->
name|symbol_ptr_ptr
argument_list|,
name|coff_section_data
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the queued relocs into the given section.  */
end_comment

begin_function
specifier|static
name|void
name|pe_ILF_save_relocs
parameter_list|(
name|pe_ILF_vars
modifier|*
name|vars
parameter_list|,
name|asection_ptr
name|sec
parameter_list|)
block|{
comment|/* Make sure that there is somewhere to store the internal relocs.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|sec
argument_list|)
operator|==
name|NULL
condition|)
comment|/* We should probably return an error indication here.  */
name|abort
argument_list|()
expr_stmt|;
name|coff_section_data
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|vars
operator|->
name|int_reltab
expr_stmt|;
name|coff_section_data
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|keep_relocs
operator|=
name|true
expr_stmt|;
name|sec
operator|->
name|relocation
operator|=
name|vars
operator|->
name|reltab
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
name|vars
operator|->
name|relcount
expr_stmt|;
name|sec
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|vars
operator|->
name|reltab
operator|+=
name|vars
operator|->
name|relcount
expr_stmt|;
name|vars
operator|->
name|int_reltab
operator|+=
name|vars
operator|->
name|relcount
expr_stmt|;
name|vars
operator|->
name|relcount
operator|=
literal|0
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|)
name|vars
operator|->
name|int_reltab
operator|<
operator|(
name|bfd_byte
operator|*
operator|)
name|vars
operator|->
name|string_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a global symbol and add it to the relevant tables.  */
end_comment

begin_function
specifier|static
name|void
name|pe_ILF_make_a_symbol
parameter_list|(
name|pe_ILF_vars
modifier|*
name|vars
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol_name
parameter_list|,
name|asection_ptr
name|section
parameter_list|,
name|flagword
name|extra_flags
parameter_list|)
block|{
name|coff_symbol_type
modifier|*
name|sym
decl_stmt|;
name|combined_entry_type
modifier|*
name|ent
decl_stmt|;
name|SYMENT
modifier|*
name|esym
decl_stmt|;
name|unsigned
name|short
name|sclass
decl_stmt|;
if|if
condition|(
name|extra_flags
operator|&
name|BSF_LOCAL
condition|)
name|sclass
operator|=
name|C_STAT
expr_stmt|;
else|else
name|sclass
operator|=
name|C_EXT
expr_stmt|;
ifdef|#
directive|ifdef
name|THUMBPEMAGIC
if|if
condition|(
name|vars
operator|->
name|magic
operator|==
name|THUMBPEMAGIC
condition|)
block|{
if|if
condition|(
name|extra_flags
operator|&
name|BSF_FUNCTION
condition|)
name|sclass
operator|=
name|C_THUMBEXTFUNC
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_flags
operator|&
name|BSF_LOCAL
condition|)
name|sclass
operator|=
name|C_THUMBSTAT
expr_stmt|;
else|else
name|sclass
operator|=
name|C_THUMBEXT
expr_stmt|;
block|}
endif|#
directive|endif
name|BFD_ASSERT
argument_list|(
name|vars
operator|->
name|sym_index
operator|<
name|NUM_ILF_SYMS
argument_list|)
expr_stmt|;
name|sym
operator|=
name|vars
operator|->
name|sym_ptr
expr_stmt|;
name|ent
operator|=
name|vars
operator|->
name|native_ptr
expr_stmt|;
name|esym
operator|=
name|vars
operator|->
name|esym_ptr
expr_stmt|;
comment|/* Copy the symbol's name into the string table.  */
name|sprintf
argument_list|(
name|vars
operator|->
name|string_ptr
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
name|section
operator|=
operator|(
name|asection_ptr
operator|)
operator|&
name|bfd_und_section
expr_stmt|;
comment|/* Initialise the external symbol.  */
name|H_PUT_32
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|vars
operator|->
name|string_ptr
operator|-
name|vars
operator|->
name|string_table
argument_list|,
name|esym
operator|->
name|e
operator|.
name|e
operator|.
name|e_offset
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|section
operator|->
name|target_index
argument_list|,
name|esym
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
name|esym
operator|->
name|e_sclass
index|[
literal|0
index|]
operator|=
name|sclass
expr_stmt|;
comment|/* The following initialisations are unnecessary - the memory is      zero initialised.  They are just kept here as reminders.  */
if|#
directive|if
literal|0
block|esym->e.e.e_zeroes = 0;   esym->e_value = 0;   esym->e_type = T_NULL;   esym->e_numaux = 0;
endif|#
directive|endif
comment|/* Initialise the internal symbol structure.  */
name|ent
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|sclass
expr_stmt|;
name|ent
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|section
operator|->
name|target_index
expr_stmt|;
name|ent
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
name|long
operator|)
name|sym
expr_stmt|;
if|#
directive|if
literal|0
comment|/* See comment above.  */
block|ent->u.syment.n_value  = 0;   ent->u.syment.n_flags  = 0;   ent->u.syment.n_type   = T_NULL;   ent->u.syment.n_numaux = 0;   ent->fix_value         = 0;
endif|#
directive|endif
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|vars
operator|->
name|abfd
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|vars
operator|->
name|string_ptr
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
operator||
name|extra_flags
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|sym
operator|->
name|native
operator|=
name|ent
expr_stmt|;
if|#
directive|if
literal|0
comment|/* See comment above.  */
block|sym->symbol.value   = 0;   sym->symbol.udata.i = 0;   sym->done_lineno    = false;   sym->lineno         = NULL;
endif|#
directive|endif
operator|*
name|vars
operator|->
name|table_ptr
operator|=
name|vars
operator|->
name|sym_index
expr_stmt|;
operator|*
name|vars
operator|->
name|sym_ptr_ptr
operator|=
name|sym
expr_stmt|;
comment|/* Adjust pointers for the next symbol.  */
name|vars
operator|->
name|sym_index
operator|++
expr_stmt|;
name|vars
operator|->
name|sym_ptr
operator|++
expr_stmt|;
name|vars
operator|->
name|sym_ptr_ptr
operator|++
expr_stmt|;
name|vars
operator|->
name|table_ptr
operator|++
expr_stmt|;
name|vars
operator|->
name|native_ptr
operator|++
expr_stmt|;
name|vars
operator|->
name|esym_ptr
operator|++
expr_stmt|;
name|vars
operator|->
name|string_ptr
operator|+=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|vars
operator|->
name|string_ptr
operator|<
name|vars
operator|->
name|end_string_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a section.  */
end_comment

begin_function
specifier|static
name|asection_ptr
name|pe_ILF_make_a_section
parameter_list|(
name|pe_ILF_vars
modifier|*
name|vars
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|flagword
name|extra_flags
parameter_list|)
block|{
name|asection_ptr
name|sec
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|sec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_KEEP
operator||
name|SEC_IN_MEMORY
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
operator||
name|extra_flags
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Check that we will not run out of space.  */
name|BFD_ASSERT
argument_list|(
name|vars
operator|->
name|data
operator|+
name|size
operator|<
name|vars
operator|->
name|bim
operator|->
name|buffer
operator|+
name|vars
operator|->
name|bim
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Set the section size and contents.  The actual      contents are filled in by our parent.  */
name|bfd_set_section_size
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|size
argument_list|)
expr_stmt|;
name|sec
operator|->
name|contents
operator|=
name|vars
operator|->
name|data
expr_stmt|;
name|sec
operator|->
name|target_index
operator|=
name|vars
operator|->
name|sec_index
operator|++
expr_stmt|;
comment|/* Advance data pointer in the vars structure.  */
name|vars
operator|->
name|data
operator|+=
name|size
expr_stmt|;
comment|/* Skip the padding byte if it was not needed.      The logic here is that if the string length is odd,      then the entire string length, including the null byte,      is even and so the extra, padding byte, is not needed.  */
if|if
condition|(
name|size
operator|&
literal|1
condition|)
name|vars
operator|->
name|data
operator|--
expr_stmt|;
comment|/* Create a coff_section_tdata structure for our use.  */
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
expr|struct
name|coff_section_tdata
operator|*
operator|)
name|vars
operator|->
name|data
expr_stmt|;
name|vars
operator|->
name|data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|vars
operator|->
name|data
operator|<=
name|vars
operator|->
name|bim
operator|->
name|buffer
operator|+
name|vars
operator|->
name|bim
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Create a symbol to refer to this section.  */
name|pe_ILF_make_a_symbol
argument_list|(
name|vars
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|sec
argument_list|,
name|BSF_LOCAL
argument_list|)
expr_stmt|;
comment|/* Cache the index to the symbol in the coff_section_data structure.  */
name|coff_section_data
argument_list|(
name|vars
operator|->
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|i
operator|=
name|vars
operator|->
name|sym_index
operator|-
literal|1
expr_stmt|;
return|return
name|sec
return|;
block|}
end_function

begin_comment
comment|/* This structure contains the code that goes into the .text section    in order to perform a jump into the DLL lookup table.  The entries    in the table are index by the magic number used to represent the    machine type in the PE file.  The contents of the data[] arrays in    these entries are stolen from the jtab[] arrays in ld/pe-dll.c.    The SIZE field says how many bytes in the DATA array are actually    used.  The OFFSET field says where in the data array the address    of the .idata$5 section should be placed.  */
end_comment

begin_define
define|#
directive|define
name|MAX_TEXT_SECTION_SIZE
value|32
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|magic
decl_stmt|;
name|unsigned
name|char
name|data
index|[
name|MAX_TEXT_SECTION_SIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
block|}
name|jump_table
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|jump_table
name|jtab
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|I386MAGIC
block|{
name|I386MAGIC
block|,
block|{
literal|0xff
block|,
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x90
block|,
literal|0x90
block|}
block|,
literal|8
block|,
literal|2
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC68MAGIC
block|{
name|MC68MAGIC
block|,
block|{
comment|/* XXX fill me in */
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS_ARCH_MAGIC_WINCE
block|{
name|MIPS_ARCH_MAGIC_WINCE
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x3c
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x8d
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
literal|16
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SH_ARCH_MAGIC_WINCE
block|{
name|SH_ARCH_MAGIC_WINCE
block|,
block|{
literal|0x01
block|,
literal|0xd0
block|,
literal|0x02
block|,
literal|0x60
block|,
literal|0x2b
block|,
literal|0x40
block|,
literal|0x09
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
literal|12
block|,
literal|8
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARMPEMAGIC
block|{
name|ARMPEMAGIC
block|,
block|{
literal|0x00
block|,
literal|0xc0
block|,
literal|0x9f
block|,
literal|0xe5
block|,
literal|0x00
block|,
literal|0xf0
block|,
literal|0x9c
block|,
literal|0xe5
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
literal|12
block|,
literal|8
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|THUMBPEMAGIC
block|{
name|THUMBPEMAGIC
block|,
block|{
literal|0x40
block|,
literal|0xb4
block|,
literal|0x02
block|,
literal|0x4e
block|,
literal|0x36
block|,
literal|0x68
block|,
literal|0xb4
block|,
literal|0x46
block|,
literal|0x40
block|,
literal|0xbc
block|,
literal|0x60
block|,
literal|0x47
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
literal|16
block|,
literal|12
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
block|{
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NUM_ENTRIES
end_ifndef

begin_define
define|#
directive|define
name|NUM_ENTRIES
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a)[0])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build a full BFD from the information supplied in a ILF object.  */
end_comment

begin_function
specifier|static
name|boolean
name|pe_ILF_build_a_bfd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|magic
parameter_list|,
name|bfd_byte
modifier|*
name|symbol_name
parameter_list|,
name|bfd_byte
modifier|*
name|source_dll
parameter_list|,
name|unsigned
name|int
name|ordinal
parameter_list|,
name|unsigned
name|int
name|types
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|ptr
decl_stmt|;
name|pe_ILF_vars
name|vars
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|unsigned
name|int
name|import_type
decl_stmt|;
name|unsigned
name|int
name|import_name_type
decl_stmt|;
name|asection_ptr
name|id4
decl_stmt|,
name|id5
decl_stmt|,
name|id6
init|=
name|NULL
decl_stmt|,
name|text
init|=
name|NULL
decl_stmt|;
name|coff_symbol_type
modifier|*
modifier|*
name|imp_sym
decl_stmt|;
name|unsigned
name|int
name|imp_index
decl_stmt|;
comment|/* Decode and verify the types field of the ILF structure.  */
name|import_type
operator|=
name|types
operator|&
literal|0x3
expr_stmt|;
name|import_name_type
operator|=
operator|(
name|types
operator|&
literal|0x1c
operator|)
operator|>>
literal|2
expr_stmt|;
switch|switch
condition|(
name|import_type
condition|)
block|{
case|case
name|IMPORT_CODE
case|:
case|case
name|IMPORT_DATA
case|:
break|break;
case|case
name|IMPORT_CONST
case|:
comment|/* XXX code yet to be written.  */
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: Unhandled import type; %x"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|import_type
argument_list|)
expr_stmt|;
return|return
name|false
return|;
default|default:
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: Unrecognised import type; %x"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|import_type
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
switch|switch
condition|(
name|import_name_type
condition|)
block|{
case|case
name|IMPORT_ORDINAL
case|:
case|case
name|IMPORT_NAME
case|:
case|case
name|IMPORT_NAME_NOPREFIX
case|:
case|case
name|IMPORT_NAME_UNDECORATE
case|:
break|break;
default|default:
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: Unrecognised import name type; %x"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|import_name_type
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Initialise local variables.       Note these are kept in a structure rather than being      declared as statics since bfd frowns on global variables.       We are going to construct the contents of the BFD in memory,      so allocate all the space that we will need right now.  */
name|ptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|ILF_DATA_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Create a bfd_in_memory structure.  */
name|vars
operator|.
name|bim
operator|=
operator|(
expr|struct
name|bfd_in_memory
operator|*
operator|)
name|ptr
expr_stmt|;
name|vars
operator|.
name|bim
operator|->
name|buffer
operator|=
name|ptr
expr_stmt|;
name|vars
operator|.
name|bim
operator|->
name|size
operator|=
name|ILF_DATA_SIZE
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|vars
operator|.
name|bim
argument_list|)
expr_stmt|;
comment|/* Initialise the pointers to regions of the memory and the      other contents of the pe_ILF_vars structure as well.  */
name|vars
operator|.
name|sym_cache
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|ptr
expr_stmt|;
name|vars
operator|.
name|sym_ptr
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|ptr
expr_stmt|;
name|vars
operator|.
name|sym_index
operator|=
literal|0
expr_stmt|;
name|ptr
operator|+=
name|SIZEOF_ILF_SYMS
expr_stmt|;
name|vars
operator|.
name|sym_table
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ptr
expr_stmt|;
name|vars
operator|.
name|table_ptr
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|SIZEOF_ILF_SYM_TABLE
expr_stmt|;
name|vars
operator|.
name|native_syms
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|ptr
expr_stmt|;
name|vars
operator|.
name|native_ptr
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|SIZEOF_ILF_NATIVE_SYMS
expr_stmt|;
name|vars
operator|.
name|sym_ptr_table
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|*
operator|)
name|ptr
expr_stmt|;
name|vars
operator|.
name|sym_ptr_ptr
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|SIZEOF_ILF_SYM_PTR_TABLE
expr_stmt|;
name|vars
operator|.
name|esym_table
operator|=
operator|(
name|SYMENT
operator|*
operator|)
name|ptr
expr_stmt|;
name|vars
operator|.
name|esym_ptr
operator|=
operator|(
name|SYMENT
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|SIZEOF_ILF_EXT_SYMS
expr_stmt|;
name|vars
operator|.
name|reltab
operator|=
operator|(
name|arelent
operator|*
operator|)
name|ptr
expr_stmt|;
name|vars
operator|.
name|relcount
operator|=
literal|0
expr_stmt|;
name|ptr
operator|+=
name|SIZEOF_ILF_RELOCS
expr_stmt|;
name|vars
operator|.
name|int_reltab
operator|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|SIZEOF_ILF_INT_RELOCS
expr_stmt|;
name|vars
operator|.
name|string_table
operator|=
name|ptr
expr_stmt|;
name|vars
operator|.
name|string_ptr
operator|=
name|ptr
operator|+
name|STRING_SIZE_SIZE
expr_stmt|;
name|ptr
operator|+=
name|SIZEOF_ILF_STRINGS
expr_stmt|;
name|vars
operator|.
name|end_string_ptr
operator|=
name|ptr
expr_stmt|;
comment|/* The remaining space in bim->buffer is used      by the pe_ILF_make_a_section() function.  */
name|vars
operator|.
name|data
operator|=
name|ptr
expr_stmt|;
name|vars
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|vars
operator|.
name|sec_index
operator|=
literal|0
expr_stmt|;
name|vars
operator|.
name|magic
operator|=
name|magic
expr_stmt|;
comment|/* Create the initial .idata$<n> sections:      [.idata$2:  Import Directory Table -- not needed]      .idata$4:  Import Lookup Table      .idata$5:  Import Address Table       Note we do not create a .idata$3 section as this is      created for us by the linker script.  */
name|id4
operator|=
name|pe_ILF_make_a_section
argument_list|(
operator|&
name|vars
argument_list|,
literal|".idata$4"
argument_list|,
name|SIZEOF_IDATA4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|id5
operator|=
name|pe_ILF_make_a_section
argument_list|(
operator|&
name|vars
argument_list|,
literal|".idata$5"
argument_list|,
name|SIZEOF_IDATA5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id4
operator|==
name|NULL
operator|||
name|id5
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Fill in the contents of these sections.  */
if|if
condition|(
name|import_name_type
operator|==
name|IMPORT_ORDINAL
condition|)
block|{
if|if
condition|(
name|ordinal
operator|==
literal|0
condition|)
comment|/* XXX - treat as IMPORT_NAME ??? */
name|abort
argument_list|()
expr_stmt|;
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|id4
operator|->
name|contents
operator|=
name|ordinal
operator||
literal|0x80000000
expr_stmt|;
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|id5
operator|->
name|contents
operator|=
name|ordinal
operator||
literal|0x80000000
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|symbol
decl_stmt|;
comment|/* Create .idata$6 - the Hint Name Table.  */
name|id6
operator|=
name|pe_ILF_make_a_section
argument_list|(
operator|&
name|vars
argument_list|,
literal|".idata$6"
argument_list|,
name|SIZEOF_IDATA6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id6
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* If necessary, trim the import symbol name.  */
name|symbol
operator|=
name|symbol_name
expr_stmt|;
if|if
condition|(
name|import_name_type
operator|!=
name|IMPORT_NAME
condition|)
comment|/* Skip any prefix in symbol_name.  */
while|while
condition|(
operator|*
name|symbol
operator|==
literal|'@'
operator|||
operator|*
name|symbol
operator|==
literal|'?'
operator|||
operator|*
name|symbol
operator|==
literal|'_'
condition|)
operator|++
name|symbol
expr_stmt|;
if|if
condition|(
name|import_name_type
operator|==
name|IMPORT_NAME_UNDECORATE
condition|)
block|{
comment|/* Truncate at the first '@'  */
while|while
condition|(
operator|*
name|symbol
operator|!=
literal|0
operator|&&
operator|*
name|symbol
operator|!=
literal|'@'
condition|)
name|symbol
operator|++
expr_stmt|;
operator|*
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
name|id6
operator|->
name|contents
index|[
literal|0
index|]
operator|=
name|ordinal
operator|&
literal|0xff
expr_stmt|;
name|id6
operator|->
name|contents
index|[
literal|1
index|]
operator|=
name|ordinal
operator|>>
literal|8
expr_stmt|;
name|strcpy
argument_list|(
name|id6
operator|->
name|contents
operator|+
literal|2
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|import_name_type
operator|!=
name|IMPORT_ORDINAL
condition|)
block|{
name|pe_ILF_make_a_reloc
argument_list|(
operator|&
name|vars
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
name|id6
argument_list|)
expr_stmt|;
name|pe_ILF_save_relocs
argument_list|(
operator|&
name|vars
argument_list|,
name|id4
argument_list|)
expr_stmt|;
name|pe_ILF_make_a_reloc
argument_list|(
operator|&
name|vars
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
name|id6
argument_list|)
expr_stmt|;
name|pe_ILF_save_relocs
argument_list|(
operator|&
name|vars
argument_list|,
name|id5
argument_list|)
expr_stmt|;
block|}
comment|/* Create extra sections depending upon the type of import we are dealing with.  */
switch|switch
condition|(
name|import_type
condition|)
block|{
name|int
name|i
decl_stmt|;
case|case
name|IMPORT_CODE
case|:
comment|/* Create a .text section. 	 First we need to look up its contents in the jump table.  */
for|for
control|(
name|i
operator|=
name|NUM_ENTRIES
argument_list|(
name|jtab
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
if|if
condition|(
name|jtab
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|jtab
index|[
name|i
index|]
operator|.
name|magic
operator|==
name|magic
condition|)
break|break;
block|}
comment|/* If we did not find a matching entry something is wrong.  */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create the .text section.  */
name|text
operator|=
name|pe_ILF_make_a_section
argument_list|(
operator|&
name|vars
argument_list|,
literal|".text"
argument_list|,
name|jtab
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|SEC_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Copy in the jump code.  */
name|memcpy
argument_list|(
name|text
operator|->
name|contents
argument_list|,
name|jtab
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|jtab
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* Create an import symbol.  */
name|pe_ILF_make_a_symbol
argument_list|(
operator|&
name|vars
argument_list|,
literal|"__imp_"
argument_list|,
name|symbol_name
argument_list|,
name|id5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imp_sym
operator|=
name|vars
operator|.
name|sym_ptr_ptr
operator|-
literal|1
expr_stmt|;
name|imp_index
operator|=
name|vars
operator|.
name|sym_index
operator|-
literal|1
expr_stmt|;
comment|/* Create a reloc for the data in the text section.  */
ifdef|#
directive|ifdef
name|MIPS_ARCH_MAGIC_WINCE
if|if
condition|(
name|magic
operator|==
name|MIPS_ARCH_MAGIC_WINCE
condition|)
block|{
name|pe_ILF_make_a_symbol_reloc
argument_list|(
operator|&
name|vars
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|,
operator|(
expr|struct
name|symbol_cache_entry
operator|*
operator|*
operator|)
name|imp_sym
argument_list|,
name|imp_index
argument_list|)
expr_stmt|;
name|pe_ILF_make_a_reloc
argument_list|(
operator|&
name|vars
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|pe_ILF_make_a_symbol_reloc
argument_list|(
operator|&
name|vars
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|4
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
operator|(
expr|struct
name|symbol_cache_entry
operator|*
operator|*
operator|)
name|imp_sym
argument_list|,
name|imp_index
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|pe_ILF_make_a_symbol_reloc
argument_list|(
operator|&
name|vars
argument_list|,
operator|(
name|bfd_vma
operator|)
name|jtab
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|BFD_RELOC_32
argument_list|,
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|imp_sym
argument_list|,
name|imp_index
argument_list|)
expr_stmt|;
name|pe_ILF_save_relocs
argument_list|(
operator|&
name|vars
argument_list|,
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMPORT_DATA
case|:
break|break;
default|default:
comment|/* XXX code not yet written.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Initialise the bfd.  */
name|memset
argument_list|(
operator|&
name|internal_f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|internal_f
argument_list|)
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_magic
operator|=
name|magic
expr_stmt|;
name|internal_f
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_nsyms
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator|=
name|F_AR32WR
operator||
name|F_LNNO
expr_stmt|;
comment|/* XXX is this correct ?  */
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|||
operator|!
name|bfd_coff_set_arch_mach_hook
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_f
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_coff_mkobject_hook
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_f
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|THUMBPEMAGIC
if|if
condition|(
name|vars
operator|.
name|magic
operator|==
name|THUMBPEMAGIC
condition|)
comment|/* Stop some linker warnings about thumb code not supporting interworking.  */
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator||=
name|F_INTERWORK
operator||
name|F_INTERWORK_SET
expr_stmt|;
endif|#
directive|endif
comment|/* Switch from file contents to memory contents.  */
name|bfd_cache_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|vars
operator|.
name|bim
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|BFD_IN_MEMORY
comment|/* | HAS_LOCALS */
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now create a symbol describing the imported value.  */
switch|switch
condition|(
name|import_type
condition|)
block|{
case|case
name|IMPORT_CODE
case|:
name|pe_ILF_make_a_symbol
argument_list|(
operator|&
name|vars
argument_list|,
literal|""
argument_list|,
name|symbol_name
argument_list|,
name|text
argument_list|,
name|BSF_NOT_AT_END
operator||
name|BSF_FUNCTION
argument_list|)
expr_stmt|;
comment|/* Create an import symbol for the DLL, without the        .dll suffix.  */
name|ptr
operator|=
name|strrchr
argument_list|(
name|source_dll
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
name|pe_ILF_make_a_symbol
argument_list|(
operator|&
name|vars
argument_list|,
literal|"__IMPORT_DESCRIPTOR_"
argument_list|,
name|source_dll
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
literal|'.'
expr_stmt|;
break|break;
case|case
name|IMPORT_DATA
case|:
comment|/* Nothing to do here.  */
break|break;
default|default:
comment|/* XXX code not yet written.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Point the bfd at the symbol table.  */
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|vars
operator|.
name|sym_cache
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|vars
operator|.
name|sym_index
expr_stmt|;
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|=
name|vars
operator|.
name|native_syms
expr_stmt|;
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|=
name|vars
operator|.
name|sym_index
expr_stmt|;
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|PTR
operator|)
name|vars
operator|.
name|esym_table
expr_stmt|;
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|obj_convert
argument_list|(
name|abfd
argument_list|)
operator|=
name|vars
operator|.
name|sym_table
expr_stmt|;
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|vars
operator|.
name|sym_index
expr_stmt|;
name|obj_coff_strings
argument_list|(
name|abfd
argument_list|)
operator|=
name|vars
operator|.
name|string_table
expr_stmt|;
name|obj_coff_keep_strings
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We have detected a Image Library Format archive element.    Decode the element and return the appropriate target.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|pe_ILF_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_byte
name|buffer
index|[
literal|16
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|ptr
decl_stmt|;
name|bfd_byte
modifier|*
name|symbol_name
decl_stmt|;
name|bfd_byte
modifier|*
name|source_dll
decl_stmt|;
name|unsigned
name|int
name|machine
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|unsigned
name|int
name|ordinal
decl_stmt|;
name|unsigned
name|int
name|types
decl_stmt|;
name|unsigned
name|int
name|magic
decl_stmt|;
comment|/* Upon entry the first four buyes of the ILF header have       already been read.  Now read the rest of the header.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buffer
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|16
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|16
condition|)
return|return
name|NULL
return|;
name|ptr
operator|=
name|buffer
expr_stmt|;
comment|/*  We do not bother to check the version number.       version = H_GET_16 (abfd, ptr);  */
name|ptr
operator|+=
literal|2
expr_stmt|;
name|machine
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
comment|/* Check that the machine type is recognised.  */
name|magic
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|IMAGE_FILE_MACHINE_UNKNOWN
case|:
case|case
name|IMAGE_FILE_MACHINE_ALPHA
case|:
case|case
name|IMAGE_FILE_MACHINE_ALPHA64
case|:
case|case
name|IMAGE_FILE_MACHINE_IA64
case|:
break|break;
case|case
name|IMAGE_FILE_MACHINE_I386
case|:
ifdef|#
directive|ifdef
name|I386MAGIC
name|magic
operator|=
name|I386MAGIC
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IMAGE_FILE_MACHINE_M68K
case|:
ifdef|#
directive|ifdef
name|MC68AGIC
name|magic
operator|=
name|MC68MAGIC
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IMAGE_FILE_MACHINE_R3000
case|:
case|case
name|IMAGE_FILE_MACHINE_R4000
case|:
case|case
name|IMAGE_FILE_MACHINE_R10000
case|:
case|case
name|IMAGE_FILE_MACHINE_MIPS16
case|:
case|case
name|IMAGE_FILE_MACHINE_MIPSFPU
case|:
case|case
name|IMAGE_FILE_MACHINE_MIPSFPU16
case|:
ifdef|#
directive|ifdef
name|MIPS_ARCH_MAGIC_WINCE
name|magic
operator|=
name|MIPS_ARCH_MAGIC_WINCE
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IMAGE_FILE_MACHINE_SH3
case|:
case|case
name|IMAGE_FILE_MACHINE_SH4
case|:
ifdef|#
directive|ifdef
name|SH_ARCH_MAGIC_WINCE
name|magic
operator|=
name|SH_ARCH_MAGIC_WINCE
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IMAGE_FILE_MACHINE_ARM
case|:
ifdef|#
directive|ifdef
name|ARMPEMAGIC
name|magic
operator|=
name|ARMPEMAGIC
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IMAGE_FILE_MACHINE_THUMB
case|:
ifdef|#
directive|ifdef
name|THUMBPEMAGIC
block|{
specifier|extern
specifier|const
name|bfd_target
name|TARGET_LITTLE_SYM
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|==
operator|&
name|TARGET_LITTLE_SYM
condition|)
name|magic
operator|=
name|THUMBPEMAGIC
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|IMAGE_FILE_MACHINE_POWERPC
case|:
comment|/* We no longer support PowerPC.  */
default|default:
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: Unrecognised machine type (0x%x) in Import Library Format archive"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|machine
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
break|break;
block|}
if|if
condition|(
name|magic
operator|==
literal|0
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: Recognised but unhandled machine type (0x%x) in Import Library Format archive"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|machine
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* We do not bother to check the date.      date = H_GET_32 (abfd, ptr);  */
name|ptr
operator|+=
literal|4
expr_stmt|;
name|size
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: size field is zero in Import Library Format header"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ordinal
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
name|types
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* ptr += 2; */
comment|/* Now read in the two strings that follow.  */
name|ptr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
return|return
name|NULL
return|;
name|symbol_name
operator|=
name|ptr
expr_stmt|;
name|source_dll
operator|=
name|ptr
operator|+
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Verify that the strings are null terminated.  */
if|if
condition|(
name|ptr
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|0
operator|||
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|source_dll
operator|-
name|ptr
argument_list|)
operator|>=
name|size
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: string not null terminated in ILF object file."
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now construct the bfd.  */
if|if
condition|(
operator|!
name|pe_ILF_build_a_bfd
argument_list|(
name|abfd
argument_list|,
name|magic
argument_list|,
name|symbol_name
argument_list|,
name|source_dll
argument_list|,
name|ordinal
argument_list|,
name|types
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|pe_bfd_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|external_PEI_DOS_hdr
name|dos_hdr
decl_stmt|;
name|struct
name|external_PEI_IMAGE_hdr
name|image_hdr
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
comment|/* Detect if this a Microsoft Import Library Format element.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|buffer
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|buffer
argument_list|)
operator|==
literal|0xffff0000
condition|)
return|return
name|pe_ILF_object_p
argument_list|(
name|abfd
argument_list|)
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|&
name|dos_hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|dos_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|dos_hdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* There are really two magic numbers involved; the magic number      that says this is a NT executable (PEI) and the magic number that      determines the architecture.  The former is DOSMAGIC, stored in      the e_magic field.  The latter is stored in the f_magic field.      If the NT magic number isn't valid, the architecture magic number      could be mimicked by some other field (specifically, the number      of relocs in section 3).  Since this routine can only be called      correctly for a PEI file, check the e_magic number here, and, if      it doesn't match, clobber the f_magic number so that we don't get      a false match.  */
if|if
condition|(
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|dos_hdr
operator|.
name|e_magic
argument_list|)
operator|!=
name|DOSMAGIC
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|dos_hdr
operator|.
name|e_lfanew
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
operator|&
name|image_hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|image_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|image_hdr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|image_hdr
operator|.
name|nt_signature
argument_list|)
operator|!=
literal|0x4550
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Here is the hack.  coff_object_p wants to read filhsz bytes to      pick up the COFF header for PE, see "struct external_PEI_filehdr"      in include/coff/pe.h.  We adjust so that that will work. */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|offset
operator|-
sizeof|sizeof
argument_list|(
name|dos_hdr
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|coff_object_p
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_object_p
value|pe_bfd_object_p
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF_IMAGE_WITH_PE */
end_comment

end_unit

