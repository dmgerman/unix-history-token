begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hitachi SH specific support for 32-bit ELF    Copyright 1996 Free Software Foundation, Inc.    Contributed by Ian Lance Taylor, Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sh_elf_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sh_elf_ignore_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|sh_elf_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sh_elf_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_relax_delete_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_align_loads
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_swap_insns
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|sh_elf_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|sh_reloc_type
block|{
name|R_SH_NONE
init|=
literal|0
block|,
name|R_SH_DIR32
block|,
name|R_SH_REL32
block|,
name|R_SH_DIR8WPN
block|,
name|R_SH_IND12W
block|,
name|R_SH_DIR8WPL
block|,
name|R_SH_DIR8WPZ
block|,
name|R_SH_DIR8BP
block|,
name|R_SH_DIR8W
block|,
name|R_SH_DIR8L
block|,
name|FIRST_INVALID_RELOC
block|,
name|LAST_INVALID_RELOC
init|=
literal|24
block|,
comment|/* The remaining relocs are a GNU extension used for relaxation.  We      use the same constants as COFF uses, not that it really matters.  */
name|R_SH_SWITCH16
init|=
literal|25
block|,
name|R_SH_SWITCH32
block|,
name|R_SH_USES
block|,
name|R_SH_COUNT
block|,
name|R_SH_ALIGN
block|,
name|R_SH_CODE
block|,
name|R_SH_DATA
block|,
name|R_SH_LABEL
block|,
name|R_SH_max
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|sh_elf_howto_table
index|[]
init|=
block|{
comment|/* No relocation.  */
name|HOWTO
argument_list|(
name|R_SH_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit absolute relocation.  Setting partial_inplace to true and      src_mask to a non-zero value is similar to the COFF toolchain.  */
name|HOWTO
argument_list|(
name|R_SH_DIR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_SH_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_REL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit PC relative branch divided by 2.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8WPN
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8WPN"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 12 bit PC relative branch divided by 2.  */
name|HOWTO
argument_list|(
name|R_SH_IND12W
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IND12W"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit unsigned PC relative divided by 4.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8WPL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8WPL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit unsigned PC relative divided by 2.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8WPZ
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8WPZ"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit GBR relative.  FIXME: This only makes sense if we have some      special symbol for the GBR relative area, and that is not      implemented.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8BP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8BP"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit GBR relative divided by 2.  FIXME: This only makes sense if      we have some special symbol for the GBR relative area, and that      is not implemented.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8W
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8W"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit GBR relative divided by 4.  FIXME: This only makes sense if      we have some special symbol for the GBR relative area, and that      is not implemented.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8L
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8L"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
block|{
literal|10
block|}
block|,
block|{
literal|11
block|}
block|,
block|{
literal|12
block|}
block|,
block|{
literal|13
block|}
block|,
block|{
literal|14
block|}
block|,
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
block|{
literal|17
block|}
block|,
block|{
literal|18
block|}
block|,
block|{
literal|19
block|}
block|,
block|{
literal|20
block|}
block|,
block|{
literal|21
block|}
block|,
block|{
literal|22
block|}
block|,
block|{
literal|23
block|}
block|,
block|{
literal|24
block|}
block|,
comment|/* The remaining relocs are a GNU extension used for relaxing.  The      final pass of the linker never needs to do anything with any of      these relocs.  Any required operations are handled by the      relaxation code.  */
comment|/* A 16 bit switch table entry.  This is generated for an expression      such as ``.word L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_SH_SWITCH16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SWITCH16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit switch table entry.  This is generated for an expression      such as ``.long L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_SH_SWITCH32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SWITCH32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Indicates a .uses pseudo-op.  The compiler will generate .uses      pseudo-ops when it finds a function call which can be relaxed.      The offset field holds the PC relative offset to the instruction      which loads the register used in the function call.  */
name|HOWTO
argument_list|(
name|R_SH_USES
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_USES"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler will generate this reloc for addresses referred to      by the register loads associated with USES relocs.  The offset      field holds the number of times the address is referenced in the      object file.  */
name|HOWTO
argument_list|(
name|R_SH_COUNT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_COUNT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Indicates an alignment statement.  The offset field is the power      of 2 to which subsequent portions of the object file must be      aligned.  */
name|HOWTO
argument_list|(
name|R_SH_ALIGN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_ALIGN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler will generate this reloc before a block of      instructions.  A section should be processed as assumining it      contains data, unless this reloc is seen.  */
name|HOWTO
argument_list|(
name|R_SH_CODE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_CODE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler will generate this reloc after a block of      instructions when it sees data that is not instructions.  */
name|HOWTO
argument_list|(
name|R_SH_DATA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DATA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler generates this reloc for each label within a block      of instructions.  This permits the linker to avoid swapping      instructions which are the targets of branches.  */
name|HOWTO
argument_list|(
argument|R_SH_LABEL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
argument|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
argument|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_LABEL"
argument_list|,
comment|/* name */
argument|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
argument|true
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function is used for normal relocs.  This is like the COFF    function, and is almost certainly incorrect for other ELF targets.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sh_elf_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol_in
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|enum
name|sh_reloc_type
name|r_type
decl_stmt|;
name|bfd_vma
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|addr
operator|+
operator|(
name|bfd_byte
operator|*
operator|)
name|data
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|sh_reloc_type
operator|)
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
comment|/* Partial linking--do nothing.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Almost all relocs have to do with relaxing.  If any work must be      done for them, it has been done in sh_relax_section.  */
if|if
condition|(
name|r_type
operator|!=
name|R_SH_DIR32
operator|&&
operator|(
name|r_type
operator|!=
name|R_SH_IND12W
operator|||
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|bfd_reloc_ok
return|;
if|if
condition|(
name|symbol_in
operator|!=
name|NULL
operator|&&
name|bfd_is_und_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
name|sym_value
operator|=
literal|0
expr_stmt|;
else|else
name|sym_value
operator|=
operator|(
name|symbol_in
operator|->
name|value
operator|+
name|symbol_in
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol_in
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SH_DIR32
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_IND12W
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|sym_value
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|sym_value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|addr
operator|+
literal|4
operator|)
expr_stmt|;
name|sym_value
operator|+=
operator|(
name|insn
operator|&
literal|0xfff
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|&
literal|0x800
condition|)
name|sym_value
operator|-=
literal|0x1000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
operator||
operator|(
name|sym_value
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_value
operator|<
operator|(
name|bfd_vma
operator|)
operator|-
literal|0x1000
operator|||
name|sym_value
operator|>=
literal|0x1000
condition|)
return|return
name|bfd_reloc_overflow
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* This function is used for relocs which are only used for relaxing,    which the linker should otherwise ignore.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sh_elf_ignore_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* This structure is used to map BFD reloc codes to SH ELF relocs.  */
end_comment

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|unsigned
name|char
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An array mapping BFD reloc codes to SH ELF relocs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_reloc_map
name|sh_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_SH_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_SH_DIR32
block|}
block|,
block|{
name|BFD_RELOC_CTOR
block|,
name|R_SH_DIR32
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_SH_REL32
block|}
block|,
block|{
name|BFD_RELOC_SH_PCDISP8BY2
block|,
name|R_SH_DIR8WPN
block|}
block|,
block|{
name|BFD_RELOC_SH_PCDISP12BY2
block|,
name|R_SH_IND12W
block|}
block|,
block|{
name|BFD_RELOC_SH_PCRELIMM8BY2
block|,
name|R_SH_DIR8WPZ
block|}
block|,
block|{
name|BFD_RELOC_SH_PCRELIMM8BY4
block|,
name|R_SH_DIR8WPL
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH16
block|,
name|R_SH_SWITCH16
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH32
block|,
name|R_SH_SWITCH32
block|}
block|,
block|{
name|BFD_RELOC_SH_USES
block|,
name|R_SH_USES
block|}
block|,
block|{
name|BFD_RELOC_SH_COUNT
block|,
name|R_SH_COUNT
block|}
block|,
block|{
name|BFD_RELOC_SH_ALIGN
block|,
name|R_SH_ALIGN
block|}
block|,
block|{
name|BFD_RELOC_SH_CODE
block|,
name|R_SH_CODE
block|}
block|,
block|{
name|BFD_RELOC_SH_DATA
block|,
name|R_SH_DATA
block|}
block|,
block|{
name|BFD_RELOC_SH_LABEL
block|,
name|R_SH_LABEL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a BFD reloc code, return the howto structure for the    corresponding SH ELf reloc.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|sh_elf_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sh_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sh_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|sh_elf_howto_table
index|[
operator|(
name|int
operator|)
name|sh_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given an ELF reloc, fill in the howto field of a relent.  */
end_comment

begin_function
specifier|static
name|void
name|sh_elf_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r
decl_stmt|;
name|r
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_SH_max
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
name|FIRST_INVALID_RELOC
operator|||
name|r
operator|>
name|LAST_INVALID_RELOC
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|sh_elf_howto_table
index|[
name|r
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function handles relaxing for SH ELF.  See the corresponding    function in coff-sh.c for a description of what this does.  FIXME:    There is a lot of duplication here between this code and the COFF    specific code.  The format of relocs and symbols is wound deeply    into this code, but it would still be better if the duplication    could be eliminated somehow.  Note in particular that although both    functions use symbols like R_SH_CODE, those symbols have different    values; in coff-sh.c they come from include/coff/sh.h, whereas here    they come from enum sh_reloc_type in this file.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
name|boolean
name|have_code
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|free_contents
init|=
name|NULL
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|extsyms
init|=
name|NULL
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|free_extsyms
init|=
name|NULL
decl_stmt|;
operator|*
name|again
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|relocateable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If this is the first time we have been called for this section,      initialize the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_elf32_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free_relocs
operator|=
name|internal_relocs
expr_stmt|;
name|have_code
operator|=
name|false
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|laddr
decl_stmt|,
name|paddr
decl_stmt|,
name|symval
decl_stmt|;
name|unsigned
name|short
name|insn
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelfn
decl_stmt|,
modifier|*
name|irelscan
decl_stmt|,
modifier|*
name|irelcount
decl_stmt|;
name|bfd_signed_vma
name|foff
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_CODE
condition|)
name|have_code
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_USES
condition|)
continue|continue;
comment|/* Get the section contents.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* The r_addend field of the R_SH_USES reloc will point us to          the register load.  The 4 is because the r_addend field is          computed as though it were a jump offset, which are based          from 4 bytes after the jump instruction.  */
name|laddr
operator|=
name|irel
operator|->
name|r_offset
operator|+
literal|4
operator|+
name|irel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|laddr
operator|>=
name|sec
operator|->
name|_raw_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: bad R_SH_USES offset"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|laddr
argument_list|)
expr_stmt|;
comment|/* If the instruction is not mov.l NN,rN, we don't know what to          do.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xf000
operator|)
operator|!=
literal|0xd000
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|,
name|insn
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the address from which the register is being loaded.  The       	 displacement in the mov.l instruction is quadrupled.  It is a       	 displacement from four bytes after the movl instruction, but,       	 before adding in the PC address, two least significant bits       	 of the PC are cleared.  We assume that the section is aligned       	 on a four byte boundary.  */
name|paddr
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|paddr
operator|*=
literal|4
expr_stmt|;
name|paddr
operator|+=
operator|(
name|laddr
operator|+
literal|4
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|paddr
operator|>=
name|sec
operator|->
name|_raw_size
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: bad R_SH_USES load offset"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the reloc for the address from which the register is          being loaded.  This reloc will tell us which function is          actually being called.  */
for|for
control|(
name|irelfn
operator|=
name|internal_relocs
init|;
name|irelfn
operator|<
name|irelend
condition|;
name|irelfn
operator|++
control|)
if|if
condition|(
name|irelfn
operator|->
name|r_offset
operator|==
name|paddr
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_DIR32
condition|)
break|break;
if|if
condition|(
name|irelfn
operator|>=
name|irelend
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: could not find expected reloc"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Read the local symbols.  */
if|if
condition|(
name|extsyms
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|symtab_hdr
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|extsyms
operator|=
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
else|else
block|{
name|extsyms
operator|=
operator|(
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extsyms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_extsyms
operator|=
name|extsyms
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|extsyms
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf_Internal_Sym
name|isym
decl_stmt|;
comment|/* A local symbol.  */
name|bfd_elf32_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|extsyms
operator|+
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
argument_list|,
operator|&
name|isym
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|!=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: symbol in unexpected section"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
name|symval
operator|=
operator|(
name|isym
operator|.
name|st_value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This appears to be a reference to an undefined                  symbol.  Just ignore it--it will be caught by the                  regular reloc processing.  */
continue|continue;
block|}
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
name|symval
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|paddr
argument_list|)
expr_stmt|;
comment|/* See if this function call can be shortened.  */
name|foff
operator|=
operator|(
name|symval
operator|-
operator|(
name|irel
operator|->
name|r_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|foff
operator|<
operator|-
literal|0x1000
operator|||
name|foff
operator|>=
literal|0x1000
condition|)
block|{
comment|/* After all that work, we can't shorten this function call.  */
continue|continue;
block|}
comment|/* Shorten the function call.  */
comment|/* For simplicity of coding, we are going to modify the section 	 contents, the section relocs, and the BFD symbol table.  We 	 must tell the rest of the code not to free up this 	 information.  It would be possible to instead create a table 	 of changes which have to be made, as is done in coff-mips.c; 	 that would be more work, but would require less memory when 	 the linker is run.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|extsyms
expr_stmt|;
name|free_extsyms
operator|=
name|NULL
expr_stmt|;
comment|/* Replace the jsr with a bsr.  */
comment|/* Change the R_SH_USES reloc into an R_SH_IND12W reloc, and          replace the jsr with a bsr.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_SH_IND12W
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* If this needs to be changed because of future relaxing,              it will be handled here like other internal IND12W              relocs.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
literal|0xb000
operator||
operator|(
operator|(
name|foff
operator|>>
literal|1
operator|)
operator|&
literal|0xfff
operator|)
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't fully resolve this yet, because the external              symbol value may be changed by future relaxing.  We let              the final link phase handle it.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
literal|0xb000
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
comment|/* See if there is another R_SH_USES reloc referring to the same          register load.  */
for|for
control|(
name|irelscan
operator|=
name|internal_relocs
init|;
name|irelscan
operator|<
name|irelend
condition|;
name|irelscan
operator|++
control|)
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irelscan
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_USES
operator|&&
name|laddr
operator|==
name|irelscan
operator|->
name|r_offset
operator|+
literal|4
operator|+
name|irelscan
operator|->
name|r_addend
condition|)
break|break;
if|if
condition|(
name|irelscan
operator|<
name|irelend
condition|)
block|{
comment|/* Some other function call depends upon this register load, 	     and we have not yet converted that function call. 	     Indeed, we may never be able to convert it.  There is 	     nothing else we can do at this point.  */
continue|continue;
block|}
comment|/* Look for a R_SH_COUNT reloc on the location where the          function address is stored.  Do this before deleting any          bytes, to avoid confusion about the address.  */
for|for
control|(
name|irelcount
operator|=
name|internal_relocs
init|;
name|irelcount
operator|<
name|irelend
condition|;
name|irelcount
operator|++
control|)
if|if
condition|(
name|irelcount
operator|->
name|r_offset
operator|==
name|paddr
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irelcount
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_COUNT
condition|)
break|break;
comment|/* Delete the register load.  */
if|if
condition|(
operator|!
name|sh_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|laddr
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, just in case it permits some          other function call to come within range, we should relax          again.  Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|true
expr_stmt|;
comment|/* Now check whether we got a COUNT reloc.  */
if|if
condition|(
name|irelcount
operator|>=
name|irelend
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: could not find expected COUNT reloc"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* The number of uses is stored in the r_addend field.  We've          just deleted one.  */
if|if
condition|(
name|irelcount
operator|->
name|r_addend
operator|==
literal|0
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: bad count"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
operator|--
name|irelcount
operator|->
name|r_addend
expr_stmt|;
comment|/* If there are no more uses, we can delete the address.  Reload          the address from irelfn, in case it was changed by the          previous call to sh_elf_relax_delete_bytes.  */
if|if
condition|(
name|irelcount
operator|->
name|r_addend
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sh_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irelfn
operator|->
name|r_offset
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* We've done all we can with that function call.  */
block|}
comment|/* Look for load and store instructions that we can align on four      byte boundaries.  */
if|if
condition|(
name|have_code
condition|)
block|{
name|boolean
name|swapped
decl_stmt|;
comment|/* Get the section contents.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|sh_elf_align_loads
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|internal_relocs
argument_list|,
name|contents
argument_list|,
operator|&
name|swapped
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|swapped
condition|)
block|{
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|extsyms
expr_stmt|;
name|free_extsyms
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
name|free_contents
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
name|extsyms
expr_stmt|;
block|}
name|free_extsyms
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  FIXME: There is a    lot of duplication between this function and sh_relax_delete_bytes    in coff-sh.c.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_relax_delete_bytes
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|extsyms
decl_stmt|;
name|int
name|shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|esym
decl_stmt|,
modifier|*
name|esymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|,
modifier|*
modifier|*
name|sym_hash_end
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|extsyms
operator|=
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_ALIGN
operator|&&
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|count
operator|<
operator|(
literal|1
operator|<<
name|irel
operator|->
name|r_addend
operator|)
condition|)
block|{
name|irelalign
operator|=
name|irel
expr_stmt|;
name|toaddr
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
break|break;
block|}
block|}
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|irelalign
operator|==
name|NULL
condition|)
name|sec
operator|->
name|_cooked_size
operator|-=
name|count
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|NOP_OPCODE
value|(0x0009)
name|BFD_ASSERT
argument_list|(
operator|(
name|count
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|+=
literal|2
control|)
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|NOP_OPCODE
argument_list|,
name|contents
operator|+
name|toaddr
operator|-
name|count
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|nraddr
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|int
name|insn
init|=
literal|0
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|int
name|off
decl_stmt|,
name|adjust
decl_stmt|,
name|oinsn
decl_stmt|;
name|bfd_signed_vma
name|voff
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
comment|/* Get the new reloc address.  */
name|nraddr
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
operator|||
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_ALIGN
operator|&&
name|irel
operator|->
name|r_offset
operator|==
name|toaddr
operator|)
condition|)
name|nraddr
operator|-=
name|count
expr_stmt|;
comment|/* See if this reloc was for the bytes we have deleted, in which 	 case we no longer care about it.  Don't delete relocs which 	 represent addresses, though.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|>=
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|addr
operator|+
name|count
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_ALIGN
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_CODE
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_DATA
condition|)
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|R_SH_NONE
argument_list|)
expr_stmt|;
comment|/* If this is a PC relative reloc, see if the range it covers          includes the bytes we have deleted.  */
switch|switch
condition|(
operator|(
expr|enum
name|sh_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|R_SH_DIR8WPN
case|:
case|case
name|R_SH_IND12W
case|:
case|case
name|R_SH_DIR8WPZ
case|:
case|case
name|R_SH_DIR8WPL
case|:
name|start
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|(
expr|enum
name|sh_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|R_SH_DIR32
case|:
comment|/* If this reloc is against a symbol defined in this              section, and the symbol will not be adjusted below, we              must check the addend to see it will put the value in              range to be adjusted, and hence must be changed.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|bfd_elf32_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|extsyms
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|shndx
operator|&&
operator|(
name|sym
operator|.
name|st_value
operator|<=
name|addr
operator|||
name|sym
operator|.
name|st_value
operator|>=
name|toaddr
operator|)
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
name|val
operator|+=
name|sym
operator|.
name|st_value
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|addr
operator|&&
name|val
operator|<
name|toaddr
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
operator|-
name|count
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
block|}
block|}
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPN
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|0x80
condition|)
name|off
operator|-=
literal|0x100
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_IND12W
case|:
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
else|else
block|{
name|off
operator|=
name|insn
operator|&
literal|0xfff
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|0x800
condition|)
name|off
operator|-=
literal|0x1000
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_SH_DIR8WPZ
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|stop
operator|=
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPL
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|stop
operator|=
operator|(
name|start
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
operator|)
operator|+
literal|4
operator|+
name|off
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH16
case|:
case|case
name|R_SH_SWITCH32
case|:
comment|/* These relocs types represent 	       .word L2-L1 	     The r_offset field holds the difference between the reloc 	     address and L1.  That is the start of the reloc, and 	     adding in the contents gives us the top.  We must adjust 	     both the r_offset field and the section contents.  */
name|start
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|-
operator|(
name|long
operator|)
name|irel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
operator|&&
operator|(
name|stop
operator|<=
name|addr
operator|||
name|stop
operator|>=
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_addend
operator|+=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|stop
operator|>
name|addr
operator|&&
name|stop
operator|<
name|toaddr
operator|&&
operator|(
name|start
operator|<=
name|addr
operator|||
name|start
operator|>=
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_addend
operator|-=
name|count
expr_stmt|;
name|start
operator|=
name|stop
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_SWITCH16
condition|)
name|voff
operator|=
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
else|else
name|voff
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
name|voff
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_USES
case|:
name|start
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
operator|(
name|long
operator|)
name|irel
operator|->
name|r_addend
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
operator|&&
operator|(
name|stop
operator|<=
name|addr
operator|||
name|stop
operator|>=
name|toaddr
operator|)
condition|)
name|adjust
operator|=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|stop
operator|>
name|addr
operator|&&
name|stop
operator|<
name|toaddr
operator|&&
operator|(
name|start
operator|<=
name|addr
operator|||
name|start
operator|>=
name|toaddr
operator|)
condition|)
name|adjust
operator|=
operator|-
name|count
expr_stmt|;
else|else
name|adjust
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
block|{
name|oinsn
operator|=
name|insn
expr_stmt|;
name|overflow
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
operator|(
expr|enum
name|sh_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPN
case|:
case|case
name|R_SH_DIR8WPZ
case|:
name|insn
operator|+=
name|adjust
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_IND12W
case|:
name|insn
operator|+=
name|adjust
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xf000
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPL
case|:
name|BFD_ASSERT
argument_list|(
name|adjust
operator|==
name|count
operator|||
name|count
operator|>=
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|4
condition|)
name|insn
operator|+=
name|adjust
operator|/
literal|4
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
operator|++
name|insn
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH16
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
if|if
condition|(
name|voff
operator|<
operator|-
literal|0x8000
operator|||
name|voff
operator|>=
literal|0x8000
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_signed_16
argument_list|(
name|abfd
argument_list|,
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH32
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
name|bfd_put_signed_32
argument_list|(
name|abfd
argument_list|,
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_USES
case|:
name|irel
operator|->
name|r_addend
operator|+=
name|adjust
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|overflow
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: fatal: reloc overflow while relaxing"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|irel
operator|->
name|r_offset
operator|=
name|nraddr
expr_stmt|;
block|}
comment|/* Look through all the other sections.  If there contain any IMM32      relocs against internal symbols which we are not going to adjust      below, we may need to adjust the addends.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelscan
decl_stmt|,
modifier|*
name|irelscanend
decl_stmt|;
name|bfd_byte
modifier|*
name|ocontents
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|sec
operator|||
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* We always cache the relocs.  Perhaps, if info->keep_memory is          false, we should free them, if we are permitted to, when we          leave sh_coff_relax_section.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf32_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|ocontents
operator|=
name|NULL
expr_stmt|;
name|irelscanend
operator|=
name|internal_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irelscan
operator|=
name|internal_relocs
init|;
name|irelscan
operator|<
name|irelscanend
condition|;
name|irelscan
operator|++
control|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irelscan
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_DIR32
condition|)
continue|continue;
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irelscan
operator|->
name|r_info
argument_list|)
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
continue|continue;
name|bfd_elf32_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|extsyms
operator|+
name|ELF32_R_SYM
argument_list|(
name|irelscan
operator|->
name|r_info
argument_list|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|shndx
operator|&&
operator|(
name|sym
operator|.
name|st_value
operator|<=
name|addr
operator|||
name|sym
operator|.
name|st_value
operator|>=
name|toaddr
operator|)
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|ocontents
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* We always cache the section contents.                          Perhaps, if info->keep_memory is false, we                          should free them, if we are permitted to,                          when we leave sh_coff_relax_section.  */
name|ocontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|o
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|ocontents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|ocontents
expr_stmt|;
block|}
block|}
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|val
operator|+=
name|sym
operator|.
name|st_value
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|addr
operator|&&
name|val
operator|<
name|toaddr
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
operator|-
name|count
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Adjust all the symbols.  */
name|esym
operator|=
name|extsyms
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
init|;
name|esym
operator|<
name|esymend
condition|;
name|esym
operator|++
control|)
block|{
name|Elf_Internal_Sym
name|isym
decl_stmt|;
name|bfd_elf32_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
operator|&
name|isym
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|==
name|shndx
operator|&&
name|isym
operator|.
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|.
name|st_value
operator|<
name|toaddr
condition|)
block|{
name|isym
operator|.
name|st_value
operator|-=
name|count
expr_stmt|;
name|bfd_elf32_swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|isym
argument_list|,
name|esym
argument_list|)
expr_stmt|;
block|}
block|}
name|sym_hash
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hash_end
operator|=
operator|(
name|sym_hash
operator|+
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|sym_hash
operator|<
name|sym_hash_end
condition|;
name|sym_hash
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
block|{
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/* See if we can move the ALIGN reloc forward.  We have adjusted      r_offset for it already.  */
if|if
condition|(
name|irelalign
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|alignto
decl_stmt|,
name|alignaddr
decl_stmt|;
name|alignto
operator|=
name|BFD_ALIGN
argument_list|(
name|toaddr
argument_list|,
literal|1
operator|<<
name|irelalign
operator|->
name|r_addend
argument_list|)
expr_stmt|;
name|alignaddr
operator|=
name|BFD_ALIGN
argument_list|(
name|irelalign
operator|->
name|r_offset
argument_list|,
literal|1
operator|<<
name|irelalign
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignto
operator|!=
name|alignaddr
condition|)
block|{
comment|/* Tail recursion.  */
return|return
name|sh_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|alignaddr
argument_list|,
name|alignto
operator|-
name|alignaddr
argument_list|)
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Look for loads and stores which we can align to four byte    boundaries.  This is like sh_align_loads in coff-sh.c.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_align_loads
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|internal_relocs
parameter_list|,
name|contents
parameter_list|,
name|pswapped
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|boolean
modifier|*
name|pswapped
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_vma
modifier|*
name|labels
init|=
name|NULL
decl_stmt|;
name|bfd_vma
modifier|*
name|label
decl_stmt|,
modifier|*
name|label_end
decl_stmt|;
operator|*
name|pswapped
operator|=
name|false
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Get all the addresses with labels on them.  */
name|labels
operator|=
operator|(
name|bfd_vma
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|label_end
operator|=
name|labels
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_LABEL
condition|)
block|{
operator|*
name|label_end
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
operator|++
name|label_end
expr_stmt|;
block|}
block|}
comment|/* Note that the assembler currently always outputs relocs in      address order.  If that ever changes, this code will need to sort      the label values and the relocs.  */
name|label
operator|=
name|labels
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|start
decl_stmt|,
name|stop
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_CODE
condition|)
continue|continue;
name|start
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
for|for
control|(
name|irel
operator|++
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_DATA
condition|)
break|break;
if|if
condition|(
name|irel
operator|<
name|irelend
condition|)
name|stop
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
else|else
name|stop
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_sh_align_load_span
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|sh_elf_swap_insns
argument_list|,
operator|(
name|PTR
operator|)
name|internal_relocs
argument_list|,
operator|&
name|label
argument_list|,
name|label_end
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|pswapped
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|labels
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|labels
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|labels
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Swap two SH instructions.  This is like sh_swap_insns in coff-sh.c.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_swap_insns
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|,
name|contents
parameter_list|,
name|addr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|relocs
decl_stmt|;
name|unsigned
name|short
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
comment|/* Swap the instructions themselves.  */
name|i1
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
name|i2
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|i2
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|i1
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Adjust all reloc addresses.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|enum
name|sh_reloc_type
name|type
decl_stmt|;
name|int
name|add
decl_stmt|;
comment|/* There are a few special types of relocs that we don't want to          adjust.  These relocs do not apply to the instruction itself,          but are only associated with the address.  */
name|type
operator|=
operator|(
expr|enum
name|sh_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|R_SH_ALIGN
operator|||
name|type
operator|==
name|R_SH_CODE
operator|||
name|type
operator|==
name|R_SH_DATA
operator|||
name|type
operator|==
name|R_SH_LABEL
condition|)
continue|continue;
comment|/* If an R_SH_USES reloc points to one of the addresses being          swapped, we must adjust it.  It would be incorrect to do this          for a jump, though, since we want to execute both          instructions after the jump.  (We have avoided swapping          around a label, so the jump will not wind up executing an          instruction it shouldn't).  */
if|if
condition|(
name|type
operator|==
name|R_SH_USES
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
name|irel
operator|->
name|r_offset
operator|+
literal|4
operator|+
name|irel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|addr
condition|)
name|irel
operator|->
name|r_offset
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|off
operator|==
name|addr
operator|+
literal|2
condition|)
name|irel
operator|->
name|r_offset
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|addr
condition|)
block|{
name|irel
operator|->
name|r_offset
operator|+=
literal|2
expr_stmt|;
name|add
operator|=
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|addr
operator|+
literal|2
condition|)
block|{
name|irel
operator|->
name|r_offset
operator|-=
literal|2
expr_stmt|;
name|add
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|add
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|add
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|short
name|insn
decl_stmt|,
name|oinsn
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
name|loc
operator|=
name|contents
operator|+
name|irel
operator|->
name|r_offset
expr_stmt|;
name|overflow
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|R_SH_DIR8WPN
case|:
case|case
name|R_SH_DIR8WPZ
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|oinsn
operator|=
name|insn
expr_stmt|;
name|insn
operator|+=
name|add
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_IND12W
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|oinsn
operator|=
name|insn
expr_stmt|;
name|insn
operator|+=
name|add
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xf000
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPL
case|:
comment|/* This reloc ignores the least significant 3 bits of                  the program counter before adding in the offset.                  This means that if ADDR is at an even address, the                  swap will not affect the offset.  If ADDR is an at an                  odd address, then the instruction will be crossing a                  four byte boundary, and must be adjusted.  */
if|if
condition|(
operator|(
name|addr
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|oinsn
operator|=
name|insn
expr_stmt|;
name|insn
operator|+=
name|add
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|overflow
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: fatal: reloc overflow while relaxing"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an SH ELF section.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change              anything, unless the reloc is against a section symbol,              in which case we have to adjust according to where the              section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
continue|continue;
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Many of the relocs are only used for relaxing, and are          handled entirely by the relaxation code.  */
if|if
condition|(
name|r_type
operator|>
operator|(
name|int
operator|)
name|LAST_INVALID_RELOC
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|FIRST_INVALID_RELOC
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FIXME: This is certainly incorrect.  However, it is how the          COFF linker works.  */
if|if
condition|(
name|r_type
operator|!=
operator|(
name|int
operator|)
name|R_SH_DIR32
operator|&&
name|r_type
operator|!=
operator|(
name|int
operator|)
name|R_SH_IND12W
condition|)
continue|continue;
name|howto
operator|=
name|sh_elf_howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* There is nothing to be done for an internal IND12W              relocation.  FIXME: This is probably wrong, but it's how              the COFF relocations work.  */
if|if
condition|(
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_SH_IND12W
condition|)
continue|continue;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* FIXME: This is how the COFF relocations work.  */
if|if
condition|(
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_SH_IND12W
condition|)
name|relocation
operator|-=
literal|4
expr_stmt|;
comment|/* FIXME: We should use the addend, but the COFF relocations          don't.  */
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses sh_elf_relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|sh_elf_get_relocated_section_contents
parameter_list|(
name|output_bfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|external_syms
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|internal_syms
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocateable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isymp
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|esym
decl_stmt|,
modifier|*
name|esymend
decl_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|external_syms
operator|=
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
else|else
block|{
name|external_syms
operator|=
operator|(
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|external_syms
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|>
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|external_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
name|input_bfd
argument_list|)
operator|!=
operator|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
block|}
name|internal_relocs
operator|=
operator|(
name|_bfd_elf32_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|internal_syms
operator|=
operator|(
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_syms
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|>
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|>
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|isymp
operator|=
name|internal_syms
expr_stmt|;
name|secpp
operator|=
name|sections
expr_stmt|;
name|esym
operator|=
name|external_syms
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
init|;
name|esym
operator|<
name|esymend
condition|;
operator|++
name|esym
operator|,
operator|++
name|isymp
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
name|bfd_elf32_swap_symbol_in
argument_list|(
name|input_bfd
argument_list|,
name|esym
argument_list|,
name|isymp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymp
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isymp
operator|->
name|st_shndx
operator|>
literal|0
operator|&&
name|isymp
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isymp
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isymp
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isymp
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
block|{
comment|/* Who knows?  */
name|isec
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sh_elf_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|internal_syms
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
name|sections
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|internal_syms
argument_list|)
expr_stmt|;
name|internal_syms
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|external_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|external_syms
argument_list|)
expr_stmt|;
name|external_syms
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|internal_relocs
operator|!=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|external_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_sh_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-sh"
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_shl_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-shl"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_sh
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_SH
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|sh_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|sh_elf_info_to_howto
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|sh_elf_relax_section
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|sh_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|sh_elf_get_relocated_section_contents
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

