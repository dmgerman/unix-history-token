begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hitachi SH specific support for 32-bit ELF    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by Ian Lance Taylor, Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/sh.h"
end_include

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sh_elf_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sh_elf_ignore_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|sh_elf_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sh_elf_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_copy_private_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_merge_private_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_set_mach_from_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_relax_delete_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_align_loads
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_swap_insns
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|sh_elf_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sh_elf_copy_indirect_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_backend_data
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|sh_elf_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|sh_elf_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sh_elf_reloc_loop
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|sh_elf_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_elf_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_dynrelocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|readonly_dynrelocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|sh_elf_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
end_ifdef

begin_decl_stmt
specifier|inline
specifier|static
name|void
name|movi_shori_putval
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|long
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/libc.so.1"
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|sh_elf_howto_table
index|[]
init|=
block|{
comment|/* No relocation.  */
name|HOWTO
argument_list|(
name|R_SH_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit absolute relocation.  Setting partial_inplace to true and      src_mask to a non-zero value is similar to the COFF toolchain.  */
name|HOWTO
argument_list|(
name|R_SH_DIR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_SH_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_REL32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit PC relative branch divided by 2.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8WPN
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8WPN"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 12 bit PC relative branch divided by 2.  */
name|HOWTO
argument_list|(
name|R_SH_IND12W
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IND12W"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit unsigned PC relative divided by 4.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8WPL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8WPL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit unsigned PC relative divided by 2.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8WPZ
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8WPZ"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit GBR relative.  FIXME: This only makes sense if we have some      special symbol for the GBR relative area, and that is not      implemented.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8BP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8BP"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit GBR relative divided by 2.  FIXME: This only makes sense if      we have some special symbol for the GBR relative area, and that      is not implemented.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8W
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8W"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit GBR relative divided by 4.  FIXME: This only makes sense if      we have some special symbol for the GBR relative area, and that      is not implemented.  */
name|HOWTO
argument_list|(
name|R_SH_DIR8L
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR8L"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|10
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|11
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|12
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|13
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|15
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|16
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|17
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|18
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|19
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|20
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|21
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|22
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|23
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|24
argument_list|)
block|,
comment|/* The remaining relocs are a GNU extension used for relaxing.  The      final pass of the linker never needs to do anything with any of      these relocs.  Any required operations are handled by the      relaxation code.  */
comment|/* A 16 bit switch table entry.  This is generated for an expression      such as ``.word L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_SH_SWITCH16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SWITCH16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit switch table entry.  This is generated for an expression      such as ``.long L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_SH_SWITCH32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SWITCH32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Indicates a .uses pseudo-op.  The compiler will generate .uses      pseudo-ops when it finds a function call which can be relaxed.      The offset field holds the PC relative offset to the instruction      which loads the register used in the function call.  */
name|HOWTO
argument_list|(
name|R_SH_USES
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_USES"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler will generate this reloc for addresses referred to      by the register loads associated with USES relocs.  The offset      field holds the number of times the address is referenced in the      object file.  */
name|HOWTO
argument_list|(
name|R_SH_COUNT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_COUNT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Indicates an alignment statement.  The offset field is the power      of 2 to which subsequent portions of the object file must be      aligned.  */
name|HOWTO
argument_list|(
name|R_SH_ALIGN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_ALIGN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler will generate this reloc before a block of      instructions.  A section should be processed as assumining it      contains data, unless this reloc is seen.  */
name|HOWTO
argument_list|(
name|R_SH_CODE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_CODE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler will generate this reloc after a block of      instructions when it sees data that is not instructions.  */
name|HOWTO
argument_list|(
name|R_SH_DATA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DATA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler generates this reloc for each label within a block      of instructions.  This permits the linker to avoid swapping      instructions which are the targets of branches.  */
name|HOWTO
argument_list|(
name|R_SH_LABEL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_LABEL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit switch table entry.  This is generated for an expression      such as ``.word L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_SH_SWITCH8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SWITCH8"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy */
name|HOWTO
argument_list|(
name|R_SH_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_SH_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage */
name|HOWTO
argument_list|(
name|R_SH_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_SH_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
name|HOWTO
argument_list|(
name|R_SH_LOOP_START
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_LOOP_START"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
name|HOWTO
argument_list|(
name|R_SH_LOOP_END
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_LOOP_END"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|38
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|39
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|40
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|41
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|42
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|43
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|44
argument_list|)
block|,
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
comment|/* Used in SHLLI.L and SHLRI.L.  */
name|HOWTO
argument_list|(
name|R_SH_DIR5U
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|5
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR5U"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in SHARI, SHLLI et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR6U
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR6U"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in BxxI, LDHI.L et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR6S
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR6S"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in ADDI, ANDI et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR10S
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|10
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR10S"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in LD.UW, ST.W et al.	 */
name|HOWTO
argument_list|(
name|R_SH_DIR10SW
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|11
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR10SW"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in LD.L, FLD.S et al.	 */
name|HOWTO
argument_list|(
name|R_SH_DIR10SL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR10SL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in FLD.D, FST.P et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR10SQ
argument_list|,
comment|/* type */
literal|3
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR10SQ"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
else|#
directive|else
name|EMPTY_HOWTO
argument_list|(
literal|45
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|46
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|47
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|48
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|49
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|50
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|51
argument_list|)
block|,
endif|#
directive|endif
name|EMPTY_HOWTO
argument_list|(
literal|52
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|53
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|54
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|55
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|56
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|57
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|58
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|59
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|60
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|61
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|62
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|63
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|64
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|65
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|66
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|67
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|68
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|69
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|70
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|71
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|72
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|73
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|74
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|75
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|76
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|77
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|78
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|79
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|80
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|81
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|82
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|83
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|84
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|85
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|86
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|87
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|88
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|89
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|90
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|91
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|92
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|93
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|94
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|95
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|96
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|97
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|98
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|99
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|100
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|101
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|102
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|103
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|104
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|105
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|106
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|107
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|108
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|109
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|110
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|111
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|112
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|113
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|114
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|115
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|116
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|117
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|118
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|119
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|120
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|121
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|122
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|123
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|124
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|125
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|126
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|127
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|128
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|129
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|130
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|131
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|132
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|133
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|134
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|135
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|136
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|137
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|138
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|139
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|140
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|141
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|142
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|143
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|144
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|145
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|146
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|147
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|148
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|149
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|150
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|151
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|152
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|153
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|154
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|155
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|156
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|157
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|158
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|159
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SH_GOT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_SH_GOT32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_PLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_SH_PLT32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_SH_COPY"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_SH_GLOB_DAT"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_SH_JMP_SLOT"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_SH_RELATIVE"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_GOTOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_SH_GOTOFF"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_GOTPC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_SH_GOTPC"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_SH_GOTPLT32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOT_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT_LOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOT_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT_MEDLOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOT_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT_MEDHI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOT_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT_LOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT_MEDLOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT_MEDHI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_PLT_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PLT_LOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_PLT_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PLT_MEDLOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_PLT_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PLT_MEDHI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_PLT_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PLT_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTOFF_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTOFF_LOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTOFF_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTOFF_MEDLOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTOFF_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTOFF_MEDHI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTOFF_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTOFF_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPC_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPC_LOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPC_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPC_MEDLOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPC_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPC_MEDHI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPC_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPC_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in LD.L, FLD.S et al.	 */
name|HOWTO
argument_list|(
name|R_SH_GOT10BY4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT10BY4"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in LD.L, FLD.S et al.	 */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT10BY4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT10BY4"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in FLD.D, FST.P et al.  */
name|HOWTO
argument_list|(
name|R_SH_GOT10BY8
argument_list|,
comment|/* type */
literal|3
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT10BY8"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in FLD.D, FST.P et al.  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT10BY8
argument_list|,
comment|/* type */
literal|3
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT10BY8"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_COPY64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_COPY64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_GLOB_DAT64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GLOB_DAT64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_JMP_SLOT64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_JMP_SLOT64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_RELATIVE64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_RELATIVE64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|197
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|198
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|199
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|200
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|201
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|202
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|203
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|204
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|205
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|206
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|207
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|208
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|209
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|210
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|211
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|212
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|213
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|214
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|215
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|216
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|217
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|218
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|219
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|220
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|221
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|222
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|223
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|224
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|225
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|226
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|227
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|228
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|229
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|230
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|231
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|232
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|233
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|234
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|235
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|236
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|237
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|238
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|239
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|240
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|241
argument_list|)
block|,
comment|/* Relocations for SHmedia code.  None of these are partial_inplace or      use the field being relocated (except R_SH_PT_16).  */
comment|/* The assembler will generate this reloc before a block of SHmedia      instructions.  A section should be processed as assuming it contains      data, unless this reloc is seen.  Note that a block of SHcompact      instructions are instead preceded by R_SH_CODE.      This is currently not implemented, but should be used for SHmedia      linker relaxation.  */
name|HOWTO
argument_list|(
name|R_SH_SHMEDIA_CODE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SHMEDIA_CODE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler will generate this reloc at a PTA or PTB instruction,      and the linker checks the right type of target, or changes a PTA to a      PTB, if the original insn was PT.  */
name|HOWTO
argument_list|(
name|R_SH_PT_16
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|18
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PT_16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in unexpanded MOVI.  */
name|HOWTO
argument_list|(
name|R_SH_IMMS16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMMS16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in SHORI.  */
name|HOWTO
argument_list|(
name|R_SH_IMMU16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMMU16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_LOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x - $)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_LOW16_PCREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_LOW16_PCREL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_MEDLOW16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (((x - $)>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_MEDLOW16_PCREL
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_MEDLOW16_PCREL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_MEDHI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (((x - $)>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_MEDHI16_PCREL
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_MEDHI16_PCREL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (((x - $)>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_HI16_PCREL
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_HI16_PCREL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* For the .uaquad pseudo.  */
name|HOWTO
argument_list|(
name|R_SH_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* For the .uaquad pseudo, (x - $).  */
name|HOWTO
argument_list|(
name|R_SH_64_PCREL
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_64_PCREL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_status_type
name|sh_elf_reloc_loop
parameter_list|(
name|r_type
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|addr
parameter_list|,
name|symbol_section
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|int
name|r_type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|asection
modifier|*
name|symbol_section
decl_stmt|;
name|bfd_vma
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|static
name|bfd_vma
name|last_addr
decl_stmt|;
specifier|static
name|asection
modifier|*
name|last_symbol_section
decl_stmt|;
name|bfd_byte
modifier|*
name|start_ptr
decl_stmt|,
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|last_ptr
decl_stmt|;
name|int
name|diff
decl_stmt|,
name|cum_diff
decl_stmt|;
name|bfd_signed_vma
name|x
decl_stmt|;
name|int
name|insn
decl_stmt|;
comment|/* Sanity check the address.  */
if|if
condition|(
name|addr
operator|>
name|input_section
operator|->
name|_raw_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* We require the start and end relocations to be processed consecutively -      although we allow then to be processed forwards or backwards.  */
if|if
condition|(
operator|!
name|last_addr
condition|)
block|{
name|last_addr
operator|=
name|addr
expr_stmt|;
name|last_symbol_section
operator|=
name|symbol_section
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|last_addr
operator|!=
name|addr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|last_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|symbol_section
operator|||
name|last_symbol_section
operator|!=
name|symbol_section
operator|||
name|end
operator|<
name|start
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Get the symbol_section contents.  */
if|if
condition|(
name|symbol_section
operator|!=
name|input_section
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|symbol_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|symbol_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symbol_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|symbol_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|symbol_section
operator|->
name|_raw_size
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
block|}
block|}
define|#
directive|define
name|IS_PPI
parameter_list|(
name|PTR
parameter_list|)
value|((bfd_get_16 (input_bfd, (PTR))& 0xfc00) == 0xf800)
name|start_ptr
operator|=
name|contents
operator|+
name|start
expr_stmt|;
for|for
control|(
name|cum_diff
operator|=
operator|-
literal|6
operator|,
name|ptr
operator|=
name|contents
operator|+
name|end
init|;
name|cum_diff
operator|<
literal|0
operator|&&
name|ptr
operator|>
name|start_ptr
condition|;
control|)
block|{
for|for
control|(
name|last_ptr
operator|=
name|ptr
operator|,
name|ptr
operator|-=
literal|4
init|;
name|ptr
operator|>=
name|start_ptr
operator|&&
name|IS_PPI
argument_list|(
name|ptr
argument_list|)
condition|;
control|)
name|ptr
operator|-=
literal|2
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
name|diff
operator|=
operator|(
name|last_ptr
operator|-
name|ptr
operator|)
operator|>>
literal|1
expr_stmt|;
name|cum_diff
operator|+=
name|diff
operator|&
literal|1
expr_stmt|;
name|cum_diff
operator|+=
name|diff
expr_stmt|;
block|}
comment|/* Calculate the start / end values to load into rs / re minus four -      so that will cancel out the four we would otherwise have to add to      addr to get the value to subtract in order to get relative addressing.  */
if|if
condition|(
name|cum_diff
operator|>=
literal|0
condition|)
block|{
name|start
operator|-=
literal|4
expr_stmt|;
name|end
operator|=
operator|(
name|ptr
operator|+
name|cum_diff
operator|*
literal|2
operator|)
operator|-
name|contents
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|start0
init|=
name|start
operator|-
literal|4
decl_stmt|;
while|while
condition|(
name|start0
operator|&&
name|IS_PPI
argument_list|(
name|contents
operator|+
name|start0
argument_list|)
condition|)
name|start0
operator|-=
literal|2
expr_stmt|;
name|start0
operator|=
name|start
operator|-
literal|2
operator|-
operator|(
operator|(
name|start
operator|-
name|start0
operator|)
operator|&
literal|2
operator|)
expr_stmt|;
name|start
operator|=
name|start0
operator|-
name|cum_diff
operator|-
literal|2
expr_stmt|;
name|end
operator|=
name|start0
expr_stmt|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|symbol_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|insn
operator|&
literal|0x200
condition|?
name|end
else|:
name|start
operator|)
operator|-
name|addr
expr_stmt|;
if|if
condition|(
name|input_section
operator|!=
name|symbol_section
condition|)
name|x
operator|+=
operator|(
operator|(
name|symbol_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol_section
operator|->
name|output_offset
operator|)
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
operator|)
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|<
operator|-
literal|128
operator|||
name|x
operator|>
literal|127
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xff
operator|)
operator||
operator|(
name|x
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* This function is used for normal relocs.  This used to be like the COFF    function, and is almost certainly incorrect for other ELF targets.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sh_elf_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol_in
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|enum
name|elf_sh_reloc_type
name|r_type
decl_stmt|;
name|bfd_vma
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|addr
operator|+
operator|(
name|bfd_byte
operator|*
operator|)
name|data
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_sh_reloc_type
operator|)
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
comment|/* Partial linking--do nothing.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Almost all relocs have to do with relaxing.  If any work must be      done for them, it has been done in sh_relax_section.  */
if|if
condition|(
name|r_type
operator|==
name|R_SH_IND12W
operator|&&
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
condition|)
return|return
name|bfd_reloc_ok
return|;
if|if
condition|(
name|symbol_in
operator|!=
name|NULL
operator|&&
name|bfd_is_und_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
name|sym_value
operator|=
literal|0
expr_stmt|;
else|else
name|sym_value
operator|=
operator|(
name|symbol_in
operator|->
name|value
operator|+
name|symbol_in
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol_in
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SH_DIR32
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_IND12W
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|sym_value
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|sym_value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|addr
operator|+
literal|4
operator|)
expr_stmt|;
name|sym_value
operator|+=
operator|(
name|insn
operator|&
literal|0xfff
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|&
literal|0x800
condition|)
name|sym_value
operator|-=
literal|0x1000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
operator||
operator|(
name|sym_value
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_value
operator|<
operator|(
name|bfd_vma
operator|)
operator|-
literal|0x1000
operator|||
name|sym_value
operator|>=
literal|0x1000
condition|)
return|return
name|bfd_reloc_overflow
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* This function is used for relocs which are only used for relaxing,    which the linker should otherwise ignore.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sh_elf_ignore_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* This structure is used to map BFD reloc codes to SH ELF relocs.  */
end_comment

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An array mapping BFD reloc codes to SH ELF relocs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_reloc_map
name|sh_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_SH_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_SH_DIR32
block|}
block|,
block|{
name|BFD_RELOC_CTOR
block|,
name|R_SH_DIR32
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_SH_REL32
block|}
block|,
block|{
name|BFD_RELOC_SH_PCDISP8BY2
block|,
name|R_SH_DIR8WPN
block|}
block|,
block|{
name|BFD_RELOC_SH_PCDISP12BY2
block|,
name|R_SH_IND12W
block|}
block|,
block|{
name|BFD_RELOC_SH_PCRELIMM8BY2
block|,
name|R_SH_DIR8WPZ
block|}
block|,
block|{
name|BFD_RELOC_SH_PCRELIMM8BY4
block|,
name|R_SH_DIR8WPL
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_SH_SWITCH8
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH16
block|,
name|R_SH_SWITCH16
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH32
block|,
name|R_SH_SWITCH32
block|}
block|,
block|{
name|BFD_RELOC_SH_USES
block|,
name|R_SH_USES
block|}
block|,
block|{
name|BFD_RELOC_SH_COUNT
block|,
name|R_SH_COUNT
block|}
block|,
block|{
name|BFD_RELOC_SH_ALIGN
block|,
name|R_SH_ALIGN
block|}
block|,
block|{
name|BFD_RELOC_SH_CODE
block|,
name|R_SH_CODE
block|}
block|,
block|{
name|BFD_RELOC_SH_DATA
block|,
name|R_SH_DATA
block|}
block|,
block|{
name|BFD_RELOC_SH_LABEL
block|,
name|R_SH_LABEL
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_SH_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_SH_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_SH_LOOP_START
block|,
name|R_SH_LOOP_START
block|}
block|,
block|{
name|BFD_RELOC_SH_LOOP_END
block|,
name|R_SH_LOOP_END
block|}
block|,
block|{
name|BFD_RELOC_32_GOT_PCREL
block|,
name|R_SH_GOT32
block|}
block|,
block|{
name|BFD_RELOC_32_PLT_PCREL
block|,
name|R_SH_PLT32
block|}
block|,
block|{
name|BFD_RELOC_SH_COPY
block|,
name|R_SH_COPY
block|}
block|,
block|{
name|BFD_RELOC_SH_GLOB_DAT
block|,
name|R_SH_GLOB_DAT
block|}
block|,
block|{
name|BFD_RELOC_SH_JMP_SLOT
block|,
name|R_SH_JMP_SLOT
block|}
block|,
block|{
name|BFD_RELOC_SH_RELATIVE
block|,
name|R_SH_RELATIVE
block|}
block|,
block|{
name|BFD_RELOC_32_GOTOFF
block|,
name|R_SH_GOTOFF
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPC
block|,
name|R_SH_GOTPC
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT32
block|,
name|R_SH_GOTPLT32
block|}
block|,
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
block|{
name|BFD_RELOC_SH_GOT_LOW16
block|,
name|R_SH_GOT_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT_MEDLOW16
block|,
name|R_SH_GOT_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT_MEDHI16
block|,
name|R_SH_GOT_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT_HI16
block|,
name|R_SH_GOT_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT_LOW16
block|,
name|R_SH_GOTPLT_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT_MEDLOW16
block|,
name|R_SH_GOTPLT_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT_MEDHI16
block|,
name|R_SH_GOTPLT_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT_HI16
block|,
name|R_SH_GOTPLT_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_PLT_LOW16
block|,
name|R_SH_PLT_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_PLT_MEDLOW16
block|,
name|R_SH_PLT_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_PLT_MEDHI16
block|,
name|R_SH_PLT_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_PLT_HI16
block|,
name|R_SH_PLT_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTOFF_LOW16
block|,
name|R_SH_GOTOFF_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTOFF_MEDLOW16
block|,
name|R_SH_GOTOFF_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTOFF_MEDHI16
block|,
name|R_SH_GOTOFF_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTOFF_HI16
block|,
name|R_SH_GOTOFF_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPC_LOW16
block|,
name|R_SH_GOTPC_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPC_MEDLOW16
block|,
name|R_SH_GOTPC_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPC_MEDHI16
block|,
name|R_SH_GOTPC_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPC_HI16
block|,
name|R_SH_GOTPC_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_COPY64
block|,
name|R_SH_COPY64
block|}
block|,
block|{
name|BFD_RELOC_SH_GLOB_DAT64
block|,
name|R_SH_GLOB_DAT64
block|}
block|,
block|{
name|BFD_RELOC_SH_JMP_SLOT64
block|,
name|R_SH_JMP_SLOT64
block|}
block|,
block|{
name|BFD_RELOC_SH_RELATIVE64
block|,
name|R_SH_RELATIVE64
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT10BY4
block|,
name|R_SH_GOT10BY4
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT10BY8
block|,
name|R_SH_GOT10BY8
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT10BY4
block|,
name|R_SH_GOTPLT10BY4
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT10BY8
block|,
name|R_SH_GOTPLT10BY8
block|}
block|,
block|{
name|BFD_RELOC_SH_PT_16
block|,
name|R_SH_PT_16
block|}
block|,
block|{
name|BFD_RELOC_SH_SHMEDIA_CODE
block|,
name|R_SH_SHMEDIA_CODE
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMU5
block|,
name|R_SH_DIR5U
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS6
block|,
name|R_SH_DIR6S
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMU6
block|,
name|R_SH_DIR6U
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS10
block|,
name|R_SH_DIR10S
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS10BY2
block|,
name|R_SH_DIR10SW
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS10BY4
block|,
name|R_SH_DIR10SL
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS10BY8
block|,
name|R_SH_DIR10SQ
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS16
block|,
name|R_SH_IMMS16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMU16
block|,
name|R_SH_IMMU16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_LOW16
block|,
name|R_SH_IMM_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_LOW16_PCREL
block|,
name|R_SH_IMM_LOW16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_MEDLOW16
block|,
name|R_SH_IMM_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
block|,
name|R_SH_IMM_MEDLOW16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_MEDHI16
block|,
name|R_SH_IMM_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
block|,
name|R_SH_IMM_MEDHI16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_HI16
block|,
name|R_SH_IMM_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_HI16_PCREL
block|,
name|R_SH_IMM_HI16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_64
block|,
name|R_SH_64
block|}
block|,
block|{
name|BFD_RELOC_64_PCREL
block|,
name|R_SH_64_PCREL
block|}
block|,
endif|#
directive|endif
comment|/* not INCLUDE_SHMEDIA */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a BFD reloc code, return the howto structure for the    corresponding SH ELf reloc.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|sh_elf_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sh_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sh_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|sh_elf_howto_table
index|[
operator|(
name|int
operator|)
name|sh_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given an ELF reloc, fill in the howto field of a relent.  */
end_comment

begin_function
specifier|static
name|void
name|sh_elf_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r
decl_stmt|;
name|r
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_SH_max
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
name|R_SH_FIRST_INVALID_RELOC
operator|||
name|r
operator|>
name|R_SH_LAST_INVALID_RELOC
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
name|R_SH_FIRST_INVALID_RELOC_2
operator|||
name|r
operator|>
name|R_SH_LAST_INVALID_RELOC_2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
name|R_SH_FIRST_INVALID_RELOC_3
operator|||
name|r
operator|>
name|R_SH_LAST_INVALID_RELOC_3
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
name|R_SH_FIRST_INVALID_RELOC_4
operator|||
name|r
operator|>
name|R_SH_LAST_INVALID_RELOC_4
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|sh_elf_howto_table
index|[
name|r
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function handles relaxing for SH ELF.  See the corresponding    function in coff-sh.c for a description of what this does.  FIXME:    There is a lot of duplication here between this code and the COFF    specific code.  The format of relocs and symbols is wound deeply    into this code, but it would still be better if the duplication    could be eliminated somehow.  Note in particular that although both    functions use symbols like R_SH_CODE, those symbols have different    values; in coff-sh.c they come from include/coff/sh.h, whereas here    they come from enum elf_sh_reloc_type in include/elf/sh.h.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|boolean
name|have_code
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
operator|*
name|again
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|relocateable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator|&
operator|(
name|SHF_SH5_ISA32
operator||
name|SHF_SH5_ISA32_MIXED
operator|)
condition|)
block|{
return|return
name|true
return|;
block|}
endif|#
directive|endif
comment|/* If this is the first time we have been called for this section,      initialize the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_elf32_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|have_code
operator|=
name|false
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|laddr
decl_stmt|,
name|paddr
decl_stmt|,
name|symval
decl_stmt|;
name|unsigned
name|short
name|insn
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelfn
decl_stmt|,
modifier|*
name|irelscan
decl_stmt|,
modifier|*
name|irelcount
decl_stmt|;
name|bfd_signed_vma
name|foff
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_CODE
condition|)
name|have_code
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_USES
condition|)
continue|continue;
comment|/* Get the section contents.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* The r_addend field of the R_SH_USES reloc will point us to 	 the register load.  The 4 is because the r_addend field is 	 computed as though it were a jump offset, which are based 	 from 4 bytes after the jump instruction.  */
name|laddr
operator|=
name|irel
operator|->
name|r_offset
operator|+
literal|4
operator|+
name|irel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|laddr
operator|>=
name|sec
operator|->
name|_raw_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: warning: bad R_SH_USES offset"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|laddr
argument_list|)
expr_stmt|;
comment|/* If the instruction is not mov.l NN,rN, we don't know what to 	 do.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xf000
operator|)
operator|!=
literal|0xd000
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|,
name|insn
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the address from which the register is being loaded.  The 	 displacement in the mov.l instruction is quadrupled.  It is a 	 displacement from four bytes after the movl instruction, but, 	 before adding in the PC address, two least significant bits 	 of the PC are cleared.  We assume that the section is aligned 	 on a four byte boundary.  */
name|paddr
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|paddr
operator|*=
literal|4
expr_stmt|;
name|paddr
operator|+=
operator|(
name|laddr
operator|+
literal|4
operator|)
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
expr_stmt|;
if|if
condition|(
name|paddr
operator|>=
name|sec
operator|->
name|_raw_size
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: warning: bad R_SH_USES load offset"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the reloc for the address from which the register is 	 being loaded.  This reloc will tell us which function is 	 actually being called.  */
for|for
control|(
name|irelfn
operator|=
name|internal_relocs
init|;
name|irelfn
operator|<
name|irelend
condition|;
name|irelfn
operator|++
control|)
if|if
condition|(
name|irelfn
operator|->
name|r_offset
operator|==
name|paddr
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_DIR32
condition|)
break|break;
if|if
condition|(
name|irelfn
operator|>=
name|irelend
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: warning: could not find expected reloc"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Read this BFD's symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: warning: symbol in unexpected section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
name|symval
operator|=
operator|(
name|isym
operator|->
name|st_value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This appears to be a reference to an undefined 		 symbol.  Just ignore it--it will be caught by the 		 regular reloc processing.  */
continue|continue;
block|}
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
name|symval
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|paddr
argument_list|)
expr_stmt|;
comment|/* See if this function call can be shortened.  */
name|foff
operator|=
operator|(
name|symval
operator|-
operator|(
name|irel
operator|->
name|r_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|foff
operator|<
operator|-
literal|0x1000
operator|||
name|foff
operator|>=
literal|0x1000
condition|)
block|{
comment|/* After all that work, we can't shorten this function call.  */
continue|continue;
block|}
comment|/* Shorten the function call.  */
comment|/* For simplicity of coding, we are going to modify the section 	 contents, the section relocs, and the BFD symbol table.  We 	 must tell the rest of the code not to free up this 	 information.  It would be possible to instead create a table 	 of changes which have to be made, as is done in coff-mips.c; 	 that would be more work, but would require less memory when 	 the linker is run.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Replace the jsr with a bsr.  */
comment|/* Change the R_SH_USES reloc into an R_SH_IND12W reloc, and 	 replace the jsr with a bsr.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_SH_IND12W
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irelfn
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* If this needs to be changed because of future relaxing, 	     it will be handled here like other internal IND12W 	     relocs.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0xb000
operator||
operator|(
operator|(
name|foff
operator|>>
literal|1
operator|)
operator|&
literal|0xfff
operator|)
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't fully resolve this yet, because the external 	     symbol value may be changed by future relaxing.  We let 	     the final link phase handle it.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0xb000
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
comment|/* See if there is another R_SH_USES reloc referring to the same 	 register load.  */
for|for
control|(
name|irelscan
operator|=
name|internal_relocs
init|;
name|irelscan
operator|<
name|irelend
condition|;
name|irelscan
operator|++
control|)
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irelscan
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_USES
operator|&&
name|laddr
operator|==
name|irelscan
operator|->
name|r_offset
operator|+
literal|4
operator|+
name|irelscan
operator|->
name|r_addend
condition|)
break|break;
if|if
condition|(
name|irelscan
operator|<
name|irelend
condition|)
block|{
comment|/* Some other function call depends upon this register load, 	     and we have not yet converted that function call. 	     Indeed, we may never be able to convert it.  There is 	     nothing else we can do at this point.  */
continue|continue;
block|}
comment|/* Look for a R_SH_COUNT reloc on the location where the 	 function address is stored.  Do this before deleting any 	 bytes, to avoid confusion about the address.  */
for|for
control|(
name|irelcount
operator|=
name|internal_relocs
init|;
name|irelcount
operator|<
name|irelend
condition|;
name|irelcount
operator|++
control|)
if|if
condition|(
name|irelcount
operator|->
name|r_offset
operator|==
name|paddr
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irelcount
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_COUNT
condition|)
break|break;
comment|/* Delete the register load.  */
if|if
condition|(
operator|!
name|sh_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|laddr
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, just in case it permits some 	 other function call to come within range, we should relax 	 again.  Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|true
expr_stmt|;
comment|/* Now check whether we got a COUNT reloc.  */
if|if
condition|(
name|irelcount
operator|>=
name|irelend
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: warning: could not find expected COUNT reloc"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* The number of uses is stored in the r_addend field.  We've 	 just deleted one.  */
if|if
condition|(
name|irelcount
operator|->
name|r_addend
operator|==
literal|0
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: warning: bad count"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
operator|--
name|irelcount
operator|->
name|r_addend
expr_stmt|;
comment|/* If there are no more uses, we can delete the address.  Reload 	 the address from irelfn, in case it was changed by the 	 previous call to sh_elf_relax_delete_bytes.  */
if|if
condition|(
name|irelcount
operator|->
name|r_addend
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sh_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irelfn
operator|->
name|r_offset
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* We've done all we can with that function call.  */
block|}
comment|/* Look for load and store instructions that we can align on four      byte boundaries.  */
if|if
condition|(
name|have_code
condition|)
block|{
name|boolean
name|swapped
decl_stmt|;
comment|/* Get the section contents.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|sh_elf_align_loads
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|internal_relocs
argument_list|,
name|contents
argument_list|,
operator|&
name|swapped
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|swapped
condition|)
block|{
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  FIXME: There is a    lot of duplication between this function and sh_relax_delete_bytes    in coff-sh.c.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_relax_delete_bytes
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|,
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_ALIGN
operator|&&
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|count
operator|<
operator|(
literal|1
operator|<<
name|irel
operator|->
name|r_addend
operator|)
condition|)
block|{
name|irelalign
operator|=
name|irel
expr_stmt|;
name|toaddr
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
break|break;
block|}
block|}
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|irelalign
operator|==
name|NULL
condition|)
name|sec
operator|->
name|_cooked_size
operator|-=
name|count
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|NOP_OPCODE
value|(0x0009)
name|BFD_ASSERT
argument_list|(
operator|(
name|count
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|+=
literal|2
control|)
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|NOP_OPCODE
argument_list|,
name|contents
operator|+
name|toaddr
operator|-
name|count
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|nraddr
decl_stmt|,
name|stop
decl_stmt|;
name|bfd_vma
name|start
init|=
literal|0
decl_stmt|;
name|int
name|insn
init|=
literal|0
decl_stmt|;
name|int
name|off
decl_stmt|,
name|adjust
decl_stmt|,
name|oinsn
decl_stmt|;
name|bfd_signed_vma
name|voff
init|=
literal|0
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
comment|/* Get the new reloc address.  */
name|nraddr
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
operator|||
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_ALIGN
operator|&&
name|irel
operator|->
name|r_offset
operator|==
name|toaddr
operator|)
condition|)
name|nraddr
operator|-=
name|count
expr_stmt|;
comment|/* See if this reloc was for the bytes we have deleted, in which 	 case we no longer care about it.  Don't delete relocs which 	 represent addresses, though.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|>=
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|addr
operator|+
name|count
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_ALIGN
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_CODE
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_DATA
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_LABEL
condition|)
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|R_SH_NONE
argument_list|)
expr_stmt|;
comment|/* If this is a PC relative reloc, see if the range it covers 	 includes the bytes we have deleted.  */
switch|switch
condition|(
operator|(
expr|enum
name|elf_sh_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|R_SH_DIR8WPN
case|:
case|case
name|R_SH_IND12W
case|:
case|case
name|R_SH_DIR8WPZ
case|:
case|case
name|R_SH_DIR8WPL
case|:
name|start
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|(
expr|enum
name|elf_sh_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|R_SH_DIR32
case|:
comment|/* If this reloc is against a symbol defined in this 	     section, and the symbol will not be adjusted below, we 	     must check the addend to see it will put the value in 	     range to be adjusted, and hence must be changed.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
operator|(
name|isym
operator|->
name|st_value
operator|<=
name|addr
operator|||
name|isym
operator|->
name|st_value
operator|>=
name|toaddr
operator|)
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
name|val
operator|+=
name|isym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|addr
operator|&&
name|val
operator|<
name|toaddr
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
operator|-
name|count
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
block|}
block|}
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPN
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|0x80
condition|)
name|off
operator|-=
literal|0x100
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_IND12W
case|:
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
else|else
block|{
name|off
operator|=
name|insn
operator|&
literal|0xfff
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|0x800
condition|)
name|off
operator|-=
literal|0x1000
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_SH_DIR8WPZ
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|stop
operator|=
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPL
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|stop
operator|=
operator|(
name|start
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
operator|)
operator|+
literal|4
operator|+
name|off
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH8
case|:
case|case
name|R_SH_SWITCH16
case|:
case|case
name|R_SH_SWITCH32
case|:
comment|/* These relocs types represent 	       .word L2-L1 	     The r_addend field holds the difference between the reloc 	     address and L1.  That is the start of the reloc, and 	     adding in the contents gives us the top.  We must adjust 	     both the r_offset field and the section contents. 	     N.B. in gas / coff bfd, the elf bfd r_addend is called r_offset, 	     and the elf bfd r_offset is called r_vaddr.  */
name|stop
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|start
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|stop
operator|-
operator|(
name|long
operator|)
name|irel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
operator|&&
operator|(
name|stop
operator|<=
name|addr
operator|||
name|stop
operator|>=
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_addend
operator|+=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|stop
operator|>
name|addr
operator|&&
name|stop
operator|<
name|toaddr
operator|&&
operator|(
name|start
operator|<=
name|addr
operator|||
name|start
operator|>=
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_addend
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_SWITCH16
condition|)
name|voff
operator|=
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_SWITCH8
condition|)
name|voff
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
else|else
name|voff
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
name|voff
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_USES
case|:
name|start
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
operator|(
name|long
operator|)
name|irel
operator|->
name|r_addend
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
operator|&&
operator|(
name|stop
operator|<=
name|addr
operator|||
name|stop
operator|>=
name|toaddr
operator|)
condition|)
name|adjust
operator|=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|stop
operator|>
name|addr
operator|&&
name|stop
operator|<
name|toaddr
operator|&&
operator|(
name|start
operator|<=
name|addr
operator|||
name|start
operator|>=
name|toaddr
operator|)
condition|)
name|adjust
operator|=
operator|-
name|count
expr_stmt|;
else|else
name|adjust
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
block|{
name|oinsn
operator|=
name|insn
expr_stmt|;
name|overflow
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
operator|(
expr|enum
name|elf_sh_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPN
case|:
case|case
name|R_SH_DIR8WPZ
case|:
name|insn
operator|+=
name|adjust
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_IND12W
case|:
name|insn
operator|+=
name|adjust
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xf000
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPL
case|:
name|BFD_ASSERT
argument_list|(
name|adjust
operator|==
name|count
operator|||
name|count
operator|>=
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|4
condition|)
name|insn
operator|+=
name|adjust
operator|/
literal|4
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
operator|++
name|insn
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH8
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
if|if
condition|(
name|voff
operator|<
literal|0
operator|||
name|voff
operator|>=
literal|0xff
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH16
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
if|if
condition|(
name|voff
operator|<
operator|-
literal|0x8000
operator|||
name|voff
operator|>=
literal|0x8000
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_signed_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH32
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
name|bfd_put_signed_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_USES
case|:
name|irel
operator|->
name|r_addend
operator|+=
name|adjust
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|overflow
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: fatal: reloc overflow while relaxing"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|irel
operator|->
name|r_offset
operator|=
name|nraddr
expr_stmt|;
block|}
comment|/* Look through all the other sections.  If there contain any IMM32      relocs against internal symbols which we are not going to adjust      below, we may need to adjust the addends.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelscan
decl_stmt|,
modifier|*
name|irelscanend
decl_stmt|;
name|bfd_byte
modifier|*
name|ocontents
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|sec
operator|||
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* We always cache the relocs.  Perhaps, if info->keep_memory is 	 false, we should free them, if we are permitted to, when we 	 leave sh_coff_relax_section.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf32_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|ocontents
operator|=
name|NULL
expr_stmt|;
name|irelscanend
operator|=
name|internal_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irelscan
operator|=
name|internal_relocs
init|;
name|irelscan
operator|<
name|irelscanend
condition|;
name|irelscan
operator|++
control|)
block|{
comment|/* Dwarf line numbers use R_SH_SWITCH32 relocs.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irelscan
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_SWITCH32
condition|)
block|{
name|bfd_vma
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|bfd_signed_vma
name|voff
decl_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|ocontents
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* We always cache the section contents. 			 Perhaps, if info->keep_memory is false, we 			 should free them, if we are permitted to, 			 when we leave sh_coff_relax_section.  */
name|ocontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|o
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|ocontents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|ocontents
expr_stmt|;
block|}
block|}
name|stop
operator|=
name|irelscan
operator|->
name|r_offset
expr_stmt|;
name|start
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|stop
operator|-
operator|(
name|long
operator|)
name|irelscan
operator|->
name|r_addend
argument_list|)
expr_stmt|;
comment|/* STOP is in a different section, so it won't change.  */
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
condition|)
name|irelscan
operator|->
name|r_addend
operator|+=
name|count
expr_stmt|;
name|voff
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
name|voff
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
operator|&&
operator|(
name|stop
operator|<=
name|addr
operator|||
name|stop
operator|>=
name|toaddr
operator|)
condition|)
name|bfd_put_signed_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|voff
operator|+
name|count
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stop
operator|>
name|addr
operator|&&
name|stop
operator|<
name|toaddr
operator|&&
operator|(
name|start
operator|<=
name|addr
operator|||
name|start
operator|>=
name|toaddr
operator|)
condition|)
name|bfd_put_signed_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|voff
operator|-
name|count
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irelscan
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_DIR32
condition|)
continue|continue;
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irelscan
operator|->
name|r_info
argument_list|)
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
continue|continue;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irelscan
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
operator|(
name|isym
operator|->
name|st_value
operator|<=
name|addr
operator|||
name|isym
operator|->
name|st_value
operator|>=
name|toaddr
operator|)
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|ocontents
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* We always cache the section contents. 			 Perhaps, if info->keep_memory is false, we 			 should free them, if we are permitted to, 			 when we leave sh_coff_relax_section.  */
name|ocontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|o
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|ocontents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|ocontents
expr_stmt|;
block|}
block|}
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|val
operator|+=
name|isym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|addr
operator|&&
name|val
operator|<
name|toaddr
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
operator|-
name|count
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Adjust the local symbols defined in this section.  */
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
block|{
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/* See if we can move the ALIGN reloc forward.  We have adjusted      r_offset for it already.  */
if|if
condition|(
name|irelalign
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|alignto
decl_stmt|,
name|alignaddr
decl_stmt|;
name|alignto
operator|=
name|BFD_ALIGN
argument_list|(
name|toaddr
argument_list|,
literal|1
operator|<<
name|irelalign
operator|->
name|r_addend
argument_list|)
expr_stmt|;
name|alignaddr
operator|=
name|BFD_ALIGN
argument_list|(
name|irelalign
operator|->
name|r_offset
argument_list|,
literal|1
operator|<<
name|irelalign
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignto
operator|!=
name|alignaddr
condition|)
block|{
comment|/* Tail recursion.  */
return|return
name|sh_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|alignaddr
argument_list|,
call|(
name|int
call|)
argument_list|(
name|alignto
operator|-
name|alignaddr
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Look for loads and stores which we can align to four byte    boundaries.  This is like sh_align_loads in coff-sh.c.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_align_loads
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|internal_relocs
parameter_list|,
name|contents
parameter_list|,
name|pswapped
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|boolean
modifier|*
name|pswapped
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_vma
modifier|*
name|labels
init|=
name|NULL
decl_stmt|;
name|bfd_vma
modifier|*
name|label
decl_stmt|,
modifier|*
name|label_end
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
operator|*
name|pswapped
operator|=
name|false
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Get all the addresses with labels on them.  */
name|amt
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
expr_stmt|;
name|labels
operator|=
operator|(
name|bfd_vma
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|label_end
operator|=
name|labels
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_LABEL
condition|)
block|{
operator|*
name|label_end
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
operator|++
name|label_end
expr_stmt|;
block|}
block|}
comment|/* Note that the assembler currently always outputs relocs in      address order.  If that ever changes, this code will need to sort      the label values and the relocs.  */
name|label
operator|=
name|labels
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|start
decl_stmt|,
name|stop
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_SH_CODE
condition|)
continue|continue;
name|start
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
for|for
control|(
name|irel
operator|++
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_SH_DATA
condition|)
break|break;
if|if
condition|(
name|irel
operator|<
name|irelend
condition|)
name|stop
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
else|else
name|stop
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_sh_align_load_span
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|sh_elf_swap_insns
argument_list|,
operator|(
name|PTR
operator|)
name|internal_relocs
argument_list|,
operator|&
name|label
argument_list|,
name|label_end
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|pswapped
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|labels
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|labels
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|labels
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Swap two SH instructions.  This is like sh_swap_insns in coff-sh.c.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_swap_insns
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|,
name|contents
parameter_list|,
name|addr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|relocs
decl_stmt|;
name|unsigned
name|short
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
comment|/* Swap the instructions themselves.  */
name|i1
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
name|i2
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|i2
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|i1
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Adjust all reloc addresses.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|enum
name|elf_sh_reloc_type
name|type
decl_stmt|;
name|int
name|add
decl_stmt|;
comment|/* There are a few special types of relocs that we don't want to 	 adjust.  These relocs do not apply to the instruction itself, 	 but are only associated with the address.  */
name|type
operator|=
operator|(
expr|enum
name|elf_sh_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|R_SH_ALIGN
operator|||
name|type
operator|==
name|R_SH_CODE
operator|||
name|type
operator|==
name|R_SH_DATA
operator|||
name|type
operator|==
name|R_SH_LABEL
condition|)
continue|continue;
comment|/* If an R_SH_USES reloc points to one of the addresses being 	 swapped, we must adjust it.  It would be incorrect to do this 	 for a jump, though, since we want to execute both 	 instructions after the jump.  (We have avoided swapping 	 around a label, so the jump will not wind up executing an 	 instruction it shouldn't).  */
if|if
condition|(
name|type
operator|==
name|R_SH_USES
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
name|irel
operator|->
name|r_offset
operator|+
literal|4
operator|+
name|irel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|addr
condition|)
name|irel
operator|->
name|r_offset
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|off
operator|==
name|addr
operator|+
literal|2
condition|)
name|irel
operator|->
name|r_offset
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|addr
condition|)
block|{
name|irel
operator|->
name|r_offset
operator|+=
literal|2
expr_stmt|;
name|add
operator|=
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|addr
operator|+
literal|2
condition|)
block|{
name|irel
operator|->
name|r_offset
operator|-=
literal|2
expr_stmt|;
name|add
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|add
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|add
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|short
name|insn
decl_stmt|,
name|oinsn
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
name|loc
operator|=
name|contents
operator|+
name|irel
operator|->
name|r_offset
expr_stmt|;
name|overflow
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|R_SH_DIR8WPN
case|:
case|case
name|R_SH_DIR8WPZ
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|oinsn
operator|=
name|insn
expr_stmt|;
name|insn
operator|+=
name|add
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_IND12W
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|oinsn
operator|=
name|insn
expr_stmt|;
name|insn
operator|+=
name|add
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xf000
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPL
case|:
comment|/* This reloc ignores the least significant 3 bits of 		 the program counter before adding in the offset. 		 This means that if ADDR is at an even address, the 		 swap will not affect the offset.  If ADDR is an at an 		 odd address, then the instruction will be crossing a 		 four byte boundary, and must be adjusted.  */
if|if
condition|(
operator|(
name|addr
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|oinsn
operator|=
name|insn
expr_stmt|;
name|insn
operator|+=
name|add
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|overflow
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: fatal: reloc overflow while relaxing"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
end_ifdef

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|64
end_define

begin_comment
comment|/* First entry in an absolute procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt0_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x10
block|,
comment|/* movi  .got.plt>> 16, r17 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x10
block|,
comment|/* shori .got.plt& 65535, r17 */
literal|0x89
block|,
literal|0x10
block|,
literal|0x09
block|,
literal|0x90
block|,
comment|/* ld.l  r17, 8, r25 */
literal|0x6b
block|,
literal|0xf1
block|,
literal|0x46
block|,
literal|0x00
block|,
comment|/* ptabs r17, tr0 */
literal|0x89
block|,
literal|0x10
block|,
literal|0x05
block|,
literal|0x10
block|,
comment|/* ld.l  r17, 4, r17 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt0_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x10
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  .got.plt>> 16, r17 */
literal|0x10
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori .got.plt& 65535, r17 */
literal|0x90
block|,
literal|0x09
block|,
literal|0x10
block|,
literal|0x89
block|,
comment|/* ld.l  r17, 8, r25 */
literal|0x00
block|,
literal|0x46
block|,
literal|0xf1
block|,
literal|0x6b
block|,
comment|/* ptabs r17, tr0 */
literal|0x10
block|,
literal|0x05
block|,
literal|0x10
block|,
literal|0x89
block|,
comment|/* ld.l  r17, 4, r17 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sebsequent entries in an absolute procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* movi  nameN-in-GOT>> 16, r25 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* shori nameN-in-GOT& 65535, r25 */
literal|0x89
block|,
literal|0x90
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* ld.l  r25, 0, r25 */
literal|0x6b
block|,
literal|0xf1
block|,
literal|0x66
block|,
literal|0x00
block|,
comment|/* ptabs r25, tr0 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* movi  .PLT0>> 16, r25 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* shori .PLT0& 65535, r25 */
literal|0x6b
block|,
literal|0xf1
block|,
literal|0x66
block|,
literal|0x00
block|,
comment|/* ptabs r25, tr0 */
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x50
block|,
comment|/* movi  reloc-offset>> 16, r21 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x50
block|,
comment|/* shori reloc-offset& 65535, r21 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  nameN-in-GOT>> 16, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori nameN-in-GOT& 65535, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x90
block|,
literal|0x89
block|,
comment|/* ld.l  r25, 0, r25 */
literal|0x00
block|,
literal|0x66
block|,
literal|0xf1
block|,
literal|0x6b
block|,
comment|/* ptabs r25, tr0 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  .PLT0>> 16, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori .PLT0& 65535, r25 */
literal|0x00
block|,
literal|0x66
block|,
literal|0xf1
block|,
literal|0x6b
block|,
comment|/* ptabs r25, tr0 */
literal|0x50
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  reloc-offset>> 16, r21 */
literal|0x50
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori reloc-offset& 65535, r21 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entries in a PIC procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_pic_plt_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* movi  nameN@GOT>> 16, r25 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* shori nameN@GOT& 65535, r25 */
literal|0x40
block|,
literal|0xc2
block|,
literal|0x65
block|,
literal|0x90
block|,
comment|/* ldx.l r12, r25, r25 */
literal|0x6b
block|,
literal|0xf1
block|,
literal|0x66
block|,
literal|0x00
block|,
comment|/* ptabs r25, tr0 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0xce
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x10
block|,
comment|/* movi  -GOT_BIAS, r17 */
literal|0x00
block|,
literal|0xca
block|,
literal|0x45
block|,
literal|0x10
block|,
comment|/* sub.l r12, r17, r17 */
literal|0x89
block|,
literal|0x10
block|,
literal|0x09
block|,
literal|0x90
block|,
comment|/* ld.l  r17, 8, r25 */
literal|0x6b
block|,
literal|0xf1
block|,
literal|0x66
block|,
literal|0x00
block|,
comment|/* ptabs r25, tr0 */
literal|0x89
block|,
literal|0x10
block|,
literal|0x05
block|,
literal|0x10
block|,
comment|/* ld.l  r17, 4, r17 */
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x50
block|,
comment|/* movi  reloc-offset>> 16, r21 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x50
block|,
comment|/* shori reloc-offset& 65535, r21 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_pic_plt_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  nameN@GOT>> 16, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori nameN@GOT& 65535, r25 */
literal|0x90
block|,
literal|0x65
block|,
literal|0xc2
block|,
literal|0x40
block|,
comment|/* ldx.l r12, r25, r25 */
literal|0x00
block|,
literal|0x66
block|,
literal|0xf1
block|,
literal|0x6b
block|,
comment|/* ptabs r25, tr0 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0x10
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xce
block|,
comment|/* movi  -GOT_BIAS, r17 */
literal|0x10
block|,
literal|0x45
block|,
literal|0xca
block|,
literal|0x00
block|,
comment|/* sub.l r12, r17, r17 */
literal|0x90
block|,
literal|0x09
block|,
literal|0x10
block|,
literal|0x89
block|,
comment|/* ld.l  r17, 8, r25 */
literal|0x00
block|,
literal|0x66
block|,
literal|0xf1
block|,
literal|0x6b
block|,
comment|/* ptabs r25, tr0 */
literal|0x10
block|,
literal|0x05
block|,
literal|0x10
block|,
literal|0x89
block|,
comment|/* ld.l  r17, 4, r17 */
literal|0x50
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  reloc-offset>> 16, r21 */
literal|0x50
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori reloc-offset& 65535, r21 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
modifier|*
name|elf_sh_plt0_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
modifier|*
name|elf_sh_plt_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
modifier|*
name|elf_sh_pic_plt_entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return size of a PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_sizeof_plt
parameter_list|(
name|info
parameter_list|)
value|PLT_ENTRY_SIZE
end_define

begin_comment
comment|/* Return offset of the PLT0 address in an absolute PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt_plt0_offset
parameter_list|(
name|info
parameter_list|)
value|32
end_define

begin_comment
comment|/* Return offset of the linker in PLT0 entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt0_gotplt_offset
parameter_list|(
name|info
parameter_list|)
value|0
end_define

begin_comment
comment|/* Return offset of the trampoline in PLT entry */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt_temp_offset
parameter_list|(
name|info
parameter_list|)
value|33
end_define

begin_comment
comment|/* Add one because it's SHmedia.  */
end_comment

begin_comment
comment|/* Return offset of the symbol in PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt_symbol_offset
parameter_list|(
name|info
parameter_list|)
value|0
end_define

begin_comment
comment|/* Return offset of the relocation in PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt_reloc_offset
parameter_list|(
name|info
parameter_list|)
value|(info->shared ? 52 : 44)
end_define

begin_function
specifier|inline
specifier|static
name|void
name|movi_shori_putval
parameter_list|(
name|output_bfd
parameter_list|,
name|value
parameter_list|,
name|addr
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|addr
argument_list|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|6
operator|)
operator|&
literal|0x3fffc00
operator|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|addr
operator|+
literal|4
argument_list|)
operator||
operator|(
operator|(
name|value
operator|<<
literal|10
operator|)
operator|&
literal|0x3fffc00
operator|)
argument_list|,
name|addr
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|28
end_define

begin_comment
comment|/* First entry in an absolute procedure linkage table look like this.  */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* Note - this code has been "optimised" not to use r2.  r2 is used by    GCC to return the address of large strutcures, so it should not be    corrupted here.  This does mean however, that this PLT does not conform    to the SH PIC ABI.  That spec says that r0 contains the type of the PLT    and r2 contains the GOT id.  This version stores the GOT id in r0 and    ignores the type.  Loaders can easily detect this difference however,    since the type will always be 0 or 8, and the GOT ids will always be    greater than or equal to 12.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt0_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xd0
block|,
literal|0x05
block|,
comment|/* mov.l 2f,r0 */
literal|0x60
block|,
literal|0x02
block|,
comment|/* mov.l @r0,r0 */
literal|0x2f
block|,
literal|0x06
block|,
comment|/* mov.l r0,@-r15 */
literal|0xd0
block|,
literal|0x03
block|,
comment|/* mov.l 1f,r0 */
literal|0x60
block|,
literal|0x02
block|,
comment|/* mov.l @r0,r0 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0x60
block|,
literal|0xf6
block|,
comment|/*  mov.l @r15+,r0 */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of .got.plt + 8.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 2: replaced with address of .got.plt + 4.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt0_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x05
block|,
literal|0xd0
block|,
comment|/* mov.l 2f,r0 */
literal|0x02
block|,
literal|0x60
block|,
comment|/* mov.l @r0,r0 */
literal|0x06
block|,
literal|0x2f
block|,
comment|/* mov.l r0,@-r15 */
literal|0x03
block|,
literal|0xd0
block|,
comment|/* mov.l 1f,r0 */
literal|0x02
block|,
literal|0x60
block|,
comment|/* mov.l @r0,r0 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0xf6
block|,
literal|0x60
block|,
comment|/*  mov.l @r15+,r0 */
literal|0x09
block|,
literal|0x00
block|,
comment|/* nop */
literal|0x09
block|,
literal|0x00
block|,
comment|/* nop */
literal|0x09
block|,
literal|0x00
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of .got.plt + 8.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 2: replaced with address of .got.plt + 4.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sebsequent entries in an absolute procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xd0
block|,
literal|0x04
block|,
comment|/* mov.l 1f,r0 */
literal|0x60
block|,
literal|0x02
block|,
comment|/* mov.l @r0,r0 */
literal|0xd1
block|,
literal|0x02
block|,
comment|/* mov.l 0f,r1 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0x60
block|,
literal|0x13
block|,
comment|/*  mov r1,r0 */
literal|0xd1
block|,
literal|0x03
block|,
comment|/* mov.l 2f,r1 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0: replaced with address of .PLT0.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of this symbol in .got.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 2: replaced with offset into relocation table.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x04
block|,
literal|0xd0
block|,
comment|/* mov.l 1f,r0 */
literal|0x02
block|,
literal|0x60
block|,
comment|/* mov.l @r0,r0 */
literal|0x02
block|,
literal|0xd1
block|,
comment|/* mov.l 0f,r1 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0x13
block|,
literal|0x60
block|,
comment|/*  mov r1,r0 */
literal|0x03
block|,
literal|0xd1
block|,
comment|/* mov.l 2f,r1 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0x09
block|,
literal|0x00
block|,
comment|/*  nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0: replaced with address of .PLT0.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of this symbol in .got.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 2: replaced with offset into relocation table.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entries in a PIC procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_pic_plt_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xd0
block|,
literal|0x04
block|,
comment|/* mov.l 1f,r0 */
literal|0x00
block|,
literal|0xce
block|,
comment|/* mov.l @(r0,r12),r0 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0x00
block|,
literal|0x09
block|,
comment|/*  nop */
literal|0x50
block|,
literal|0xc2
block|,
comment|/* mov.l @(8,r12),r0 */
literal|0xd1
block|,
literal|0x03
block|,
comment|/* mov.l 2f,r1 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0x50
block|,
literal|0xc1
block|,
comment|/*  mov.l @(4,r12),r0 */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of this symbol in .got.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* 2: replaced with offset into relocation table.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_pic_plt_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x04
block|,
literal|0xd0
block|,
comment|/* mov.l 1f,r0 */
literal|0xce
block|,
literal|0x00
block|,
comment|/* mov.l @(r0,r12),r0 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0x09
block|,
literal|0x00
block|,
comment|/*  nop */
literal|0xc2
block|,
literal|0x50
block|,
comment|/* mov.l @(8,r12),r0 */
literal|0x03
block|,
literal|0xd1
block|,
comment|/* mov.l 2f,r1 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0xc1
block|,
literal|0x50
block|,
comment|/*  mov.l @(4,r12),r0 */
literal|0x09
block|,
literal|0x00
block|,
comment|/*  nop */
literal|0x09
block|,
literal|0x00
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of this symbol in .got.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* 2: replaced with offset into relocation table.  */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* These are the old style PLT entries.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt0_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xd0
block|,
literal|0x04
block|,
comment|/* mov.l 1f,r0 */
literal|0xd2
block|,
literal|0x05
block|,
comment|/* mov.l 2f,r2 */
literal|0x60
block|,
literal|0x02
block|,
comment|/* mov.l @r0,r0 */
literal|0x62
block|,
literal|0x22
block|,
comment|/* mov.l @r2,r2 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0xe0
block|,
literal|0x00
block|,
comment|/*  mov #0,r0 */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of .got.plt + 8.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 2: replaced with address of .got.plt + 4.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt0_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x04
block|,
literal|0xd0
block|,
comment|/* mov.l 1f,r0 */
literal|0x05
block|,
literal|0xd2
block|,
comment|/* mov.l 2f,r2 */
literal|0x02
block|,
literal|0x60
block|,
comment|/* mov.l @r0,r0 */
literal|0x22
block|,
literal|0x62
block|,
comment|/* mov.l @r2,r2 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0x00
block|,
literal|0xe0
block|,
comment|/*  mov #0,r0 */
literal|0x09
block|,
literal|0x00
block|,
comment|/* nop */
literal|0x09
block|,
literal|0x00
block|,
comment|/* nop */
literal|0x09
block|,
literal|0x00
block|,
comment|/* nop */
literal|0x09
block|,
literal|0x00
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of .got.plt + 8.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 2: replaced with address of .got.plt + 4.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sebsequent entries in an absolute procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xd0
block|,
literal|0x04
block|,
comment|/* mov.l 1f,r0 */
literal|0x60
block|,
literal|0x02
block|,
comment|/* mov.l @r0,r0 */
literal|0xd2
block|,
literal|0x02
block|,
comment|/* mov.l 0f,r2 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0x60
block|,
literal|0x23
block|,
comment|/*  mov r2,r0 */
literal|0xd1
block|,
literal|0x03
block|,
comment|/* mov.l 2f,r1 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0: replaced with address of .PLT0.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of this symbol in .got.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 2: replaced with offset into relocation table.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_plt_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x04
block|,
literal|0xd0
block|,
comment|/* mov.l 1f,r0 */
literal|0x02
block|,
literal|0x60
block|,
comment|/* mov.l @r0,r0 */
literal|0x02
block|,
literal|0xd2
block|,
comment|/* mov.l 0f,r2 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0x23
block|,
literal|0x60
block|,
comment|/*  mov r2,r0 */
literal|0x03
block|,
literal|0xd1
block|,
comment|/* mov.l 2f,r1 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0x09
block|,
literal|0x00
block|,
comment|/*  nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0: replaced with address of .PLT.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of this symbol in .got.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 2: replaced with offset into relocation table.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entries in a PIC procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_pic_plt_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xd0
block|,
literal|0x04
block|,
comment|/* mov.l 1f,r0 */
literal|0x00
block|,
literal|0xce
block|,
comment|/* mov.l @(r0,r12),r0 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0x00
block|,
literal|0x09
block|,
comment|/*  nop */
literal|0x50
block|,
literal|0xc2
block|,
comment|/* 0: mov.l @(8,r12),r0 */
literal|0x52
block|,
literal|0xc1
block|,
comment|/* 1: mov.l @(4,r12),r2 */
literal|0xd1
block|,
literal|0x02
block|,
comment|/* mov.l 2f,r1 */
literal|0x40
block|,
literal|0x2b
block|,
comment|/* jmp @r0 */
literal|0xe0
block|,
literal|0x00
block|,
comment|/*  mov #0,r0 ! shows the type of PLT.  */
literal|0x00
block|,
literal|0x09
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of this symbol in .got.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* 2: replaced with offset into relocation table.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh_pic_plt_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x04
block|,
literal|0xd0
block|,
comment|/* mov.l 1f,r0 */
literal|0xce
block|,
literal|0x00
block|,
comment|/* mov.l @(r0,r12),r0 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0x09
block|,
literal|0x00
block|,
comment|/*  nop */
literal|0xc2
block|,
literal|0x50
block|,
comment|/* 0: mov.l @(8,r12),r0 */
literal|0xc1
block|,
literal|0x52
block|,
comment|/* 1: mov.l @(4,r12),r2 */
literal|0x02
block|,
literal|0xd1
block|,
comment|/* mov.l 2f,r1 */
literal|0x2b
block|,
literal|0x40
block|,
comment|/* jmp @r0 */
literal|0x00
block|,
literal|0xe0
block|,
comment|/*  mov #0,r0 ! shows the type of PLT.  */
literal|0x09
block|,
literal|0x00
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 1: replaced with address of this symbol in .got.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* 2: replaced with offset into relocation table.  */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* old style PLT entries.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
modifier|*
name|elf_sh_plt0_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
modifier|*
name|elf_sh_plt_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
modifier|*
name|elf_sh_pic_plt_entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return size of a PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_sizeof_plt
parameter_list|(
name|info
parameter_list|)
value|PLT_ENTRY_SIZE
end_define

begin_comment
comment|/* Return offset of the PLT0 address in an absolute PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt_plt0_offset
parameter_list|(
name|info
parameter_list|)
value|16
end_define

begin_comment
comment|/* Return offset of the linker in PLT0 entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt0_linker_offset
parameter_list|(
name|info
parameter_list|)
value|20
end_define

begin_comment
comment|/* Return offset of the GOT id in PLT0 entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt0_gotid_offset
parameter_list|(
name|info
parameter_list|)
value|24
end_define

begin_comment
comment|/* Return offset of the tempoline in PLT entry */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt_temp_offset
parameter_list|(
name|info
parameter_list|)
value|8
end_define

begin_comment
comment|/* Return offset of the symbol in PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt_symbol_offset
parameter_list|(
name|info
parameter_list|)
value|20
end_define

begin_comment
comment|/* Return offset of the relocation in PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh_plt_reloc_offset
parameter_list|(
name|info
parameter_list|)
value|24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The sh linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_sh_dyn_relocs
block|{
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* sh ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|elf_sh_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
name|bfd_vma
name|datalabel_got_offset
decl_stmt|;
endif|#
directive|endif
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
name|bfd_signed_vma
name|gotplt_refcount
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* sh ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_sh_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelbss
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Traverse an sh ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|sh_elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the sh ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|sh_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf_sh_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Create an entry in an sh ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|sh_elf_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_sh_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|ret
expr_stmt|;
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|gotplt_refcount
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
name|ret
operator|->
name|datalabel_got_offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create an sh ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|sh_elf_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_sh_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_sh_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|sh_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|sgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sgotplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up    shortcuts to them in our hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|create_got_section
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|htab
operator|=
name|sh_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|||
operator|!
name|htab
operator|->
name|sgotplt
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|flagword
name|flags
decl_stmt|,
name|pltflags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
condition|)
block|{
case|case
literal|32
case|:
name|ptralign
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|ptralign
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|htab
operator|=
name|sh_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and      .rel[a].bss sections.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|pltflags
operator|=
name|flags
expr_stmt|;
name|pltflags
operator||=
name|SEC_CODE
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_not_loaded
condition|)
name|pltflags
operator|&=
operator|~
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_readonly
condition|)
name|pltflags
operator||=
name|SEC_READONLY
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|splt
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|pltflags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|plt_alignment
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bed
operator|->
name|want_plt_sym
condition|)
block|{
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the 	 .plt section.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.plt"
else|:
literal|".rel.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
name|char
modifier|*
name|relname
decl_stmt|;
name|flagword
name|secflags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|secflags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|secflags
operator|&
operator|(
name|SEC_DATA
operator||
name|SEC_LINKER_CREATED
operator|)
operator|)
operator|||
operator|(
operator|(
name|secflags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
name|SEC_HAS_CONTENTS
operator|)
condition|)
continue|continue;
name|secname
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|relname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|secname
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|relname
argument_list|,
literal|".rela"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|relname
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|relname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|bed
operator|->
name|want_dynbss
condition|)
block|{
comment|/* The .dynbss section is a place to put symbols which are defined 	 by dynamic objects, are referenced by regular objects, and are 	 not functions.  We must allocate space for them in the process 	 image and use a R_*_COPY reloc to tell the dynamic linker to 	 initialize them at run time.  The linker script puts the .dynbss 	 section into the .bss section of the final image.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The .rel[a].bss section holds copy relocs.  This section is not 	 normally needed.  We need to create it here, though, so that the 	 linker will map it to an output section.  We can't just create it 	 only if we need it, because we will not know whether we need it 	 until we have seen all the input files, and the first time the 	 main linker code calls BFD after examining all the input files 	 (size_dynamic_sections) the input sections have already been 	 mapped to the output sections.  If the section turns out not to 	 be needed, we can discard it later.  We will never need this 	 section when generating a shared object, since they do not use 	 copy relocs.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.bss"
else|:
literal|".rel.bss"
operator|)
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelbss
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
condition|)
block|{
comment|/* This case can occur if we saw a PLT reloc in an input 	     file, but the symbol was never referred to by a dynamic 	     object.  In such a case, we don't actually need to build 	     a procedure linkage table, and we can just do a REL32 	     reloc instead.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|true
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If -z nocopyreloc was given, we won't generate them either.  */
if|if
condition|(
name|info
operator|->
name|nocopyreloc
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
return|return
name|true
return|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in sections which needs the      copy reloc, then we'll be keeping the dynamic relocs and avoiding      the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|htab
operator|=
name|sh_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sdynbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_SH_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is the condition under which sh_elf_finish_dynamic_symbol    will be called from elflink.h.  If elflink.h doesn't call our    finish_dynamic_symbol routine, we'll need to do something about    initializing any .plt and .got entries in sh_elf_relocate_section.  */
end_comment

begin_define
define|#
directive|define
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
parameter_list|(
name|DYN
parameter_list|,
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|((DYN)								\&& ((INFO)->shared							\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) == 0)	\&& ((H)->dynindx != -1						\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) != 0))
end_define

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_dynrelocs
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_sh_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
comment|/* When warning symbols are created, they **replace** the "real"        entry in the hash table, thus we never get to see the real        symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|sh_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
name|eh
operator|->
name|gotplt_refcount
operator|>
literal|0
condition|)
block|{
comment|/* The symbol has been forced local, or we have some direct got refs,          so treat all the gotplt refs as got refs. */
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
name|eh
operator|->
name|gotplt_refcount
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>=
name|eh
operator|->
name|gotplt_refcount
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
name|eh
operator|->
name|gotplt_refcount
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|splt
decl_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	     first entry.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	     not generating a shared library, then set the symbol to this 	     location in the .plt.  This is required to make function 	     pointers compare as equal between the normal executable and 	     the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Make room for this entry.  */
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .got.plt section, which 	     will be placed in the .got section by the linker script.  */
name|htab
operator|->
name|sgotplt
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rel.plt section.  */
name|htab
operator|->
name|srelplt
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|dyn
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_DATALABEL
condition|)
block|{
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|hsh
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|hsh
operator|->
name|datalabel_got_offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
else|#
directive|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for pc-relative relocs that have become local due to symbol      visibility changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
operator|||
name|info
operator|->
name|symbolic
operator|)
condition|)
block|{
name|struct
name|elf_sh_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|readonly_dynrelocs
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|htab
operator|=
name|sh_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_sh_dyn_relocs
operator|*
operator|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
comment|/* Count datalabel local GOT.  */
name|locsymcount
operator|*=
literal|2
expr_stmt|;
endif|#
directive|endif
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
control|)
block|{
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|,
name|allocate_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* We now have determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|splt
operator|||
name|s
operator|==
name|htab
operator|->
name|sgot
operator|||
name|s
operator|==
name|htab
operator|->
name|sgotplt
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|!=
literal|0
operator|&&
name|s
operator|!=
name|htab
operator|->
name|srelplt
condition|)
name|relocs
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 	     to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rela.bss and 	     .rela.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  We use bfd_zalloc 	 here in case unused entries are not reclaimed before the 	 section's contents are written out.  This should not happen, 	 but this way if it does, we get a R_SH_NONE reloc instead 	 of garbage.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in sh_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If any dynamic relocs apply to a read-only section, 	     then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|,
name|readonly_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an SH ELF section.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|htab
operator|=
name|sh_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|sgotplt
operator|=
name|htab
operator|->
name|sgotplt
expr_stmt|;
name|splt
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|addend
init|=
operator|(
name|bfd_vma
operator|)
literal|0
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|int
name|seen_stt_datalabel
init|=
literal|0
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Many of the relocs are only used for relaxing, and are 	 handled entirely by the relaxation code.  */
if|if
condition|(
name|r_type
operator|>
operator|(
name|int
operator|)
name|R_SH_LAST_INVALID_RELOC
operator|&&
name|r_type
operator|<
operator|(
name|int
operator|)
name|R_SH_LOOP_START
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_SH_NONE
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
name|R_SH_max
operator|||
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_FIRST_INVALID_RELOC
operator|&&
name|r_type
operator|<=
operator|(
name|int
operator|)
name|R_SH_LAST_INVALID_RELOC
operator|)
operator|||
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_FIRST_INVALID_RELOC_3
operator|&&
name|r_type
operator|<=
operator|(
name|int
operator|)
name|R_SH_LAST_INVALID_RELOC_3
operator|)
operator|||
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_FIRST_INVALID_RELOC_4
operator|&&
name|r_type
operator|<=
operator|(
name|int
operator|)
name|R_SH_LAST_INVALID_RELOC_4
operator|)
operator|||
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_FIRST_INVALID_RELOC_2
operator|&&
name|r_type
operator|<=
operator|(
name|int
operator|)
name|R_SH_LAST_INVALID_RELOC_2
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|howto
operator|=
name|sh_elf_howto_table
operator|+
name|r_type
expr_stmt|;
comment|/* For relocs that aren't partial_inplace, we get the addend from 	 the relocation.  */
if|if
condition|(
operator|!
name|howto
operator|->
name|partial_inplace
condition|)
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
comment|/* A local symbol never has STO_SH5_ISA32, so we don't need 	     datalabel processing here.  Make sure this does not change 	     without notice.  */
if|if
condition|(
operator|(
name|sym
operator|->
name|st_other
operator|&
name|STO_SH5_ISA32
operator|)
operator|!=
literal|0
condition|)
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"Unexpected STO_SH5_ISA32 on local symbol is not handled"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change 		 anything, unless the reloc is against a section symbol, 		 in which case we have to adjust according to where the 		 section symbol winds up in the output section.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
if|if
condition|(
operator|!
name|howto
operator|->
name|partial_inplace
condition|)
block|{
comment|/* For relocations with the addend in the 			 relocation, we need just to update the addend. 			 All real relocs are of type partial_inplace; this 			 code is mostly for completeness.  */
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
continue|continue;
block|}
comment|/* Relocs of type partial_inplace need to pick up the 		     contents in the contents and add the offset resulting 		     from the changed location of the section symbol. 		     Using _bfd_final_link_relocate (e.g. goto 		     final_link_relocate) here would be wrong, because 		     relocations marked pc_relative would get the current 		     location subtracted, and we must only do that at the 		     final link.  */
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
goto|goto
name|relocation_done
goto|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|howto
operator|->
name|partial_inplace
condition|)
block|{
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|||
name|howto
operator|->
name|src_mask
operator|!=
literal|0xffffffff
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): %s relocation against SEC_MERGE section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|msec
operator|=
name|sec
expr_stmt|;
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|addend
argument_list|)
operator|-
name|relocation
expr_stmt|;
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Section symbol are never (?) placed in the hash table, so 	     we can just ignore hash relocations when creating a 	     relocateable object file.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
continue|continue;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
comment|/* If the reference passes a symbol marked with 		 STT_DATALABEL, then any STO_SH5_ISA32 on the final value 		 doesn't count.  */
name|seen_stt_datalabel
operator||=
name|h
operator|->
name|type
operator|==
name|STT_DATALABEL
expr_stmt|;
endif|#
directive|endif
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|boolean
name|dyn
decl_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
comment|/* In these cases, we don't need the relocation value. 		 We check specially because in some obscure cases 		 sec->output_section will be NULL.  */
if|if
condition|(
name|r_type
operator|==
name|R_SH_GOTPC
operator|||
name|r_type
operator|==
name|R_SH_GOTPC_LOW16
operator|||
name|r_type
operator|==
name|R_SH_GOTPC_MEDLOW16
operator|||
name|r_type
operator|==
name|R_SH_GOTPC_MEDHI16
operator|||
name|r_type
operator|==
name|R_SH_GOTPC_HI16
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_SH_PLT32
operator|||
name|r_type
operator|==
name|R_SH_PLT_LOW16
operator|||
name|r_type
operator|==
name|R_SH_PLT_MEDLOW16
operator|||
name|r_type
operator|==
name|R_SH_PLT_MEDHI16
operator|||
name|r_type
operator|==
name|R_SH_PLT_HI16
operator|)
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_SH_GOT32
operator|||
name|r_type
operator|==
name|R_SH_GOT_LOW16
operator|||
name|r_type
operator|==
name|R_SH_GOT_MEDLOW16
operator|||
name|r_type
operator|==
name|R_SH_GOT_MEDHI16
operator|||
name|r_type
operator|==
name|R_SH_GOT_HI16
operator|)
operator|&&
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
comment|/* The cases above are those in which relocation is 		     overwritten in the switch block below.  The cases 		     below are those in which we must defer relocation 		     to run-time, because we can't resolve absolute 		     addresses when creating a shared library.  */
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|r_type
operator|==
name|R_SH_DIR32
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
operator|)
operator|||
name|r_type
operator|==
name|R_SH_REL32
operator|)
operator|&&
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
comment|/* DWARF will emit R_SH_DIR32 relocations in its 			     sections against symbols defined externally 			     in shared libraries.  We can't do anything 			     with them here.  */
operator|||
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: unresolvable relocation against symbol `%s' from %s section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|relocation
operator|=
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
comment|/* A STO_SH5_ISA32 causes a "bitor 1" to the 				 symbol value, unless we've seen 				 STT_DATALABEL on the way to it.  */
operator||
operator|(
operator|(
name|h
operator|->
name|other
operator|&
name|STO_SH5_ISA32
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|seen_stt_datalabel
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|allow_shlib_undefined
operator|)
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|r_type
condition|)
block|{
name|final_link_relocate
label|:
comment|/* COFF relocs don't use the addend. The addend is used for 	     R_SH_DIR32 to be compatible with other compilers.  */
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_IND12W
case|:
name|relocation
operator|-=
literal|4
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_DIR8WPN
case|:
case|case
name|R_SH_DIR8WPZ
case|:
case|case
name|R_SH_DIR8WPL
case|:
comment|/* If the reloc is against the start of this section, then 	     the assembler has already taken care of it and the reloc 	     is here only to assist in relaxing.  If the reloc is not 	     against the start of this section, then it's against an 	     external symbol and we must deal with it ourselves.  */
if|if
condition|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|!=
name|relocation
condition|)
block|{
name|int
name|disp
init|=
operator|(
name|relocation
operator|-
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|-
name|input_section
operator|->
name|output_offset
operator|-
name|rel
operator|->
name|r_offset
operator|)
decl_stmt|;
name|int
name|mask
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SH_DIR8WPN
case|:
case|case
name|R_SH_DIR8WPZ
case|:
name|mask
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_SH_DIR8WPL
case|:
name|mask
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|mask
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|disp
operator|&
name|mask
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: 0x%lx: fatal: unaligned branch target for relax-support relocation"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|relocation
operator|-=
literal|4
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
block|}
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
if|if
condition|(
name|shmedia_prepare_reloc
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
operator|&
name|relocation
argument_list|)
condition|)
goto|goto
name|final_link_relocate
goto|;
endif|#
directive|endif
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|R_SH_DIR32
case|:
case|case
name|R_SH_REL32
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|r_type
operator|!=
name|R_SH_REL32
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|false
expr_stmt|;
name|relocate
operator|=
name|false
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|true
operator|,
name|relocate
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SH_REL32
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_REL32
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* h->dynindx may be -1 if this symbol was marked to 		     become local.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|relocate
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SH_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_DIR32
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|sreloc
operator|->
name|contents
operator|)
operator|+
name|sreloc
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* If this reloc is against an external symbol, we do 		 not want to fiddle with the addend.  Otherwise, we 		 need to include the symbol value so that it becomes 		 an addend for the dynamic reloc.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_GOTPLT32
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_GOTPLT_LOW16
case|:
case|case
name|R_SH_GOTPLT_MEDLOW16
case|:
case|case
name|R_SH_GOTPLT_MEDHI16
case|:
case|case
name|R_SH_GOTPLT_HI16
case|:
case|case
name|R_SH_GOTPLT10BY4
case|:
case|case
name|R_SH_GOTPLT10BY8
case|:
endif|#
directive|endif
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
goto|goto
name|force_got
goto|;
comment|/* Relocation is to the entry for this symbol in the global 	     offset table extension for the procedure linkage table.  */
name|BFD_ASSERT
argument_list|(
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|sgotplt
operator|->
name|output_offset
operator|+
operator|(
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
name|elf_sh_sizeof_plt
argument_list|(
name|info
argument_list|)
operator|-
literal|1
operator|+
literal|3
operator|)
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GOT_BIAS
name|relocation
operator|-=
name|GOT_BIAS
expr_stmt|;
endif|#
directive|endif
goto|goto
name|final_link_relocate
goto|;
name|force_got
label|:
case|case
name|R_SH_GOT32
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_GOT_LOW16
case|:
case|case
name|R_SH_GOT_MEDLOW16
case|:
case|case
name|R_SH_GOT_MEDHI16
case|:
case|case
name|R_SH_GOT_HI16
case|:
case|case
name|R_SH_GOT10BY4
case|:
case|case
name|R_SH_GOT10BY8
case|:
endif|#
directive|endif
comment|/* Relocation is to the entry for this symbol in the global 	     offset table.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
if|if
condition|(
name|seen_stt_datalabel
condition|)
block|{
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|hsh
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|off
operator|=
name|hsh
operator|->
name|datalabel_got_offset
expr_stmt|;
block|}
endif|#
directive|endif
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 		     -Bsymbolic link and the symbol is defined 		     locally, or the symbol was forced to be local 		     because of a version file.  We must initialize 		     this entry in the global offset table.  Since the 		     offset must always be a multiple of 4, we use the 		     least significant bit to record whether we have 		     initialized it already.  		     When doing a dynamic link, we create a .rela.got 		     relocation entry to initialize the value.  This 		     is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
if|if
condition|(
name|seen_stt_datalabel
condition|)
block|{
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|hsh
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|hsh
operator|->
name|datalabel_got_offset
operator||=
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
if|if
condition|(
name|rel
operator|->
name|r_addend
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
operator|(
name|local_got_offsets
index|[
name|symtab_hdr
operator|->
name|sh_info
operator|+
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|symtab_hdr
operator|->
name|sh_info
operator|+
name|r_symndx
index|]
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
block|}
endif|#
directive|endif
comment|/* The offset must always be a multiple of 4.  We use 		 the least significant bit to record whether we have 		 already generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SH_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srelgot
operator|->
name|contents
operator|)
operator|+
name|srelgot
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|srelgot
operator|->
name|reloc_count
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
if|if
condition|(
name|rel
operator|->
name|r_addend
condition|)
name|local_got_offsets
index|[
name|symtab_hdr
operator|->
name|sh_info
operator|+
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GOT_BIAS
name|relocation
operator|-=
name|GOT_BIAS
expr_stmt|;
endif|#
directive|endif
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_GOTOFF
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_GOTOFF_LOW16
case|:
case|case
name|R_SH_GOTOFF_MEDLOW16
case|:
case|case
name|R_SH_GOTOFF_MEDHI16
case|:
case|case
name|R_SH_GOTOFF_HI16
case|:
endif|#
directive|endif
comment|/* Relocation is relative to the start of the global offset 	     table.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Note that sgot->output_offset is not involved in this 	     calculation.  We always want the start of .got.  If we 	     defined _GLOBAL_OFFSET_TABLE in a different way, as is 	     permitted by the ABI, we might have to change this 	     calculation.  */
name|relocation
operator|-=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
ifdef|#
directive|ifdef
name|GOT_BIAS
name|relocation
operator|-=
name|GOT_BIAS
expr_stmt|;
endif|#
directive|endif
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_GOTPC
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_GOTPC_LOW16
case|:
case|case
name|R_SH_GOTPC_MEDLOW16
case|:
case|case
name|R_SH_GOTPC_MEDHI16
case|:
case|case
name|R_SH_GOTPC_HI16
case|:
endif|#
directive|endif
comment|/* Use global offset table as symbol value.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
ifdef|#
directive|ifdef
name|GOT_BIAS
name|relocation
operator|+=
name|GOT_BIAS
expr_stmt|;
endif|#
directive|endif
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_PLT32
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_PLT_LOW16
case|:
case|case
name|R_SH_PLT_MEDLOW16
case|:
case|case
name|R_SH_PLT_MEDHI16
case|:
case|case
name|R_SH_PLT_HI16
case|:
endif|#
directive|endif
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
comment|/* Resolve a PLT reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|final_link_relocate
goto|;
if|if
condition|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
condition|)
goto|goto
name|final_link_relocate
goto|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
goto|goto
name|final_link_relocate
goto|;
block|}
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
name|relocation
operator|++
expr_stmt|;
endif|#
directive|endif
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_LOOP_START
case|:
block|{
specifier|static
name|bfd_vma
name|start
decl_stmt|,
name|end
decl_stmt|;
name|start
operator|=
operator|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|-
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
operator|)
expr_stmt|;
name|r
operator|=
name|sh_elf_reloc_loop
argument_list|(
name|r_type
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|sec
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_LOOP_END
case|:
name|end
operator|=
operator|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|-
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
operator|)
expr_stmt|;
name|r
operator|=
name|sh_elf_reloc_loop
argument_list|(
name|r_type
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|sec
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|relocation_done
label|:
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses sh_elf_relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|sh_elf_get_relocated_section_contents
parameter_list|(
name|output_bfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocateable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
operator|(
name|size_t
operator|)
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_elf32_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|secpp
operator|=
name|sections
init|;
name|isym
operator|<
name|isymend
condition|;
operator|++
name|isym
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sh_elf_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|sh_elf_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SH_GNU_VTINHERIT
case|:
case|case
name|R_SH_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SH_GOT32
case|:
case|case
name|R_SH_GOTOFF
case|:
case|case
name|R_SH_GOTPC
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_GOT_LOW16
case|:
case|case
name|R_SH_GOT_MEDLOW16
case|:
case|case
name|R_SH_GOT_MEDHI16
case|:
case|case
name|R_SH_GOT_HI16
case|:
case|case
name|R_SH_GOT10BY4
case|:
case|case
name|R_SH_GOT10BY8
case|:
case|case
name|R_SH_GOTOFF_LOW16
case|:
case|case
name|R_SH_GOTOFF_MEDLOW16
case|:
case|case
name|R_SH_GOTOFF_MEDHI16
case|:
case|case
name|R_SH_GOTOFF_HI16
case|:
case|case
name|R_SH_GOTPC_LOW16
case|:
case|case
name|R_SH_GOTPC_MEDLOW16
case|:
case|case
name|R_SH_GOTPC_MEDHI16
case|:
case|case
name|R_SH_GOTPC_HI16
case|:
endif|#
directive|endif
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_SH_DIR32
case|:
case|case
name|R_SH_REL32
case|:
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_sh_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_SH_REL32
condition|)
name|p
operator|->
name|pc_count
operator|-=
literal|1
expr_stmt|;
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|R_SH_PLT32
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_PLT_LOW16
case|:
case|case
name|R_SH_PLT_MEDLOW16
case|:
case|case
name|R_SH_PLT_MEDHI16
case|:
case|case
name|R_SH_PLT_HI16
case|:
endif|#
directive|endif
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_SH_GOTPLT32
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_GOTPLT_LOW16
case|:
case|case
name|R_SH_GOTPLT_MEDLOW16
case|:
case|case
name|R_SH_GOTPLT_MEDHI16
case|:
case|case
name|R_SH_GOTPLT_HI16
case|:
case|case
name|R_SH_GOTPLT10BY4
case|:
case|case
name|R_SH_GOTPLT10BY8
case|:
endif|#
directive|endif
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|gotplt_refcount
operator|>
literal|0
condition|)
block|{
name|eh
operator|->
name|gotplt_refcount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|sh_elf_copy_indirect_symbol
parameter_list|(
name|bed
parameter_list|,
name|dir
parameter_list|,
name|ind
parameter_list|)
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
decl_stmt|,
decl|*
name|ind
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|elf_sh_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_sh_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|ind
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
argument_list|)
expr_stmt|;
comment|/* Add reloc counts against the weak sym to the strong sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|edir
operator|->
name|gotplt_refcount
operator|=
name|eind
operator|->
name|gotplt_refcount
expr_stmt|;
name|eind
operator|->
name|gotplt_refcount
operator|=
literal|0
expr_stmt|;
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|bed
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
name|struct
name|elf_sh_link_hash_table
modifier|*
name|htab
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|htab
operator|=
name|sh_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SH_GOTPLT32
case|:
case|case
name|R_SH_GOT32
case|:
case|case
name|R_SH_GOTOFF
case|:
case|case
name|R_SH_GOTPC
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_GOTPLT_LOW16
case|:
case|case
name|R_SH_GOTPLT_MEDLOW16
case|:
case|case
name|R_SH_GOTPLT_MEDHI16
case|:
case|case
name|R_SH_GOTPLT_HI16
case|:
case|case
name|R_SH_GOTPLT10BY4
case|:
case|case
name|R_SH_GOTPLT10BY8
case|:
case|case
name|R_SH_GOT_LOW16
case|:
case|case
name|R_SH_GOT_MEDLOW16
case|:
case|case
name|R_SH_GOT_MEDHI16
case|:
case|case
name|R_SH_GOT_HI16
case|:
case|case
name|R_SH_GOT10BY4
case|:
case|case
name|R_SH_GOT10BY8
case|:
case|case
name|R_SH_GOTOFF_LOW16
case|:
case|case
name|R_SH_GOTOFF_MEDLOW16
case|:
case|case
name|R_SH_GOTOFF_MEDHI16
case|:
case|case
name|R_SH_GOTOFF_HI16
case|:
case|case
name|R_SH_GOTPC_LOW16
case|:
case|case
name|R_SH_GOTPC_MEDLOW16
case|:
case|case
name|R_SH_GOTPC_MEDHI16
case|:
case|case
name|R_SH_GOTPC_HI16
case|:
endif|#
directive|endif
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_SH_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|_bfd_elf32_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_SH_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|_bfd_elf32_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
name|force_got
label|:
case|case
name|R_SH_GOT32
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_GOT_LOW16
case|:
case|case
name|R_SH_GOT_MEDLOW16
case|:
case|case
name|R_SH_GOT_MEDHI16
case|:
case|case
name|R_SH_GOT_HI16
case|:
case|case
name|R_SH_GOT10BY4
case|:
case|case
name|R_SH_GOT10BY8
case|:
endif|#
directive|endif
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local 		 symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
comment|/* Reserve space for both the datalabel and 		     codelabel local GOT offsets.  */
name|size
operator|*=
literal|2
expr_stmt|;
endif|#
directive|endif
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_SH_GOTPLT32
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_GOTPLT_LOW16
case|:
case|case
name|R_SH_GOTPLT_MEDLOW16
case|:
case|case
name|R_SH_GOTPLT_MEDHI16
case|:
case|case
name|R_SH_GOTPLT_HI16
case|:
case|case
name|R_SH_GOTPLT10BY4
case|:
case|case
name|R_SH_GOTPLT10BY8
case|:
endif|#
directive|endif
comment|/* If this is a local symbol, we resolve it directly without 	     creating a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
goto|goto
name|force_got
goto|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|gotplt_refcount
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|R_SH_PLT32
case|:
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
case|case
name|R_SH_PLT_LOW16
case|:
case|case
name|R_SH_PLT_MEDLOW16
case|:
case|case
name|R_SH_PLT_MEDHI16
case|:
case|case
name|R_SH_PLT_HI16
case|:
endif|#
directive|endif
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol, 	     because this might be a case of linking PIC code which is 	     never referenced by a dynamic object, in which case we 	     don't need to generate a procedure linkage table entry 	     after all.  */
comment|/* If this is a local symbol, we resolve it directly without 	     creating a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
condition|)
break|break;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|R_SH_DIR32
case|:
case|case
name|R_SH_REL32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  We account for that 	     possibility below by storing information in the 	     dyn_relocs field of the hash table entry. A similar 	     situation occurs when creating shared libraries and symbol 	     visibility changes render the symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_SH_REL32
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|struct
name|elf_sh_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_sh_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
comment|/* When creating a shared object, we must copy these 		 reloc types into the output file.  We create a reloc 		 section in dynobj and make room for this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_READONLY
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|elf_sh_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Track dynamic relocs needed for local syms too.  */
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|elf_sh_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_sh_dyn_relocs
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
name|amt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_SH_REL32
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|sh_elf_set_mach_from_flags
end_ifndef

begin_function
specifier|static
name|boolean
name|sh_elf_set_mach_from_flags
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|flagword
name|flags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|EF_SH_MACH_MASK
condition|)
block|{
case|case
name|EF_SH1
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
name|bfd_mach_sh
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH2
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
name|bfd_mach_sh2
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH_DSP
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
name|bfd_mach_sh_dsp
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH3
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
name|bfd_mach_sh3
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH3_DSP
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
name|bfd_mach_sh3_dsp
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH3E
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
name|bfd_mach_sh3e
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH_UNKNOWN
case|:
case|case
name|EF_SH4
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
name|bfd_mach_sh4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not sh_elf_set_mach_from_flags */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sh_elf_set_private_flags
end_ifndef

begin_comment
comment|/* Function to keep SH specific file flags.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|sh_elf_set_mach_from_flags
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not sh_elf_set_private_flags */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sh_elf_copy_private_data
end_ifndef

begin_comment
comment|/* Copy backend specific data from one object module to another */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_copy_private_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
return|return
name|sh_elf_set_private_flags
argument_list|(
name|obfd
argument_list|,
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not sh_elf_copy_private_data */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sh_elf_merge_private_data
end_ifndef

begin_comment
comment|/* This routine checks for linking big and little endian objects    together, and for linking sh-dsp with sh3e / sh4 objects.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_merge_private_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|old_flags
decl_stmt|,
name|new_flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* This happens when ld starts out with a 'blank' output file.  */
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|EF_SH1
expr_stmt|;
block|}
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|(
name|EF_SH_HAS_DSP
argument_list|(
name|old_flags
argument_list|)
operator|&&
name|EF_SH_HAS_FP
argument_list|(
name|new_flags
argument_list|)
operator|)
operator|||
operator|(
name|EF_SH_HAS_DSP
argument_list|(
name|new_flags
argument_list|)
operator|&&
name|EF_SH_HAS_FP
argument_list|(
name|old_flags
argument_list|)
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: uses %s instructions while previous modules use %s instructions"
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|EF_SH_HAS_DSP
argument_list|(
name|new_flags
argument_list|)
condition|?
literal|"dsp"
else|:
literal|"floating point"
argument_list|,
name|EF_SH_HAS_DSP
argument_list|(
name|new_flags
argument_list|)
condition|?
literal|"floating point"
else|:
literal|"dsp"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|EF_SH_MERGE_MACH
argument_list|(
name|old_flags
argument_list|,
name|new_flags
argument_list|)
expr_stmt|;
return|return
name|sh_elf_set_mach_from_flags
argument_list|(
name|obfd
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not sh_elf_merge_private_data */
end_comment

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|htab
operator|=
name|sh_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
name|sgot
operator|=
name|htab
operator|->
name|sgotplt
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the index in the procedure linkage table which 	 corresponds to this symbol.  This is the index of this symbol 	 in all the symbols for which we are making plt entries.  The 	 first entry in the procedure linkage table is reserved.  */
name|plt_index
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
name|elf_sh_sizeof_plt
argument_list|(
name|info
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Get the offset into the .got table of the entry that 	 corresponds to this function.  Each .got entry is 4 bytes. 	 The first three are reserved.  */
name|got_offset
operator|=
operator|(
name|plt_index
operator|+
literal|3
operator|)
operator|*
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|GOT_BIAS
name|got_offset
operator|-=
name|GOT_BIAS
expr_stmt|;
endif|#
directive|endif
comment|/* Fill in the entry in the procedure linkage table.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|elf_sh_plt_entry
operator|==
name|NULL
condition|)
block|{
name|elf_sh_plt_entry
operator|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_sh_plt_entry_be
else|:
name|elf_sh_plt_entry_le
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_sh_plt_entry
argument_list|,
name|elf_sh_sizeof_plt
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
name|movi_shori_putval
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh_plt_symbol_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|movi_shori_putval
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh_plt_plt0_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh_plt_symbol_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh_plt_plt0_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|elf_sh_pic_plt_entry
operator|==
name|NULL
condition|)
block|{
name|elf_sh_pic_plt_entry
operator|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_sh_pic_plt_entry_be
else|:
name|elf_sh_pic_plt_entry_le
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_sh_pic_plt_entry
argument_list|,
name|elf_sh_sizeof_plt
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
name|movi_shori_putval
argument_list|(
name|output_bfd
argument_list|,
name|got_offset
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh_plt_symbol_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_offset
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh_plt_symbol_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|GOT_BIAS
name|got_offset
operator|+=
name|GOT_BIAS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
name|movi_shori_putval
argument_list|(
name|output_bfd
argument_list|,
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh_plt_reloc_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh_plt_reloc_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fill in the entry in the global offset table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh_plt_temp_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rela.plt section.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_JMP_SLOT
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|GOT_BIAS
name|rel
operator|.
name|r_addend
operator|=
name|GOT_BIAS
expr_stmt|;
endif|#
directive|endif
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srel
operator|->
name|contents
operator|+
name|plt_index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it 	 up.  */
name|sgot
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a static link, or it is a -Bsymbolic link and the 	 symbol is defined locally or was forced to be local because 	 of a version file, we just want to emit a RELATIVE reloc. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SH_RELATIVE
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_GLOB_DAT
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srel
operator|->
name|contents
operator|+
name|srel
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|srel
operator|->
name|reloc_count
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_COPY
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_elf_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_sh_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|htab
operator|=
name|sh_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
name|sgot
operator|=
name|htab
operator|->
name|sgotplt
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_PLTGOT
case|:
name|s
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_section
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_JMPREL
case|:
name|s
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|output_section
expr_stmt|;
name|get_vma
label|:
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|output_section
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* My reading of the SVR4 ABI indicates that the 		 procedure linkage table relocs (DT_JMPREL) should be 		 included in the overall relocs (DT_RELA).  This is 		 what Solaris does.  However, UnixWare can not handle 		 that case.  Therefore, we override the DT_RELASZ entry 		 here to make it not include the JMPREL relocs.  Since 		 the linker script arranges for .rela.plt to follow all 		 other relocation sections, we don't have to worry 		 about changing the DT_RELA entry.  */
if|if
condition|(
name|htab
operator|->
name|srelplt
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
name|splt
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
if|if
condition|(
name|splt
operator|&&
name|splt
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|elf_sh_pic_plt_entry
operator|==
name|NULL
condition|)
block|{
name|elf_sh_pic_plt_entry
operator|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_sh_pic_plt_entry_be
else|:
name|elf_sh_pic_plt_entry_le
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_sh_pic_plt_entry
argument_list|,
name|elf_sh_sizeof_plt
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|elf_sh_plt0_entry
operator|==
name|NULL
condition|)
block|{
name|elf_sh_plt0_entry
operator|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_sh_plt0_entry_be
else|:
name|elf_sh_plt0_entry_le
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_sh_plt0_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_SHMEDIA
name|movi_shori_putval
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|elf_sh_plt0_gotplt_offset
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|4
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|elf_sh_plt0_gotid_offset
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|8
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|elf_sh_plt0_linker_offset
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* UnixWare sets the entsize of .plt to 4, although that doesn't 	     really seem like the right value.  */
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
block|}
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|sgot
operator|&&
name|sgot
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|sh_elf_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SH_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_SH_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_SH_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ELF_ARCH
end_ifndef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_sh_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-sh"
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_shl_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-shl"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_sh
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_SH
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|128
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ELF_ARCH */
end_comment

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|sh_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|sh_elf_info_to_howto
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|sh_elf_relax_section
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|sh_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|sh_elf_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|sh_elf_set_mach_from_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_bfd_flags
define|\
value|sh_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
define|\
value|sh_elf_copy_private_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
define|\
value|sh_elf_merge_private_data
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|sh_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|sh_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|sh_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
define|\
value|sh_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|sh_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|sh_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|sh_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|sh_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|sh_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|sh_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|sh_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|PLT_ENTRY_SIZE
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

