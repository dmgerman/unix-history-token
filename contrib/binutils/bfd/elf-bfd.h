begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end data structures for ELF files.    Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBELF_H_
end_ifndef

begin_define
define|#
directive|define
name|_LIBELF_H_
value|1
end_define

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/internal.h"
end_include

begin_include
include|#
directive|include
file|"elf/external.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_comment
comment|/* The number of entries in a section is its size divided by the size    of a single entry.  This is normally only applicable to reloc and    symbol table sections.  */
end_comment

begin_define
define|#
directive|define
name|NUM_SHDR_ENTRIES
parameter_list|(
name|shdr
parameter_list|)
value|((shdr)->sh_size / (shdr)->sh_entsize)
end_define

begin_comment
comment|/* If size isn't specified as 64 or 32, NAME macro should fail.  */
end_comment

begin_comment
comment|/* Do not "beautify" the CONCAT* macro args.  Traditional C will not    remove whitespace added here, and thus will fail to concatenate    the tokens.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME
end_ifndef

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CONCAT4 (x,64,_,y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CONCAT4 (x,32,_,y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NAME
end_ifndef

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CONCAT4 (x,NOSIZE,_,y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ElfNAME
parameter_list|(
name|X
parameter_list|)
value|NAME(Elf,X)
end_define

begin_define
define|#
directive|define
name|elfNAME
parameter_list|(
name|X
parameter_list|)
value|NAME(elf,X)
end_define

begin_comment
comment|/* Information held for an ELF symbol.  The first field is the    corresponding asymbol.  Every symbol is an ELF file is actually a    pointer to this structure, although it is often handled as a    pointer to an asymbol.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The BFD symbol.  */
name|asymbol
name|symbol
decl_stmt|;
comment|/* ELF symbol information.  */
name|Elf_Internal_Sym
name|internal_elf_sym
decl_stmt|;
comment|/* Backend specific information.  */
union|union
block|{
name|unsigned
name|int
name|hppa_arg_reloc
decl_stmt|;
name|PTR
name|mips_extr
decl_stmt|;
name|PTR
name|any
decl_stmt|;
block|}
name|tc_data
union|;
comment|/* Version information.  This is from an Elf_Internal_Versym      structure in a SHT_GNU_versym section.  It is zero if there is no      version information.  */
name|unsigned
name|short
name|version
decl_stmt|;
block|}
name|elf_symbol_type
typedef|;
end_typedef

begin_escape
end_escape

begin_struct_decl
struct_decl|struct
name|elf_strtab_hash
struct_decl|;
end_struct_decl

begin_comment
comment|/* ELF linker hash table entries.  */
end_comment

begin_struct
struct|struct
name|elf_link_hash_entry
block|{
name|struct
name|bfd_link_hash_entry
name|root
decl_stmt|;
comment|/* Symbol index in output file.  This is initialized to -1.  It is      set to -2 if the symbol is used by a reloc.  */
name|long
name|indx
decl_stmt|;
comment|/* Symbol index as a dynamic symbol.  Initialized to -1, and remains      -1 if this is not a dynamic symbol.  */
comment|/* ??? Note that this is consistently used as a synonym for tests      against whether we can perform various simplifying transformations      to the code.  (E.g. changing a pc-relative jump to a PLT entry      into a pc-relative jump to the target function.)  That test, which      is often relatively complex, and someplaces wrong or incomplete,      should really be replaced by a predicate in elflink.c.       End result: this field -1 does not indicate that the symbol is      not in the dynamic symbol table, but rather that the symbol is      not visible outside this DSO.  */
name|long
name|dynindx
decl_stmt|;
comment|/* String table index in .dynstr if this is a dynamic symbol.  */
name|unsigned
name|long
name|dynstr_index
decl_stmt|;
comment|/* Hash value of the name computed using the ELF hash function.  */
name|unsigned
name|long
name|elf_hash_value
decl_stmt|;
comment|/* If this is a weak defined symbol from a dynamic object, this      field points to a defined symbol with the same value, if there is      one.  Otherwise it is NULL.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|weakdef
decl_stmt|;
comment|/* If this symbol is used in the linker created sections, the processor      specific backend uses this field to map the field into the offset      from the beginning of the section.  */
name|struct
name|elf_linker_section_pointers
modifier|*
name|linker_section_pointer
decl_stmt|;
comment|/* Version information.  */
union|union
block|{
comment|/* This field is used for a symbol which is not defined in a        regular object.  It points to the version information read in        from the dynamic object.  */
name|Elf_Internal_Verdef
modifier|*
name|verdef
decl_stmt|;
comment|/* This field is used for a symbol which is defined in a regular        object.  It is set up in size_dynamic_sections.  It points to        the version information we should write out for this symbol.  */
name|struct
name|bfd_elf_version_tree
modifier|*
name|vertree
decl_stmt|;
block|}
name|verinfo
union|;
comment|/* Virtual table entry use information.  This array is nominally of size      size/sizeof(target_void_pointer), though we have to be able to assume      and track a size while the symbol is still undefined.  It is indexed      via offset/sizeof(target_void_pointer).  */
name|size_t
name|vtable_entries_size
decl_stmt|;
name|boolean
modifier|*
name|vtable_entries_used
decl_stmt|;
comment|/* Virtual table derivation info.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|vtable_parent
decl_stmt|;
comment|/* If this symbol requires an entry in the global offset table, the      processor specific backend uses this field to track usage and      final offset.  We use a union and two names primarily to document      the intent of any particular piece of code.  The field should be      used as a count until size_dynamic_sections, at which point the      contents of the .got is fixed.  Afterward, if this field is -1,      then the symbol does not require a global offset table entry.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|got
union|;
comment|/* Same, but tracks a procedure linkage table entry.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|plt
union|;
comment|/* Symbol size.  */
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Symbol type (STT_NOTYPE, STT_OBJECT, etc.).  */
name|char
name|type
decl_stmt|;
comment|/* Symbol st_other value, symbol visibility.  */
name|unsigned
name|char
name|other
decl_stmt|;
comment|/* Some flags; legal values follow.  */
name|unsigned
name|short
name|elf_link_hash_flags
decl_stmt|;
comment|/* Symbol is referenced by a non-shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_REF_REGULAR
value|01
comment|/* Symbol is defined by a non-shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_DEF_REGULAR
value|02
comment|/* Symbol is referenced by a shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_REF_DYNAMIC
value|04
comment|/* Symbol is defined by a shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_DEF_DYNAMIC
value|010
comment|/* Symbol has a non-weak reference from a non-shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
value|020
comment|/* Dynamic symbol has been adjustd.  */
define|#
directive|define
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
value|040
comment|/* Symbol needs a copy reloc.  */
define|#
directive|define
name|ELF_LINK_HASH_NEEDS_COPY
value|0100
comment|/* Symbol needs a procedure linkage table entry.  */
define|#
directive|define
name|ELF_LINK_HASH_NEEDS_PLT
value|0200
comment|/* Symbol appears in a non-ELF input file.  */
define|#
directive|define
name|ELF_LINK_NON_ELF
value|0400
comment|/* Symbol should be marked as hidden in the version information.  */
define|#
directive|define
name|ELF_LINK_HIDDEN
value|01000
comment|/* Symbol was forced to local scope due to a version script file.  */
define|#
directive|define
name|ELF_LINK_FORCED_LOCAL
value|02000
comment|/* Symbol was marked during garbage collection.  */
define|#
directive|define
name|ELF_LINK_HASH_MARK
value|04000
comment|/* Symbol is referenced by a non-GOT/non-PLT relocation.  This is      not currently set by all the backends.  */
define|#
directive|define
name|ELF_LINK_NON_GOT_REF
value|010000
block|}
struct|;
end_struct

begin_comment
comment|/* Records local symbols to be emitted in the dynamic symbol table.  */
end_comment

begin_struct
struct|struct
name|elf_link_local_dynamic_entry
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|next
decl_stmt|;
comment|/* The input bfd this symbol came from.  */
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
comment|/* The index of the local symbol being copied.  */
name|long
name|input_indx
decl_stmt|;
comment|/* The index in the outgoing dynamic symbol table.  */
name|long
name|dynindx
decl_stmt|;
comment|/* A copy of the input symbol.  */
name|Elf_Internal_Sym
name|isym
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|elf_link_info_type
block|{
name|ELF_INFO_TYPE_NONE
block|,
name|ELF_INFO_TYPE_STABS
block|,
name|ELF_INFO_TYPE_MERGE
block|,
name|ELF_INFO_TYPE_EH_FRAME
block|,
name|ELF_INFO_TYPE_EH_FRAME_HDR
block|,
name|ELF_INFO_TYPE_LAST
block|}
enum|;
end_enum

begin_comment
comment|/* ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_link_hash_table
block|{
name|struct
name|bfd_link_hash_table
name|root
decl_stmt|;
comment|/* Whether we have created the special dynamic sections required      when linking against or generating a shared object.  */
name|boolean
name|dynamic_sections_created
decl_stmt|;
comment|/* The BFD used to hold special sections created by the linker.      This will be the first BFD found which requires these sections to      be created.  */
name|bfd
modifier|*
name|dynobj
decl_stmt|;
comment|/* The value to use when initialising got.refcount/offset and      plt.refcount/offset in an elf_link_hash_entry.  Set to zero when      the values are refcounts.  Set to -1 in size_dynamic_sections      when the values may be offsets.  */
name|bfd_signed_vma
name|init_refcount
decl_stmt|;
comment|/* The number of symbols found in the link which must be put into      the .dynsym section.  */
name|bfd_size_type
name|dynsymcount
decl_stmt|;
comment|/* The string table of dynamic symbols, which becomes the .dynstr      section.  */
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
decl_stmt|;
comment|/* The number of buckets in the hash table in the .hash section.      This is based on the number of dynamic symbols.  */
name|bfd_size_type
name|bucketcount
decl_stmt|;
comment|/* A linked list of DT_NEEDED names found in dynamic objects      included in the link.  */
name|struct
name|bfd_link_needed_list
modifier|*
name|needed
decl_stmt|;
comment|/* The _GLOBAL_OFFSET_TABLE_ symbol.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|hgot
decl_stmt|;
comment|/* A pointer to information used to link stabs in sections.  */
name|PTR
name|stab_info
decl_stmt|;
comment|/* A pointer to information used to merge SEC_MERGE sections.  */
name|PTR
name|merge_info
decl_stmt|;
comment|/* A linked list of local symbols to be added to .dynsym.  */
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|dynlocal
decl_stmt|;
comment|/* A linked list of DT_RPATH/DT_RUNPATH names found in dynamic      objects included in the link.  */
name|struct
name|bfd_link_needed_list
modifier|*
name|runpath
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in an ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct elf_link_hash_entry *)					\    bfd_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse an ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(bfd_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf_hash_table
parameter_list|(
name|p
parameter_list|)
value|((struct elf_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Returns true if the hash table is a struct elf_link_hash_table.  */
end_comment

begin_define
define|#
directive|define
name|is_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((p)->hash->type == bfd_link_elf_hash_table)
end_define

begin_comment
comment|/* Used by bfd_section_from_r_symndx to cache a small number of local    symbol to section mappings.  */
end_comment

begin_define
define|#
directive|define
name|LOCAL_SYM_CACHE_SIZE
value|32
end_define

begin_struct
struct|struct
name|sym_sec_cache
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|indx
index|[
name|LOCAL_SYM_CACHE_SIZE
index|]
decl_stmt|;
name|asection
modifier|*
name|sec
index|[
name|LOCAL_SYM_CACHE_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Constant information held for an ELF backend.  */
end_comment

begin_struct
struct|struct
name|elf_size_info
block|{
name|unsigned
name|char
name|sizeof_ehdr
decl_stmt|,
name|sizeof_phdr
decl_stmt|,
name|sizeof_shdr
decl_stmt|;
name|unsigned
name|char
name|sizeof_rel
decl_stmt|,
name|sizeof_rela
decl_stmt|,
name|sizeof_sym
decl_stmt|,
name|sizeof_dyn
decl_stmt|,
name|sizeof_note
decl_stmt|;
comment|/* The size of entries in the .hash section.  */
name|unsigned
name|char
name|sizeof_hash_entry
decl_stmt|;
comment|/* The number of internal relocations to allocate per external      relocation entry.  */
name|unsigned
name|char
name|int_rels_per_ext_rel
decl_stmt|;
name|unsigned
name|char
name|arch_size
decl_stmt|,
name|file_align
decl_stmt|;
name|unsigned
name|char
name|elfclass
decl_stmt|,
name|ev_current
decl_stmt|;
name|int
argument_list|(
argument|*write_out_phdrs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
name|boolean
argument_list|(
argument|*write_shdrs_and_ehdr
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*write_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*swap_symbol_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
name|boolean
argument_list|(
argument|*slurp_reloc_table
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
expr_stmt|;
name|long
argument_list|(
argument|*slurp_symbol_table
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*swap_dyn_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*swap_dyn_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Dyn
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, is called to swap in a REL      relocation.  If an external relocation corresponds to more than      one internal relocation, then all relocations are swapped in at      once.  */
name|void
argument_list|(
argument|*swap_reloc_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, is called to swap out a REL      relocation.  */
name|void
argument_list|(
argument|*swap_reloc_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rel
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, is called to swap in a RELA      relocation.  If an external relocation corresponds to more than      one internal relocation, then all relocations are swapped in at      once.  */
name|void
argument_list|(
argument|*swap_reloca_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, is called to swap out a RELA      relocation.  */
name|void
argument_list|(
argument|*swap_reloca_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_symbol_from
parameter_list|(
name|ABFD
parameter_list|,
name|S
parameter_list|)
define|\
value|(((S)->the_bfd->xvec->flavour == bfd_target_elf_flavour \&& (S)->the_bfd->tdata.elf_obj_data != 0) \ 	 ? (elf_symbol_type *) (S) \ 	 : 0)
end_define

begin_enum
enum|enum
name|elf_reloc_type_class
block|{
name|reloc_class_normal
block|,
name|reloc_class_relative
block|,
name|reloc_class_plt
block|,
name|reloc_class_copy
block|}
enum|;
end_enum

begin_struct
struct|struct
name|elf_reloc_cookie
block|{
name|Elf_Internal_Rela
modifier|*
name|rels
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|PTR
name|locsyms
decl_stmt|;
name|PTR
name|locsym_shndx
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|size_t
name|locsymcount
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|boolean
name|bad_symtab
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf_backend_data
block|{
comment|/* The architecture for this backend.  */
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
comment|/* The ELF machine code (EM_xxxx) for this backend.  */
name|int
name|elf_machine_code
decl_stmt|;
comment|/* The maximum page size for this backend.  */
name|bfd_vma
name|maxpagesize
decl_stmt|;
comment|/* A function to translate an ELF RELA relocation to a BFD arelent      structure.  */
name|void
argument_list|(
argument|*elf_info_to_howto
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to translate an ELF REL relocation to a BFD arelent      structure.  */
name|void
argument_list|(
argument|*elf_info_to_howto_rel
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to determine whether a symbol is global when      partitioning the symbol table into local and global symbols.      This should be NULL for most targets, in which case the correct      thing will be done.  MIPS ELF, at least on the Irix 5, has      special requirements.  */
name|boolean
argument_list|(
argument|*elf_backend_sym_is_global
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* The remaining functions are hooks which are called only if they      are not NULL.  */
comment|/* A function to permit a backend specific check on whether a      particular BFD format is relevant for an object file, and to      permit the backend to set any global information it wishes.  When      this is called elf_elfheader is set, but anything else should be      used with caution.  If this returns false, the check_format      routine will return a bfd_error_wrong_format error.  */
name|boolean
argument_list|(
argument|*elf_backend_object_p
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do additional symbol processing when reading the      ELF symbol table.  This is where any processor-specific special      section indices are handled.  */
name|void
argument_list|(
argument|*elf_backend_symbol_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do additional symbol processing after reading the      entire ELF symbol table.  */
name|boolean
argument_list|(
argument|*elf_backend_symbol_table_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|elf_symbol_type
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to set the type of the info field.  Processor-specific      types should be handled here.  */
name|int
argument_list|(
argument|*elf_backend_get_symbol_type
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Sym
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do additional processing on the ELF section header      just before writing it out.  This is used to set the flags and      type fields for some sections, or to actually write out data for      unusual sections.  */
name|boolean
argument_list|(
argument|*elf_backend_section_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to handle unusual section types when creating BFD      sections from ELF sections.  */
name|boolean
argument_list|(
argument|*elf_backend_section_from_shdr
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to convert machine dependent section header flags to      BFD internal section header flags.  */
name|boolean
argument_list|(
argument|*elf_backend_section_flags
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to handle unusual program segment types when creating BFD      sections from ELF program segments.  */
name|boolean
argument_list|(
argument|*elf_backend_section_from_phdr
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Phdr
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to set up the ELF section header for a BFD section in      preparation for writing it out.  This is where the flags and type      fields are set for unusual sections.  */
name|boolean
argument_list|(
argument|*elf_backend_fake_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to get the ELF section index for a BFD section.  If      this returns true, the section was found.  If it is a normal ELF      section, *RETVAL should be left unchanged.  If it is not a normal      ELF section *RETVAL should be set to the SHN_xxxx index.  */
name|boolean
argument_list|(
argument|*elf_backend_section_from_bfd_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|int
operator|*
name|retval
operator|)
argument_list|)
expr_stmt|;
comment|/* If this field is not NULL, it is called by the add_symbols phase      of a link just before adding a symbol to the global linker hash      table.  It may modify any of the fields as it wishes.  If *NAME      is set to NULL, the symbol will be skipped rather than being      added to the hash table.  This function is responsible for      handling all processor dependent symbol bindings and section      indices, and must set at least *FLAGS and *SEC for each processor      dependent case; failure to do so will cause a link error.  */
name|boolean
argument_list|(
argument|*elf_add_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
name|name
operator|,
name|flagword
operator|*
name|flags
operator|,
name|asection
operator|*
operator|*
name|sec
operator|,
name|bfd_vma
operator|*
name|value
operator|)
argument_list|)
expr_stmt|;
comment|/* If this field is not NULL, it is called by the elf_link_output_sym      phase of a link for each symbol which will appear in the object file.  */
name|boolean
argument_list|(
argument|*elf_backend_link_output_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* The CREATE_DYNAMIC_SECTIONS function is called by the ELF backend      linker the first time it encounters a dynamic object in the link.      This function must create any sections required for dynamic      linking.  The ABFD argument is a dynamic object.  The .interp,      .dynamic, .dynsym, .dynstr, and .hash functions have already been      created, and this function may modify the section flags if      desired.  This function will normally create the .got and .plt      sections, but different backends have different requirements.  */
name|boolean
argument_list|(
argument|*elf_backend_create_dynamic_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* The CHECK_RELOCS function is called by the add_symbols phase of      the ELF backend linker.  It is called once for each section with      relocs of an object file, just after the symbols for the object      file have been added to the global linker hash table.  The      function must look through the relocs and do any special handling      required.  This generally means allocating space in the global      offset table, and perhaps allocating space for a reloc.  The      relocs are always passed as Rela structures; if the section      actually uses Rel structures, the r_addend field will always be      zero.  */
name|boolean
argument_list|(
argument|*check_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|o
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|relocs
operator|)
argument_list|)
expr_stmt|;
comment|/* The ADJUST_DYNAMIC_SYMBOL function is called by the ELF backend      linker for every symbol which is defined by a dynamic object and      referenced by a regular object.  This is called after all the      input files have been seen, but before the SIZE_DYNAMIC_SECTIONS      function has been called.  The hash table entry should be      bfd_link_hash_defined ore bfd_link_hash_defweak, and it should be      defined in a section from a dynamic object.  Dynamic object      sections are not included in the final link, and this function is      responsible for changing the value to something which the rest of      the link can deal with.  This will normally involve adding an      entry to the .plt or .got or some such section, and setting the      symbol to point to that.  */
name|boolean
argument_list|(
argument|*elf_backend_adjust_dynamic_symbol
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* The ALWAYS_SIZE_SECTIONS function is called by the backend linker      after all the linker input files have been seen but before the      section sizes have been set.  This is called after      ADJUST_DYNAMIC_SYMBOL, but before SIZE_DYNAMIC_SECTIONS.  */
name|boolean
argument_list|(
argument|*elf_backend_always_size_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* The SIZE_DYNAMIC_SECTIONS function is called by the ELF backend      linker after all the linker input files have been seen but before      the sections sizes have been set.  This is called after      ADJUST_DYNAMIC_SYMBOL has been called on all appropriate symbols.      It is only called when linking against a dynamic object.  It must      set the sizes of the dynamic sections, and may fill in their      contents as well.  The generic ELF linker can handle the .dynsym,      .dynstr and .hash sections.  This function must handle the      .interp section and any sections created by the      CREATE_DYNAMIC_SECTIONS entry point.  */
name|boolean
argument_list|(
argument|*elf_backend_size_dynamic_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker      to handle the relocations for a section.       The relocs are always passed as Rela structures; if the section      actually uses Rel structures, the r_addend field will always be      zero.       This function is responsible for adjust the section contents as      necessary, and (if using Rela relocs and generating a      relocateable output file) adjusting the reloc addend as      necessary.       This function does not have to worry about setting the reloc      address or the reloc symbol index.       LOCAL_SYMS is a pointer to the swapped in local symbols.       LOCAL_SECTIONS is an array giving the section in the input file      corresponding to the st_shndx field of each local symbol.       The global hash table entry for the global symbols can be found      via elf_sym_hashes (input_bfd).       When generating relocateable output, this function must handle      STB_LOCAL/STT_SECTION symbols specially.  The output symbol is      going to be the section symbol corresponding to the output      section, which means that the addend must be adjusted      accordingly.  */
name|boolean
argument_list|(
argument|*elf_backend_relocate_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd_byte
operator|*
name|contents
operator|,
name|Elf_Internal_Rela
operator|*
name|relocs
operator|,
name|Elf_Internal_Sym
operator|*
name|local_syms
operator|,
name|asection
operator|*
operator|*
name|local_sections
operator|)
argument_list|)
expr_stmt|;
comment|/* The FINISH_DYNAMIC_SYMBOL function is called by the ELF backend      linker just before it writes a symbol out to the .dynsym section.      The processor backend may make any required adjustment to the      symbol.  It may also take the opportunity to set contents of the      dynamic sections.  Note that FINISH_DYNAMIC_SYMBOL is called on      all .dynsym symbols, while ADJUST_DYNAMIC_SYMBOL is only called      on those symbols which are defined by a dynamic object.  */
name|boolean
argument_list|(
argument|*elf_backend_finish_dynamic_symbol
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|Elf_Internal_Sym
operator|*
name|sym
operator|)
argument_list|)
expr_stmt|;
comment|/* The FINISH_DYNAMIC_SECTIONS function is called by the ELF backend      linker just before it writes all the dynamic sections out to the      output file.  The FINISH_DYNAMIC_SYMBOL will have been called on      all dynamic symbols.  */
name|boolean
argument_list|(
argument|*elf_backend_finish_dynamic_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do any beginning processing needed for the ELF file      before building the ELF headers and computing file positions.  */
name|void
argument_list|(
argument|*elf_backend_begin_write_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do any final processing needed for the ELF file      before writing it out.  The LINKER argument is true if this BFD      was created by the ELF backend linker.  */
name|void
argument_list|(
argument|*elf_backend_final_write_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
name|linker
operator|)
argument_list|)
expr_stmt|;
comment|/* This function is called by get_program_header_size.  It should      return the number of additional program segments which this BFD      will need.  It should return -1 on error.  */
name|int
argument_list|(
argument|*elf_backend_additional_program_headers
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function is called to modify an existing segment map in a      backend specific fashion.  */
name|boolean
argument_list|(
argument|*elf_backend_modify_segment_map
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function is called during section gc to discover the section a      particular relocation refers to.  It need not be defined for hosts      that have no queer relocation types.  */
name|asection
operator|*
operator|(
operator|*
name|gc_mark_hook
operator|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, is called during the sweep phase of gc      in order that a backend might update any data structures it might      be maintaining.  */
name|boolean
argument_list|(
argument|*gc_sweep_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|o
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|relocs
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, is called after the ELF headers have      been created.  This allows for things like the OS and ABI versions      to be changed.  */
name|void
argument_list|(
argument|*elf_backend_post_process_headers
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, prints a symbol to file and returns the      name of the symbol to be printed.  It should return NULL to fall      back to default symbol printing.  */
specifier|const
name|char
operator|*
operator|(
operator|*
name|elf_backend_print_symbol_all
operator|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, is called after all local symbols and      global symbols converted to locals are emited into the symtab      section.  It allows the backend to emit special global symbols      not handled in the hash table.  */
name|boolean
argument_list|(
argument|*elf_backend_output_arch_syms
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|PTR
operator|,
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|PTR
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|Elf_Internal_Sym
operator|*
argument_list|,
name|asection
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy any information related to dynamic linking from a pre-existing       symbol to a newly created symbol.  Also called to copy flags and      other back-end info to a weakdef, in which case the symbol is not      newly created and plt/got refcounts and dynamic indices should not      be copied.  */
name|void
argument_list|(
argument|*elf_backend_copy_indirect_symbol
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Modify any information related to dynamic linking such that the      symbol is not exported.  */
name|void
argument_list|(
argument|*elf_backend_hide_symbol
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|boolean
operator|)
argument_list|)
expr_stmt|;
comment|/* Emit relocations.  Overrides default routine for emitting relocs,      except during a relocatable link, or if all relocs are being emitted.  */
name|void
argument_list|(
argument|*elf_backend_emit_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Count relocations.  Not called for relocatable links      or if all relocs are being preserved in the output.  */
name|unsigned
name|int
argument_list|(
operator|*
name|elf_backend_count_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* This function, if defined, is called when an NT_PRSTATUS note is found      in a core file. */
name|boolean
argument_list|(
argument|*elf_backend_grok_prstatus
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Note
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, is called when an NT_PSINFO or NT_PRPSINFO      note is found in a core file. */
name|boolean
argument_list|(
argument|*elf_backend_grok_psinfo
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Note
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Functions to print VMAs.  Special code to handle 64 bit ELF files.  */
name|void
argument_list|(
argument|* elf_backend_sprintf_vma
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|* elf_backend_fprintf_vma
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
expr_stmt|;
comment|/* This function returns class of a reloc type.  */
name|enum
name|elf_reloc_type_class
argument_list|(
operator|*
name|elf_backend_reloc_type_class
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* This function, if defined, removes information about discarded functions      from other sections which mention them.  */
name|boolean
argument_list|(
argument|*elf_backend_discard_info
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf_reloc_cookie
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, signals that the function above has removed      the discarded relocations for this section.  */
name|boolean
argument_list|(
argument|*elf_backend_ignore_discarded_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function, if defined, may write out the given section.      Returns true if it did so and false if the caller should.  */
name|boolean
argument_list|(
argument|*elf_backend_write_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* The swapping table to use when dealing with ECOFF information.      Used for the MIPS ELF .mdebug section.  */
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|elf_backend_ecoff_debug_swap
decl_stmt|;
comment|/* Alternate EM_xxxx machine codes for this backend.  */
name|int
name|elf_machine_alt1
decl_stmt|;
name|int
name|elf_machine_alt2
decl_stmt|;
specifier|const
name|struct
name|elf_size_info
modifier|*
name|s
decl_stmt|;
comment|/* offset of the _GLOBAL_OFFSET_TABLE_ symbol from the start of the      .got section */
name|bfd_vma
name|got_symbol_offset
decl_stmt|;
comment|/* The size in bytes of the headers for the GOT and PLT.  This includes      the so-called reserved entries on some systems.  */
name|bfd_vma
name|got_header_size
decl_stmt|;
name|bfd_vma
name|plt_header_size
decl_stmt|;
comment|/* This is true if the linker should act like collect and gather      global constructors and destructors by name.  This is true for      MIPS ELF because the Irix 5 tools can not handle the .init      section.  */
name|unsigned
name|collect
range|:
literal|1
decl_stmt|;
comment|/* This is true if the linker should ignore changes to the type of a      symbol.  This is true for MIPS ELF because some Irix 5 objects      record undefined functions as STT_OBJECT although the definitions      are STT_FUNC.  */
name|unsigned
name|type_change_ok
range|:
literal|1
decl_stmt|;
comment|/* Whether the backend may use REL relocations.  (Some backends use      both REL and RELA relocations, and this flag is set for those      backends.)  */
name|unsigned
name|may_use_rel_p
range|:
literal|1
decl_stmt|;
comment|/* Whether the backend may use RELA relocations.  (Some backends use      both REL and RELA relocations, and this flag is set for those      backends.)  */
name|unsigned
name|may_use_rela_p
range|:
literal|1
decl_stmt|;
comment|/* Whether the default relocation type is RELA.  If a backend with      this flag set wants REL relocations for a particular section,      it must note that explicitly.  Similarly, if this flag is clear,      and the backend wants RELA relocations for a particular      section.  */
name|unsigned
name|default_use_rela_p
range|:
literal|1
decl_stmt|;
comment|/* True if addresses "naturally" sign extend.  This is used when      swapping in from Elf32 when BFD64.  */
name|unsigned
name|sign_extend_vma
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_got_plt
range|:
literal|1
decl_stmt|;
name|unsigned
name|plt_readonly
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_plt_sym
range|:
literal|1
decl_stmt|;
name|unsigned
name|plt_not_loaded
range|:
literal|1
decl_stmt|;
name|unsigned
name|plt_alignment
range|:
literal|4
decl_stmt|;
name|unsigned
name|can_gc_sections
range|:
literal|1
decl_stmt|;
name|unsigned
name|can_refcount
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_got_sym
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_dynbss
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information stored for each BFD section in an ELF file.  This    structure is allocated by elf_new_section_hook.  */
end_comment

begin_struct
struct|struct
name|bfd_elf_section_data
block|{
comment|/* The ELF header for this section.  */
name|Elf_Internal_Shdr
name|this_hdr
decl_stmt|;
comment|/* The ELF header for the reloc section associated with this      section, if any.  */
name|Elf_Internal_Shdr
name|rel_hdr
decl_stmt|;
comment|/* If there is a second reloc section associated with this section,      as can happen on Irix 6, this field points to the header.  */
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr2
decl_stmt|;
comment|/* The number of relocations currently assigned to REL_HDR.  */
name|unsigned
name|int
name|rel_count
decl_stmt|;
comment|/* The number of relocations currently assigned to REL_HDR2.  */
name|unsigned
name|int
name|rel_count2
decl_stmt|;
comment|/* A pointer to a linked list tracking dynamic relocs copied for      local symbols.  */
name|PTR
name|local_dynrel
decl_stmt|;
comment|/* A pointer to the bfd section used for dynamic relocs.  */
name|asection
modifier|*
name|sreloc
decl_stmt|;
comment|/* The ELF section number of this section.  Only used for an output      file.  */
name|int
name|this_idx
decl_stmt|;
comment|/* The ELF section number of the reloc section indicated by      REL_HDR if any.  Only used for an output file.  */
name|int
name|rel_idx
decl_stmt|;
comment|/* The ELF section number of the reloc section indicated by      REL_HDR2 if any.  Only used for an output file.  */
name|int
name|rel_idx2
decl_stmt|;
comment|/* Used by the backend linker to store the symbol hash table entries      associated with relocs against global symbols.  */
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hashes
decl_stmt|;
comment|/* A pointer to the swapped relocs.  If the section uses REL relocs,      rather than RELA, all the r_addend fields will be zero.  This      pointer may be NULL.  It is used by the backend linker.  */
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
comment|/* Used by the backend linker when generating a shared library to      record the dynamic symbol index for a section symbol      corresponding to this section.  A value of 0 means that there is      no dynamic symbol for this section.  */
name|long
name|dynindx
decl_stmt|;
comment|/* A pointer used for various section optimizations.  */
name|PTR
name|sec_info
decl_stmt|;
comment|/* Type of that information.  */
name|enum
name|elf_link_info_type
name|sec_info_type
decl_stmt|;
comment|/* Group name, if this section is part of a group.  */
specifier|const
name|char
modifier|*
name|group_name
decl_stmt|;
comment|/* A linked list of sections in the group.  Circular when used by      the linker.  */
name|asection
modifier|*
name|next_in_group
decl_stmt|;
comment|/* A pointer available for the processor specific ELF backend.  */
name|PTR
name|tdata
decl_stmt|;
comment|/* Nonzero if this section uses RELA relocations, rather than REL.  */
name|unsigned
name|int
name|use_rela_p
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_section_data
parameter_list|(
name|sec
parameter_list|)
value|((struct bfd_elf_section_data*)sec->used_by_bfd)
end_define

begin_define
define|#
directive|define
name|elf_group_name
parameter_list|(
name|sec
parameter_list|)
value|(elf_section_data(sec)->group_name)
end_define

begin_define
define|#
directive|define
name|elf_next_in_group
parameter_list|(
name|sec
parameter_list|)
value|(elf_section_data(sec)->next_in_group)
end_define

begin_comment
comment|/* Return true if section has been discarded.  */
end_comment

begin_define
define|#
directive|define
name|elf_discarded_section
parameter_list|(
name|sec
parameter_list|)
define|\
value|(!bfd_is_abs_section(sec)						\&& bfd_is_abs_section((sec)->output_section)				\&& elf_section_data (sec)->sec_info_type != ELF_INFO_TYPE_MERGE)
end_define

begin_define
define|#
directive|define
name|get_elf_backend_data
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct elf_backend_data *) (abfd)->xvec->backend_data)
end_define

begin_comment
comment|/* Enumeration to specify the special section.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|elf_linker_section_enum
block|{
name|LINKER_SECTION_UNKNOWN
block|,
comment|/* not used */
name|LINKER_SECTION_GOT
block|,
comment|/* .got section for global offset pointers */
name|LINKER_SECTION_PLT
block|,
comment|/* .plt section for generated procedure stubs */
name|LINKER_SECTION_SDATA
block|,
comment|/* .sdata/.sbss section for PowerPC */
name|LINKER_SECTION_SDATA2
block|,
comment|/* .sdata2/.sbss2 section for PowerPC */
name|LINKER_SECTION_MAX
comment|/* # of linker sections */
block|}
name|elf_linker_section_enum_t
typedef|;
end_typedef

begin_comment
comment|/* Sections created by the linker.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|elf_linker_section
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the section */
name|char
modifier|*
name|rel_name
decl_stmt|;
comment|/* name of the associated .rel{,a}. section */
name|char
modifier|*
name|bss_name
decl_stmt|;
comment|/* name of a related .bss section */
name|char
modifier|*
name|sym_name
decl_stmt|;
comment|/* name of symbol to reference this section */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* pointer to the section */
name|asection
modifier|*
name|bss_section
decl_stmt|;
comment|/* pointer to the bss section associated with this */
name|asection
modifier|*
name|rel_section
decl_stmt|;
comment|/* pointer to the relocations needed for this section */
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
decl_stmt|;
comment|/* pointer to the created symbol hash value */
name|bfd_vma
name|initial_size
decl_stmt|;
comment|/* initial size before any linker generated allocations */
name|bfd_vma
name|sym_offset
decl_stmt|;
comment|/* offset of symbol from beginning of section */
name|bfd_vma
name|hole_size
decl_stmt|;
comment|/* size of reserved address hole in allocation */
name|bfd_vma
name|hole_offset
decl_stmt|;
comment|/* current offset for the hole */
name|bfd_vma
name|max_hole_offset
decl_stmt|;
comment|/* maximum offset for the hole */
name|elf_linker_section_enum_t
name|which
decl_stmt|;
comment|/* which section this is */
name|boolean
name|hole_written_p
decl_stmt|;
comment|/* whether the hole has been initialized */
name|unsigned
name|int
name|alignment
decl_stmt|;
comment|/* alignment for the section */
name|flagword
name|flags
decl_stmt|;
comment|/* flags to use to create the section */
block|}
name|elf_linker_section_t
typedef|;
end_typedef

begin_comment
comment|/* Linked list of allocated pointer entries.  This hangs off of the symbol lists, and    provides allows us to return different pointers, based on different addend's.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|elf_linker_section_pointers
block|{
name|struct
name|elf_linker_section_pointers
modifier|*
name|next
decl_stmt|;
comment|/* next allocated pointer for this symbol */
name|bfd_vma
name|offset
decl_stmt|;
comment|/* offset of pointer from beginning of section */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* addend used */
name|elf_linker_section_enum_t
name|which
decl_stmt|;
comment|/* which linker section this is */
name|boolean
name|written_address_p
decl_stmt|;
comment|/* whether address was written yet */
block|}
name|elf_linker_section_pointers_t
typedef|;
end_typedef

begin_comment
comment|/* Some private data is stashed away for future use using the tdata pointer    in the bfd structure.  */
end_comment

begin_struct
struct|struct
name|elf_obj_tdata
block|{
name|Elf_Internal_Ehdr
name|elf_header
index|[
literal|1
index|]
decl_stmt|;
comment|/* Actual data, but ref like ptr */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|elf_sect_ptr
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|segment_map
decl_stmt|;
name|struct
name|elf_strtab_hash
modifier|*
name|strtab_ptr
decl_stmt|;
name|int
name|num_locals
decl_stmt|;
name|int
name|num_globals
decl_stmt|;
name|unsigned
name|int
name|num_elf_sections
decl_stmt|;
comment|/* elf_sect_ptr size */
name|int
name|num_section_syms
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|section_syms
decl_stmt|;
comment|/* STT_SECTION symbols for each section */
name|Elf_Internal_Shdr
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|shstrtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|strtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynsymtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynstrtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynversym_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynverref_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynverdef_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|symtab_shndx_hdr
decl_stmt|;
name|unsigned
name|int
name|symtab_section
decl_stmt|,
name|shstrtab_section
decl_stmt|;
name|unsigned
name|int
name|strtab_section
decl_stmt|,
name|dynsymtab_section
decl_stmt|;
name|unsigned
name|int
name|symtab_shndx_section
decl_stmt|;
name|unsigned
name|int
name|dynversym_section
decl_stmt|,
name|dynverdef_section
decl_stmt|,
name|dynverref_section
decl_stmt|;
name|file_ptr
name|next_file_pos
decl_stmt|;
if|#
directive|if
literal|0
comment|/* we don't need these inside bfd anymore, and I think      these weren't used outside bfd.  */
block|void *prstatus;
comment|/* The raw /proc prstatus structure */
block|void *prpsinfo;
comment|/* The raw /proc prpsinfo structure */
endif|#
directive|endif
name|bfd_vma
name|gp
decl_stmt|;
comment|/* The gp value */
name|unsigned
name|int
name|gp_size
decl_stmt|;
comment|/* The gp size */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|group_sect_ptr
decl_stmt|;
name|int
name|num_group
decl_stmt|;
comment|/* Information grabbed from an elf core file.  */
name|int
name|core_signal
decl_stmt|;
name|int
name|core_pid
decl_stmt|;
name|int
name|core_lwpid
decl_stmt|;
name|char
modifier|*
name|core_program
decl_stmt|;
name|char
modifier|*
name|core_command
decl_stmt|;
comment|/* This is set to true if the object was created by the backend      linker.  */
name|boolean
name|linker
decl_stmt|;
comment|/* A mapping from external symbols to entries in the linker hash      table, used when linking.  This is indexed by the symbol index      minus the sh_info field of the symbol table header.  */
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
comment|/* A mapping from local symbols to offsets into the global offset      table, used when linking.  This is indexed by the symbol index.      Like for the globals, we use a union and two names primarily to      document the intent of any particular piece of code.  The field      should be used as a count until size_dynamic_sections, at which      point the contents of the .got is fixed.  Afterward, if an entry      is -1, then the symbol does not require a global offset table entry.  */
union|union
block|{
name|bfd_signed_vma
modifier|*
name|refcounts
decl_stmt|;
name|bfd_vma
modifier|*
name|offsets
decl_stmt|;
block|}
name|local_got
union|;
comment|/* A mapping from local symbols to offsets into the various linker      sections added.  This is index by the symbol index.  */
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|linker_section_pointers
decl_stmt|;
comment|/* The linker ELF emulation code needs to let the backend ELF linker      know what filename should be used for a dynamic object if the      dynamic object is found using a search.  The emulation code then      sometimes needs to know what name was actually used.  Until the      file has been added to the linker symbol table, this field holds      the name the linker wants.  After it has been added, it holds the      name actually used, which will be the DT_SONAME entry if there is      one.  */
specifier|const
name|char
modifier|*
name|dt_name
decl_stmt|;
comment|/* When a reference in a regular object is resolved by a shared      object is loaded into via the DT_NEEDED entries by the linker      ELF emulation code, we need to add the shared object to the      DT_NEEDED list of the resulting binary to indicate the dependency      as if the -l option is passed to the linker. This field holds the      name of the loaded shared object.  */
specifier|const
name|char
modifier|*
name|dt_soname
decl_stmt|;
comment|/* Irix 5 often screws up the symbol table, sorting local symbols      after global symbols.  This flag is set if the symbol table in      this BFD appears to be screwed up.  If it is, we ignore the      sh_info field in the symbol table header, and always read all the      symbols.  */
name|boolean
name|bad_symtab
decl_stmt|;
comment|/* Records the result of `get_program_header_size'.  */
name|bfd_size_type
name|program_header_size
decl_stmt|;
comment|/* Used by find_nearest_line entry point.  */
name|PTR
name|line_info
decl_stmt|;
comment|/* Used by MIPS ELF find_nearest_line entry point.  The structure      could be included directly in this one, but there's no point to      wasting the memory just for the infrequently called      find_nearest_line.  */
name|struct
name|mips_elf_find_line
modifier|*
name|find_line_info
decl_stmt|;
comment|/* A place to stash dwarf1 info for this bfd.  */
name|struct
name|dwarf1_debug
modifier|*
name|dwarf1_find_line_info
decl_stmt|;
comment|/* A place to stash dwarf2 info for this bfd.  */
name|PTR
name|dwarf2_find_line_info
decl_stmt|;
comment|/* An array of stub sections indexed by symbol number, used by the      MIPS ELF linker.  FIXME: We should figure out some way to only      include this field for a MIPS ELF target.  */
name|asection
modifier|*
modifier|*
name|local_stubs
decl_stmt|;
comment|/* Used to determine if the e_flags field has been initialized */
name|boolean
name|flags_init
decl_stmt|;
comment|/* Used to determine if PT_GNU_EH_FRAME segment header should be      created.  */
name|boolean
name|eh_frame_hdr
decl_stmt|;
comment|/* Number of symbol version definitions we are about to emit.  */
name|unsigned
name|int
name|cverdefs
decl_stmt|;
comment|/* Number of symbol version references we are about to emit.  */
name|unsigned
name|int
name|cverrefs
decl_stmt|;
comment|/* Symbol version definitions in external objects.  */
name|Elf_Internal_Verdef
modifier|*
name|verdef
decl_stmt|;
comment|/* Symbol version references to external objects.  */
name|Elf_Internal_Verneed
modifier|*
name|verref
decl_stmt|;
comment|/* Linker sections that we are interested in.  */
name|struct
name|elf_linker_section
modifier|*
name|linker_section
index|[
operator|(
name|int
operator|)
name|LINKER_SECTION_MAX
index|]
decl_stmt|;
comment|/* The Irix 5 support uses two virtual sections, which represent      text/data symbols defined in dynamic objects.  */
name|asymbol
modifier|*
name|elf_data_symbol
decl_stmt|;
name|asymbol
modifier|*
name|elf_text_symbol
decl_stmt|;
name|asection
modifier|*
name|elf_data_section
decl_stmt|;
name|asection
modifier|*
name|elf_text_section
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_tdata
parameter_list|(
name|bfd
parameter_list|)
value|((bfd) -> tdata.elf_obj_data)
end_define

begin_define
define|#
directive|define
name|elf_elfheader
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> elf_header)
end_define

begin_define
define|#
directive|define
name|elf_elfsections
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> elf_sect_ptr)
end_define

begin_define
define|#
directive|define
name|elf_numsections
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> num_elf_sections)
end_define

begin_define
define|#
directive|define
name|elf_shstrtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> strtab_ptr)
end_define

begin_define
define|#
directive|define
name|elf_onesymtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> symtab_section)
end_define

begin_define
define|#
directive|define
name|elf_symtab_shndx
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> symtab_shndx_section)
end_define

begin_define
define|#
directive|define
name|elf_dynsymtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dynsymtab_section)
end_define

begin_define
define|#
directive|define
name|elf_dynversym
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dynversym_section)
end_define

begin_define
define|#
directive|define
name|elf_dynverdef
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dynverdef_section)
end_define

begin_define
define|#
directive|define
name|elf_dynverref
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dynverref_section)
end_define

begin_define
define|#
directive|define
name|elf_num_locals
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> num_locals)
end_define

begin_define
define|#
directive|define
name|elf_num_globals
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> num_globals)
end_define

begin_define
define|#
directive|define
name|elf_section_syms
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> section_syms)
end_define

begin_define
define|#
directive|define
name|elf_num_section_syms
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> num_section_syms)
end_define

begin_define
define|#
directive|define
name|core_prpsinfo
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> prpsinfo)
end_define

begin_define
define|#
directive|define
name|core_prstatus
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> prstatus)
end_define

begin_define
define|#
directive|define
name|elf_gp
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> gp)
end_define

begin_define
define|#
directive|define
name|elf_gp_size
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> gp_size)
end_define

begin_define
define|#
directive|define
name|elf_sym_hashes
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> sym_hashes)
end_define

begin_define
define|#
directive|define
name|elf_local_got_refcounts
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> local_got.refcounts)
end_define

begin_define
define|#
directive|define
name|elf_local_got_offsets
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> local_got.offsets)
end_define

begin_define
define|#
directive|define
name|elf_local_ptr_offsets
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> linker_section_pointers)
end_define

begin_define
define|#
directive|define
name|elf_dt_name
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dt_name)
end_define

begin_define
define|#
directive|define
name|elf_dt_soname
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dt_soname)
end_define

begin_define
define|#
directive|define
name|elf_bad_symtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> bad_symtab)
end_define

begin_define
define|#
directive|define
name|elf_flags_init
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> flags_init)
end_define

begin_define
define|#
directive|define
name|elf_linker_section
parameter_list|(
name|bfd
parameter_list|,
name|n
parameter_list|)
value|(elf_tdata(bfd) -> linker_section[(int)n])
end_define

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verdef_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Verdef
operator|*
operator|,
name|Elf_Internal_Verdef
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verdef_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Verdef
operator|*
operator|,
name|Elf_External_Verdef
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verdaux_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Verdaux
operator|*
operator|,
name|Elf_Internal_Verdaux
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verdaux_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Verdaux
operator|*
operator|,
name|Elf_External_Verdaux
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verneed_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Verneed
operator|*
operator|,
name|Elf_Internal_Verneed
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verneed_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Verneed
operator|*
operator|,
name|Elf_External_Verneed
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_vernaux_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Vernaux
operator|*
operator|,
name|Elf_Internal_Vernaux
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_vernaux_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Vernaux
operator|*
operator|,
name|Elf_External_Vernaux
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_versym_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Versym
operator|*
operator|,
name|Elf_Internal_Versym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_versym_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Versym
operator|*
operator|,
name|Elf_External_Versym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_bfd_elf_section_from_bfd_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf_string_from_elf_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf_get_str_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf_print_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|,
name|bfd_print_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|elf_string_from_elf_strtab
parameter_list|(
name|abfd
parameter_list|,
name|strindex
parameter_list|)
define|\
value|bfd_elf_string_from_elf_section(abfd, elf_elfheader(abfd)->e_shstrndx, \ 				  strindex)
end_define

begin_define
define|#
directive|define
name|bfd_elf32_print_symbol
value|bfd_elf_print_symbol
end_define

begin_define
define|#
directive|define
name|bfd_elf64_print_symbol
value|bfd_elf_print_symbol
end_define

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_sprintf_vma
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_fprintf_vma
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|enum
name|elf_reloc_type_class
name|_bfd_elf_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_vma
name|_bfd_elf_rela_local_sym
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_vma
name|_bfd_elf_rel_local_sym
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_vma
name|_bfd_elf_section_offset
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|bfd_elf_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|bfd_elf_generic_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf_mkcorefile
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Elf_Internal_Shdr
modifier|*
name|bfd_elf_find_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_make_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_make_section_from_phdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_elf_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_elf_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_link_hash_copy_indirect
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_link_hash_hide_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_link_hash_table_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_table
operator|*
operator|,
name|bfd
operator|*
operator|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_slurp_version_tables
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_merge_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_copy_private_symbol_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_copy_private_section_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_write_corefile_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_dynamic_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_canonicalize_dynamic_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_canonicalize_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_dynamic_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_canonicalize_dynamic_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|asymbol
modifier|*
name|_bfd_elf_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|alent
modifier|*
name|_bfd_elf_get_lineno
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|_bfd_elf_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|_bfd_elf_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_decl_stmt
specifier|extern
name|int
name|_bfd_elf_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_init_reloc_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the target doesn't have reloc handling written yet:  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_no_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
name|shindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_section_from_phdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_bfd_elf_symbol_from_bfd_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|asection
modifier|*
name|bfd_section_from_r_symndx
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|sym_sec_cache
operator|*
operator|,
name|asection
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|asection
modifier|*
name|bfd_section_from_elf_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_strtab_hash
modifier|*
name|_bfd_elf_stringtab_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|elf_strtab_hash
modifier|*
name|_bfd_elf_strtab_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_strtab_free
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_strtab_hash
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_size_type
name|_bfd_elf_strtab_add
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_strtab_hash
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_strtab_addref
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_strtab_hash
operator|*
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_strtab_delref
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_strtab_hash
operator|*
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_strtab_clear_all_refs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_strtab_hash
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_size_type
name|_bfd_elf_strtab_size
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_strtab_hash
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_size_type
name|_bfd_elf_strtab_offset
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_strtab_hash
operator|*
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_strtab_emit
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf_strtab_hash
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_strtab_finalize
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_strtab_hash
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_discard_section_eh_frame
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
name|asection
operator|*
operator|,
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd_vma
argument_list|,
name|PTR
argument_list|)
operator|,
expr|struct
name|elf_reloc_cookie
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_discard_section_eh_frame_hdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_vma
name|_bfd_elf_eh_frame_section_offset
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_write_section_eh_frame
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_write_section_eh_frame_hdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_maybe_strip_eh_frame_hdr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_link_record_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_link_lookup_local_dynindx
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_compute_section_file_positions
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_assign_file_positions_for_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|file_ptr
name|_bfd_elf_assign_file_position_for_section
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|,
name|file_ptr
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_validate_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|_bfd_elf_link_renumber_dynsyms
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elfcore_make_pseudosection
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|,
name|ufile_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|_bfd_elfcore_strndup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|elf_linker_section_t
modifier|*
name|_bfd_elf_create_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|enum
name|elf_linker_section_enum
operator|,
name|elf_linker_section_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|elf_linker_section_pointers_t
modifier|*
name|_bfd_elf_find_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|elf_linker_section_pointers_t
operator|*
operator|,
name|bfd_vma
operator|,
name|elf_linker_section_enum_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_create_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|elf_linker_section_t
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
specifier|const
name|Elf32_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_vma
name|bfd_elf32_finish_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|elf_linker_section_t
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|Elf32_Internal_Rela
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_create_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|elf_linker_section_t
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
specifier|const
name|Elf64_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_vma
name|bfd_elf64_finish_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|elf_linker_section_t
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|Elf64_Internal_Rela
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_make_linker_section_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|elf_linker_section_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf32_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf32_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf32_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf32_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_bfd_link_add_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_bfd_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_symbol_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_Sym
operator|*
operator|,
specifier|const
name|Elf_External_Sym_Shndx
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_symbol_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_Rel
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rel
operator|*
operator|,
name|Elf32_External_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloca_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloca_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf32_External_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_phdr_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_Phdr
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_phdr_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|Elf32_External_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_dyn_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_dyn_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Dyn
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf32_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_write_shdrs_and_ehdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf32_write_out_phdrs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_add_dynamic_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_link_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Elf_Internal_Rela
modifier|*
name|_bfd_elf32_link_read_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf64_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf64_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf64_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf64_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_bfd_link_add_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_bfd_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_symbol_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_External_Sym
operator|*
operator|,
specifier|const
name|Elf_External_Sym_Shndx
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_symbol_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_External_Rel
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rel
operator|*
operator|,
name|Elf64_External_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloca_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_External_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloca_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf64_External_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_phdr_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_External_Phdr
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_phdr_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|Elf64_External_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_dyn_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_dyn_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Dyn
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf64_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_write_shdrs_and_ehdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf64_write_out_phdrs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_add_dynamic_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_link_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Elf_Internal_Rela
modifier|*
name|_bfd_elf64_link_read_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bfd_elf32_link_record_dynamic_symbol
define|\
value|_bfd_elf_link_record_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|bfd_elf64_link_record_dynamic_symbol
define|\
value|_bfd_elf_link_record_dynamic_symbol
end_define

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf32_link_record_local_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf64_link_record_local_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_close_and_cleanup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_elf_rel_vtable_reloc_fn
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
expr|struct
name|symbol_cache_entry
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf32_gc_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf32_gc_common_finalize_got_offsets
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf32_gc_common_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf32_gc_record_vtinherit
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf32_gc_record_vtentry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf64_gc_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf64_gc_common_finalize_got_offsets
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf64_gc_common_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf64_gc_record_vtinherit
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf64_gc_record_vtentry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf32_reloc_symbol_deleted_p
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf64_reloc_symbol_deleted_p
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exported interface for writing elf corefile notes. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|elfcore_write_note
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|elfcore_write_prpsinfo
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|elfcore_write_prstatus
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|long
operator|,
name|int
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|elfcore_write_pstatus
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|long
operator|,
name|int
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|elfcore_write_prfpreg
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|elfcore_write_prxfpreg
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|elfcore_write_lwpstatus
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|long
operator|,
name|int
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MIPS ELF specific routines.  */
end_comment

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_section_from_bfd_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_section_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_mips_elf_symbol_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_read_ecoff_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_mips_elf_final_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_hi16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_lo16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_got16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel32_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|asection
modifier|*
name|_bfd_mips_elf_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_always_size_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_mips_elf_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_link_output_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_bfd_mips_elf_additional_program_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_modify_segment_map
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SH ELF specific routine.  */
end_comment

begin_decl_stmt
specifier|extern
name|boolean
name|_sh_elf_set_mach_from_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBELF_H_ */
end_comment

end_unit

