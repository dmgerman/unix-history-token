begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end data structures for ELF files.    Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBELF_H_
end_ifndef

begin_define
define|#
directive|define
name|_LIBELF_H_
value|1
end_define

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/internal.h"
end_include

begin_include
include|#
directive|include
file|"elf/external.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_comment
comment|/* If size isn't specified as 64 or 32, NAME macro should fail.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME
end_ifndef

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CAT4(x,64,_,y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CAT4(x,32,_,y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NAME
end_ifndef

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CAT4(x,NOSIZE,_,y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ElfNAME
parameter_list|(
name|X
parameter_list|)
value|NAME(Elf,X)
end_define

begin_define
define|#
directive|define
name|elfNAME
parameter_list|(
name|X
parameter_list|)
value|NAME(elf,X)
end_define

begin_comment
comment|/* Information held for an ELF symbol.  The first field is the    corresponding asymbol.  Every symbol is an ELF file is actually a    pointer to this structure, although it is often handled as a    pointer to an asymbol.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The BFD symbol.  */
name|asymbol
name|symbol
decl_stmt|;
comment|/* ELF symbol information.  */
name|Elf_Internal_Sym
name|internal_elf_sym
decl_stmt|;
comment|/* Backend specific information.  */
union|union
block|{
name|unsigned
name|int
name|hppa_arg_reloc
decl_stmt|;
name|PTR
name|mips_extr
decl_stmt|;
name|PTR
name|any
decl_stmt|;
block|}
name|tc_data
union|;
comment|/* Version information.  This is from an Elf_Internal_Versym      structure in a SHT_GNU_versym section.  It is zero if there is no      version information.  */
name|unsigned
name|short
name|version
decl_stmt|;
block|}
name|elf_symbol_type
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* ELF linker hash table entries.  */
end_comment

begin_struct
struct|struct
name|elf_link_hash_entry
block|{
name|struct
name|bfd_link_hash_entry
name|root
decl_stmt|;
comment|/* Symbol index in output file.  This is initialized to -1.  It is      set to -2 if the symbol is used by a reloc.  */
name|long
name|indx
decl_stmt|;
comment|/* Symbol size.  */
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Symbol index as a dynamic symbol.  Initialized to -1, and remains      -1 if this is not a dynamic symbol.  */
name|long
name|dynindx
decl_stmt|;
comment|/* String table index in .dynstr if this is a dynamic symbol.  */
name|unsigned
name|long
name|dynstr_index
decl_stmt|;
comment|/* If this is a weak defined symbol from a dynamic object, this      field points to a defined symbol with the same value, if there is      one.  Otherwise it is NULL.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|weakdef
decl_stmt|;
comment|/* If this symbol requires an entry in the global offset table, the      processor specific backend uses this field to hold the offset      into the .got section.  If this field is -1, then the symbol does      not require a global offset table entry.  */
name|bfd_vma
name|got_offset
decl_stmt|;
comment|/* If this symbol requires an entry in the procedure linkage table,      the processor specific backend uses these two fields to hold the      offset into the procedure linkage section and the offset into the      .got section.  If plt_offset is -1, then the symbol does not      require an entry in the procedure linkage table.  */
name|bfd_vma
name|plt_offset
decl_stmt|;
comment|/* If this symbol is used in the linker created sections, the processor      specific backend uses this field to map the field into the offset      from the beginning of the section.  */
name|struct
name|elf_linker_section_pointers
modifier|*
name|linker_section_pointer
decl_stmt|;
comment|/* Version information.  */
union|union
block|{
comment|/* This field is used for a symbol which is not defined in a        regular object.  It points to the version information read in        from the dynamic object.  */
name|Elf_Internal_Verdef
modifier|*
name|verdef
decl_stmt|;
comment|/* This field is used for a symbol which is defined in a regular        object.  It is set up in size_dynamic_sections.  It points to        the version information we should write out for this symbol.  */
name|struct
name|bfd_elf_version_tree
modifier|*
name|vertree
decl_stmt|;
block|}
name|verinfo
union|;
comment|/* Symbol type (STT_NOTYPE, STT_OBJECT, etc.).  */
name|char
name|type
decl_stmt|;
comment|/* Symbol st_other value.  */
name|unsigned
name|char
name|other
decl_stmt|;
comment|/* Some flags; legal values follow.  */
name|unsigned
name|short
name|elf_link_hash_flags
decl_stmt|;
comment|/* Symbol is referenced by a non-shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_REF_REGULAR
value|01
comment|/* Symbol is defined by a non-shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_DEF_REGULAR
value|02
comment|/* Symbol is referenced by a shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_REF_DYNAMIC
value|04
comment|/* Symbol is defined by a shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_DEF_DYNAMIC
value|010
comment|/* Dynamic symbol has been adjustd.  */
define|#
directive|define
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
value|020
comment|/* Symbol needs a copy reloc.  */
define|#
directive|define
name|ELF_LINK_HASH_NEEDS_COPY
value|040
comment|/* Symbol needs a procedure linkage table entry.  */
define|#
directive|define
name|ELF_LINK_HASH_NEEDS_PLT
value|0100
comment|/* Symbol appears in a non-ELF input file.  */
define|#
directive|define
name|ELF_LINK_NON_ELF
value|0200
comment|/* Symbol should be marked as hidden in the version information.  */
define|#
directive|define
name|ELF_LINK_HIDDEN
value|0400
comment|/* Symbol was forced to local scope due to a version script file.  */
define|#
directive|define
name|ELF_LINK_FORCED_LOCAL
value|01000
block|}
struct|;
end_struct

begin_comment
comment|/* ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_link_hash_table
block|{
name|struct
name|bfd_link_hash_table
name|root
decl_stmt|;
comment|/* Whether we have created the special dynamic sections required      when linking against or generating a shared object.  */
name|boolean
name|dynamic_sections_created
decl_stmt|;
comment|/* The BFD used to hold special sections created by the linker.      This will be the first BFD found which requires these sections to      be created.  */
name|bfd
modifier|*
name|dynobj
decl_stmt|;
comment|/* The number of symbols found in the link which must be put into      the .dynsym section.  */
name|bfd_size_type
name|dynsymcount
decl_stmt|;
comment|/* The string table of dynamic symbols, which becomes the .dynstr      section.  */
name|struct
name|bfd_strtab_hash
modifier|*
name|dynstr
decl_stmt|;
comment|/* The number of buckets in the hash table in the .hash section.      This is based on the number of dynamic symbols.  */
name|bfd_size_type
name|bucketcount
decl_stmt|;
comment|/* A linked list of DT_NEEDED names found in dynamic objects      included in the link.  */
name|struct
name|bfd_link_needed_list
modifier|*
name|needed
decl_stmt|;
comment|/* The _GLOBAL_OFFSET_TABLE_ symbol.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|hgot
decl_stmt|;
comment|/* A pointer to information used to link stabs in sections.  */
name|PTR
name|stab_info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in an ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct elf_link_hash_entry *)					\    bfd_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse an ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(bfd_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf_hash_table
parameter_list|(
name|p
parameter_list|)
value|((struct elf_link_hash_table *) ((p)->hash))
end_define

begin_escape
end_escape

begin_comment
comment|/* Constant information held for an ELF backend.  */
end_comment

begin_struct
struct|struct
name|elf_size_info
block|{
name|unsigned
name|char
name|sizeof_ehdr
decl_stmt|,
name|sizeof_phdr
decl_stmt|,
name|sizeof_shdr
decl_stmt|;
name|unsigned
name|char
name|sizeof_rel
decl_stmt|,
name|sizeof_rela
decl_stmt|,
name|sizeof_sym
decl_stmt|,
name|sizeof_dyn
decl_stmt|,
name|sizeof_note
decl_stmt|;
name|unsigned
name|char
name|arch_size
decl_stmt|,
name|file_align
decl_stmt|;
name|unsigned
name|char
name|elfclass
decl_stmt|,
name|ev_current
decl_stmt|;
name|int
argument_list|(
argument|*write_out_phdrs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
name|boolean
argument_list|(
argument|*write_shdrs_and_ehdr
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*write_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*swap_symbol_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
name|boolean
argument_list|(
argument|*slurp_reloc_table
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
expr_stmt|;
name|long
argument_list|(
argument|*slurp_symbol_table
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*swap_dyn_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_symbol_from
parameter_list|(
name|ABFD
parameter_list|,
name|S
parameter_list|)
define|\
value|(((S)->the_bfd->xvec->flavour == bfd_target_elf_flavour \&& (S)->the_bfd->tdata.elf_obj_data != 0) \ 	 ? (elf_symbol_type *) (S) \ 	 : 0)
end_define

begin_struct
struct|struct
name|elf_backend_data
block|{
comment|/* Whether the backend uses REL or RELA relocations.  FIXME: some      ELF backends use both.  When we need to support one, this whole      approach will need to be changed.  */
name|int
name|use_rela_p
decl_stmt|;
comment|/* The architecture for this backend.  */
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
comment|/* The ELF machine code (EM_xxxx) for this backend.  */
name|int
name|elf_machine_code
decl_stmt|;
comment|/* The maximum page size for this backend.  */
name|bfd_vma
name|maxpagesize
decl_stmt|;
comment|/* This is true if the linker should act like collect and gather      global constructors and destructors by name.  This is true for      MIPS ELF because the Irix 5 tools can not handle the .init      section.  */
name|boolean
name|collect
decl_stmt|;
comment|/* This is true if the linker should ignore changes to the type of a      symbol.  This is true for MIPS ELF because some Irix 5 objects      record undefined functions as STT_OBJECT although the definitions      are STT_FUNC.  */
name|boolean
name|type_change_ok
decl_stmt|;
comment|/* A function to translate an ELF RELA relocation to a BFD arelent      structure.  */
name|void
argument_list|(
argument|*elf_info_to_howto
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to translate an ELF REL relocation to a BFD arelent      structure.  */
name|void
argument_list|(
argument|*elf_info_to_howto_rel
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to determine whether a symbol is global when      partitioning the symbol table into local and global symbols.      This should be NULL for most targets, in which case the correct      thing will be done.  MIPS ELF, at least on the Irix 5, has      special requirements.  */
name|boolean
argument_list|(
argument|*elf_backend_sym_is_global
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* The remaining functions are hooks which are called only if they      are not NULL.  */
comment|/* A function to permit a backend specific check on whether a      particular BFD format is relevant for an object file, and to      permit the backend to set any global information it wishes.  When      this is called elf_elfheader is set, but anything else should be      used with caution.  If this returns false, the check_format      routine will return a bfd_error_wrong_format error.  */
name|boolean
argument_list|(
argument|*elf_backend_object_p
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do additional symbol processing when reading the      ELF symbol table.  This is where any processor-specific special      section indices are handled.  */
name|void
argument_list|(
argument|*elf_backend_symbol_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do additional symbol processing after reading the      entire ELF symbol table.  */
name|boolean
argument_list|(
argument|*elf_backend_symbol_table_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|elf_symbol_type
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do additional processing on the ELF section header      just before writing it out.  This is used to set the flags and      type fields for some sections, or to actually write out data for      unusual sections.  */
name|boolean
argument_list|(
argument|*elf_backend_section_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to handle unusual section types when creating BFD      sections from ELF sections.  */
name|boolean
argument_list|(
argument|*elf_backend_section_from_shdr
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to set up the ELF section header for a BFD section in      preparation for writing it out.  This is where the flags and type      fields are set for unusual sections.  */
name|boolean
argument_list|(
argument|*elf_backend_fake_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to get the ELF section index for a BFD section.  If      this returns true, the section was found.  If it is a normal ELF      section, *RETVAL should be left unchanged.  If it is not a normal      ELF section *RETVAL should be set to the SHN_xxxx index.  */
name|boolean
argument_list|(
argument|*elf_backend_section_from_bfd_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|,
name|int
operator|*
name|retval
operator|)
argument_list|)
expr_stmt|;
comment|/* If this field is not NULL, it is called by the add_symbols phase      of a link just before adding a symbol to the global linker hash      table.  It may modify any of the fields as it wishes.  If *NAME      is set to NULL, the symbol will be skipped rather than being      added to the hash table.  This function is responsible for      handling all processor dependent symbol bindings and section      indices, and must set at least *FLAGS and *SEC for each processor      dependent case; failure to do so will cause a link error.  */
name|boolean
argument_list|(
argument|*elf_add_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
name|name
operator|,
name|flagword
operator|*
name|flags
operator|,
name|asection
operator|*
operator|*
name|sec
operator|,
name|bfd_vma
operator|*
name|value
operator|)
argument_list|)
expr_stmt|;
comment|/* If this field is not NULL, it is called by the elf_link_output_sym      phase of a link for each symbol which will appear in the object file.  */
name|boolean
argument_list|(
argument|*elf_backend_link_output_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* The CREATE_DYNAMIC_SECTIONS function is called by the ELF backend      linker the first time it encounters a dynamic object in the link.      This function must create any sections required for dynamic      linking.  The ABFD argument is a dynamic object.  The .interp,      .dynamic, .dynsym, .dynstr, and .hash functions have already been      created, and this function may modify the section flags if      desired.  This function will normally create the .got and .plt      sections, but different backends have different requirements.  */
name|boolean
argument_list|(
argument|*elf_backend_create_dynamic_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* The CHECK_RELOCS function is called by the add_symbols phase of      the ELF backend linker.  It is called once for each section with      relocs of an object file, just after the symbols for the object      file have been added to the global linker hash table.  The      function must look through the relocs and do any special handling      required.  This generally means allocating space in the global      offset table, and perhaps allocating space for a reloc.  The      relocs are always passed as Rela structures; if the section      actually uses Rel structures, the r_addend field will always be      zero.  */
name|boolean
argument_list|(
argument|*check_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|o
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|relocs
operator|)
argument_list|)
expr_stmt|;
comment|/* The ADJUST_DYNAMIC_SYMBOL function is called by the ELF backend      linker for every symbol which is defined by a dynamic object and      referenced by a regular object.  This is called after all the      input files have been seen, but before the SIZE_DYNAMIC_SECTIONS      function has been called.  The hash table entry should be      bfd_link_hash_defined ore bfd_link_hash_defweak, and it should be      defined in a section from a dynamic object.  Dynamic object      sections are not included in the final link, and this function is      responsible for changing the value to something which the rest of      the link can deal with.  This will normally involve adding an      entry to the .plt or .got or some such section, and setting the      symbol to point to that.  */
name|boolean
argument_list|(
argument|*elf_backend_adjust_dynamic_symbol
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* The ALWAYS_SIZE_SECTIONS function is called by the backend linker      after all the linker input files have been seen but before the      section sizes have been set.  This is called after      ADJUST_DYNAMIC_SYMBOL, but before SIZE_DYNAMIC_SECTIONS.  */
name|boolean
argument_list|(
argument|*elf_backend_always_size_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* The SIZE_DYNAMIC_SECTIONS function is called by the ELF backend      linker after all the linker input files have been seen but before      the sections sizes have been set.  This is called after      ADJUST_DYNAMIC_SYMBOL has been called on all appropriate symbols.      It is only called when linking against a dynamic object.  It must      set the sizes of the dynamic sections, and may fill in their      contents as well.  The generic ELF linker can handle the .dynsym,      .dynstr and .hash sections.  This function must handle the      .interp section and any sections created by the      CREATE_DYNAMIC_SECTIONS entry point.  */
name|boolean
argument_list|(
argument|*elf_backend_size_dynamic_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker      to handle the relocations for a section.       The relocs are always passed as Rela structures; if the section      actually uses Rel structures, the r_addend field will always be      zero.       This function is responsible for adjust the section contents as      necessary, and (if using Rela relocs and generating a      relocateable output file) adjusting the reloc addend as      necessary.       This function does not have to worry about setting the reloc      address or the reloc symbol index.       LOCAL_SYMS is a pointer to the swapped in local symbols.       LOCAL_SECTIONS is an array giving the section in the input file      corresponding to the st_shndx field of each local symbol.       The global hash table entry for the global symbols can be found      via elf_sym_hashes (input_bfd).       When generating relocateable output, this function must handle      STB_LOCAL/STT_SECTION symbols specially.  The output symbol is      going to be the section symbol corresponding to the output      section, which means that the addend must be adjusted      accordingly.  */
name|boolean
argument_list|(
argument|*elf_backend_relocate_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd_byte
operator|*
name|contents
operator|,
name|Elf_Internal_Rela
operator|*
name|relocs
operator|,
name|Elf_Internal_Sym
operator|*
name|local_syms
operator|,
name|asection
operator|*
operator|*
name|local_sections
operator|)
argument_list|)
expr_stmt|;
comment|/* The FINISH_DYNAMIC_SYMBOL function is called by the ELF backend      linker just before it writes a symbol out to the .dynsym section.      The processor backend may make any required adjustment to the      symbol.  It may also take the opportunity to set contents of the      dynamic sections.  Note that FINISH_DYNAMIC_SYMBOL is called on      all .dynsym symbols, while ADJUST_DYNAMIC_SYMBOL is only called      on those symbols which are defined by a dynamic object.  */
name|boolean
argument_list|(
argument|*elf_backend_finish_dynamic_symbol
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|Elf_Internal_Sym
operator|*
name|sym
operator|)
argument_list|)
expr_stmt|;
comment|/* The FINISH_DYNAMIC_SECTIONS function is called by the ELF backend      linker just before it writes all the dynamic sections out to the      output file.  The FINISH_DYNAMIC_SYMBOL will have been called on      all dynamic symbols.  */
name|boolean
argument_list|(
argument|*elf_backend_finish_dynamic_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do any beginning processing needed for the ELF file      before building the ELF headers and computing file positions.  */
name|void
argument_list|(
argument|*elf_backend_begin_write_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do any final processing needed for the ELF file      before writing it out.  The LINKER argument is true if this BFD      was created by the ELF backend linker.  */
name|void
argument_list|(
argument|*elf_backend_final_write_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
name|linker
operator|)
argument_list|)
expr_stmt|;
comment|/* This function is called by get_program_header_size.  It should      return the number of additional program segments which this BFD      will need.  It should return -1 on error.  */
name|int
argument_list|(
argument|*elf_backend_additional_program_headers
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This function is called to modify an existing segment map in a      backend specific fashion.  */
name|boolean
argument_list|(
argument|*elf_backend_modify_segment_map
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* The swapping table to use when dealing with ECOFF information.      Used for the MIPS ELF .mdebug section.  */
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|elf_backend_ecoff_debug_swap
decl_stmt|;
comment|/* Alternate EM_xxxx machine codes for this backend.  */
name|int
name|elf_machine_alt1
decl_stmt|;
name|int
name|elf_machine_alt2
decl_stmt|;
specifier|const
name|struct
name|elf_size_info
modifier|*
name|s
decl_stmt|;
name|unsigned
name|want_got_plt
range|:
literal|1
decl_stmt|;
name|unsigned
name|plt_readonly
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_plt_sym
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information stored for each BFD section in an ELF file.  This    structure is allocated by elf_new_section_hook.  */
end_comment

begin_struct
struct|struct
name|bfd_elf_section_data
block|{
comment|/* The ELF header for this section.  */
name|Elf_Internal_Shdr
name|this_hdr
decl_stmt|;
comment|/* The ELF header for the reloc section associated with this      section, if any.  */
name|Elf_Internal_Shdr
name|rel_hdr
decl_stmt|;
comment|/* If there is a second reloc section associated with this section,      as can happen on Irix 6, this field points to the header.  */
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr2
decl_stmt|;
comment|/* The ELF section number of this section.  Only used for an output      file.  */
name|int
name|this_idx
decl_stmt|;
comment|/* The ELF section number of the reloc section associated with this      section, if any.  Only used for an output file.  */
name|int
name|rel_idx
decl_stmt|;
comment|/* Used by the backend linker to store the symbol hash table entries      associated with relocs against global symbols.  */
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hashes
decl_stmt|;
comment|/* A pointer to the swapped relocs.  If the section uses REL relocs,      rather than RELA, all the r_addend fields will be zero.  This      pointer may be NULL.  It is used by the backend linker.  */
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
comment|/* Used by the backend linker when generating a shared library to      record the dynamic symbol index for a section symbol      corresponding to this section.  */
name|long
name|dynindx
decl_stmt|;
comment|/* A pointer used for .stab linking optimizations.  */
name|PTR
name|stab_info
decl_stmt|;
comment|/* A pointer available for the processor specific ELF backend.  */
name|PTR
name|tdata
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_section_data
parameter_list|(
name|sec
parameter_list|)
value|((struct bfd_elf_section_data*)sec->used_by_bfd)
end_define

begin_define
define|#
directive|define
name|get_elf_backend_data
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct elf_backend_data *) (abfd)->xvec->backend_data)
end_define

begin_comment
comment|/* Enumeration to specify the special section.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|elf_linker_section_enum
block|{
name|LINKER_SECTION_UNKNOWN
block|,
comment|/* not used */
name|LINKER_SECTION_GOT
block|,
comment|/* .got section for global offset pointers */
name|LINKER_SECTION_PLT
block|,
comment|/* .plt section for generated procedure stubs */
name|LINKER_SECTION_SDATA
block|,
comment|/* .sdata/.sbss section for PowerPC */
name|LINKER_SECTION_SDATA2
block|,
comment|/* .sdata2/.sbss2 section for PowerPC */
name|LINKER_SECTION_MAX
comment|/* # of linker sections */
block|}
name|elf_linker_section_enum_t
typedef|;
end_typedef

begin_comment
comment|/* Sections created by the linker.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|elf_linker_section
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the section */
name|char
modifier|*
name|rel_name
decl_stmt|;
comment|/* name of the associated .rel{,a}. section */
name|char
modifier|*
name|bss_name
decl_stmt|;
comment|/* name of a related .bss section */
name|char
modifier|*
name|sym_name
decl_stmt|;
comment|/* name of symbol to reference this section */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* pointer to the section */
name|asection
modifier|*
name|bss_section
decl_stmt|;
comment|/* pointer to the bss section associated with this */
name|asection
modifier|*
name|rel_section
decl_stmt|;
comment|/* pointer to the relocations needed for this section */
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
decl_stmt|;
comment|/* pointer to the created symbol hash value */
name|bfd_vma
name|initial_size
decl_stmt|;
comment|/* initial size before any linker generated allocations */
name|bfd_vma
name|sym_offset
decl_stmt|;
comment|/* offset of symbol from beginning of section */
name|bfd_vma
name|hole_size
decl_stmt|;
comment|/* size of reserved address hole in allocation */
name|bfd_vma
name|hole_offset
decl_stmt|;
comment|/* current offset for the hole */
name|bfd_vma
name|max_hole_offset
decl_stmt|;
comment|/* maximum offset for the hole */
name|elf_linker_section_enum_t
name|which
decl_stmt|;
comment|/* which section this is */
name|boolean
name|hole_written_p
decl_stmt|;
comment|/* whether the hole has been initialized */
name|int
name|alignment
decl_stmt|;
comment|/* alignment for the section */
name|flagword
name|flags
decl_stmt|;
comment|/* flags to use to create the section */
block|}
name|elf_linker_section_t
typedef|;
end_typedef

begin_comment
comment|/* Linked list of allocated pointer entries.  This hangs off of the symbol lists, and    provides allows us to return different pointers, based on different addend's.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|elf_linker_section_pointers
block|{
name|struct
name|elf_linker_section_pointers
modifier|*
name|next
decl_stmt|;
comment|/* next allocated pointer for this symbol */
name|bfd_vma
name|offset
decl_stmt|;
comment|/* offset of pointer from beginning of section */
name|bfd_signed_vma
name|addend
decl_stmt|;
comment|/* addend used */
name|elf_linker_section_enum_t
name|which
decl_stmt|;
comment|/* which linker section this is */
name|boolean
name|written_address_p
decl_stmt|;
comment|/* whether address was written yet */
block|}
name|elf_linker_section_pointers_t
typedef|;
end_typedef

begin_comment
comment|/* Some private data is stashed away for future use using the tdata pointer    in the bfd structure.  */
end_comment

begin_struct
struct|struct
name|elf_obj_tdata
block|{
name|Elf_Internal_Ehdr
name|elf_header
index|[
literal|1
index|]
decl_stmt|;
comment|/* Actual data, but ref like ptr */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|elf_sect_ptr
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|segment_map
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|strtab_ptr
decl_stmt|;
name|int
name|num_locals
decl_stmt|;
name|int
name|num_globals
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|section_syms
decl_stmt|;
comment|/* STT_SECTION symbols for each section */
name|Elf_Internal_Shdr
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|shstrtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|strtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynsymtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynstrtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynversym_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynverref_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynverdef_hdr
decl_stmt|;
name|unsigned
name|int
name|symtab_section
decl_stmt|,
name|shstrtab_section
decl_stmt|;
name|unsigned
name|int
name|strtab_section
decl_stmt|,
name|dynsymtab_section
decl_stmt|;
name|unsigned
name|int
name|dynversym_section
decl_stmt|,
name|dynverdef_section
decl_stmt|,
name|dynverref_section
decl_stmt|;
name|file_ptr
name|next_file_pos
decl_stmt|;
name|void
modifier|*
name|prstatus
decl_stmt|;
comment|/* The raw /proc prstatus structure */
name|void
modifier|*
name|prpsinfo
decl_stmt|;
comment|/* The raw /proc prpsinfo structure */
name|bfd_vma
name|gp
decl_stmt|;
comment|/* The gp value (MIPS only, for now) */
name|unsigned
name|int
name|gp_size
decl_stmt|;
comment|/* The gp size (MIPS only, for now) */
comment|/* This is set to true if the object was created by the backend      linker.  */
name|boolean
name|linker
decl_stmt|;
comment|/* A mapping from external symbols to entries in the linker hash      table, used when linking.  This is indexed by the symbol index      minus the sh_info field of the symbol table header.  */
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
comment|/* A mapping from local symbols to offsets into the global offset      table, used when linking.  This is indexed by the symbol index.  */
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
comment|/* A mapping from local symbols to offsets into the various linker      sections added.  This is index by the symbol index.  */
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|linker_section_pointers
decl_stmt|;
comment|/* The linker ELF emulation code needs to let the backend ELF linker      know what filename should be used for a dynamic object if the      dynamic object is found using a search.  The emulation code then      sometimes needs to know what name was actually used.  Until the      file has been added to the linker symbol table, this field holds      the name the linker wants.  After it has been added, it holds the      name actually used, which will be the DT_SONAME entry if there is      one.  */
specifier|const
name|char
modifier|*
name|dt_name
decl_stmt|;
comment|/* Irix 5 often screws up the symbol table, sorting local symbols      after global symbols.  This flag is set if the symbol table in      this BFD appears to be screwed up.  If it is, we ignore the      sh_info field in the symbol table header, and always read all the      symbols.  */
name|boolean
name|bad_symtab
decl_stmt|;
comment|/* Records the result of `get_program_header_size'.  */
name|bfd_size_type
name|program_header_size
decl_stmt|;
comment|/* Used by find_nearest_line entry point.  */
name|PTR
name|line_info
decl_stmt|;
comment|/* Used by MIPS ELF find_nearest_line entry point.  The structure      could be included directly in this one, but there's no point to      wasting the memory just for the infrequently called      find_nearest_line.  */
name|struct
name|mips_elf_find_line
modifier|*
name|find_line_info
decl_stmt|;
comment|/* An array of stub sections indexed by symbol number, used by the      MIPS ELF linker.  FIXME: We should figure out some way to only      include this field for a MIPS ELF target.  */
name|asection
modifier|*
modifier|*
name|local_stubs
decl_stmt|;
comment|/* Used to determine if the e_flags field has been initialized */
name|boolean
name|flags_init
decl_stmt|;
comment|/* Number of symbol version definitions we are about to emit.  */
name|int
name|cverdefs
decl_stmt|;
comment|/* Number of symbol version references we are about to emit.  */
name|int
name|cverrefs
decl_stmt|;
comment|/* Symbol version definitions in external objects.  */
name|Elf_Internal_Verdef
modifier|*
name|verdef
decl_stmt|;
comment|/* Symbol version references to external objects.  */
name|Elf_Internal_Verneed
modifier|*
name|verref
decl_stmt|;
comment|/* Linker sections that we are interested in.  */
name|struct
name|elf_linker_section
modifier|*
name|linker_section
index|[
operator|(
name|int
operator|)
name|LINKER_SECTION_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_tdata
parameter_list|(
name|bfd
parameter_list|)
value|((bfd) -> tdata.elf_obj_data)
end_define

begin_define
define|#
directive|define
name|elf_elfheader
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> elf_header)
end_define

begin_define
define|#
directive|define
name|elf_elfsections
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> elf_sect_ptr)
end_define

begin_define
define|#
directive|define
name|elf_shstrtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> strtab_ptr)
end_define

begin_define
define|#
directive|define
name|elf_onesymtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> symtab_section)
end_define

begin_define
define|#
directive|define
name|elf_dynsymtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dynsymtab_section)
end_define

begin_define
define|#
directive|define
name|elf_dynversym
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dynversym_section)
end_define

begin_define
define|#
directive|define
name|elf_dynverdef
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dynverdef_section)
end_define

begin_define
define|#
directive|define
name|elf_dynverref
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dynverref_section)
end_define

begin_define
define|#
directive|define
name|elf_num_locals
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> num_locals)
end_define

begin_define
define|#
directive|define
name|elf_num_globals
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> num_globals)
end_define

begin_define
define|#
directive|define
name|elf_section_syms
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> section_syms)
end_define

begin_define
define|#
directive|define
name|core_prpsinfo
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> prpsinfo)
end_define

begin_define
define|#
directive|define
name|core_prstatus
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> prstatus)
end_define

begin_define
define|#
directive|define
name|elf_gp
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> gp)
end_define

begin_define
define|#
directive|define
name|elf_gp_size
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> gp_size)
end_define

begin_define
define|#
directive|define
name|elf_sym_hashes
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> sym_hashes)
end_define

begin_define
define|#
directive|define
name|elf_local_got_offsets
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> local_got_offsets)
end_define

begin_define
define|#
directive|define
name|elf_local_ptr_offsets
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> linker_section_pointers)
end_define

begin_define
define|#
directive|define
name|elf_dt_name
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dt_name)
end_define

begin_define
define|#
directive|define
name|elf_bad_symtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> bad_symtab)
end_define

begin_define
define|#
directive|define
name|elf_flags_init
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> flags_init)
end_define

begin_define
define|#
directive|define
name|elf_linker_section
parameter_list|(
name|bfd
parameter_list|,
name|n
parameter_list|)
value|(elf_tdata(bfd) -> linker_section[(int)n])
end_define

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verdef_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Verdef
operator|*
operator|,
name|Elf_Internal_Verdef
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verdef_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Verdef
operator|*
operator|,
name|Elf_External_Verdef
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verdaux_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Verdaux
operator|*
operator|,
name|Elf_Internal_Verdaux
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verdaux_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Verdaux
operator|*
operator|,
name|Elf_External_Verdaux
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verneed_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Verneed
operator|*
operator|,
name|Elf_Internal_Verneed
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_verneed_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Verneed
operator|*
operator|,
name|Elf_External_Verneed
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_vernaux_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Vernaux
operator|*
operator|,
name|Elf_Internal_Vernaux
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_vernaux_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Vernaux
operator|*
operator|,
name|Elf_External_Vernaux
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_versym_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_External_Versym
operator|*
operator|,
name|Elf_Internal_Versym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_swap_versym_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Versym
operator|*
operator|,
name|Elf_External_Versym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_bfd_elf_section_from_bfd_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf_string_from_elf_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf_get_str_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf_print_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|,
name|bfd_print_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|elf_string_from_elf_strtab
parameter_list|(
name|abfd
parameter_list|,
name|strindex
parameter_list|)
define|\
value|bfd_elf_string_from_elf_section(abfd,elf_elfheader(abfd)->e_shstrndx,strindex)
end_define

begin_define
define|#
directive|define
name|bfd_elf32_print_symbol
value|bfd_elf_print_symbol
end_define

begin_define
define|#
directive|define
name|bfd_elf64_print_symbol
value|bfd_elf_print_symbol
end_define

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|bfd_elf_hash
name|PARAMS
argument_list|(
operator|(
name|CONST
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|bfd_elf_generic_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Elf_Internal_Shdr
modifier|*
name|bfd_elf_find_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_make_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|Elf_Internal_Shdr
operator|*
name|hdr
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_elf_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_elf_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_link_hash_table_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_table
operator|*
operator|,
name|bfd
operator|*
operator|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_slurp_version_tables
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_copy_private_symbol_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_copy_private_section_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_dynamic_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_canonicalize_dynamic_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_canonicalize_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_get_dynamic_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|_bfd_elf_canonicalize_dynamic_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|asymbol
modifier|*
name|_bfd_elf_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|alent
modifier|*
name|_bfd_elf_get_lineno
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|_bfd_elf_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|_bfd_elf_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_decl_stmt
specifier|extern
name|int
name|_bfd_elf_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the target doesn't have reloc handling written yet:  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|_bfd_elf_no_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
name|shindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_section_from_phdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_bfd_elf_symbol_from_bfd_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|bfd_section_from_elf_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_strtab_hash
modifier|*
name|_bfd_elf_stringtab_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_elf_link_record_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_elf_compute_section_file_positions
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_bfd_elf_assign_file_positions_for_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|file_ptr
name|_bfd_elf_assign_file_position_for_section
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|,
name|file_ptr
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_validate_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_elf_create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|elf_linker_section_t
modifier|*
name|_bfd_elf_create_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|enum
name|elf_linker_section_enum
operator|,
name|elf_linker_section_t
operator|*
name|defaults
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|elf_linker_section_pointers_t
modifier|*
name|_bfd_elf_find_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|elf_linker_section_pointers_t
operator|*
name|linker_pointers
operator|,
name|bfd_signed_vma
name|addend
operator|,
name|elf_linker_section_enum_t
name|which
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_elf32_create_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|elf_linker_section_t
operator|*
name|lsect
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
specifier|const
name|Elf32_Internal_Rela
operator|*
name|rel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|bfd_elf32_finish_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_abfd
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|elf_linker_section_t
operator|*
name|lsect
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|bfd_vma
name|relocation
operator|,
specifier|const
name|Elf32_Internal_Rela
operator|*
name|rel
operator|,
name|int
name|relative_reloc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_elf64_create_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|elf_linker_section_t
operator|*
name|lsect
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
specifier|const
name|Elf64_Internal_Rela
operator|*
name|rel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|bfd_elf64_finish_pointer_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_abfd
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|elf_linker_section_t
operator|*
name|lsect
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|bfd_vma
name|relocation
operator|,
specifier|const
name|Elf64_Internal_Rela
operator|*
name|rel
operator|,
name|int
name|relative_reloc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_elf_make_linker_section_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|dynobj
operator|,
name|elf_linker_section_t
operator|*
name|lsect
operator|,
name|int
name|alignment
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf32_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf32_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf32_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf32_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_bfd_link_add_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_bfd_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_symbol_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_Sym
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_symbol_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_Rel
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rel
operator|*
operator|,
name|Elf32_External_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloca_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloca_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf32_External_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_phdr_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_Phdr
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_phdr_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|Elf32_External_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_dyn_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_dyn_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Dyn
operator|*
operator|,
name|Elf32_External_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf32_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_write_shdrs_and_ehdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf32_write_out_phdrs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_add_dynamic_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_link_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Elf_Internal_Rela
modifier|*
name|_bfd_elf32_link_read_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf64_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf64_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf64_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf64_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_bfd_link_add_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_bfd_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_symbol_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_External_Sym
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_symbol_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_External_Rel
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rel
operator|*
operator|,
name|Elf64_External_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloca_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_External_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloca_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf64_External_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_phdr_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_External_Phdr
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_phdr_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|Elf64_External_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_dyn_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_dyn_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Dyn
operator|*
operator|,
name|Elf64_External_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf64_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_write_shdrs_and_ehdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf64_write_out_phdrs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Phdr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_add_dynamic_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_link_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Elf_Internal_Rela
modifier|*
name|_bfd_elf64_link_read_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bfd_elf32_link_record_dynamic_symbol
value|_bfd_elf_link_record_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|bfd_elf64_link_record_dynamic_symbol
value|_bfd_elf_link_record_dynamic_symbol
end_define

begin_comment
comment|/* MIPS ELF specific routines.  */
end_comment

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_section_from_bfd_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_section_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_mips_elf_symbol_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_read_ecoff_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_mips_elf_final_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_hi16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_lo16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_got16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel32_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_mips_elf_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBELF_H_ */
end_comment

end_unit

