begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MIPS-specific support for 64-bit ELF    Copyright 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Ian Lance Taylor, Cygnus Support    Linker support added by Mark Mitchell, CodeSourcery, LLC.<mark@codesourcery.com>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file supports the 64-bit (MIPS) ELF archives.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_comment
comment|/* Irix 6 defines a 64bit archive map format, so that they can    have archives more than 4 GB in size.  */
end_comment

begin_decl_stmt
name|boolean
name|bfd_elf64_archive_slurp_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_elf64_archive_write_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|orl
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read an Irix 6 armap.  */
end_comment

begin_function
name|boolean
name|bfd_elf64_archive_slurp_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|file_ptr
name|arhdrpos
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|,
name|parsed_size
decl_stmt|,
name|nsymz
decl_stmt|,
name|stringsize
decl_stmt|,
name|carsym_size
decl_stmt|,
name|ptrsize
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|bfd_byte
name|int_buf
index|[
literal|8
index|]
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|bfd_byte
modifier|*
name|raw_armap
init|=
name|NULL
decl_stmt|;
name|carsym
modifier|*
name|carsyms
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
name|NULL
expr_stmt|;
comment|/* Get the name of the first element.  */
name|arhdrpos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i
operator|=
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|16
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|i
operator|!=
literal|16
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Archives with traditional armaps are still permitted.  */
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/               "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bfd_slurp_armap
argument_list|(
name|abfd
argument_list|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/SYM64/         "
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
name|mapdata
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|_bfd_read_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|parsed_size
operator|=
name|mapdata
operator|->
name|parsed_size
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|int_buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|nsymz
operator|=
name|bfd_getb64
argument_list|(
name|int_buf
argument_list|)
expr_stmt|;
name|stringsize
operator|=
name|parsed_size
operator|-
literal|8
operator|*
name|nsymz
operator|-
literal|8
expr_stmt|;
name|carsym_size
operator|=
name|nsymz
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
expr_stmt|;
name|ptrsize
operator|=
literal|8
operator|*
name|nsymz
expr_stmt|;
name|amt
operator|=
name|carsym_size
operator|+
name|stringsize
operator|+
literal|1
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ardata
operator|->
name|symdefs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|carsyms
operator|=
name|ardata
operator|->
name|symdefs
expr_stmt|;
name|stringbase
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ardata
operator|->
name|symdefs
operator|)
operator|+
name|carsym_size
expr_stmt|;
name|raw_armap
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|ptrsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
name|NULL
condition|)
goto|goto
name|release_symdefs
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|raw_armap
argument_list|,
name|ptrsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|ptrsize
operator|||
name|bfd_bread
argument_list|(
name|stringbase
argument_list|,
name|stringsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|stringsize
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
goto|goto
name|release_raw_armap
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsymz
condition|;
name|i
operator|++
control|)
block|{
name|carsyms
operator|->
name|file_offset
operator|=
name|bfd_getb64
argument_list|(
name|raw_armap
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
name|carsyms
operator|->
name|name
operator|=
name|stringbase
expr_stmt|;
name|stringbase
operator|+=
name|strlen
argument_list|(
name|stringbase
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|++
name|carsyms
expr_stmt|;
block|}
operator|*
name|stringbase
operator|=
literal|'\0'
expr_stmt|;
name|ardata
operator|->
name|symdef_count
operator|=
name|nsymz
expr_stmt|;
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary if you have to.  */
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|raw_armap
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|release_raw_armap
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|raw_armap
argument_list|)
expr_stmt|;
name|release_symdefs
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ardata
operator|->
name|symdefs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Write out an Irix 6 armap.  The Irix 6 tools are supposed to be    able to handle ordinary ELF armaps, but at least on Irix 6.2 the    linker crashes.  */
end_comment

begin_function
name|boolean
name|bfd_elf64_archive_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|symbol_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|symbol_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|unsigned
name|int
name|ranlibsize
init|=
operator|(
name|symbol_count
operator|*
literal|8
operator|)
operator|+
literal|8
decl_stmt|;
name|unsigned
name|int
name|stringsize
init|=
name|stridx
decl_stmt|;
name|unsigned
name|int
name|mapsize
init|=
name|stringsize
operator|+
name|ranlibsize
decl_stmt|;
name|file_ptr
name|archive_member_file_ptr
decl_stmt|;
name|bfd
modifier|*
name|current
init|=
name|arch
operator|->
name|archive_head
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|padding
decl_stmt|;
name|bfd_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|padding
operator|=
name|BFD_ALIGN
argument_list|(
name|mapsize
argument_list|,
literal|8
argument_list|)
operator|-
name|mapsize
expr_stmt|;
name|mapsize
operator|+=
name|padding
expr_stmt|;
comment|/* work out where the first object file will go in the archive */
name|archive_member_file_ptr
operator|=
operator|(
name|mapsize
operator|+
name|elength
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|SARMAG
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
literal|"/SYM64/"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|mapsize
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This, at least, is what Intel coff sets the values to.: */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_uid
operator|)
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_gid
operator|)
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_mode
operator|)
argument_list|,
literal|"%-7o"
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|hdr
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
comment|/* Write the ar header for this item and the number of symbols */
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_putb64
argument_list|(
operator|(
name|bfd_vma
operator|)
name|symbol_count
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|8
argument_list|,
name|arch
argument_list|)
operator|!=
literal|8
condition|)
return|return
name|false
return|;
comment|/* Two passes, first write the file offsets for each symbol -      remembering that each offset is on a two byte boundary.  */
comment|/* Write out the file offset for the file associated with each      symbol, and remember to keep the offsets padded out.  */
name|current
operator|=
name|arch
operator|->
name|archive_head
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
name|count
operator|<
name|symbol_count
condition|)
block|{
comment|/* For each symbol which is used defined in this object, write out 	 the object file's address in the archive */
while|while
condition|(
name|map
index|[
name|count
index|]
operator|.
name|u
operator|.
name|abfd
operator|==
name|current
condition|)
block|{
name|bfd_putb64
argument_list|(
operator|(
name|bfd_vma
operator|)
name|archive_member_file_ptr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|8
argument_list|,
name|arch
argument_list|)
operator|!=
literal|8
condition|)
return|return
name|false
return|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Add size of this archive entry */
name|archive_member_file_ptr
operator|+=
operator|(
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|)
expr_stmt|;
comment|/* remember about the even alignment */
name|archive_member_file_ptr
operator|+=
name|archive_member_file_ptr
operator|%
literal|2
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
comment|/* now write the strings themselves */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|symbol_count
condition|;
name|count
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|*
name|map
index|[
name|count
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|*
name|map
index|[
name|count
index|]
operator|.
name|name
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|len
argument_list|,
name|arch
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
comment|/* The spec says that this should be padded to an 8 byte boundary.      However, the Irix 6.2 tools do not appear to do this.  */
while|while
condition|(
name|padding
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_bwrite
argument_list|(
literal|""
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
operator|--
name|padding
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

