begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for ieee-695 objects.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001    Free Software Foundation, Inc.     Written by Steve Chamberlain of Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|KEEPMINUSPCININST
value|0
end_define

begin_comment
comment|/* IEEE 695 format is a stream of records, which we parse using a simple one-    token (which is one byte in this lexicon) lookahead recursive decent    parser.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"ieee.h"
end_include

begin_include
include|#
directive|include
file|"libieee.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_2bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_int
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_id
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_expression
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|,
name|asymbol
operator|*
operator|,
name|boolean
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ieee_write_int5
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_int5_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_section_part
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|do_with_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|do_as_repeat
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|do_without_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_external_part
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_data_part
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_debug_part
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_me_part
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_processor
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_slurp_debug
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_slurp_section_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions for writing to ieee files in the strange way that the    standard requires. */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_byte
parameter_list|(
name|abfd
parameter_list|,
name|barg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|barg
decl_stmt|;
block|{
name|bfd_byte
name|byte
decl_stmt|;
name|byte
operator|=
name|barg
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|byte
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_write_2bytes
parameter_list|(
name|abfd
parameter_list|,
name|bytes
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|bfd_byte
name|buffer
index|[
literal|2
index|]
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|bytes
operator|>>
literal|8
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
name|bytes
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_write_int
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|<=
literal|127
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|)
name|value
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|/* How many significant bytes ? */
comment|/* FIXME FOR LONGER INTS */
if|if
condition|(
name|value
operator|&
literal|0xff000000
condition|)
name|length
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|&
literal|0x00ff0000
condition|)
name|length
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|&
literal|0x0000ff00
condition|)
name|length
operator|=
literal|2
expr_stmt|;
else|else
name|length
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
operator|(
name|int
operator|)
name|ieee_number_repeat_start_enum
operator|+
name|length
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|value
operator|>>
literal|24
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Fall through.  */
case|case
literal|3
case|:
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|value
operator|>>
literal|16
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Fall through.  */
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|value
operator|>>
literal|8
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Fall through.  */
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_write_id
parameter_list|(
name|abfd
parameter_list|,
name|id
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|id
decl_stmt|;
block|{
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|<=
literal|127
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|)
name|length
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|255
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_extension_length_1_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|)
name|length
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|65535
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_extension_length_2_enum
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: string too long (%d chars, max 65535)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|id
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
name|abfd
argument_list|)
operator|!=
name|length
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*************************************************************************** Functions for reading from ieee files in the strange way that the standard requires: */
end_comment

begin_define
define|#
directive|define
name|this_byte
parameter_list|(
name|ieee
parameter_list|)
value|*((ieee)->input_p)
end_define

begin_define
define|#
directive|define
name|next_byte
parameter_list|(
name|ieee
parameter_list|)
value|((ieee)->input_p++)
end_define

begin_define
define|#
directive|define
name|this_byte_and_next
parameter_list|(
name|ieee
parameter_list|)
value|(*((ieee)->input_p++))
end_define

begin_function
specifier|static
name|unsigned
name|short
name|read_2bytes
parameter_list|(
name|ieee
parameter_list|)
name|common_header_type
modifier|*
name|ieee
decl_stmt|;
block|{
name|unsigned
name|char
name|c1
init|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|c2
init|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
decl_stmt|;
return|return
operator|(
name|c1
operator|<<
literal|8
operator|)
operator||
name|c2
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_get_string
parameter_list|(
name|ieee
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|)
name|common_header_type
modifier|*
name|ieee
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|length
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|string
index|[
name|i
index|]
operator|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_id
parameter_list|(
name|ieee
parameter_list|)
name|common_header_type
modifier|*
name|ieee
decl_stmt|;
block|{
name|size_t
name|length
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|length
operator|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0x7f
condition|)
block|{
comment|/* Simple string of length 0 to 127 */
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|0xde
condition|)
block|{
comment|/* Length is next byte, allowing 0..255 */
name|length
operator|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|0xdf
condition|)
block|{
comment|/* Length is next two bytes, allowing 0..65535 */
name|length
operator|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|length
operator|*
literal|256
operator|)
operator|+
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
block|}
comment|/* Buy memory and read string */
name|string
operator|=
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|abfd
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
return|return
name|NULL
return|;
name|bfd_get_string
argument_list|(
name|ieee
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|string
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_write_expression
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|,
name|symbol
parameter_list|,
name|pcrel
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|boolean
name|pcrel
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
block|{
name|unsigned
name|int
name|term_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
name|term_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* Def of a common symbol */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_X_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
condition|)
return|return
name|false
return|;
name|term_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* Ref to defined symbol - */
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_I_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
condition|)
return|return
name|false
return|;
name|term_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
operator|(
name|BSF_LOCAL
operator||
name|BSF_SECTION_SYM
operator|)
condition|)
block|{
comment|/* This is a reference to a defined local symbol.  We can 	     easily do a local as a section+offset.  */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_R_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|symbol
operator|->
name|section
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|term_count
operator|++
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
condition|)
return|return
name|false
return|;
name|term_count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unrecognized symbol `%s' flags 0x%x"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|symbol
operator|->
name|flags
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|pcrel
condition|)
block|{
comment|/* subtract the pc from here by asking for PC of this section*/
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_P_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_minus_enum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Handle the degenerate case of a 0 address.  */
if|if
condition|(
name|term_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
while|while
condition|(
name|term_count
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_plus_enum
argument_list|)
condition|)
return|return
name|false
return|;
name|term_count
operator|--
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* writes any integer into the buffer supplied and always takes 5 bytes */
end_comment

begin_function
specifier|static
name|void
name|ieee_write_int5
parameter_list|(
name|buffer
parameter_list|,
name|value
parameter_list|)
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|buffer
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|ieee_number_repeat_4_enum
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|3
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|4
index|]
operator|=
operator|(
name|value
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_write_int5_out
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_byte
name|b
index|[
literal|5
index|]
decl_stmt|;
name|ieee_write_int5
argument_list|(
name|b
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|b
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|5
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|parse_int
parameter_list|(
name|ieee
parameter_list|,
name|value_ptr
parameter_list|)
name|common_header_type
modifier|*
name|ieee
decl_stmt|;
name|bfd_vma
modifier|*
name|value_ptr
decl_stmt|;
block|{
name|int
name|value
init|=
name|this_byte
argument_list|(
name|ieee
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0
operator|&&
name|value
operator|<=
literal|127
condition|)
block|{
operator|*
name|value_ptr
operator|=
name|value
expr_stmt|;
name|next_byte
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|>=
literal|0x80
operator|&&
name|value
operator|<=
literal|0x88
condition|)
block|{
name|unsigned
name|int
name|count
init|=
name|value
operator|&
literal|0xf
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|next_byte
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|result
operator|=
operator|(
name|result
operator|<<
literal|8
operator|)
operator||
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
operator|*
name|value_ptr
operator|=
name|result
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_i
parameter_list|(
name|ieee
parameter_list|,
name|ok
parameter_list|)
name|common_header_type
modifier|*
name|ieee
decl_stmt|;
name|boolean
modifier|*
name|ok
decl_stmt|;
block|{
name|bfd_vma
name|x
decl_stmt|;
operator|*
name|ok
operator|=
name|parse_int
argument_list|(
name|ieee
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|must_parse_int
parameter_list|(
name|ieee
parameter_list|)
name|common_header_type
modifier|*
name|ieee
decl_stmt|;
block|{
name|bfd_vma
name|result
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|parse_int
argument_list|(
name|ieee
argument_list|,
operator|&
name|result
argument_list|)
operator|==
name|true
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|ieee_symbol_index_type
name|symbol
decl_stmt|;
block|}
name|ieee_value_type
typedef|;
end_typedef

begin_if
if|#
directive|if
name|KEEPMINUSPCININST
end_if

begin_define
define|#
directive|define
name|SRC_MASK
parameter_list|(
name|arg
parameter_list|)
value|arg
end_define

begin_define
define|#
directive|define
name|PCREL_OFFSET
value|false
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SRC_MASK
parameter_list|(
name|arg
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|PCREL_OFFSET
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|abs32_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"abs32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|abs16_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"abs16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|abs8_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"abs8"
argument_list|,
name|true
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|rel32_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"rel32"
argument_list|,
name|true
argument_list|,
name|SRC_MASK
argument_list|(
literal|0xffffffff
argument_list|)
argument_list|,
literal|0xffffffff
argument_list|,
name|PCREL_OFFSET
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|rel16_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"rel16"
argument_list|,
name|true
argument_list|,
name|SRC_MASK
argument_list|(
literal|0x0000ffff
argument_list|)
argument_list|,
literal|0x0000ffff
argument_list|,
name|PCREL_OFFSET
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|rel8_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"rel8"
argument_list|,
name|true
argument_list|,
name|SRC_MASK
argument_list|(
literal|0x000000ff
argument_list|)
argument_list|,
literal|0x000000ff
argument_list|,
name|PCREL_OFFSET
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee_symbol_index_type
name|NOSYMBOL
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|parse_expression
parameter_list|(
name|ieee
parameter_list|,
name|value
parameter_list|,
name|symbol
parameter_list|,
name|pcrel
parameter_list|,
name|extra
parameter_list|,
name|section
parameter_list|)
name|ieee_data_type
modifier|*
name|ieee
decl_stmt|;
name|bfd_vma
modifier|*
name|value
decl_stmt|;
name|ieee_symbol_index_type
modifier|*
name|symbol
decl_stmt|;
name|boolean
modifier|*
name|pcrel
decl_stmt|;
name|unsigned
name|int
modifier|*
name|extra
decl_stmt|;
name|asection
modifier|*
modifier|*
name|section
decl_stmt|;
block|{
define|#
directive|define
name|POS
value|sp[1]
define|#
directive|define
name|TOS
value|sp[0]
define|#
directive|define
name|NOS
value|sp[-1]
define|#
directive|define
name|INC
value|sp++;
define|#
directive|define
name|DEC
value|sp--;
name|boolean
name|loop
init|=
name|true
decl_stmt|;
name|ieee_value_type
name|stack
index|[
literal|10
index|]
decl_stmt|;
comment|/* The stack pointer always points to the next unused location */
define|#
directive|define
name|PUSH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|TOS.symbol=x;TOS.section=y;TOS.value=z;INC;
define|#
directive|define
name|POP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|DEC;x=TOS.symbol;y=TOS.section;z=TOS.value;
name|ieee_value_type
modifier|*
name|sp
init|=
name|stack
decl_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_variable_P_enum
case|:
comment|/* P variable, current program counter for section n */
block|{
name|int
name|section_n
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pcrel
operator|=
name|true
expr_stmt|;
name|section_n
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ieee_variable_L_enum
case|:
comment|/* L variable  address of section N */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_variable_R_enum
case|:
comment|/* R variable, logical address of section module */
comment|/* FIXME, this should be different to L */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_variable_S_enum
case|:
comment|/* S variable, size in MAUS of section module */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
literal|0
argument_list|,
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_variable_I_enum
case|:
comment|/* Push the address of variable n */
block|{
name|ieee_symbol_index_type
name|sy
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|sy
operator|.
name|index
operator|=
operator|(
name|int
operator|)
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|sy
operator|.
name|letter
operator|=
literal|'I'
expr_stmt|;
name|PUSH
argument_list|(
name|sy
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_variable_X_enum
case|:
comment|/* Push the address of external variable n */
block|{
name|ieee_symbol_index_type
name|sy
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|sy
operator|.
name|index
operator|=
call|(
name|int
call|)
argument_list|(
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|sy
operator|.
name|letter
operator|=
literal|'X'
expr_stmt|;
name|PUSH
argument_list|(
name|sy
argument_list|,
name|bfd_und_section_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_function_minus_enum
case|:
block|{
name|bfd_vma
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|asection
modifier|*
name|section1
decl_stmt|,
modifier|*
name|section_dummy
decl_stmt|;
name|ieee_symbol_index_type
name|sy
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|sy
argument_list|,
name|section1
argument_list|,
name|value1
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|sy
argument_list|,
name|section_dummy
argument_list|,
name|value2
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|sy
argument_list|,
name|section1
condition|?
name|section1
else|:
name|section_dummy
argument_list|,
name|value2
operator|-
name|value1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_function_plus_enum
case|:
block|{
name|bfd_vma
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|asection
modifier|*
name|section1
decl_stmt|;
name|asection
modifier|*
name|section2
decl_stmt|;
name|ieee_symbol_index_type
name|sy1
decl_stmt|;
name|ieee_symbol_index_type
name|sy2
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|sy1
argument_list|,
name|section1
argument_list|,
name|value1
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|sy2
argument_list|,
name|section2
argument_list|,
name|value2
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|sy1
operator|.
name|letter
condition|?
name|sy1
else|:
name|sy2
argument_list|,
name|bfd_is_abs_section
argument_list|(
name|section1
argument_list|)
condition|?
name|section2
else|:
name|section1
argument_list|,
name|value1
operator|+
name|value2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|bfd_vma
name|va
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|<
operator|(
name|int
operator|)
name|ieee_variable_A_enum
operator|||
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|>
operator|(
name|int
operator|)
name|ieee_variable_Z_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|va
argument_list|)
condition|)
block|{
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		  Thats all that we can understand. As far as I can see 		  there is a bug in the Microtec IEEE output which I'm 		  using to scan, whereby the comma operator is omitted 		  sometimes in an expression, giving expressions with too 		  many terms. We can tell if that's the case by ensuring 		  that sp == stack here. If not, then we've pushed 		  something too far, so we keep adding.  */
while|while
condition|(
name|sp
operator|!=
name|stack
operator|+
literal|1
condition|)
block|{
name|asection
modifier|*
name|section1
decl_stmt|;
name|ieee_symbol_index_type
name|sy1
decl_stmt|;
name|POP
argument_list|(
name|sy1
argument_list|,
name|section1
argument_list|,
operator|*
name|extra
argument_list|)
expr_stmt|;
block|}
block|{
name|asection
modifier|*
name|dummy
decl_stmt|;
name|POP
argument_list|(
operator|*
name|symbol
argument_list|,
name|dummy
argument_list|,
operator|*
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
condition|)
operator|*
name|section
operator|=
name|dummy
expr_stmt|;
block|}
name|loop
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ieee_seek
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|)
define|\
value|IEEE_DATA(abfd)->h.input_p = IEEE_DATA(abfd)->h.first_byte + offset
end_define

begin_define
define|#
directive|define
name|ieee_pos
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(IEEE_DATA(abfd)->h.input_p - IEEE_DATA(abfd)->h.first_byte)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|last_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|last_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is the index for an X or a D */
end_comment

begin_function
specifier|static
name|ieee_symbol_type
modifier|*
name|get_symbol
parameter_list|(
name|abfd
parameter_list|,
name|ieee
parameter_list|,
name|last_symbol
parameter_list|,
name|symbol_count
parameter_list|,
name|pptr
parameter_list|,
name|max_index
parameter_list|,
name|this_type
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
decl_stmt|;
name|ieee_symbol_type
modifier|*
name|last_symbol
decl_stmt|;
name|unsigned
name|int
modifier|*
name|symbol_count
decl_stmt|;
name|ieee_symbol_type
modifier|*
modifier|*
modifier|*
name|pptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|max_index
decl_stmt|;
name|char
name|this_type
decl_stmt|;
block|{
comment|/* Need a new symbol */
name|unsigned
name|int
name|new_index
init|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_index
operator|!=
name|last_index
operator|||
name|this_type
operator|!=
name|last_type
condition|)
block|{
name|ieee_symbol_type
modifier|*
name|new_symbol
init|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new_symbol
condition|)
return|return
name|NULL
return|;
name|new_symbol
operator|->
name|index
operator|=
name|new_index
expr_stmt|;
name|last_index
operator|=
name|new_index
expr_stmt|;
operator|(
operator|*
name|symbol_count
operator|)
operator|++
expr_stmt|;
operator|*
operator|*
name|pptr
operator|=
name|new_symbol
expr_stmt|;
operator|*
name|pptr
operator|=
operator|&
name|new_symbol
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|new_index
operator|>
operator|*
name|max_index
condition|)
block|{
operator|*
name|max_index
operator|=
name|new_index
expr_stmt|;
block|}
name|last_type
operator|=
name|this_type
expr_stmt|;
name|new_symbol
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
return|return
name|new_symbol
return|;
block|}
return|return
name|last_symbol
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_slurp_external_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|file_ptr
name|offset
init|=
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|external_part
decl_stmt|;
name|ieee_symbol_type
modifier|*
modifier|*
name|prev_symbols_ptr
init|=
operator|&
name|ieee
operator|->
name|external_symbols
decl_stmt|;
name|ieee_symbol_type
modifier|*
modifier|*
name|prev_reference_ptr
init|=
operator|&
name|ieee
operator|->
name|external_reference
decl_stmt|;
name|ieee_symbol_type
modifier|*
name|symbol
init|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
decl_stmt|;
name|unsigned
name|int
name|symbol_count
init|=
literal|0
decl_stmt|;
name|boolean
name|loop
init|=
name|true
decl_stmt|;
name|last_index
operator|=
literal|0xffffff
expr_stmt|;
name|ieee
operator|->
name|symbol_table_full
operator|=
name|true
expr_stmt|;
name|ieee_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_nn_record
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|get_symbol
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|symbol
argument_list|,
operator|&
name|symbol_count
argument_list|,
operator|&
name|prev_symbols_ptr
argument_list|,
operator|&
name|ieee
operator|->
name|external_symbol_max_index
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|symbol
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|name
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|udata
operator|.
name|p
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
break|break;
case|case
name|ieee_external_symbol_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|get_symbol
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|symbol
argument_list|,
operator|&
name|symbol_count
argument_list|,
operator|&
name|prev_symbols_ptr
argument_list|,
operator|&
name|ieee
operator|->
name|external_symbol_max_index
argument_list|,
literal|'D'
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
name|symbol
operator|->
name|index
operator|>=
name|ieee
operator|->
name|external_symbol_min_index
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|name
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|udata
operator|.
name|p
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
break|break;
case|case
name|ieee_attribute_record_enum
operator|>>
literal|8
case|:
block|{
name|unsigned
name|int
name|symbol_name_index
decl_stmt|;
name|unsigned
name|int
name|symbol_type_index
decl_stmt|;
name|unsigned
name|int
name|symbol_attribute_def
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
switch|switch
condition|(
name|read_2bytes
argument_list|(
name|ieee
argument_list|)
condition|)
block|{
case|case
name|ieee_attribute_record_enum
case|:
name|symbol_name_index
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol_type_index
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol_attribute_def
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|symbol_attribute_def
condition|)
block|{
case|case
literal|8
case|:
case|case
literal|19
case|:
name|parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unimplemented ATI record  %u for symbol %u"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|symbol_attribute_def
argument_list|,
name|symbol_name_index
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
break|break;
block|}
break|break;
case|case
name|ieee_external_reference_info_record_enum
case|:
comment|/* Skip over ATX record. */
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_atn_record_enum
case|:
comment|/* We may get call optimization information here, 		   which we just ignore.  The format is 		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs} */
name|parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0x3f
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unexpected ATN type %d in external part"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
name|value
operator|>
literal|0
condition|)
block|{
name|bfd_vma
name|val1
decl_stmt|;
operator|--
name|value
expr_stmt|;
switch|switch
condition|(
name|read_2bytes
argument_list|(
name|ieee
argument_list|)
condition|)
block|{
case|case
name|ieee_asn_record_enum
case|:
name|parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unexpected type after ATN"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|ieee_value_record_enum
operator|>>
literal|8
case|:
block|{
name|unsigned
name|int
name|symbol_name_index
decl_stmt|;
name|ieee_symbol_index_type
name|symbol_ignore
decl_stmt|;
name|boolean
name|pcrel_ignore
decl_stmt|;
name|unsigned
name|int
name|extra
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol_name_index
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|parse_expression
argument_list|(
name|ieee
argument_list|,
operator|&
name|symbol
operator|->
name|symbol
operator|.
name|value
argument_list|,
operator|&
name|symbol_ignore
argument_list|,
operator|&
name|pcrel_ignore
argument_list|,
operator|&
name|extra
argument_list|,
operator|&
name|symbol
operator|->
name|symbol
operator|.
name|section
argument_list|)
expr_stmt|;
comment|/* Fully linked IEEE-695 files tend to give every symbol                an absolute value.  Try to convert that back into a                section relative value.  FIXME: This won't always to                the right thing.  */
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|symbol
operator|.
name|section
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|HAS_RELOC
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|val
operator|=
name|symbol
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|val
operator|>=
name|s
operator|->
name|vma
operator|&&
name|val
operator|<
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
condition|)
block|{
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|value
operator|-=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
block|}
block|}
block|}
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
expr_stmt|;
block|}
break|break;
case|case
name|ieee_weak_external_reference_enum
case|:
block|{
name|bfd_vma
name|size
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Throw away the external reference index */
operator|(
name|void
operator|)
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch the default size if not resolved */
name|size
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch the defautlt value if available */
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
operator|==
name|false
condition|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* This turns into a common */
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|value
operator|=
name|size
expr_stmt|;
block|}
break|break;
case|case
name|ieee_external_reference_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|get_symbol
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|symbol
argument_list|,
operator|&
name|symbol_count
argument_list|,
operator|&
name|prev_reference_ptr
argument_list|,
operator|&
name|ieee
operator|->
name|external_reference_max_index
argument_list|,
literal|'X'
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|symbol
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|name
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|udata
operator|.
name|p
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|bfd_vma
operator|)
literal|0
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|symbol
operator|->
name|index
operator|>=
name|ieee
operator|->
name|external_reference_min_index
argument_list|)
expr_stmt|;
break|break;
default|default:
name|loop
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ieee
operator|->
name|external_symbol_max_index
operator|!=
literal|0
condition|)
block|{
name|ieee
operator|->
name|external_symbol_count
operator|=
name|ieee
operator|->
name|external_symbol_max_index
operator|-
name|ieee
operator|->
name|external_symbol_min_index
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ieee
operator|->
name|external_symbol_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ieee
operator|->
name|external_reference_max_index
operator|!=
literal|0
condition|)
block|{
name|ieee
operator|->
name|external_reference_count
operator|=
name|ieee
operator|->
name|external_reference_max_index
operator|-
name|ieee
operator|->
name|external_reference_min_index
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ieee
operator|->
name|external_reference_count
operator|=
literal|0
expr_stmt|;
block|}
name|abfd
operator|->
name|symcount
operator|=
name|ieee
operator|->
name|external_reference_count
operator|+
name|ieee
operator|->
name|external_symbol_count
expr_stmt|;
if|if
condition|(
name|symbol_count
operator|!=
name|abfd
operator|->
name|symcount
condition|)
block|{
comment|/* There are gaps in the table -- */
name|ieee
operator|->
name|symbol_table_full
operator|=
name|false
expr_stmt|;
block|}
operator|*
name|prev_symbols_ptr
operator|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|prev_reference_ptr
operator|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|read_symbols
operator|==
name|false
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_slurp_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|read_symbols
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|long
name|ieee_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ieee_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|abfd
operator|->
name|symcount
operator|!=
literal|0
operator|)
condition|?
operator|(
name|abfd
operator|->
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|ieee_symbol_type
operator|*
argument_list|)
operator|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move from our internal lists to the canon table, and insert in symbol index order */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|ieee_vec
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|ieee_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|location
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|location
decl_stmt|;
block|{
name|ieee_symbol_type
modifier|*
name|symp
decl_stmt|;
specifier|static
name|bfd
name|dummy_bfd
decl_stmt|;
specifier|static
name|asymbol
name|empty_symbol
init|=
block|{
operator|&
name|dummy_bfd
block|,
literal|" ieee empty"
block|,
operator|(
name|symvalue
operator|)
literal|0
block|,
name|BSF_DEBUGGING
block|,
name|bfd_abs_section_ptr
ifdef|#
directive|ifdef
name|__STDC__
comment|/* K&R compilers can't initialise unions.  */
block|,
block|{
literal|0
block|}
endif|#
directive|endif
block|}
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
condition|)
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|dummy_bfd
operator|.
name|xvec
operator|=
operator|&
name|ieee_vec
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ieee
operator|->
name|symbol_table_full
operator|==
name|false
condition|)
block|{
comment|/* Arrgh - there are gaps in the table, run through and fill them */
comment|/* up with pointers to a null place */
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|symcount
condition|;
name|i
operator|++
control|)
block|{
name|location
index|[
name|i
index|]
operator|=
operator|&
name|empty_symbol
expr_stmt|;
block|}
block|}
name|ieee
operator|->
name|external_symbol_base_offset
operator|=
operator|-
name|ieee
operator|->
name|external_symbol_min_index
expr_stmt|;
for|for
control|(
name|symp
operator|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_symbols
init|;
name|symp
operator|!=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
condition|;
name|symp
operator|=
name|symp
operator|->
name|next
control|)
block|{
comment|/* Place into table at correct index locations */
name|location
index|[
name|symp
operator|->
name|index
operator|+
name|ieee
operator|->
name|external_symbol_base_offset
index|]
operator|=
operator|&
name|symp
operator|->
name|symbol
expr_stmt|;
block|}
comment|/* The external refs are indexed in a bit */
name|ieee
operator|->
name|external_reference_base_offset
operator|=
operator|-
name|ieee
operator|->
name|external_reference_min_index
operator|+
name|ieee
operator|->
name|external_symbol_count
expr_stmt|;
for|for
control|(
name|symp
operator|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_reference
init|;
name|symp
operator|!=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
condition|;
name|symp
operator|=
name|symp
operator|->
name|next
control|)
block|{
name|location
index|[
name|symp
operator|->
name|index
operator|+
name|ieee
operator|->
name|external_reference_base_offset
index|]
operator|=
operator|&
name|symp
operator|->
name|symbol
expr_stmt|;
block|}
block|}
if|if
condition|(
name|abfd
operator|->
name|symcount
condition|)
block|{
name|location
index|[
name|abfd
operator|->
name|symcount
index|]
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|abfd
operator|->
name|symcount
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|get_section_entry
parameter_list|(
name|abfd
parameter_list|,
name|ieee
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|>=
name|ieee
operator|->
name|section_table_size
condition|)
block|{
name|unsigned
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|asection
modifier|*
modifier|*
name|n
decl_stmt|;
name|c
operator|=
name|ieee
operator|->
name|section_table_size
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|c
operator|=
literal|20
expr_stmt|;
while|while
condition|(
name|c
operator|<=
name|index
condition|)
name|c
operator|*=
literal|2
expr_stmt|;
name|n
operator|=
operator|(
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|ieee
operator|->
name|section_table
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
name|ieee
operator|->
name|section_table_size
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|n
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ieee
operator|->
name|section_table
operator|=
name|n
expr_stmt|;
name|ieee
operator|->
name|section_table_size
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|ieee
operator|->
name|section_table
index|[
name|index
index|]
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|" fsec%4d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|section_table
index|[
name|index
index|]
operator|=
name|section
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|section
operator|->
name|target_index
operator|=
name|index
expr_stmt|;
name|ieee
operator|->
name|section_table
index|[
name|index
index|]
operator|=
name|section
expr_stmt|;
block|}
return|return
name|ieee
operator|->
name|section_table
index|[
name|index
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee_slurp_sections
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|file_ptr
name|offset
init|=
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|section_part
decl_stmt|;
name|asection
modifier|*
name|section
init|=
operator|(
name|asection
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
name|section_type
index|[
literal|3
index|]
decl_stmt|;
name|ieee_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_section_type_enum
case|:
block|{
name|unsigned
name|int
name|section_index
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section_index
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|=
name|get_section_entry
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|section_index
argument_list|)
expr_stmt|;
name|section_type
index|[
literal|0
index|]
operator|=
name|this_byte_and_next
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Set minimal section attributes. Attributes are 		   extended later, based on section contents. */
switch|switch
condition|(
name|section_type
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0xC1
case|:
comment|/* Normal attributes for absolute sections	*/
name|section_type
index|[
literal|1
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
switch|switch
condition|(
name|section_type
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0xD3
case|:
comment|/* AS Absolute section attributes */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section_type
index|[
literal|2
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|section_type
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|0xD0
case|:
comment|/* Normal code */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
break|break;
case|case
literal|0xC4
case|:
comment|/* Normal data */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
break|break;
case|case
literal|0xD2
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Normal rom data */
name|section
operator|->
name|flags
operator||=
name|SEC_ROM
operator||
name|SEC_DATA
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
literal|0xC3
case|:
comment|/* Named relocatable sections (type C) */
name|section_type
index|[
literal|1
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
switch|switch
condition|(
name|section_type
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0xD0
case|:
comment|/* Normal code (CP) */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
break|break;
case|case
literal|0xC4
case|:
comment|/* Normal data (CD) */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
break|break;
case|case
literal|0xD2
case|:
comment|/* Normal rom data (CR) */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_ROM
operator||
name|SEC_DATA
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Read section name, use it if non empty. */
name|name
operator|=
name|read_id
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
condition|)
name|section
operator|->
name|name
operator|=
name|name
expr_stmt|;
comment|/* Skip these fields, which we don't care about */
block|{
name|bfd_vma
name|parent
decl_stmt|,
name|brother
decl_stmt|,
name|context
decl_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|parent
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|brother
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ieee_section_alignment_enum
case|:
block|{
name|unsigned
name|int
name|section_index
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section_index
operator|=
name|must_parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|)
expr_stmt|;
name|section
operator|=
name|get_section_entry
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|section_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_index
operator|>
name|ieee
operator|->
name|section_count
condition|)
block|{
name|ieee
operator|->
name|section_count
operator|=
name|section_index
expr_stmt|;
block|}
name|section
operator|->
name|alignment_power
operator|=
name|bfd_log2
argument_list|(
name|must_parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_e2_first_byte_enum
case|:
block|{
name|ieee_record_enum_type
name|t
init|=
call|(
name|ieee_record_enum_type
call|)
argument_list|(
name|read_2bytes
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|ieee_section_size_enum
case|:
name|section
operator|=
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_physical_region_size_enum
case|:
name|section
operator|=
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_region_base_address_enum
case|:
name|section
operator|=
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
expr_stmt|;
name|section
operator|->
name|vma
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|lma
operator|=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|ieee_mau_size_enum
case|:
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_m_value_enum
case|:
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_section_base_address_enum
case|:
name|section
operator|=
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
expr_stmt|;
name|section
operator|->
name|vma
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|lma
operator|=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|ieee_section_offset_enum
case|:
operator|(
name|void
operator|)
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
break|break;
default|default:
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make a section for the debugging information, if any.  We don't try    to interpret the debugging information; we just point the section    at the area in the file so that program which understand can dig it    out.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_slurp_debug
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|file_ptr
name|debug_end
decl_stmt|;
if|if
condition|(
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|sec
operator|->
name|flags
operator||=
name|SEC_DEBUGGING
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sec
operator|->
name|filepos
operator|=
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
expr_stmt|;
name|debug_end
operator|=
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|data_part
expr_stmt|;
if|if
condition|(
name|debug_end
operator|==
literal|0
condition|)
name|debug_end
operator|=
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|trailer_part
expr_stmt|;
if|if
condition|(
name|debug_end
operator|==
literal|0
condition|)
name|debug_end
operator|=
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|me_record
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
name|debug_end
operator|-
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*********************************************************************** *  archive stuff */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|ieee_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
name|library
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|file_ptr
name|buffer_offset
init|=
literal|0
decl_stmt|;
name|ieee_ar_data_type
modifier|*
name|save
init|=
name|abfd
operator|->
name|tdata
operator|.
name|ieee_ar_data
decl_stmt|;
name|ieee_ar_data_type
modifier|*
name|ieee
decl_stmt|;
name|unsigned
name|int
name|alc_elts
decl_stmt|;
name|ieee_ar_obstack_type
modifier|*
name|elts
init|=
name|NULL
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|ieee_ar_data
operator|=
operator|(
name|ieee_ar_data_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_ar_data_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|ieee_ar_data
condition|)
goto|goto
name|error_return
goto|;
name|ieee
operator|=
name|IEEE_AR_DATA
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* FIXME: Check return value.  I'm not sure whether it needs to read      the entire buffer or not.  */
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|first_byte
operator|=
name|buffer
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|buffer
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
name|Module_Beginning
condition|)
goto|goto
name|got_wrong_format_error
goto|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|library
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|library
argument_list|,
literal|"LIBRARY"
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* Throw away the filename.  */
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|element_count
operator|=
literal|0
expr_stmt|;
name|ieee
operator|->
name|element_index
operator|=
literal|0
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop the ad part.  */
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* And the two dummy numbers.  */
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|alc_elts
operator|=
literal|10
expr_stmt|;
name|elts
operator|=
operator|(
name|ieee_ar_obstack_type
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|alc_elts
operator|*
sizeof|sizeof
expr|*
name|elts
argument_list|)
expr_stmt|;
if|if
condition|(
name|elts
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read the index of the BB table.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|rec
decl_stmt|;
name|ieee_ar_obstack_type
modifier|*
name|t
decl_stmt|;
name|rec
operator|=
name|read_2bytes
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|!=
operator|(
name|int
operator|)
name|ieee_assign_value_to_variable_enum
condition|)
break|break;
if|if
condition|(
name|ieee
operator|->
name|element_count
operator|>=
name|alc_elts
condition|)
block|{
name|ieee_ar_obstack_type
modifier|*
name|n
decl_stmt|;
name|alc_elts
operator|*=
literal|2
expr_stmt|;
name|n
operator|=
operator|(
operator|(
name|ieee_ar_obstack_type
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|elts
argument_list|,
name|alc_elts
operator|*
sizeof|sizeof
expr|*
name|elts
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|elts
operator|=
name|n
expr_stmt|;
block|}
name|t
operator|=
operator|&
name|elts
index|[
name|ieee
operator|->
name|element_count
index|]
expr_stmt|;
name|ieee
operator|->
name|element_count
operator|++
expr_stmt|;
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|file_offset
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|abfd
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Make sure that we don't go over the end of the buffer.  */
if|if
condition|(
operator|(
name|size_t
operator|)
name|ieee_pos
argument_list|(
name|abfd
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|/
literal|2
condition|)
block|{
comment|/* Past half way, reseek and reprime.  */
name|buffer_offset
operator|+=
name|ieee_pos
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|buffer_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* FIXME: Check return value.  I'm not sure whether it needs 	     to read the entire buffer or not.  */
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|first_byte
operator|=
name|buffer
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|buffer
expr_stmt|;
block|}
block|}
name|ieee
operator|->
name|elements
operator|=
operator|(
operator|(
name|ieee_ar_obstack_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|ieee
operator|->
name|element_count
operator|*
sizeof|sizeof
expr|*
name|ieee
operator|->
name|elements
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ieee
operator|->
name|elements
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|memcpy
argument_list|(
name|ieee
operator|->
name|elements
argument_list|,
name|elts
argument_list|,
name|ieee
operator|->
name|element_count
operator|*
sizeof|sizeof
expr|*
name|ieee
operator|->
name|elements
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elts
argument_list|)
expr_stmt|;
name|elts
operator|=
name|NULL
expr_stmt|;
comment|/* Now scan the area again, and replace BB offsets with file offsets.  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ieee
operator|->
name|element_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|ieee
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|file_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* FIXME: Check return value.  I'm not sure whether it needs to 	 read the entire buffer or not.  */
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|first_byte
operator|=
name|buffer
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|buffer
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop F8.  */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop 14.  */
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop size of block.  */
if|if
condition|(
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
literal|0
condition|)
comment|/* This object has been deleted.  */
name|ieee
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|file_offset
operator|=
literal|0
expr_stmt|;
else|else
name|ieee
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|file_offset
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  abfd->has_armap = ;*/
return|return
name|abfd
operator|->
name|xvec
return|;
name|got_wrong_format_error
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|ieee_ar_data
operator|=
name|save
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|error_return
label|:
if|if
condition|(
name|elts
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|elts
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|abfd
operator|->
name|tdata
operator|.
name|ieee_data
operator|=
operator|(
name|ieee_data_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_data_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|tdata
operator|.
name|ieee_data
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_function
specifier|const
name|bfd_target
modifier|*
name|ieee_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
name|processor
decl_stmt|;
name|unsigned
name|int
name|part
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
decl_stmt|;
name|unsigned
name|char
name|buffer
index|[
literal|300
index|]
decl_stmt|;
name|ieee_data_type
modifier|*
name|save
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|ieee_data
operator|=
literal|0
expr_stmt|;
name|ieee_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Read the first few bytes in to see if it makes sense */
comment|/* FIXME: Check return value.  I'm not sure whether it needs to read      the entire buffer or not.  */
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|this_byte_and_next
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
name|Module_Beginning
condition|)
goto|goto
name|got_wrong_format
goto|;
name|ieee
operator|->
name|read_symbols
operator|=
name|false
expr_stmt|;
name|ieee
operator|->
name|read_data
operator|=
name|false
expr_stmt|;
name|ieee
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
name|ieee
operator|->
name|external_symbol_max_index
operator|=
literal|0
expr_stmt|;
name|ieee
operator|->
name|external_symbol_min_index
operator|=
name|IEEE_PUBLIC_BASE
expr_stmt|;
name|ieee
operator|->
name|external_reference_min_index
operator|=
name|IEEE_REFERENCE_BASE
expr_stmt|;
name|ieee
operator|->
name|external_reference_max_index
operator|=
literal|0
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|ieee
operator|->
name|section_table
operator|=
name|NULL
expr_stmt|;
name|ieee
operator|->
name|section_table_size
operator|=
literal|0
expr_stmt|;
name|processor
operator|=
name|ieee
operator|->
name|mb
operator|.
name|processor
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|processor
argument_list|,
literal|"LIBRARY"
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|got_wrong_format
goto|;
name|ieee
operator|->
name|mb
operator|.
name|module_name
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|filename
operator|==
operator|(
name|CONST
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|abfd
operator|->
name|filename
operator|=
name|ieee
operator|->
name|mb
operator|.
name|module_name
expr_stmt|;
block|}
comment|/* Determine the architecture and machine type of the object file.      */
block|{
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch
decl_stmt|;
name|char
name|family
index|[
literal|10
index|]
decl_stmt|;
comment|/* IEEE does not specify the format of the processor identificaton        string, so the compiler is free to put in it whatever it wants.        We try here to recognize different processors belonging to the        m68k family.  Code for other processors can be added here.  */
if|if
condition|(
operator|(
name|processor
index|[
literal|0
index|]
operator|==
literal|'6'
operator|)
operator|&&
operator|(
name|processor
index|[
literal|1
index|]
operator|==
literal|'8'
operator|)
condition|)
block|{
if|if
condition|(
name|processor
index|[
literal|2
index|]
operator|==
literal|'3'
condition|)
comment|/* 683xx integrated processors */
block|{
switch|switch
condition|(
name|processor
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* 68302, 68306, 68307 */
case|case
literal|'2'
case|:
comment|/* 68322, 68328 */
case|case
literal|'5'
case|:
comment|/* 68356 */
name|strcpy
argument_list|(
name|family
argument_list|,
literal|"68000"
argument_list|)
expr_stmt|;
comment|/* MC68000-based controllers */
break|break;
case|case
literal|'3'
case|:
comment|/* 68330, 68331, 68332, 68333, 					       68334, 68335, 68336, 68338 */
case|case
literal|'6'
case|:
comment|/* 68360 */
case|case
literal|'7'
case|:
comment|/* 68376 */
name|strcpy
argument_list|(
name|family
argument_list|,
literal|"68332"
argument_list|)
expr_stmt|;
comment|/* CPU32 and CPU32+ */
break|break;
case|case
literal|'4'
case|:
if|if
condition|(
name|processor
index|[
literal|4
index|]
operator|==
literal|'9'
condition|)
comment|/* 68349 */
name|strcpy
argument_list|(
name|family
argument_list|,
literal|"68030"
argument_list|)
expr_stmt|;
comment|/* CPU030 */
else|else
comment|/* 68340, 68341 */
name|strcpy
argument_list|(
name|family
argument_list|,
literal|"68332"
argument_list|)
expr_stmt|;
comment|/* CPU32 and CPU32+ */
break|break;
default|default:
comment|/* Does not exist yet */
name|strcpy
argument_list|(
name|family
argument_list|,
literal|"68332"
argument_list|)
expr_stmt|;
comment|/* Guess it will be CPU32 */
block|}
block|}
elseif|else
if|if
condition|(
name|toupper
argument_list|(
name|processor
index|[
literal|3
index|]
argument_list|)
operator|==
literal|'F'
condition|)
comment|/* 68F333 */
name|strcpy
argument_list|(
name|family
argument_list|,
literal|"68332"
argument_list|)
expr_stmt|;
comment|/* CPU32 */
elseif|else
if|if
condition|(
operator|(
name|toupper
argument_list|(
name|processor
index|[
literal|3
index|]
argument_list|)
operator|==
literal|'C'
operator|)
comment|/* Embedded controllers */
operator|&&
operator|(
operator|(
name|toupper
argument_list|(
name|processor
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'E'
operator|)
operator|||
operator|(
name|toupper
argument_list|(
name|processor
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'H'
operator|)
operator|||
operator|(
name|toupper
argument_list|(
name|processor
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'L'
operator|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|family
argument_list|,
literal|"68"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|family
argument_list|,
name|processor
operator|+
literal|4
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|family
index|[
literal|9
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
comment|/* "Regular" processors */
block|{
name|strncpy
argument_list|(
name|family
argument_list|,
name|processor
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|family
index|[
literal|9
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|processor
argument_list|,
literal|"cpu32"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
comment|/* CPU32 and CPU32+ */
operator|||
operator|(
name|strncmp
argument_list|(
name|processor
argument_list|,
literal|"CPU32"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|strcpy
argument_list|(
name|family
argument_list|,
literal|"68332"
argument_list|)
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|family
argument_list|,
name|processor
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|family
index|[
literal|9
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|arch
operator|=
name|bfd_scan_arch
argument_list|(
name|family
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
literal|0
condition|)
goto|goto
name|got_wrong_format
goto|;
name|abfd
operator|->
name|arch_info
operator|=
name|arch
expr_stmt|;
block|}
if|if
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|ieee_address_descriptor_enum
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|ieee
operator|->
name|ad
operator|.
name|number_of_bits_mau
argument_list|)
operator|==
name|false
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|ieee
operator|->
name|ad
operator|.
name|number_of_maus_in_address
argument_list|)
operator|==
name|false
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
comment|/* If there is a byte order info, take it */
if|if
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|==
operator|(
name|int
operator|)
name|ieee_variable_L_enum
operator|||
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|==
operator|(
name|int
operator|)
name|ieee_variable_M_enum
condition|)
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|N_W_VARIABLES
condition|;
name|part
operator|++
control|)
block|{
name|boolean
name|ok
decl_stmt|;
if|if
condition|(
name|read_2bytes
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|ieee_assign_value_to_variable_enum
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|this_byte_and_next
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
name|part
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|ieee
operator|->
name|w
operator|.
name|offset
index|[
name|part
index|]
operator|=
name|parse_i
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
name|false
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|external_part
operator|!=
literal|0
condition|)
name|abfd
operator|->
name|flags
operator|=
name|HAS_SYMS
expr_stmt|;
comment|/* By now we know that this is a real IEEE file, we're going to read      the whole thing into memory so that we can run up and down it      quickly.  We can work out how big the file is from the trailer      record */
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|h
operator|.
name|first_byte
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|me_record
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|h
operator|.
name|first_byte
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* FIXME: Check return value.  I'm not sure whether it needs to read      the entire buffer or not.  */
name|bfd_read
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|h
operator|.
name|first_byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|me_record
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee_slurp_sections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_slurp_debug
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Parse section data to activate file and section flags implied by      section contents. */
if|if
condition|(
operator|!
name|ieee_slurp_section_data
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|fail
goto|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|got_wrong_format
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|fail
label|:
operator|(
name|void
operator|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|ieee_data
operator|=
name|save
expr_stmt|;
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ieee_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|ret
operator|->
name|name
operator|=
literal|"* empty table entry "
expr_stmt|;
if|if
condition|(
operator|!
name|symbol
operator|->
name|section
condition|)
name|ret
operator|->
name|type
operator|=
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
condition|?
literal|'a'
else|:
literal|'A'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee_print_symbol
parameter_list|(
name|ignore_abfd
parameter_list|,
name|afile
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|afile
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
if|#
directive|if
literal|0
block|fprintf (file, "%4x %2x", aout_symbol (symbol)->desc& 0xffff, 	       aout_symbol (symbol)->other& 0xff);
endif|#
directive|endif
name|BFD_FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
specifier|const
name|char
modifier|*
name|section_name
init|=
operator|(
name|symbol
operator|->
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|?
literal|"*abs"
else|:
name|symbol
operator|->
name|section
operator|->
name|name
operator|)
decl_stmt|;
if|if
condition|(
name|symbol
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"* empty table entry "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %04x %02x %s"
argument_list|,
name|section_name
argument_list|,
operator|(
name|unsigned
operator|)
name|ieee_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|index
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|do_one
parameter_list|(
name|ieee
parameter_list|,
name|current_map
parameter_list|,
name|location_ptr
parameter_list|,
name|s
parameter_list|,
name|iterations
parameter_list|)
name|ieee_data_type
modifier|*
name|ieee
decl_stmt|;
name|ieee_per_section_type
modifier|*
name|current_map
decl_stmt|;
name|unsigned
name|char
modifier|*
name|location_ptr
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|iterations
decl_stmt|;
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_load_constant_bytes_enum
case|:
block|{
name|unsigned
name|int
name|number_of_maus
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|number_of_maus
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_maus
condition|;
name|i
operator|++
control|)
block|{
name|location_ptr
index|[
name|current_map
operator|->
name|pc
operator|++
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ieee_load_with_relocation_enum
case|:
block|{
name|boolean
name|loop
init|=
name|true
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_variable_R_enum
case|:
case|case
name|ieee_function_signed_open_b_enum
case|:
case|case
name|ieee_function_unsigned_open_b_enum
case|:
case|case
name|ieee_function_either_open_b_enum
case|:
block|{
name|unsigned
name|int
name|extra
init|=
literal|4
decl_stmt|;
name|boolean
name|pcrel
init|=
name|false
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|ieee_reloc_type
modifier|*
name|r
init|=
operator|(
name|ieee_reloc_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_reloc_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|false
return|;
operator|*
operator|(
name|current_map
operator|->
name|reloc_tail_ptr
operator|)
operator|=
name|r
expr_stmt|;
name|current_map
operator|->
name|reloc_tail_ptr
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|(
name|ieee_reloc_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/*			    abort();*/
name|r
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
literal|0
expr_stmt|;
name|parse_expression
argument_list|(
name|ieee
argument_list|,
operator|&
name|r
operator|->
name|relent
operator|.
name|addend
argument_list|,
operator|&
name|r
operator|->
name|symbol
argument_list|,
operator|&
name|pcrel
argument_list|,
operator|&
name|extra
argument_list|,
operator|&
name|section
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|address
operator|=
name|current_map
operator|->
name|pc
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|s
operator|->
name|owner
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
name|s
operator|->
name|reloc_count
operator|++
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|==
name|NULL
operator|&&
name|section
operator|!=
name|NULL
condition|)
name|r
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
if|if
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|==
operator|(
name|int
operator|)
name|ieee_comma
condition|)
block|{
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch number of bytes to pad */
name|extra
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_function_signed_close_b_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_function_unsigned_close_b_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_function_either_close_b_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Build a relocation entry for this type */
comment|/* If pc rel then stick -ve pc into instruction 		     and take out of reloc ..  		     I've changed this. It's all too complicated. I 		     keep 0 in the instruction now.  */
switch|switch
condition|(
name|extra
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|4
case|:
if|if
condition|(
name|pcrel
operator|==
name|true
condition|)
block|{
if|#
directive|if
name|KEEPMINUSPCININST
name|bfd_put_32
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
operator|-
name|current_map
operator|->
name|pc
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel32_howto
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|current_map
operator|->
name|pc
expr_stmt|;
else|#
directive|else
name|bfd_put_32
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel32_howto
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|abs32_howto
expr_stmt|;
block|}
name|current_map
operator|->
name|pc
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|pcrel
operator|==
name|true
condition|)
block|{
if|#
directive|if
name|KEEPMINUSPCININST
name|bfd_put_16
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|-
name|current_map
operator|->
name|pc
argument_list|)
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|current_map
operator|->
name|pc
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel16_howto
expr_stmt|;
else|#
directive|else
name|bfd_put_16
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel16_howto
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bfd_put_16
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|abs16_howto
expr_stmt|;
block|}
name|current_map
operator|->
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|pcrel
operator|==
name|true
condition|)
block|{
if|#
directive|if
name|KEEPMINUSPCININST
name|bfd_put_8
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|-
name|current_map
operator|->
name|pc
argument_list|)
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|current_map
operator|->
name|pc
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel8_howto
expr_stmt|;
else|#
directive|else
name|bfd_put_8
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel8_howto
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bfd_put_8
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|abs8_howto
expr_stmt|;
block|}
name|current_map
operator|->
name|pc
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
break|break;
default|default:
block|{
name|bfd_vma
name|this_size
decl_stmt|;
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|this_size
argument_list|)
operator|==
name|true
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|this_size
condition|;
name|i
operator|++
control|)
block|{
name|location_ptr
index|[
name|current_map
operator|->
name|pc
operator|++
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|loop
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
comment|/* Prevent more than the first load-item of an LR record 	       from being repeated (MRI convention). */
if|if
condition|(
name|iterations
operator|!=
literal|1
condition|)
name|loop
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read in all the section data and relocation stuff too */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_slurp_section_data
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|location_ptr
init|=
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|section_number
decl_stmt|;
name|ieee_per_section_type
modifier|*
name|current_map
init|=
operator|(
name|ieee_per_section_type
operator|*
operator|)
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Seek to the start of the data area */
if|if
condition|(
name|ieee
operator|->
name|read_data
operator|==
name|true
condition|)
return|return
name|true
return|;
name|ieee
operator|->
name|read_data
operator|=
name|true
expr_stmt|;
name|ieee_seek
argument_list|(
name|abfd
argument_list|,
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|data_part
argument_list|)
expr_stmt|;
comment|/* Allocate enough space for all the section contents */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|ieee_per_section_type
modifier|*
name|per
init|=
operator|(
name|ieee_per_section_type
operator|*
operator|)
name|s
operator|->
name|used_by_bfd
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|per
operator|->
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|per
operator|->
name|data
condition|)
return|return
name|false
return|;
comment|/*SUPPRESS 68*/
name|per
operator|->
name|reloc_tail_ptr
operator|=
operator|(
name|ieee_reloc_type
operator|*
operator|*
operator|)
operator|&
operator|(
name|s
operator|->
name|relocation
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
comment|/* IF we see anything strange then quit */
default|default:
return|return
name|true
return|;
case|case
name|ieee_set_current_section_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section_number
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ieee
operator|->
name|section_table
index|[
name|section_number
index|]
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|current_map
operator|=
operator|(
name|ieee_per_section_type
operator|*
operator|)
name|s
operator|->
name|used_by_bfd
expr_stmt|;
name|location_ptr
operator|=
name|current_map
operator|->
name|data
operator|-
name|s
operator|->
name|vma
expr_stmt|;
comment|/* The document I have says that Microtec's compilers reset */
comment|/* this after a sec section, even though the standard says not */
comment|/* to. SO .. */
name|current_map
operator|->
name|pc
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|ieee_e2_first_byte_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_set_current_pc_enum
operator|&
literal|0xff
case|:
block|{
name|bfd_vma
name|value
decl_stmt|;
name|ieee_symbol_index_type
name|symbol
decl_stmt|;
name|unsigned
name|int
name|extra
decl_stmt|;
name|boolean
name|pcrel
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Thow away section #*/
name|parse_expression
argument_list|(
name|ieee
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|symbol
argument_list|,
operator|&
name|pcrel
argument_list|,
operator|&
name|extra
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_map
operator|->
name|pc
operator|=
name|value
expr_stmt|;
name|BFD_ASSERT
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|value
operator|-
name|s
operator|->
name|vma
argument_list|)
operator|<=
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_value_starting_address_enum
operator|&
literal|0xff
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|==
name|ieee_function_either_open_b_enum
condition|)
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|start_address
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* We've got to the end of the data now - */
return|return
name|true
return|;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
name|ieee_repeat_data_enum
case|:
block|{
comment|/* Repeat the following LD or LR n times - we do this by 		 remembering the stream pointer before running it and 		 resetting it and running it n times. We special case 		 the repetition of a repeat_data/load_constant 		 */
name|unsigned
name|int
name|iterations
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|iterations
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|ieee
operator|->
name|h
operator|.
name|input_p
expr_stmt|;
if|if
condition|(
name|start
index|[
literal|0
index|]
operator|==
operator|(
name|int
operator|)
name|ieee_load_constant_bytes_enum
operator|&&
name|start
index|[
literal|1
index|]
operator|==
literal|1
condition|)
block|{
while|while
condition|(
name|iterations
operator|!=
literal|0
condition|)
block|{
name|location_ptr
index|[
name|current_map
operator|->
name|pc
operator|++
index|]
operator|=
name|start
index|[
literal|2
index|]
expr_stmt|;
name|iterations
operator|--
expr_stmt|;
block|}
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|iterations
operator|!=
literal|0
condition|)
block|{
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|start
expr_stmt|;
if|if
condition|(
operator|!
name|do_one
argument_list|(
name|ieee
argument_list|,
name|current_map
argument_list|,
name|location_ptr
argument_list|,
name|s
argument_list|,
name|iterations
argument_list|)
condition|)
return|return
name|false
return|;
name|iterations
operator|--
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ieee_load_constant_bytes_enum
case|:
case|case
name|ieee_load_with_relocation_enum
case|:
block|{
if|if
condition|(
operator|!
name|do_one
argument_list|(
name|ieee
argument_list|,
name|current_map
argument_list|,
name|location_ptr
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|boolean
name|ieee_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|newsect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|newsect
decl_stmt|;
block|{
name|newsect
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_per_section_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsect
operator|->
name|used_by_bfd
condition|)
return|return
name|false
return|;
name|ieee_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
expr_stmt|;
name|ieee_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|section
operator|=
name|newsect
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|long
name|ieee_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ieee_slurp_section_data
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
name|ieee_per_section_type
modifier|*
name|p
init|=
operator|(
name|ieee_per_section_type
operator|*
operator|)
name|section
operator|->
name|used_by_bfd
decl_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
return|return
name|_bfd_generic_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
name|ieee_slurp_section_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|location
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|p
operator|->
name|data
operator|+
name|offset
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|long
name|ieee_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
comment|/*  ieee_per_section_type *p = (ieee_per_section_type *) section->used_by_bfd;*/
name|ieee_reloc_type
modifier|*
name|src
init|=
operator|(
name|ieee_reloc_type
operator|*
operator|)
operator|(
name|section
operator|->
name|relocation
operator|)
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|src
operator|!=
operator|(
name|ieee_reloc_type
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Work out which symbol to attach it this reloc to */
switch|switch
condition|(
name|src
operator|->
name|symbol
operator|.
name|letter
condition|)
block|{
case|case
literal|'I'
case|:
name|src
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|src
operator|->
name|symbol
operator|.
name|index
operator|+
name|ieee
operator|->
name|external_symbol_base_offset
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|src
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|src
operator|->
name|symbol
operator|.
name|index
operator|+
name|ieee
operator|->
name|external_reference_base_offset
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|src
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|!=
name|NULL
condition|)
name|src
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|src
operator|->
name|relent
operator|.
name|sym_ptr_ptr
index|[
literal|0
index|]
operator|->
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
operator|*
name|relptr
operator|++
operator|=
operator|&
name|src
operator|->
name|relent
expr_stmt|;
name|src
operator|=
name|src
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
operator|(
name|arelent
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|comp
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
name|CONST
name|PTR
name|ap
decl_stmt|;
name|CONST
name|PTR
name|bp
decl_stmt|;
block|{
name|arelent
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
name|arelent
operator|*
operator|*
operator|)
name|ap
operator|)
decl_stmt|;
name|arelent
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bp
operator|)
decl_stmt|;
return|return
name|a
operator|->
name|address
operator|-
name|b
operator|->
name|address
return|;
block|}
end_function

begin_comment
comment|/* Write the section headers.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_section_part
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|section_part
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_section_type_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* This image is executable, so output absolute sections */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_A_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_S_enum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_C_enum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
switch|switch
condition|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator|)
condition|)
block|{
case|case
name|SEC_CODE
operator||
name|SEC_LOAD
case|:
case|case
name|SEC_CODE
case|:
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_P_enum
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SEC_DATA
case|:
default|default:
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_D_enum
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|SEC_ROM
case|:
case|case
name|SEC_ROM
operator||
name|SEC_DATA
case|:
case|case
name|SEC_ROM
operator||
name|SEC_LOAD
case|:
case|case
name|SEC_ROM
operator||
name|SEC_DATA
operator||
name|SEC_LOAD
case|:
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_R_enum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
return|return
name|false
return|;
if|#
directive|if
literal|0
block|ieee_write_int (abfd, 0);
comment|/* Parent */
block|ieee_write_int (abfd, 0);
comment|/* Brother */
block|ieee_write_int (abfd, 0);
comment|/* Context */
endif|#
directive|endif
comment|/* Alignment */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_section_alignment_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
literal|1
operator|<<
name|s
operator|->
name|alignment_power
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Size */
if|if
condition|(
operator|!
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_section_size_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* Relocateable sections don't have asl records */
comment|/* Vma */
if|if
condition|(
operator|!
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_section_base_address_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
operator|(
call|(
name|bfd_byte
call|)
argument_list|(
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
operator|)
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|lma
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|do_with_relocs
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|int
name|number_of_maus_in_address
init|=
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
operator|/
name|bfd_arch_bits_per_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|relocs_to_go
init|=
name|s
operator|->
name|reloc_count
decl_stmt|;
name|bfd_byte
modifier|*
name|stream
init|=
name|ieee_per_section
argument_list|(
name|s
argument_list|)
operator|->
name|data
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
init|=
name|s
operator|->
name|orelocation
decl_stmt|;
name|bfd_size_type
name|current_byte_index
init|=
literal|0
decl_stmt|;
name|qsort
argument_list|(
name|s
operator|->
name|orelocation
argument_list|,
name|relocs_to_go
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
operator|*
argument_list|)
argument_list|,
name|comp
argument_list|)
expr_stmt|;
comment|/* Output the section preheader */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_section_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_pc_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
operator|&&
name|relocs_to_go
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|lma
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|symbol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|relocs_to_go
operator|==
literal|0
condition|)
block|{
comment|/* If there aren't any relocations then output the load constant 	 byte opcode rather than the load with relocation opcode */
while|while
condition|(
name|current_byte_index
operator|<
name|s
operator|->
name|_raw_size
condition|)
block|{
name|bfd_size_type
name|run
decl_stmt|;
name|unsigned
name|int
name|MAXRUN
init|=
literal|127
decl_stmt|;
name|run
operator|=
name|MAXRUN
expr_stmt|;
if|if
condition|(
name|run
operator|>
name|s
operator|->
name|_raw_size
operator|-
name|current_byte_index
condition|)
block|{
name|run
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|current_byte_index
expr_stmt|;
block|}
if|if
condition|(
name|run
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_load_constant_bytes_enum
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Output a stream of bytes */
if|if
condition|(
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|run
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|stream
operator|+
name|current_byte_index
argument_list|)
argument_list|,
literal|1
argument_list|,
name|run
argument_list|,
name|abfd
argument_list|)
operator|!=
name|run
condition|)
return|return
name|false
return|;
name|current_byte_index
operator|+=
name|run
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_load_with_relocation_enum
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Output the data stream as the longest sequence of bytes 	 possible, allowing for the a reasonable packet size and 	 relocation stuffs.  */
if|if
condition|(
operator|(
name|PTR
operator|)
name|stream
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
block|{
comment|/* Outputting a section without data, fill it up */
name|stream
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|stream
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|current_byte_index
operator|<
name|s
operator|->
name|_raw_size
condition|)
block|{
name|bfd_size_type
name|run
decl_stmt|;
name|unsigned
name|int
name|MAXRUN
init|=
literal|127
decl_stmt|;
if|if
condition|(
name|relocs_to_go
condition|)
block|{
name|run
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|address
operator|-
name|current_byte_index
expr_stmt|;
if|if
condition|(
name|run
operator|>
name|MAXRUN
condition|)
name|run
operator|=
name|MAXRUN
expr_stmt|;
block|}
else|else
block|{
name|run
operator|=
name|MAXRUN
expr_stmt|;
block|}
if|if
condition|(
name|run
operator|>
name|s
operator|->
name|_raw_size
operator|-
name|current_byte_index
condition|)
block|{
name|run
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|current_byte_index
expr_stmt|;
block|}
if|if
condition|(
name|run
operator|!=
literal|0
condition|)
block|{
comment|/* Output a stream of bytes */
if|if
condition|(
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|run
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|stream
operator|+
name|current_byte_index
argument_list|)
argument_list|,
literal|1
argument_list|,
name|run
argument_list|,
name|abfd
argument_list|)
operator|!=
name|run
condition|)
return|return
name|false
return|;
name|current_byte_index
operator|+=
name|run
expr_stmt|;
block|}
comment|/* Output any relocations here */
if|if
condition|(
name|relocs_to_go
operator|&&
operator|(
operator|*
name|p
operator|)
operator|&&
operator|(
operator|*
name|p
operator|)
operator|->
name|address
operator|==
name|current_byte_index
condition|)
block|{
while|while
condition|(
name|relocs_to_go
operator|&&
operator|(
operator|*
name|p
operator|)
operator|&&
operator|(
operator|*
name|p
operator|)
operator|->
name|address
operator|==
name|current_byte_index
condition|)
block|{
name|arelent
modifier|*
name|r
init|=
operator|*
name|p
decl_stmt|;
name|bfd_signed_vma
name|ov
decl_stmt|;
if|#
directive|if
literal|0
block|if (r->howto->pc_relative) 		    { 		      r->addend += current_byte_index; 		    }
endif|#
directive|endif
switch|switch
condition|(
name|r
operator|->
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|2
case|:
name|ov
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
name|stream
operator|+
name|current_byte_index
argument_list|)
expr_stmt|;
name|current_byte_index
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ov
operator|=
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
name|stream
operator|+
name|current_byte_index
argument_list|)
expr_stmt|;
name|current_byte_index
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|ov
operator|=
name|bfd_get_signed_8
argument_list|(
name|abfd
argument_list|,
name|stream
operator|+
name|current_byte_index
argument_list|)
expr_stmt|;
name|current_byte_index
operator|++
expr_stmt|;
break|break;
default|default:
name|ov
operator|=
literal|0
expr_stmt|;
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
name|ov
operator|&=
name|r
operator|->
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|howto
operator|->
name|pc_relative
operator|&&
operator|!
name|r
operator|->
name|howto
operator|->
name|pcrel_offset
condition|)
name|ov
operator|+=
name|r
operator|->
name|address
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_either_open_b_enum
argument_list|)
condition|)
return|return
name|false
return|;
comment|/*		  abort();*/
if|if
condition|(
name|r
operator|->
name|sym_ptr_ptr
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|addend
operator|+
name|ov
argument_list|,
operator|*
operator|(
name|r
operator|->
name|sym_ptr_ptr
operator|)
argument_list|,
name|r
operator|->
name|howto
operator|->
name|pc_relative
argument_list|,
name|s
operator|->
name|index
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|addend
operator|+
name|ov
argument_list|,
operator|(
name|asymbol
operator|*
operator|)
name|NULL
argument_list|,
name|r
operator|->
name|howto
operator|->
name|pc_relative
argument_list|,
name|s
operator|->
name|index
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|number_of_maus_in_address
operator|!=
name|bfd_get_reloc_size
argument_list|(
name|r
operator|->
name|howto
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|bfd_get_reloc_size
argument_list|(
name|r
operator|->
name|howto
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_either_close_b_enum
argument_list|)
condition|)
return|return
name|false
return|;
name|relocs_to_go
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If there are no relocations in the output section then we can be    clever about how we write.  We block items up into a max of 127    bytes.  */
end_comment

begin_function
specifier|static
name|boolean
name|do_as_repeat
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_section_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_pc_enum
operator|>>
literal|8
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_pc_enum
operator|&
literal|0xff
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|lma
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_repeat_data_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_load_constant_bytes_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|do_without_relocs
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|stream
init|=
name|ieee_per_section
argument_list|(
name|s
argument_list|)
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
operator|||
operator|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|do_as_repeat
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|_raw_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stream
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|do_with_relocs
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
block|}
if|if
condition|(
operator|!
name|do_as_repeat
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|output_ptr_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|output_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|output_ptr_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|input_ptr_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|input_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|input_ptr_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_buffer
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fill
parameter_list|()
block|{
comment|/* FIXME: Check return value.  I'm not sure whether it needs to read      the entire buffer or not.  */
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|input_ptr_start
argument_list|,
literal|1
argument_list|,
name|input_ptr_end
operator|-
name|input_ptr_start
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
name|input_ptr
operator|=
name|input_ptr_start
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush
parameter_list|()
block|{
if|if
condition|(
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|output_ptr_start
argument_list|)
argument_list|,
literal|1
argument_list|,
name|output_ptr
operator|-
name|output_ptr_start
argument_list|,
name|output_bfd
argument_list|)
operator|!=
call|(
name|bfd_size_type
call|)
argument_list|(
name|output_ptr
operator|-
name|output_ptr_start
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|output_ptr
operator|=
name|output_ptr_start
expr_stmt|;
name|output_buffer
operator|++
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|THIS
parameter_list|()
value|( *input_ptr )
end_define

begin_define
define|#
directive|define
name|NEXT
parameter_list|()
value|{ input_ptr++; if (input_ptr == input_ptr_end) fill(); }
end_define

begin_define
define|#
directive|define
name|OUT
parameter_list|(
name|x
parameter_list|)
value|{ *output_ptr++ = (x); if(output_ptr == output_ptr_end)  flush(); }
end_define

begin_function
specifier|static
name|void
name|write_int
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|>=
literal|0
operator|&&
name|value
operator|<=
literal|127
condition|)
block|{
name|OUT
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|/* How many significant bytes ? */
comment|/* FIXME FOR LONGER INTS */
if|if
condition|(
name|value
operator|&
literal|0xff000000
condition|)
block|{
name|length
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|&
literal|0x00ff0000
condition|)
block|{
name|length
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|&
literal|0x0000ff00
condition|)
block|{
name|length
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|length
operator|=
literal|1
expr_stmt|;
name|OUT
argument_list|(
operator|(
name|int
operator|)
name|ieee_number_repeat_start_enum
operator|+
name|length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|4
case|:
name|OUT
argument_list|(
name|value
operator|>>
literal|24
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|OUT
argument_list|(
name|value
operator|>>
literal|16
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|OUT
argument_list|(
name|value
operator|>>
literal|8
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|OUT
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|copy_id
parameter_list|()
block|{
name|int
name|length
init|=
name|THIS
argument_list|()
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|OUT
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|VAR
parameter_list|(
name|x
parameter_list|)
value|((x | 0x80))
end_define

begin_function
specifier|static
name|void
name|copy_expression
parameter_list|()
block|{
name|int
name|stack
index|[
literal|10
index|]
decl_stmt|;
name|int
modifier|*
name|tos
init|=
name|stack
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|THIS
argument_list|()
condition|)
block|{
case|case
literal|0x84
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|0x83
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|0x82
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|0x81
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|THIS
argument_list|()
operator|>
literal|0x84
condition|)
block|{
comment|/* Not a number, just bug out with the answer */
name|write_int
argument_list|(
operator|*
operator|(
operator|--
name|tos
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|tos
operator|++
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xa5
case|:
comment|/* PLUS anything */
block|{
name|int
name|value
init|=
operator|*
operator|(
operator|--
name|tos
operator|)
decl_stmt|;
name|value
operator|+=
operator|*
operator|(
operator|--
name|tos
operator|)
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|VAR
argument_list|(
literal|'R'
argument_list|)
case|:
block|{
name|int
name|section_number
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|section_number
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|ieee
operator|=
name|IEEE_DATA
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|ieee
operator|->
name|section_table
index|[
name|section_number
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|output_section
condition|)
block|{
name|value
operator|=
name|s
operator|->
name|output_section
operator|->
name|lma
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|+=
name|s
operator|->
name|output_offset
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0x90
case|:
block|{
name|NEXT
argument_list|()
expr_stmt|;
name|write_int
argument_list|(
operator|*
operator|(
operator|--
name|tos
operator|)
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x90
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Drop the int in the buffer, and copy a null into the gap, which we    will overwrite later */
end_comment

begin_struct
struct|struct
name|output_buffer_struct
block|{
name|unsigned
name|char
modifier|*
name|ptrp
decl_stmt|;
name|int
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|fill_int
parameter_list|(
name|buf
parameter_list|)
name|struct
name|output_buffer_struct
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|buffer
operator|==
name|output_buffer
condition|)
block|{
comment|/* Still a chance to output the size */
name|int
name|value
init|=
name|output_ptr
operator|-
name|buf
operator|->
name|ptrp
operator|+
literal|3
decl_stmt|;
name|buf
operator|->
name|ptrp
index|[
literal|0
index|]
operator|=
name|value
operator|>>
literal|24
expr_stmt|;
name|buf
operator|->
name|ptrp
index|[
literal|1
index|]
operator|=
name|value
operator|>>
literal|16
expr_stmt|;
name|buf
operator|->
name|ptrp
index|[
literal|2
index|]
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|buf
operator|->
name|ptrp
index|[
literal|3
index|]
operator|=
name|value
operator|>>
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|drop_int
parameter_list|(
name|buf
parameter_list|)
name|struct
name|output_buffer_struct
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|type
init|=
name|THIS
argument_list|()
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|type
operator|<=
literal|0x84
condition|)
block|{
name|NEXT
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x84
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x83
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x82
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x81
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x80
case|:
break|break;
block|}
block|}
name|OUT
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
name|buf
operator|->
name|ptrp
operator|=
name|output_ptr
expr_stmt|;
name|buf
operator|->
name|buffer
operator|=
name|output_buffer
expr_stmt|;
name|OUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_int
parameter_list|()
block|{
name|int
name|type
init|=
name|THIS
argument_list|()
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|type
operator|<=
literal|0x84
condition|)
block|{
name|OUT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x84
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
case|case
literal|0x83
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
case|case
literal|0x82
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
case|case
literal|0x81
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
case|case
literal|0x80
case|:
break|break;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ID
value|copy_id()
end_define

begin_define
define|#
directive|define
name|INT
value|copy_int()
end_define

begin_define
define|#
directive|define
name|EXP
value|copy_expression()
end_define

begin_function_decl
specifier|static
name|void
name|copy_till_end
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|INTn
parameter_list|(
name|q
parameter_list|)
value|copy_int()
end_define

begin_define
define|#
directive|define
name|EXPn
parameter_list|(
name|q
parameter_list|)
value|copy_expression()
end_define

begin_function
specifier|static
name|void
name|f1_record
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
comment|/* ATN record */
name|NEXT
argument_list|()
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
name|OUT
argument_list|(
literal|0xf1
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc9
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf1
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0xc9
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x16
case|:
name|NEXT
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|NEXT
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x00
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|INT
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|INT
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|EXPn
argument_list|(
argument|instruction address
argument_list|)
empty_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|0xd8
case|:
comment|/* EXternal ref */
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf1
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0xd8
argument_list|)
expr_stmt|;
name|EXP
expr_stmt|;
name|EXP
expr_stmt|;
name|EXP
expr_stmt|;
name|EXP
expr_stmt|;
break|break;
case|case
literal|0xce
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf1
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0xce
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|INT
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x01
case|:
name|INT
expr_stmt|;
name|INT
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|INT
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
name|EXPn
argument_list|(
argument|external function
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x05
case|:
break|break;
case|case
literal|0x07
case|:
name|INTn
argument_list|(
argument|line number
argument_list|)
empty_stmt|;
name|INT
expr_stmt|;
case|case
literal|0x08
case|:
break|break;
case|case
literal|0x0a
case|:
name|INTn
argument_list|(
name|locked
specifier|register
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
break|break;
case|case
literal|0x3f
case|:
name|copy_till_end
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x3e
case|:
name|copy_till_end
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
name|copy_till_end
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x41
case|:
name|ID
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|f0_record
parameter_list|()
block|{
comment|/* Attribute record */
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf0
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
argument|Symbol name
argument_list|)
empty_stmt|;
name|ID
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_till_end
parameter_list|()
block|{
name|int
name|ch
init|=
name|THIS
argument_list|()
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|ch
operator|<=
literal|0x80
condition|)
block|{
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x84
case|:
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x83
case|:
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x82
case|:
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x81
case|:
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|f2_record
parameter_list|()
block|{
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf2
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xce
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
name|copy_till_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|block
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|f8_record
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x01
case|:
case|case
literal|0x02
case|:
case|case
literal|0x03
case|:
comment|/* Unique typedefs for module */
comment|/* GLobal typedefs  */
comment|/* High level module scope beginning */
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x04
case|:
comment|/* Global function */
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x04
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|INTn
argument_list|(
argument|stack size
argument_list|)
empty_stmt|;
name|INTn
argument_list|(
argument|ret val
argument_list|)
empty_stmt|;
name|EXPn
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|EXPn
argument_list|(
argument|size of block
argument_list|)
empty_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x05
case|:
comment|/* File name for source line numbers */
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x05
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|INTn
argument_list|(
name|year
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|month
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|day
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|hour
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|monute
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|second
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x06
case|:
comment|/* Local function */
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x06
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|INTn
argument_list|(
argument|stack size
argument_list|)
empty_stmt|;
name|INTn
argument_list|(
argument|type return
argument_list|)
empty_stmt|;
name|EXPn
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|EXPn
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x0a
case|:
comment|/* Assembler module scope beginning -*/
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x0a
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|ID
expr_stmt|;
name|INT
expr_stmt|;
name|ID
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x0b
case|:
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x0b
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|INT
expr_stmt|;
name|INTn
argument_list|(
argument|section index
argument_list|)
empty_stmt|;
name|EXPn
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|stuff
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|EXPn
argument_list|(
argument|Size in Maus
argument_list|)
empty_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e2_record
parameter_list|()
block|{
name|OUT
argument_list|(
literal|0xe2
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xce
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|INT
expr_stmt|;
name|EXP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|block
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0xe1
case|:
case|case
literal|0xe5
case|:
return|return;
case|case
literal|0xf9
case|:
return|return;
case|case
literal|0xf0
case|:
name|f0_record
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xf1
case|:
name|f1_record
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xf2
case|:
name|f2_record
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xf8
case|:
name|f8_record
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xe2
case|:
name|e2_record
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* relocate_debug,    moves all the debug information from the source bfd to the output    bfd, and relocates any expressions it finds */
end_comment

begin_function
specifier|static
name|void
name|relocate_debug
parameter_list|(
name|output
parameter_list|,
name|input
parameter_list|)
name|bfd
modifier|*
name|output
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|input
decl_stmt|;
block|{
define|#
directive|define
name|IBS
value|400
define|#
directive|define
name|OBS
value|400
name|unsigned
name|char
name|input_buffer
index|[
name|IBS
index|]
decl_stmt|;
name|input_ptr_start
operator|=
name|input_ptr
operator|=
name|input_buffer
expr_stmt|;
name|input_ptr_end
operator|=
name|input_buffer
operator|+
name|IBS
expr_stmt|;
name|input_bfd
operator|=
name|input
expr_stmt|;
comment|/* FIXME: Check return value.  I'm not sure whether it needs to read      the entire buffer or not.  */
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|input_ptr_start
argument_list|,
literal|1
argument_list|,
name|IBS
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gather together all the debug information from each input BFD into    one place, relocating it and emitting it as we go.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_debug_part
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_chain_type
modifier|*
name|chain
init|=
name|ieee
operator|->
name|chain_root
decl_stmt|;
name|unsigned
name|char
name|output_buffer
index|[
name|OBS
index|]
decl_stmt|;
name|boolean
name|some_debug
init|=
name|false
decl_stmt|;
name|file_ptr
name|here
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|output_ptr_start
operator|=
name|output_ptr
operator|=
name|output_buffer
expr_stmt|;
name|output_ptr_end
operator|=
name|output_buffer
operator|+
name|OBS
expr_stmt|;
name|output_ptr
operator|=
name|output_buffer
expr_stmt|;
name|output_bfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|chain
operator|==
operator|(
name|bfd_chain_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
operator|=
name|here
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|1
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|s
operator|->
name|_raw_size
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
while|while
condition|(
name|chain
operator|!=
operator|(
name|bfd_chain_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|entry
init|=
name|chain
operator|->
name|this
decl_stmt|;
name|ieee_data_type
modifier|*
name|entry_ieee
init|=
name|IEEE_DATA
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry_ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|entry
argument_list|,
name|entry_ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|relocate_debug
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|some_debug
condition|)
block|{
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
operator|=
name|here
expr_stmt|;
block|}
else|else
block|{
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
operator|=
literal|0
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write the data in an ieee way.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_data_part
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|data_part
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Skip sections that have no loadable contents (.bss,          debugging, etc.)  */
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Sort the reloc records so we can insert them in the correct 	 places */
if|if
condition|(
name|s
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|do_with_relocs
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|do_without_relocs
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|init_for_output
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|ieee_per_section
argument_list|(
name|s
argument_list|)
operator|->
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_per_section
argument_list|(
name|s
argument_list|)
operator|->
name|data
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** exec and core file sections */
end_comment

begin_comment
comment|/* set section contents is complicated with IEEE since the format is * not a byte image, but a record stream. */
end_comment

begin_function
name|boolean
name|ieee_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|section
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|section
operator|->
name|contents
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
comment|/* bfd_set_section_contents has already checked that everything          is within range.  */
name|memcpy
argument_list|(
name|section
operator|->
name|contents
operator|+
name|offset
argument_list|,
name|location
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|ieee_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|init_for_output
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|memcpy
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|ieee_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|+
name|offset
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
name|location
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write the external symbols of a file.  IEEE considers two sorts of    external symbols, public, and referenced.  It uses to internal    forms to index them as well.  When we write them out we turn their    symbol values into indexes from the right base.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_external_part
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|q
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|reference_index
init|=
name|IEEE_REFERENCE_BASE
decl_stmt|;
name|unsigned
name|int
name|public_index
init|=
name|IEEE_PUBLIC_BASE
operator|+
literal|2
decl_stmt|;
name|file_ptr
name|here
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
name|hadone
init|=
name|false
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|outsymbols
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|q
operator|=
name|abfd
operator|->
name|outsymbols
init|;
operator|*
name|q
operator|!=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
condition|;
name|q
operator|++
control|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|q
decl_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|p
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* This must be a symbol reference .. */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_external_reference_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|reference_index
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|name
argument_list|)
condition|)
return|return
name|false
return|;
name|p
operator|->
name|value
operator|=
name|reference_index
expr_stmt|;
name|reference_index
operator|++
expr_stmt|;
name|hadone
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|p
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* This is a weak reference */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_external_reference_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|reference_index
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_weak_external_reference_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|reference_index
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|value
argument_list|)
condition|)
return|return
name|false
return|;
name|p
operator|->
name|value
operator|=
name|reference_index
expr_stmt|;
name|reference_index
operator|++
expr_stmt|;
name|hadone
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
block|{
comment|/* This must be a symbol definition */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_external_symbol_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|public_index
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_attribute_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|public_index
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|15
argument_list|)
comment|/* instruction address */
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|19
argument_list|)
comment|/* static symbol */
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* one of them */
return|return
name|false
return|;
comment|/* Write out the value */
if|if
condition|(
operator|!
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_value_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|public_index
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* If fully linked, then output all symbols 			 relocated */
if|if
condition|(
operator|!
operator|(
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
operator|(
name|p
operator|->
name|value
operator|+
name|p
operator|->
name|section
operator|->
name|output_offset
operator|+
name|p
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|value
operator|+
name|p
operator|->
name|section
operator|->
name|output_offset
argument_list|,
name|p
operator|->
name|section
operator|->
name|output_section
operator|->
name|symbol
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|value
argument_list|,
name|bfd_abs_section_ptr
operator|->
name|symbol
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|p
operator|->
name|value
operator|=
name|public_index
expr_stmt|;
name|public_index
operator|++
expr_stmt|;
name|hadone
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* This can happen - when there are gaps in the symbols read */
comment|/* from an input ieee file */
block|}
block|}
block|}
if|if
condition|(
name|hadone
condition|)
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|external_part
operator|=
name|here
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|CONST
name|unsigned
name|char
name|exten
index|[]
init|=
block|{
literal|0xf0
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|0xf1
block|,
literal|0xce
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|37
block|,
literal|3
block|,
literal|3
block|,
comment|/* Set version 3 rev 3   	*/
literal|0xf1
block|,
literal|0xce
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|39
block|,
literal|2
block|,
comment|/* keep symbol in  original case */
literal|0xf1
block|,
literal|0xce
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|38
comment|/* set object type relocateable to x */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CONST
name|unsigned
name|char
name|envi
index|[]
init|=
block|{
literal|0xf0
block|,
literal|0x21
block|,
literal|0x00
block|,
comment|/*    0xf1, 0xce, 0x21, 00, 50, 0x82, 0x07, 0xc7, 0x09, 0x11, 0x11,     0x19, 0x2c, */
literal|0xf1
block|,
literal|0xce
block|,
literal|0x21
block|,
literal|00
block|,
literal|52
block|,
literal|0x00
block|,
comment|/* exec ok */
literal|0xf1
block|,
literal|0xce
block|,
literal|0x21
block|,
literal|0
block|,
literal|53
block|,
literal|0x03
block|,
comment|/* host unix */
comment|/*    0xf1, 0xce, 0x21, 0, 54, 2,1,1	tool& version # */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|ieee_write_me_part
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|trailer_part
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|start_address
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_value_starting_address_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_either_open_b_enum
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_either_close_b_enum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|me_record
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_module_end_enum
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out the IEEE processor ID.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_processor
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch
decl_stmt|;
name|arch
operator|=
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|arch
operator|->
name|arch
condition|)
block|{
default|default:
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|bfd_printable_name
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_arch_a29k
case|:
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
literal|"29000"
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_arch_h8300
case|:
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
literal|"H8/300"
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_arch_h8500
case|:
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
literal|"H8/500"
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_arch_i960
case|:
switch|switch
condition|(
name|arch
operator|->
name|mach
condition|)
block|{
default|default:
case|case
name|bfd_mach_i960_core
case|:
case|case
name|bfd_mach_i960_ka_sa
case|:
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
literal|"80960KA"
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_mach_i960_kb_sb
case|:
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
literal|"80960KB"
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_mach_i960_ca
case|:
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
literal|"80960CA"
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_mach_i960_mc
case|:
case|case
name|bfd_mach_i960_xa
case|:
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
literal|"80960MC"
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_m68k
case|:
block|{
specifier|const
name|char
modifier|*
name|id
decl_stmt|;
switch|switch
condition|(
name|arch
operator|->
name|mach
condition|)
block|{
default|default:
name|id
operator|=
literal|"68020"
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68000
case|:
name|id
operator|=
literal|"68000"
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68008
case|:
name|id
operator|=
literal|"68008"
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68010
case|:
name|id
operator|=
literal|"68010"
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68020
case|:
name|id
operator|=
literal|"68020"
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68030
case|:
name|id
operator|=
literal|"68030"
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68040
case|:
name|id
operator|=
literal|"68040"
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68060
case|:
name|id
operator|=
literal|"68060"
expr_stmt|;
break|break;
case|case
name|bfd_mach_cpu32
case|:
name|id
operator|=
literal|"cpu32"
expr_stmt|;
break|break;
case|case
name|bfd_mach_mcf5200
case|:
name|id
operator|=
literal|"5200"
expr_stmt|;
break|break;
case|case
name|bfd_mach_mcf5206e
case|:
name|id
operator|=
literal|"5206e"
expr_stmt|;
break|break;
case|case
name|bfd_mach_mcf5307
case|:
name|id
operator|=
literal|"5307"
expr_stmt|;
break|break;
case|case
name|bfd_mach_mcf5407
case|:
name|id
operator|=
literal|"5407"
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|id
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|ieee_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|file_ptr
name|old
decl_stmt|;
comment|/* Fast forward over the header area */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_module_beginning_enum
argument_list|)
operator|||
operator|!
name|ieee_write_processor
argument_list|(
name|abfd
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Fast forward over the variable bits */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_address_descriptor_enum
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Bits per MAU */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|bfd_arch_bits_per_byte
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* MAU's per address */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_byte
call|)
argument_list|(
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
operator|/
name|bfd_arch_bits_per_byte
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|old
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
literal|8
operator|*
name|N_W_VARIABLES
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|extension_record
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|exten
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|exten
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|exten
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0x1
argument_list|)
condition|)
comment|/* Absolute */
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0x2
argument_list|)
condition|)
comment|/* Relocateable */
return|return
name|false
return|;
block|}
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|environmental_record
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envi
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|envi
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|envi
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The HP emulator database requires a timestamp in the file.  */
block|{
name|time_t
name|now
decl_stmt|;
specifier|const
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|tm
operator|*
operator|)
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
operator|(
name|int
operator|)
name|ieee_atn_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0x21
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|50
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|t
operator|->
name|tm_min
argument_list|)
operator|||
operator|!
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_section_part
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* First write the symbols.  This changes their values into table     indeces so we cant use it after this point.  */
if|if
condition|(
operator|!
name|ieee_write_external_part
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/
comment|/*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/
comment|/* Write any debugs we have been told about.  */
if|if
condition|(
operator|!
name|ieee_write_debug_part
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Can only write the data once the symbols have been written, since      the data contains relocation information which points to the      symbols.  */
if|if
condition|(
operator|!
name|ieee_write_data_part
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* At the end we put the end!  */
if|if
condition|(
operator|!
name|ieee_write_me_part
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Generate the header */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|old
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_W_VARIABLES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_assign_value_to_variable_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|)
name|i
argument_list|)
operator|||
operator|!
name|ieee_write_int5_out
argument_list|(
name|abfd
argument_list|,
name|ieee
operator|->
name|w
operator|.
name|offset
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Native-level interface to symbols. */
end_comment

begin_comment
comment|/* We read the symbols into a buffer, which is discarded when this    function exits.  We read the strings into a buffer large enough to    hold them all plus all the cached symbol entries. */
end_comment

begin_function
name|asymbol
modifier|*
name|ieee_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ieee_symbol_type
modifier|*
name|new
init|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|NULL
return|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|ieee_openr_next_archived_file
parameter_list|(
name|arch
parameter_list|,
name|prev
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|bfd
modifier|*
name|prev
decl_stmt|;
block|{
name|ieee_ar_data_type
modifier|*
name|ar
init|=
name|IEEE_AR_DATA
argument_list|(
name|arch
argument_list|)
decl_stmt|;
comment|/* take the next one from the arch state, or reset */
if|if
condition|(
name|prev
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Reset the index - the first two entries are bogus*/
name|ar
operator|->
name|element_index
operator|=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|true
condition|)
block|{
name|ieee_ar_obstack_type
modifier|*
name|p
init|=
name|ar
operator|->
name|elements
operator|+
name|ar
operator|->
name|element_index
decl_stmt|;
name|ar
operator|->
name|element_index
operator|++
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|element_index
operator|<=
name|ar
operator|->
name|element_count
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|file_offset
operator|!=
operator|(
name|file_ptr
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|abfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|->
name|abfd
operator|=
name|_bfd_create_empty_archive_element_shell
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|p
operator|->
name|abfd
operator|->
name|origin
operator|=
name|p
operator|->
name|file_offset
expr_stmt|;
block|}
return|return
name|p
operator|->
name|abfd
return|;
block|}
block|}
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
operator|(
name|bfd
operator|*
operator|)
name|NULL
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|ieee_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|offset
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ieee_generic_stat_arch_elt
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
block|{
name|ieee_ar_data_type
modifier|*
name|ar
init|=
operator|(
name|ieee_ar_data_type
operator|*
operator|)
name|NULL
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
operator|!=
name|NULL
condition|)
name|ar
operator|=
name|abfd
operator|->
name|my_archive
operator|->
name|tdata
operator|.
name|ieee_ar_data
expr_stmt|;
if|if
condition|(
name|ar
operator|==
operator|(
name|ieee_ar_data_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ieee_object_p
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|ieee
operator|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|buf
operator|->
name|st_size
operator|=
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|me_record
operator|+
literal|1
expr_stmt|;
name|buf
operator|->
name|st_mode
operator|=
literal|0644
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ieee_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|x
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|boolean
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The debug info routines are never used.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void ieee_bfd_debug_info_start (abfd)      bfd *abfd; {  }  static void ieee_bfd_debug_info_end (abfd)      bfd *abfd; {  }
comment|/* Add this section to the list of sections we have debug info for, to    be ready to output it at close time    */
end_comment

begin_comment
unit|static void ieee_bfd_debug_info_accumulate (abfd, section)      bfd *abfd;      asection *section; {   ieee_data_type *ieee = IEEE_DATA (section->owner);   ieee_data_type *output_ieee = IEEE_DATA (abfd);
comment|/* can only accumulate data from other ieee bfds */
end_comment

begin_comment
unit|if (section->owner->xvec != abfd->xvec)     return;
comment|/* Only bother once per bfd */
end_comment

begin_comment
unit|if (ieee->done_debug == true)     return;   ieee->done_debug = true;
comment|/* Don't bother if there is no debug info */
end_comment

begin_comment
unit|if (ieee->w.r.debug_information_part == 0)     return;
comment|/* Add to chain */
end_comment

begin_comment
unit|{     bfd_chain_type *n = (bfd_chain_type *) bfd_alloc (abfd, sizeof (bfd_chain_type));     if (!n)       abort ();
comment|/* FIXME */
end_comment

begin_endif
unit|n->this = section->owner;     n->next = (bfd_chain_type *) NULL;      if (output_ieee->chain_head)       { 	output_ieee->chain_head->next = n;       }     else       { 	output_ieee->chain_root = n;        }     output_ieee->chain_head = n;   } }
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ieee_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|ieee_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|ieee_slurp_armap
value|bfd_true
end_define

begin_define
define|#
directive|define
name|ieee_slurp_extended_name_table
value|bfd_true
end_define

begin_define
define|#
directive|define
name|ieee_construct_extended_name_table
define|\
value|((boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \    bfd_true)
end_define

begin_define
define|#
directive|define
name|ieee_truncate_arname
value|bfd_dont_truncate_arname
end_define

begin_define
define|#
directive|define
name|ieee_write_armap
define|\
value|((boolean (*) \     PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int))) \    bfd_true)
end_define

begin_define
define|#
directive|define
name|ieee_read_ar_hdr
value|bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|ieee_update_armap_timestamp
value|bfd_true
end_define

begin_define
define|#
directive|define
name|ieee_get_elt_at_index
value|_bfd_generic_get_elt_at_index
end_define

begin_define
define|#
directive|define
name|ieee_bfd_is_local_label_name
value|bfd_generic_is_local_label_name
end_define

begin_define
define|#
directive|define
name|ieee_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|ieee_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|ieee_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|ieee_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|ieee_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|ieee_set_arch_mach
value|_bfd_generic_set_arch_mach
end_define

begin_define
define|#
directive|define
name|ieee_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|ieee_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|ieee_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|ieee_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|ieee_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|ieee_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|ieee_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|ieee_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_comment
comment|/*SUPPRESS 460 */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
name|ieee_vec
init|=
block|{
literal|"ieee"
block|,
comment|/* name */
name|bfd_target_ieee_flavour
block|,
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target byte order */
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|'_'
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|ieee_object_p
block|,
comment|/* bfd_check_format */
name|ieee_archive_p
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|ieee_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|ieee_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|ieee
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|ieee
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|ieee
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|ieee
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|ieee
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|ieee
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

