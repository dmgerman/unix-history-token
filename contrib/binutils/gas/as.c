begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* as.c - GAS main program.    Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA. */
end_comment

begin_comment
comment|/*  * Main program for AS; a 32-bit assembler of GNU.  * Understands command arguments.  * Has a few routines that don't fit in other modules because they  * are shared.  *  *  *			bugs  *  * : initialisers  *	Since no-one else says they will support them in future: I  * don't support them now.  *  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_define
define|#
directive|define
name|COMMON
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"output-file.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ITBL_CPU
end_ifndef

begin_define
define|#
directive|define
name|itbl_parse
parameter_list|(
name|itbl_file
parameter_list|)
value|1
end_define

begin_define
define|#
directive|define
name|itbl_init
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SBRK
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_SBRK
end_ifdef

begin_function_decl
specifier|extern
name|PTR
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|show_usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_args
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_statistics
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|perform_an_assembly_pass
name|PARAMS
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|macro_expr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|listing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if a listing is wanted */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|listing_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of listing file.  */
end_comment

begin_comment
comment|/* Type of debugging to generate.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_type
name|debug_type
init|=
name|DEBUG_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum level of macro nesting.  */
end_comment

begin_decl_stmt
name|int
name|max_macro_nest
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argv[0] */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
name|segT
name|reg_section
decl_stmt|,
name|expr_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|segT
name|text_section
decl_stmt|,
name|data_section
decl_stmt|,
name|bss_section
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default obstack chunk size.  If we set this to zero, the    obstack code will use whatever will fit in a 4096 byte block.  */
end_comment

begin_decl_stmt
name|int
name|chunksize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To monitor memory allocation more effectively, make this non-zero.    Then the chunk sizes for gas and bfd will be reduced.  */
end_comment

begin_decl_stmt
name|int
name|debug_memory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We build a list of defsyms as we read the options, and then define    them after we have initialized everything.  */
end_comment

begin_struct
struct|struct
name|defsym_list
block|{
name|struct
name|defsym_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|valueT
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|defsym_list
modifier|*
name|defsyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep a record of the itbl files we read in. */
end_comment

begin_struct
struct|struct
name|itbl_file_list
block|{
name|struct
name|itbl_file_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|itbl_file_list
modifier|*
name|itbl_files
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|print_version_id
parameter_list|()
block|{
specifier|static
name|int
name|printed
decl_stmt|;
if|if
condition|(
name|printed
condition|)
return|return;
name|printed
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GNU assembler version %s (%s)"
argument_list|,
name|VERSION
argument_list|,
name|TARGET_ALIAS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", using BFD version %s"
argument_list|,
name|BFD_VERSION
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Usage: %s [option...] [asmfile...]\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ Options:\n\ -a[sub-option...]	turn on listings\n\   Sub-options [default hls]:\n\   c	omit false conditionals\n\   d	omit debugging directives\n\   h	include high-level source\n\   l	include assembly\n\   m     include macro expansions\n\   n	omit forms processing\n\   s	include symbols\n\   =file set listing file name (must be last sub-option)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ -D			produce assembler debugging messages\n\ --defsym SYM=VAL	define symbol SYM to given value\n\ -f			skip whitespace and comment preprocessing\n\ --gstabs		generate stabs debugging information\n\ --help			show this message and exit\n\ -I DIR			add DIR to search list for .include directives\n\ -J			don't warn about signed overflow\n\ -K			warn when differences altered for long displacements\n\ -L,--keep-locals	keep local symbols (e.g. starting with `L')\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ -M,--mri		assemble in MRI compatibility mode\n\ --MD FILE		write dependency information in FILE (default none)\n\ -nocpp			ignored\n\ -o OBJFILE		name the object-file output OBJFILE (default a.out)\n\ -R			fold data section into text section\n\ --statistics		print various measured statistics from execution\n\ --strip-local-absolute	strip local absolute symbols\n\ --traditional-format	Use same format as native assembler when possible\n\ --version		print assembler version number and exit\n\ -W			suppress warnings\n\ --itbl INSTTBL		extend instruction set to include instructions\n\ 			matching the specifications defined in file INSTTBL\n\ -w			ignored\n\ -X			ignored\n\ -Z			generate object file even after errors\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ --listing-lhs-width	set the width in words of the output data column of\n\ 			the listing\n\ --listing-lhs-width2	set the width in words of the continuation lines\n\ 			of the output data column; ignored if smaller than\n\ 			the width of the first line\n\ --listing-rhs-width	set the max width in characters of the lines from\n\ 			the source file\n\ --listing-cont-lines	set the maximum number of continuation lines used\n\ 			for the output data column of the listing\n"
argument_list|)
expr_stmt|;
name|md_show_usage
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nReport bugs to bug-gnu-utils@gnu.org\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_EMULATIONS
end_ifdef

begin_define
define|#
directive|define
name|EMULATION_ENVIRON
value|"AS_EMULATION"
end_define

begin_decl_stmt
specifier|extern
name|struct
name|emulation
name|mipsbelf
decl_stmt|,
name|mipslelf
decl_stmt|,
name|mipself
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|emulation
name|mipsbecoff
decl_stmt|,
name|mipslecoff
decl_stmt|,
name|mipsecoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|emulation
name|i386coff
decl_stmt|,
name|i386elf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|emulation
modifier|*
specifier|const
name|emulations
index|[]
init|=
block|{
name|EMULATIONS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|n_emulations
init|=
sizeof|sizeof
argument_list|(
name|emulations
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|emulations
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|select_emulation_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|select_emulation_mode
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|em
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"--em"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|argc
condition|)
goto|goto
name|do_default
goto|;
name|p
operator|=
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
condition|)
name|as_fatal
argument_list|(
literal|"missing emulation mode name"
argument_list|)
expr_stmt|;
name|em
operator|=
name|p
expr_stmt|;
name|do_default
label|:
if|if
condition|(
name|em
operator|==
literal|0
condition|)
name|em
operator|=
name|getenv
argument_list|(
name|EMULATION_ENVIRON
argument_list|)
expr_stmt|;
if|if
condition|(
name|em
operator|==
literal|0
condition|)
name|em
operator|=
name|DEFAULT_EMULATION
expr_stmt|;
if|if
condition|(
name|em
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_emulations
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|emulations
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|em
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|n_emulations
condition|)
name|as_fatal
argument_list|(
literal|"unrecognized emulation name `%s'"
argument_list|,
name|em
argument_list|)
expr_stmt|;
name|this_emulation
operator|=
name|emulations
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|this_emulation
operator|=
name|emulations
index|[
literal|0
index|]
expr_stmt|;
name|this_emulation
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|default_emul_bfd_name
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|common_emul_init
parameter_list|()
block|{
name|this_format
operator|=
name|this_emulation
operator|->
name|format
expr_stmt|;
if|if
condition|(
name|this_emulation
operator|->
name|leading_underscore
operator|==
literal|2
condition|)
name|this_emulation
operator|->
name|leading_underscore
operator|=
name|this_format
operator|->
name|dfl_leading_underscore
expr_stmt|;
if|if
condition|(
name|this_emulation
operator|->
name|default_endian
operator|!=
literal|2
condition|)
name|target_big_endian
operator|=
name|this_emulation
operator|->
name|default_endian
expr_stmt|;
if|if
condition|(
name|this_emulation
operator|->
name|fake_label_name
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|this_emulation
operator|->
name|leading_underscore
condition|)
name|this_emulation
operator|->
name|fake_label_name
operator|=
literal|"L0\001"
expr_stmt|;
else|else
comment|/* What other parameters should we test?  */
name|this_emulation
operator|->
name|fake_label_name
operator|=
literal|".L0\001"
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Since it is easy to do here we interpret the special arg "-"  * to mean "use stdin" and we set that argv[] pointing to "".  * After we have munged argv[], the only things left are source file  * name(s) and ""(s) denoting stdin. These file names are used  * (perhaps more than once) later.  *  * check for new machine-dep cmdline options in  * md_parse_option definitions in config/tc-*.c  */
end_comment

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|pargc
parameter_list|,
name|pargv
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|pargv
decl_stmt|;
block|{
name|int
name|old_argc
decl_stmt|,
name|new_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_argv
decl_stmt|,
modifier|*
modifier|*
name|new_argv
decl_stmt|;
comment|/* Starting the short option string with '-' is for programs that      expect options and other ARGV-elements in any order and that care about      the ordering of the two.  We describe each non-option ARGV-element      as if it were the argument of an option with character code 1.  */
name|char
modifier|*
name|shortopts
decl_stmt|;
specifier|extern
name|CONST
name|char
modifier|*
name|md_shortopts
decl_stmt|;
specifier|static
specifier|const
name|char
name|std_shortopts
index|[]
init|=
block|{
literal|'-'
block|,
literal|'J'
block|,
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* -K is not meaningful if .word is not being hacked.  */
literal|'K'
block|,
endif|#
directive|endif
literal|'L'
block|,
literal|'M'
block|,
literal|'R'
block|,
literal|'W'
block|,
literal|'Z'
block|,
literal|'f'
block|,
literal|'a'
block|,
literal|':'
block|,
literal|':'
block|,
literal|'D'
block|,
literal|'I'
block|,
literal|':'
block|,
literal|'o'
block|,
literal|':'
block|,
ifndef|#
directive|ifndef
name|VMS
comment|/* -v takes an argument on VMS, so we don't make it a generic          option.  */
literal|'v'
block|,
endif|#
directive|endif
literal|'w'
block|,
literal|'X'
block|,
comment|/* New option for extending instruction set (see also --itbl below) */
literal|'t'
block|,
literal|':'
block|,
literal|'\0'
block|}
decl_stmt|;
name|struct
name|option
modifier|*
name|longopts
decl_stmt|;
specifier|extern
name|struct
name|option
name|md_longopts
index|[]
decl_stmt|;
specifier|extern
name|size_t
name|md_longopts_size
decl_stmt|;
specifier|static
specifier|const
name|struct
name|option
name|std_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_HELP
value|(OPTION_STD_BASE)
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_HELP
block|}
block|,
block|{
literal|"keep-locals"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"mri"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
define|#
directive|define
name|OPTION_NOCPP
value|(OPTION_STD_BASE + 1)
block|{
literal|"nocpp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOCPP
block|}
block|,
define|#
directive|define
name|OPTION_STATISTICS
value|(OPTION_STD_BASE + 2)
block|{
literal|"statistics"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_STATISTICS
block|}
block|,
define|#
directive|define
name|OPTION_VERSION
value|(OPTION_STD_BASE + 3)
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERSION
block|}
block|,
define|#
directive|define
name|OPTION_DUMPCONFIG
value|(OPTION_STD_BASE + 4)
block|{
literal|"dump-config"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DUMPCONFIG
block|}
block|,
define|#
directive|define
name|OPTION_VERBOSE
value|(OPTION_STD_BASE + 5)
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERBOSE
block|}
block|,
define|#
directive|define
name|OPTION_EMULATION
value|(OPTION_STD_BASE + 6)
block|{
literal|"emulation"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_EMULATION
block|}
block|,
define|#
directive|define
name|OPTION_DEFSYM
value|(OPTION_STD_BASE + 7)
block|{
literal|"defsym"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DEFSYM
block|}
block|,
define|#
directive|define
name|OPTION_INSTTBL
value|(OPTION_STD_BASE + 8)
comment|/* New option for extending instruction set (see also -t above).        The "-t file" or "--itbl file" option extends the basic set of        valid instructions by reading "file", a text file containing a        list of instruction formats.  The additional opcodes and their        formats are added to the built-in set of instructions, and        mnemonics for new registers may also be defined.  */
block|{
literal|"itbl"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_INSTTBL
block|}
block|,
define|#
directive|define
name|OPTION_LISTING_LHS_WIDTH
value|(OPTION_STD_BASE + 9)
block|{
literal|"listing-lhs-width"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_LISTING_LHS_WIDTH
block|}
block|,
define|#
directive|define
name|OPTION_LISTING_LHS_WIDTH2
value|(OPTION_STD_BASE + 10)
block|{
literal|"listing-lhs-width"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_LISTING_LHS_WIDTH2
block|}
block|,
define|#
directive|define
name|OPTION_LISTING_RHS_WIDTH
value|(OPTION_STD_BASE + 11)
block|{
literal|"listing-rhs-width"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_LISTING_RHS_WIDTH
block|}
block|,
define|#
directive|define
name|OPTION_LISTING_CONT_LINES
value|(OPTION_STD_BASE + 12)
block|{
literal|"listing-cont-lines"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_LISTING_CONT_LINES
block|}
block|,
define|#
directive|define
name|OPTION_DEPFILE
value|(OPTION_STD_BASE + 13)
block|{
literal|"MD"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DEPFILE
block|}
block|,
define|#
directive|define
name|OPTION_GSTABS
value|(OPTION_STD_BASE + 14)
block|{
literal|"gstabs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GSTABS
block|}
block|,
define|#
directive|define
name|OPTION_STRIP_LOCAL_ABSOLUTE
value|(OPTION_STD_BASE + 15)
block|{
literal|"strip-local-absolute"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_STRIP_LOCAL_ABSOLUTE
block|}
block|,
define|#
directive|define
name|OPTION_TRADITIONAL_FORMAT
value|(OPTION_STD_BASE + 16)
block|{
literal|"traditional-format"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TRADITIONAL_FORMAT
block|}
block|}
decl_stmt|;
comment|/* Construct the option lists from the standard list and the      target dependent list.  */
name|shortopts
operator|=
name|concat
argument_list|(
name|std_shortopts
argument_list|,
name|md_shortopts
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|longopts
operator|=
operator|(
expr|struct
name|option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|std_longopts
argument_list|)
operator|+
name|md_longopts_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|longopts
argument_list|,
name|std_longopts
argument_list|,
sizeof|sizeof
argument_list|(
name|std_longopts
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longopts
operator|+
sizeof|sizeof
argument_list|(
name|std_longopts
argument_list|)
argument_list|,
name|md_longopts
argument_list|,
name|md_longopts_size
argument_list|)
expr_stmt|;
comment|/* Make a local copy of the old argv.  */
name|old_argc
operator|=
operator|*
name|pargc
expr_stmt|;
name|old_argv
operator|=
operator|*
name|pargv
expr_stmt|;
comment|/* Initialize a new argv that contains no options.  */
name|new_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|old_argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
name|old_argv
index|[
literal|0
index|]
expr_stmt|;
name|new_argc
operator|=
literal|1
expr_stmt|;
name|new_argv
index|[
name|new_argc
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* getopt_long_only is like getopt_long, but '-' as well as '--' can 	 indicate a long option.  */
name|int
name|longind
decl_stmt|;
name|int
name|optc
init|=
name|getopt_long_only
argument_list|(
name|old_argc
argument_list|,
name|old_argv
argument_list|,
name|shortopts
argument_list|,
name|longopts
argument_list|,
operator|&
name|longind
argument_list|)
decl_stmt|;
if|if
condition|(
name|optc
operator|==
operator|-
literal|1
condition|)
break|break;
switch|switch
condition|(
name|optc
condition|)
block|{
default|default:
comment|/* md_parse_option should return 1 if it recognizes optc, 	     0 if not.  */
if|if
condition|(
name|md_parse_option
argument_list|(
name|optc
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* `-v' isn't included in the general short_opts list, so check for 	     it explicity here before deciding we've gotten a bad argument.  */
if|if
condition|(
name|optc
operator|==
literal|'v'
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/* Telling getopt to treat -v's value as optional can result 		 in it picking up a following filename argument here.  The 		 VMS code in md_parse_option can return 0 in that case, 		 but it has no way of pushing the filename argument back.  */
if|if
condition|(
name|optarg
operator|&&
operator|*
name|optarg
condition|)
name|new_argv
index|[
name|new_argc
operator|++
index|]
operator|=
name|optarg
operator|,
name|new_argv
index|[
name|new_argc
index|]
operator|=
name|NULL
expr_stmt|;
else|else
else|#
directive|else
case|case
literal|'v'
case|:
endif|#
directive|endif
case|case
name|OPTION_VERBOSE
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/*FALLTHRU*/
case|case
literal|'?'
case|:
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
comment|/* File name.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"-"
argument_list|)
condition|)
name|optarg
operator|=
literal|""
expr_stmt|;
name|new_argv
index|[
name|new_argc
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
name|new_argv
index|[
name|new_argc
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPTION_HELP
case|:
name|show_usage
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
name|OPTION_NOCPP
case|:
break|break;
case|case
name|OPTION_STATISTICS
case|:
name|flag_print_statistics
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_LOCAL_ABSOLUTE
case|:
name|flag_strip_local_absolute
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_TRADITIONAL_FORMAT
case|:
name|flag_traditional_format
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION
case|:
comment|/* This output is intended to follow the GNU standards document.  */
name|printf
argument_list|(
literal|"GNU assembler %s\n"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Copyright 1997 Free Software Foundation, Inc.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ This program is free software; you may redistribute it under the terms of\n\ the GNU General Public License.  This program has absolutely no warranty.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"This assembler was configured for a target of `%s'.\n"
argument_list|,
name|TARGET_ALIAS
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
name|OPTION_EMULATION
case|:
ifdef|#
directive|ifdef
name|USE_EMULATIONS
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|this_emulation
operator|->
name|name
argument_list|)
condition|)
name|as_fatal
argument_list|(
literal|"multiple emulation names specified"
argument_list|)
expr_stmt|;
else|#
directive|else
name|as_fatal
argument_list|(
literal|"emulations not handled in this configuration"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|OPTION_DUMPCONFIG
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"alias = %s\n"
argument_list|,
name|TARGET_ALIAS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"canonical = %s\n"
argument_list|,
name|TARGET_CANONICAL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cpu-type = %s\n"
argument_list|,
name|TARGET_CPU
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_OBJ_FORMAT
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"format = %s\n"
argument_list|,
name|TARGET_OBJ_FORMAT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_FORMAT
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bfd-target = %s\n"
argument_list|,
name|TARGET_FORMAT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
name|OPTION_DEFSYM
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|i
decl_stmt|;
name|struct
name|defsym_list
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|s
operator|=
name|optarg
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|'='
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|as_fatal
argument_list|(
literal|"bad defsym; format is --defsym name=value"
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|defsym_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|defsyms
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|optarg
expr_stmt|;
name|n
operator|->
name|value
operator|=
name|i
expr_stmt|;
name|defsyms
operator|=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_INSTTBL
case|:
case|case
literal|'t'
case|:
block|{
comment|/* optarg is the name of the file containing the instruction  	       formats, opcodes, register names, etc. */
name|struct
name|itbl_file_list
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|optarg
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|"No file name following -t option\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
operator|(
expr|struct
name|itbl_file_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|itbl_files
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|optarg
expr_stmt|;
name|itbl_files
operator|=
name|n
expr_stmt|;
comment|/* Parse the file and add the new instructions to our internal 	       table.  If multiple instruction tables are specified, the  	       information from this table gets appended onto the existing  	       internal table. */
name|itbl_files
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|itbl_parse
argument_list|(
name|itbl_files
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to read instruction table %s\n"
argument_list|,
name|itbl_files
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPTION_DEPFILE
case|:
name|start_dependencies
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_GSTABS
case|:
name|debug_type
operator|=
name|DEBUG_STABS
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|flag_signed_overflow_ok
operator|=
literal|1
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
case|case
literal|'K'
case|:
name|flag_warn_displacement
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'L'
case|:
name|flag_keep_locals
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_LISTING_LHS_WIDTH
case|:
name|listing_lhs_width
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|listing_lhs_width_second
operator|<
name|listing_lhs_width
condition|)
name|listing_lhs_width_second
operator|=
name|listing_lhs_width
expr_stmt|;
break|break;
case|case
name|OPTION_LISTING_LHS_WIDTH2
case|:
block|{
name|int
name|tmp
init|=
name|atoi
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|>
name|listing_lhs_width
condition|)
name|listing_lhs_width_second
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_LISTING_RHS_WIDTH
case|:
name|listing_rhs_width
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LISTING_CONT_LINES
case|:
name|listing_lhs_cont_lines
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|flag_mri
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
name|flag_m68k_mri
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'R'
case|:
name|flag_readonly_data_in_text
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|flag_no_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|flag_always_generate_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
while|while
condition|(
operator|*
name|optarg
condition|)
block|{
switch|switch
condition|(
operator|*
name|optarg
condition|)
block|{
case|case
literal|'c'
case|:
name|listing
operator||=
name|LISTING_NOCOND
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|listing
operator||=
name|LISTING_NODEBUG
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|listing
operator||=
name|LISTING_HLL
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|listing
operator||=
name|LISTING_LISTING
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|listing
operator||=
name|LISTING_MACEXP
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|listing
operator||=
name|LISTING_NOFORM
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|listing
operator||=
name|LISTING_SYMBOLS
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|listing_filename
operator|=
name|xstrdup
argument_list|(
name|optarg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|optarg
operator|+=
name|strlen
argument_list|(
name|listing_filename
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"invalid listing option `%c'"
argument_list|,
operator|*
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
name|optarg
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|listing
condition|)
name|listing
operator|=
name|LISTING_DEFAULT
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* DEBUG is implemented: it debugs different */
comment|/* things from other people's assemblers. */
name|flag_debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flag_no_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
block|{
comment|/* Include file directory */
name|char
modifier|*
name|temp
init|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
name|add_include_dir
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'o'
case|:
name|out_file_name
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
break|break;
case|case
literal|'X'
case|:
comment|/* -X means treat warnings as errors */
break|break;
block|}
block|}
name|free
argument_list|(
name|shortopts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|longopts
argument_list|)
expr_stmt|;
operator|*
name|pargc
operator|=
name|new_argc
expr_stmt|;
operator|*
name|pargv
operator|=
name|new_argv
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|long
name|start_time
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|macro_alternate
decl_stmt|;
name|int
name|macro_strip_at
decl_stmt|;
name|int
name|keep_it
decl_stmt|;
name|start_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_memory
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
specifier|extern
name|long
name|_bfd_chunksize
decl_stmt|;
name|_bfd_chunksize
operator|=
literal|64
expr_stmt|;
endif|#
directive|endif
name|chunksize
operator|=
literal|64
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HOST_SPECIAL_INIT
name|HOST_SPECIAL_INIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|myname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|myname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_DEFAULT_OUTPUT_FILE_NAME
define|#
directive|define
name|OBJ_DEFAULT_OUTPUT_FILE_NAME
value|"a.out"
endif|#
directive|endif
name|out_file_name
operator|=
name|OBJ_DEFAULT_OUTPUT_FILE_NAME
expr_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_init
argument_list|()
expr_stmt|;
name|bfd_set_error_program_name
argument_list|(
name|myname
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_EMULATIONS
name|select_emulation_mode
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|symbol_begin
argument_list|()
expr_stmt|;
name|frag_init
argument_list|()
expr_stmt|;
name|subsegs_begin
argument_list|()
expr_stmt|;
name|parse_args
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|read_begin
argument_list|()
expr_stmt|;
name|input_scrub_begin
argument_list|()
expr_stmt|;
name|expr_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_print_statistics
condition|)
name|xatexit
argument_list|(
name|dump_statistics
argument_list|)
expr_stmt|;
name|macro_alternate
operator|=
literal|0
expr_stmt|;
name|macro_strip_at
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
name|macro_strip_at
operator|=
name|flag_mri
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_A29K
comment|/* For compatibility with the AMD 29K family macro assembler      specification.  */
name|macro_alternate
operator|=
literal|1
expr_stmt|;
name|macro_strip_at
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|macro_init
argument_list|(
name|macro_alternate
argument_list|,
name|flag_mri
argument_list|,
name|macro_strip_at
argument_list|,
name|macro_expr
argument_list|)
expr_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|output_file_create
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|stdoutput
operator|!=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|tc_init_after_args
name|tc_init_after_args
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|itbl_init
argument_list|()
expr_stmt|;
comment|/* Now that we have fully initialized, and have created the output      file, define any symbols requested by --defsym command line      arguments.  */
while|while
condition|(
name|defsyms
operator|!=
name|NULL
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|struct
name|defsym_list
modifier|*
name|next
decl_stmt|;
name|sym
operator|=
name|symbol_new
argument_list|(
name|defsyms
operator|->
name|name
argument_list|,
name|absolute_section
argument_list|,
name|defsyms
operator|->
name|value
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|next
operator|=
name|defsyms
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|defsyms
argument_list|)
expr_stmt|;
name|defsyms
operator|=
name|next
expr_stmt|;
block|}
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|perform_an_assembly_pass
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Assemble it. */
name|cond_finish_check
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_end
name|md_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|seen_at_least_1_file
argument_list|()
operator|&&
operator|(
name|flag_always_generate_output
operator|||
name|had_errors
argument_list|()
operator|==
literal|0
operator|)
condition|)
name|keep_it
operator|=
literal|1
expr_stmt|;
else|else
name|keep_it
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
comment|/* This used to be done at the start of write_object_file in      write.c, but that caused problems when doing listings when      keep_it was zero.  This could probably be moved above md_end, but      I didn't want to risk the change.  */
name|subsegs_finish
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|keep_it
condition|)
name|write_object_file
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
name|listing_print
argument_list|(
name|listing_filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OBJ_VMS
comment|/* does its own file handling */
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
if|if
condition|(
name|keep_it
condition|)
endif|#
directive|endif
name|output_file_close
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|had_errors
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|flag_always_generate_output
condition|)
name|keep_it
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keep_it
condition|)
name|unlink
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
name|input_scrub_end
argument_list|()
expr_stmt|;
name|END_PROGRESS
argument_list|(
name|myname
argument_list|)
expr_stmt|;
comment|/* Use xexit instead of return, because under VMS environments they      may not place the same interpretation on the value given.  */
if|if
condition|(
name|had_errors
argument_list|()
operator|>
literal|0
condition|)
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* Only generate dependency file if assembler was successful.  */
name|print_dependencies
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_statistics
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|long
name|run_time
init|=
name|get_run_time
argument_list|()
operator|-
name|start_time
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: total time in assembly: %ld.%06ld\n"
argument_list|,
name|myname
argument_list|,
name|run_time
operator|/
literal|1000000
argument_list|,
name|run_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: data size %ld\n"
argument_list|,
name|myname
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|subsegs_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|write_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|symbol_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|read_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_print_statistics
name|tc_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_print_statistics
name|obj_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*			perform_an_assembly_pass()  *  * Here to attempt 1 pass over each input file.  * We scan argv[*] looking for filenames or exactly "" which is  * shorthand for stdin. Any argv that is NULL is not a file-name.  * We set need_pass_2 TRUE if, after this, we still have unresolved  * expressions of the form (unknown value)+-(unknown value).  *  * Note the un*x semantics: there is only 1 logical input file, but it  * may be a catenation of many 'physical' input files.  */
end_comment

begin_function
specifier|static
name|void
name|perform_an_assembly_pass
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|saw_a_file
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|flagword
name|applicable
decl_stmt|;
endif|#
directive|endif
name|need_pass_2
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
ifdef|#
directive|ifdef
name|MANY_SEGMENTS
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
name|segment_info
index|[
name|i
index|]
operator|.
name|fix_root
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Create the three fixed ones */
block|{
name|segT
name|seg
decl_stmt|;
ifdef|#
directive|ifdef
name|TE_APOLLO
name|seg
operator|=
name|subseg_new
argument_list|(
literal|".wtext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|seg
operator|=
name|subseg_new
argument_list|(
literal|".text"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|seg
operator|==
name|SEG_E0
argument_list|)
expr_stmt|;
name|seg
operator|=
name|subseg_new
argument_list|(
literal|".data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|seg
operator|==
name|SEG_E1
argument_list|)
expr_stmt|;
name|seg
operator|=
name|subseg_new
argument_list|(
literal|".bss"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|seg
operator|==
name|SEG_E2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TE_APOLLO
name|create_target_segments
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* not MANY_SEGMENTS */
name|text_fix_root
operator|=
name|NULL
expr_stmt|;
name|data_fix_root
operator|=
name|NULL
expr_stmt|;
name|bss_fix_root
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* not MANY_SEGMENTS */
else|#
directive|else
comment|/* BFD_ASSEMBLER */
comment|/* Create the standard sections, and those the assembler uses      internally.  */
name|text_section
operator|=
name|subseg_new
argument_list|(
name|TEXT_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data_section
operator|=
name|subseg_new
argument_list|(
name|DATA_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bss_section
operator|=
name|subseg_new
argument_list|(
name|BSS_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* @@ FIXME -- we're setting the RELOC flag so that sections are assumed      to have relocs, otherwise we don't find out in time. */
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
comment|/* @@ FIXME -- SEC_CODE seems to mean code only, rather than code possibly.*/
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|data_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|bss_section
argument_list|,
name|applicable
operator|&
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|bss_section
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
name|subseg_new
argument_list|(
name|BFD_ABS_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subseg_new
argument_list|(
name|BFD_UND_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_section
operator|=
name|subseg_new
argument_list|(
literal|"*GAS `reg' section*"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr_section
operator|=
name|subseg_new
argument_list|(
literal|"*GAS `expr' section*"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BFD_ASSEMBLER */
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This may add symbol table entries, which requires having an open BFD,      and sections already created, in BFD_ASSEMBLER mode.  */
name|md_begin
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|obj_begin
name|obj_begin
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|argv
operator|++
expr_stmt|;
comment|/* skip argv[0] */
name|argc
operator|--
expr_stmt|;
comment|/* skip argv[0] */
while|while
condition|(
name|argc
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|argv
condition|)
block|{
comment|/* Is it a file-name argument? */
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|saw_a_file
operator|++
expr_stmt|;
comment|/* argv->"" if stdin desired, else->filename */
name|read_a_source_file
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
comment|/* completed that argv */
block|}
if|if
condition|(
operator|!
name|saw_a_file
condition|)
name|read_a_source_file
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* perform_an_assembly_pass() */
end_comment

begin_comment
comment|/* The interface between the macro code and gas expression handling.  */
end_comment

begin_function
specifier|static
name|int
name|macro_expr
parameter_list|(
name|emsg
parameter_list|,
name|idx
parameter_list|,
name|in
parameter_list|,
name|val
parameter_list|)
specifier|const
name|char
modifier|*
name|emsg
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|hold
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|sb_terminate
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|in
operator|->
name|ptr
operator|+
name|idx
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|idx
operator|=
name|input_line_pointer
operator|-
name|in
operator|->
name|ptr
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|emsg
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|int
operator|)
name|ex
operator|.
name|X_add_number
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* end of as.c */
end_comment

end_unit

