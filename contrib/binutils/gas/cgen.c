begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GAS interface for targets using CGEN: Cpu tools GENerator.    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,    2006 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free Software    Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"cgen-desc.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COMPLEX_RELC
end_ifdef

begin_function_decl
specifier|static
name|expressionS
modifier|*
name|make_right_shifted_expr
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|gas_cgen_encode_addend
parameter_list|(
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|unsigned
name|long
parameter_list|, \
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|unsigned
name|long
parameter_list|, \
specifier|const
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|weak_operand_overflow_check
parameter_list|(
specifier|const
name|expressionS
modifier|*
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|queue_fixup_recursively
parameter_list|(
specifier|const
name|int
parameter_list|,
specifier|const
name|int
parameter_list|,
name|expressionS
modifier|*
parameter_list|, \
specifier|const
name|CGEN_MAYBE_MULTI_IFLD
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|rightshift
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|queue_fixup
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Opcode table descriptor, must be set by md_begin.  */
end_comment

begin_decl_stmt
name|CGEN_CPU_DESC
name|gas_cgen_cpu_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callback to insert a register into the symbol table.    A target may choose to let GAS parse the registers.    ??? Not currently used.  */
end_comment

begin_function
name|void
name|cgen_asm_record_register
parameter_list|(
name|name
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
comment|/* Use symbol_create here instead of symbol_new so we don't try to      output registers into the object file's symbol table.  */
name|symbol_table_insert
argument_list|(
name|symbol_create
argument_list|(
name|name
argument_list|,
name|reg_section
argument_list|,
name|number
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We need to keep a list of fixups.  We can't simply generate them as    we go, because that would require us to first create the frag, and    that would screw up references to ``.''.     This is used by cpu's with simple operands.  It keeps knowledge of what    an `expressionS' is and what a `fixup' is out of CGEN which for the time    being is preferable.     OPINDEX is the index in the operand table.    OPINFO is something the caller chooses to help in reloc determination.  */
end_comment

begin_struct
struct|struct
name|fixup
block|{
name|int
name|opindex
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|struct
name|cgen_maybe_multi_ifield
modifier|*
name|field
decl_stmt|;
name|int
name|msb_field_p
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|fixup
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_fixups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prepare to parse an instruction.    ??? May wish to make this static and delete calls in md_assemble.  */
end_comment

begin_function
name|void
name|gas_cgen_init_parse
parameter_list|()
block|{
name|num_fixups
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Queue a fixup.  */
end_comment

begin_function
specifier|static
name|void
name|queue_fixup
parameter_list|(
name|opindex
parameter_list|,
name|opinfo
parameter_list|,
name|expP
parameter_list|)
name|int
name|opindex
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|num_fixups
operator|>=
name|GAS_CGEN_MAX_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|num_fixups
index|]
operator|.
name|exp
operator|=
operator|*
name|expP
expr_stmt|;
name|fixups
index|[
name|num_fixups
index|]
operator|.
name|opindex
operator|=
name|opindex
expr_stmt|;
name|fixups
index|[
name|num_fixups
index|]
operator|.
name|opinfo
operator|=
name|opinfo
expr_stmt|;
operator|++
name|num_fixups
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following functions allow fixup chains to be stored, retrieved,    and swapped.  They are a generalization of a pre-existing scheme    for storing, restoring and swapping fixup chains that was used by    the m32r port.  The functionality is essentially the same, only    instead of only being able to store a single fixup chain, an entire    array of fixup chains can be stored.  It is the user's responsibility    to keep track of how many fixup chains have been stored and which    elements of the array they are in.     The algorithms used are the same as in the old scheme.  Other than the    "array-ness" of the whole thing, the functionality is identical to the    old scheme.     gas_cgen_initialize_saved_fixups_array():       Sets num_fixups_in_chain to 0 for each element. Call this from       md_begin() if you plan to use these functions and you want the       fixup count in each element to be set to 0 initially.  This is       not necessary, but it's included just in case.  It performs       the same function for each element in the array of fixup chains       that gas_init_parse() performs for the current fixups.     gas_cgen_save_fixups (element):       element - element number of the array you wish to store the fixups                 to.  No mechanism is built in for tracking what element                 was last stored to.     gas_cgen_restore_fixups (element):       element - element number of the array you wish to restore the fixups                 from.     gas_cgen_swap_fixups(int element):        element - swap the current fixups with those in this element number. */
end_comment

begin_struct
struct|struct
name|saved_fixups
block|{
name|struct
name|fixup
name|fixup_chain
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|num_fixups_in_chain
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|saved_fixups
name|stored_fixups
index|[
name|MAX_SAVED_FIXUP_CHAINS
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|gas_cgen_initialize_saved_fixups_array
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|MAX_SAVED_FIXUP_CHAINS
condition|)
name|stored_fixups
index|[
name|i
operator|++
index|]
operator|.
name|num_fixups_in_chain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gas_cgen_save_fixups
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|MAX_SAVED_FIXUP_CHAINS
condition|)
block|{
name|as_fatal
argument_list|(
literal|"index into stored_fixups[] out of bounds"
argument_list|)
expr_stmt|;
return|return;
block|}
name|stored_fixups
index|[
name|i
index|]
operator|.
name|num_fixups_in_chain
operator|=
name|num_fixups
expr_stmt|;
name|memcpy
argument_list|(
name|stored_fixups
index|[
name|i
index|]
operator|.
name|fixup_chain
argument_list|,
name|fixups
argument_list|,
sizeof|sizeof
argument_list|(
name|fixups
index|[
literal|0
index|]
argument_list|)
operator|*
name|num_fixups
argument_list|)
expr_stmt|;
name|num_fixups
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gas_cgen_restore_fixups
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|MAX_SAVED_FIXUP_CHAINS
condition|)
block|{
name|as_fatal
argument_list|(
literal|"index into stored_fixups[] out of bounds"
argument_list|)
expr_stmt|;
return|return;
block|}
name|num_fixups
operator|=
name|stored_fixups
index|[
name|i
index|]
operator|.
name|num_fixups_in_chain
expr_stmt|;
name|memcpy
argument_list|(
name|fixups
argument_list|,
name|stored_fixups
index|[
name|i
index|]
operator|.
name|fixup_chain
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|stored_fixups
index|[
name|i
index|]
operator|.
name|fixup_chain
index|[
literal|0
index|]
argument_list|)
operator|)
operator|*
name|num_fixups
argument_list|)
expr_stmt|;
name|stored_fixups
index|[
name|i
index|]
operator|.
name|num_fixups_in_chain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gas_cgen_swap_fixups
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|MAX_SAVED_FIXUP_CHAINS
condition|)
block|{
name|as_fatal
argument_list|(
literal|"index into stored_fixups[] out of bounds"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|num_fixups
operator|==
literal|0
condition|)
name|gas_cgen_restore_fixups
argument_list|(
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stored_fixups
index|[
name|i
index|]
operator|.
name|num_fixups_in_chain
operator|==
literal|0
condition|)
name|gas_cgen_save_fixups
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|tmp
decl_stmt|;
name|struct
name|fixup
name|tmp_fixup
decl_stmt|;
name|tmp
operator|=
name|stored_fixups
index|[
name|i
index|]
operator|.
name|num_fixups_in_chain
expr_stmt|;
name|stored_fixups
index|[
name|i
index|]
operator|.
name|num_fixups_in_chain
operator|=
name|num_fixups
expr_stmt|;
name|num_fixups
operator|=
name|tmp
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|GAS_CGEN_MAX_FIXUPS
init|;
name|tmp
operator|--
condition|;
control|)
block|{
name|tmp_fixup
operator|=
name|stored_fixups
index|[
name|i
index|]
operator|.
name|fixup_chain
index|[
name|tmp
index|]
expr_stmt|;
name|stored_fixups
index|[
name|i
index|]
operator|.
name|fixup_chain
index|[
name|tmp
index|]
operator|=
name|fixups
index|[
name|tmp
index|]
expr_stmt|;
name|fixups
index|[
name|tmp
index|]
operator|=
name|tmp_fixup
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Default routine to record a fixup.    This is a cover function to fix_new.    It exists because we record INSN with the fixup.     FRAG and WHERE are their respective arguments to fix_new_exp.    LENGTH is in bits.    OPINFO is something the caller chooses to help in reloc determination.     At this point we do not use a bfd_reloc_code_real_type for    operands residing in the insn, but instead just use the    operand index.  This lets us easily handle fixups for any    operand type.  We pick a BFD reloc type in md_apply_fix.  */
end_comment

begin_function
name|fixS
modifier|*
name|gas_cgen_record_fixup
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|insn
parameter_list|,
name|length
parameter_list|,
name|operand
parameter_list|,
name|opinfo
parameter_list|,
name|symbol
parameter_list|,
name|offset
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* It may seem strange to use operand->attrs and not insn->attrs here,      but it is the operand that has a pc relative relocation.  */
name|fixP
operator|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|length
operator|/
literal|8
argument_list|,
name|symbol
argument_list|,
name|offset
argument_list|,
name|CGEN_OPERAND_ATTR_VALUE
argument_list|(
name|operand
argument_list|,
name|CGEN_OPERAND_PCREL_ADDR
argument_list|)
argument_list|,
call|(
name|bfd_reloc_code_real_type
call|)
argument_list|(
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
operator|(
name|int
operator|)
name|operand
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|=
name|opinfo
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|field
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|msb_field_p
operator|=
literal|0
expr_stmt|;
return|return
name|fixP
return|;
block|}
end_function

begin_comment
comment|/* Default routine to record a fixup given an expression.    This is a cover function to fix_new_exp.    It exists because we record INSN with the fixup.     FRAG and WHERE are their respective arguments to fix_new_exp.    LENGTH is in bits.    OPINFO is something the caller chooses to help in reloc determination.     At this point we do not use a bfd_reloc_code_real_type for    operands residing in the insn, but instead just use the    operand index.  This lets us easily handle fixups for any    operand type.  We pick a BFD reloc type in md_apply_fix.  */
end_comment

begin_function
name|fixS
modifier|*
name|gas_cgen_record_fixup_exp
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|insn
parameter_list|,
name|length
parameter_list|,
name|operand
parameter_list|,
name|opinfo
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* It may seem strange to use operand->attrs and not insn->attrs here,      but it is the operand that has a pc relative relocation.  */
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|length
operator|/
literal|8
argument_list|,
name|exp
argument_list|,
name|CGEN_OPERAND_ATTR_VALUE
argument_list|(
name|operand
argument_list|,
name|CGEN_OPERAND_PCREL_ADDR
argument_list|)
argument_list|,
call|(
name|bfd_reloc_code_real_type
call|)
argument_list|(
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
operator|(
name|int
operator|)
name|operand
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|=
name|opinfo
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|field
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|msb_field_p
operator|=
literal|0
expr_stmt|;
return|return
name|fixP
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COMPLEX_RELC
end_ifdef

begin_function
specifier|static
name|symbolS
modifier|*
name|expr_build_binary
parameter_list|(
name|operatorT
name|op
parameter_list|,
name|symbolS
modifier|*
name|s1
parameter_list|,
name|symbolS
modifier|*
name|s2
parameter_list|)
block|{
name|expressionS
name|e
decl_stmt|;
name|e
operator|.
name|X_op
operator|=
name|op
expr_stmt|;
name|e
operator|.
name|X_add_symbol
operator|=
name|s1
expr_stmt|;
name|e
operator|.
name|X_op_symbol
operator|=
name|s2
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
return|return
name|make_expr_symbol
argument_list|(
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used for communication between the next two procedures.  */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|expr_jmp_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expr_jmp_buf_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callback for cgen interface.  Parse the expression at *STRP.    The result is an error message or NULL for success (in which case    *STRP is advanced past the parsed text).    WANT is an indication of what the caller is looking for.    If WANT == CGEN_ASM_PARSE_INIT the caller is beginning to try to match    a table entry with the insn, reset the queued fixups counter.    An enum cgen_parse_operand_result is stored in RESULTP.    OPINDEX is the operand's table entry index.    OPINFO is something the caller chooses to help in reloc determination.    The resulting value is stored in VALUEP.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|gas_cgen_parse_operand
parameter_list|(
name|cd
parameter_list|,
name|want
parameter_list|,
name|strP
parameter_list|,
name|opindex
parameter_list|,
name|opinfo
parameter_list|,
name|resultP
parameter_list|,
name|valueP
parameter_list|)
ifdef|#
directive|ifdef
name|OBJ_COMPLEX_RELC
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
else|#
directive|else
name|CGEN_CPU_DESC
name|cd
name|ATTRIBUTE_UNUSED
decl_stmt|;
endif|#
directive|endif
name|enum
name|cgen_parse_operand_type
name|want
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|strP
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|enum
name|cgen_parse_operand_result
modifier|*
name|resultP
decl_stmt|;
name|bfd_vma
modifier|*
name|valueP
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__STDC__
comment|/* These are volatile to survive the setjmp.  */
name|char
modifier|*
specifier|volatile
name|hold
decl_stmt|;
name|enum
name|cgen_parse_operand_result
modifier|*
specifier|volatile
name|resultP_1
decl_stmt|;
specifier|volatile
name|int
name|opinfo_1
decl_stmt|;
else|#
directive|else
specifier|static
name|char
modifier|*
name|hold
decl_stmt|;
specifier|static
name|enum
name|cgen_parse_operand_result
modifier|*
name|resultP_1
decl_stmt|;
name|int
name|opinfo_1
decl_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COMPLEX_RELC
specifier|volatile
name|int
name|signed_p
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|stmp
init|=
name|NULL
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
decl_stmt|;
name|fixS
name|dummy_fixup
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|want
operator|==
name|CGEN_PARSE_OPERAND_INIT
condition|)
block|{
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|resultP_1
operator|=
name|resultP
expr_stmt|;
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|strP
expr_stmt|;
name|opinfo_1
operator|=
name|opinfo
expr_stmt|;
comment|/* We rely on md_operand to longjmp back to us.      This is done via gas_cgen_md_operand.  */
if|if
condition|(
name|setjmp
argument_list|(
name|expr_jmp_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|expr_jmp_buf_p
operator|=
literal|0
expr_stmt|;
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|hold
expr_stmt|;
operator|*
name|resultP_1
operator|=
name|CGEN_PARSE_OPERAND_RESULT_ERROR
expr_stmt|;
return|return
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
return|;
block|}
name|expr_jmp_buf_p
operator|=
literal|1
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|expr_jmp_buf_p
operator|=
literal|0
expr_stmt|;
name|errmsg
operator|=
name|NULL
expr_stmt|;
operator|*
name|strP
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_CGEN_PARSE_FIX_EXP
name|opinfo_1
operator|=
name|TC_CGEN_PARSE_FIX_EXP
argument_list|(
name|opinfo_1
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FIXME: Need to check `want'.  */
switch|switch
condition|(
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_ERROR
expr_stmt|;
break|break;
case|case
name|O_absent
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"missing operand"
argument_list|)
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_ERROR
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
if|if
condition|(
name|want
operator|==
name|CGEN_PARSE_OPERAND_SYMBOLIC
condition|)
goto|goto
name|de_fault
goto|;
operator|*
name|valueP
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_NUMBER
expr_stmt|;
break|break;
case|case
name|O_register
case|:
operator|*
name|valueP
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_REGISTER
expr_stmt|;
break|break;
name|de_fault
label|:
default|default:
ifdef|#
directive|ifdef
name|OBJ_COMPLEX_RELC
comment|/* Look up operand, check to see if there's an obvious 	 overflow (this helps disambiguate some insn parses).  */
name|operand
operator|=
name|cgen_operand_lookup_by_num
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|)
expr_stmt|;
name|errmsg
operator|=
name|weak_operand_overflow_check
argument_list|(
operator|&
name|exp
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errmsg
condition|)
block|{
comment|/* Fragment the expression as necessary, and queue a reloc.  */
name|memset
argument_list|(
operator|&
name|dummy_fixup
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|md_cgen_lookup_reloc
argument_list|(
literal|0
argument_list|,
name|operand
argument_list|,
operator|&
name|dummy_fixup
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|reloc_type
operator|==
name|BFD_RELOC_RELC
operator|&&
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
operator|.
name|X_add_symbol
operator|->
name|bsym
operator|->
name|section
operator|!=
name|expr_section
operator|&&
name|exp
operator|.
name|X_add_symbol
operator|->
name|bsym
operator|->
name|section
operator|!=
name|absolute_section
operator|&&
name|exp
operator|.
name|X_add_symbol
operator|->
name|bsym
operator|->
name|section
operator|!=
name|undefined_section
condition|)
block|{
comment|/* Local labels will have been (eagerly) turned into constants 		 by now, due to the inappropriately deep insight of the 		 expression parser.  Unfortunately make_expr_symbol 		 prematurely dives into the symbol evaluator, and in this 		 case it gets a bad answer, so we manually create the 		 expression symbol we want here.  */
name|stmp
operator|=
name|symbol_create
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|expr_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|stmp
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
name|stmp
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
comment|/* If this is a pc-relative RELC operand, we 	     need to subtract "." from the expression.  */
if|if
condition|(
name|reloc_type
operator|==
name|BFD_RELOC_RELC
operator|&&
name|CGEN_OPERAND_ATTR_VALUE
argument_list|(
name|operand
argument_list|,
name|CGEN_OPERAND_PCREL_ADDR
argument_list|)
condition|)
name|stmp
operator|=
name|expr_build_binary
argument_list|(
name|O_subtract
argument_list|,
name|stmp
argument_list|,
name|expr_build_dot
argument_list|()
argument_list|)
expr_stmt|;
comment|/* FIXME: this is not a perfect heuristic for figuring out 	     whether an operand is signed: it only works when the operand 	     is an immediate. it's not terribly likely that any other 	     values will be signed relocs, but it's possible. */
if|if
condition|(
name|operand
operator|&&
operator|(
name|operand
operator|->
name|hw_type
operator|==
name|HW_H_SINT
operator|)
condition|)
name|signed_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stmp
operator|->
name|bsym
operator|&&
operator|(
name|stmp
operator|->
name|bsym
operator|->
name|section
operator|==
name|expr_section
operator|)
condition|)
block|{
if|if
condition|(
name|signed_p
condition|)
name|stmp
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_SRELC
expr_stmt|;
else|else
name|stmp
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_RELC
expr_stmt|;
block|}
comment|/* Now package it all up for the fixup emitter.  */
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|stmp
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Re-init rightshift quantity, just in case.  */
name|rightshift
operator|=
name|operand
operator|->
name|length
expr_stmt|;
name|queue_fixup_recursively
argument_list|(
name|opindex
argument_list|,
name|opinfo_1
argument_list|,
operator|&
name|exp
argument_list|,
operator|(
name|reloc_type
operator|==
name|BFD_RELOC_RELC
operator|)
condition|?
operator|&
operator|(
name|operand
operator|->
name|index_fields
operator|)
else|:
literal|0
argument_list|,
name|signed_p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|resultP
operator|=
name|errmsg
condition|?
name|CGEN_PARSE_OPERAND_RESULT_ERROR
else|:
name|CGEN_PARSE_OPERAND_RESULT_QUEUED
expr_stmt|;
operator|*
name|valueP
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|queue_fixup
argument_list|(
name|opindex
argument_list|,
name|opinfo_1
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
operator|*
name|valueP
operator|=
literal|0
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_QUEUED
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
name|errmsg
return|;
block|}
end_function

begin_comment
comment|/* md_operand handler to catch unrecognized expressions and halt the    parsing process so the next entry can be tried.     ??? This could be done differently by adding code to `expression'.  */
end_comment

begin_function
name|void
name|gas_cgen_md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Don't longjmp if we're not called from within cgen_parse_operand().  */
if|if
condition|(
name|expr_jmp_buf_p
condition|)
name|longjmp
argument_list|(
name|expr_jmp_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish assembling instruction INSN.    BUF contains what we've built up so far.    LENGTH is the size of the insn in bits.    RELAX_P is non-zero if relaxable insns should be emitted as such.    Otherwise they're emitted in non-relaxable forms.    The "result" is stored in RESULT if non-NULL.  */
end_comment

begin_function
name|void
name|gas_cgen_finish_insn
parameter_list|(
name|insn
parameter_list|,
name|buf
parameter_list|,
name|length
parameter_list|,
name|relax_p
parameter_list|,
name|result
parameter_list|)
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|CGEN_INSN_BYTES_PTR
name|buf
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|relax_p
decl_stmt|;
name|finished_insnS
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|relax_operand
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|unsigned
name|int
name|byte_len
init|=
name|length
operator|/
literal|8
decl_stmt|;
comment|/* ??? Target foo issues various warnings here, so one might want to provide      a hook here.  However, our caller is defined in tc-foo.c so there      shouldn't be a need for a hook.  */
comment|/* Write out the instruction.      It is important to fetch enough space in one call to `frag_more'.      We use (f - frag_now->fr_literal) to compute where we are and we      don't want frag_now to change between calls.       Relaxable instructions: We need to ensure we allocate enough      space for the largest insn.  */
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_RELAXED
argument_list|)
condition|)
comment|/* These currently shouldn't get here.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* Is there a relaxable insn with the relaxable operand needing a fixup?  */
name|relax_operand
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|relax_p
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_RELAXABLE
argument_list|)
condition|)
block|{
comment|/* Scan the fixups for the operand affected by relaxing 	 (i.e. the branch address).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_fixups
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|CGEN_OPERAND_ATTR_VALUE
argument_list|(
name|cgen_operand_lookup_by_num
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
argument_list|)
argument_list|,
name|CGEN_OPERAND_RELAX
argument_list|)
condition|)
block|{
name|relax_operand
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|relax_operand
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|max_len
decl_stmt|;
name|fragS
modifier|*
name|old_frag
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|off
decl_stmt|;
ifdef|#
directive|ifdef
name|TC_CGEN_MAX_RELAX
name|max_len
operator|=
name|TC_CGEN_MAX_RELAX
argument_list|(
name|insn
argument_list|,
name|byte_len
argument_list|)
expr_stmt|;
else|#
directive|else
name|max_len
operator|=
name|CGEN_MAX_INSN_SIZE
expr_stmt|;
endif|#
directive|endif
comment|/* Ensure variable part and fixed part are in same fragment.  */
comment|/* FIXME: Having to do this seems like a hack.  */
name|frag_grow
argument_list|(
name|max_len
argument_list|)
expr_stmt|;
comment|/* Allocate space for the fixed part.  */
name|f
operator|=
name|frag_more
argument_list|(
name|byte_len
argument_list|)
expr_stmt|;
comment|/* Create a relaxable fragment for this instruction.  */
name|old_frag
operator|=
name|frag_now
expr_stmt|;
name|exp
operator|=
operator|&
name|fixups
index|[
name|relax_operand
index|]
operator|.
name|exp
expr_stmt|;
name|sym
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
comment|/* Handle complex expressions.  */
name|sym
operator|=
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|max_len
operator|-
name|byte_len
comment|/* max chars */
argument_list|,
literal|0
comment|/* variable part already allocated */
argument_list|,
comment|/* FIXME: When we machine generate the relax table, 		   machine generate a macro to compute subtype.  */
literal|1
comment|/* subtype */
argument_list|,
name|sym
argument_list|,
name|off
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Record the operand number with the fragment so md_convert_frag 	 can use gas_cgen_md_record_fixup to record the appropriate reloc.  */
name|old_frag
operator|->
name|fr_cgen
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|old_frag
operator|->
name|fr_cgen
operator|.
name|opindex
operator|=
name|fixups
index|[
name|relax_operand
index|]
operator|.
name|opindex
expr_stmt|;
name|old_frag
operator|->
name|fr_cgen
operator|.
name|opinfo
operator|=
name|fixups
index|[
name|relax_operand
index|]
operator|.
name|opinfo
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|result
operator|->
name|frag
operator|=
name|old_frag
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|frag_more
argument_list|(
name|byte_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|result
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
block|}
comment|/* If we're recording insns as numbers (rather than a string of bytes),      target byte order handling is deferred until now.  */
if|#
directive|if
name|CGEN_INT_INSN_P
name|cgen_put_insn_value
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|f
argument_list|,
name|length
argument_list|,
operator|*
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|f
argument_list|,
name|buf
argument_list|,
name|byte_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Emit DWARF2 debugging information.  */
name|dwarf2_emit_insn
argument_list|(
name|byte_len
argument_list|)
expr_stmt|;
comment|/* Create any fixups.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_fixups
condition|;
operator|++
name|i
control|)
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
init|=
name|cgen_operand_lookup_by_num
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
argument_list|)
decl_stmt|;
comment|/* Don't create fixups for these.  That's done during relaxation. 	 We don't need to test for CGEN_INSN_RELAXED as they can't get here 	 (see above).  */
if|if
condition|(
name|relax_p
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_RELAXABLE
argument_list|)
operator|&&
name|CGEN_OPERAND_ATTR_VALUE
argument_list|(
name|operand
argument_list|,
name|CGEN_OPERAND_RELAX
argument_list|)
condition|)
continue|continue;
ifndef|#
directive|ifndef
name|md_cgen_record_fixup_exp
define|#
directive|define
name|md_cgen_record_fixup_exp
value|gas_cgen_record_fixup_exp
endif|#
directive|endif
name|fixP
operator|=
name|md_cgen_record_fixup_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|insn
argument_list|,
name|length
argument_list|,
name|operand
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|opinfo
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|field
operator|=
name|fixups
index|[
name|i
index|]
operator|.
name|field
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|msb_field_p
operator|=
name|fixups
index|[
name|i
index|]
operator|.
name|msb_field_p
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|result
operator|->
name|fixups
index|[
name|i
index|]
operator|=
name|fixP
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
block|{
name|result
operator|->
name|num_fixups
operator|=
name|num_fixups
expr_stmt|;
name|result
operator|->
name|addr
operator|=
name|f
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COMPLEX_RELC
end_ifdef

begin_comment
comment|/* Queue many fixups, recursively. If the field is a multi-ifield,    repeatedly queue its sub-parts, right shifted to fit into the field (we    assume here multi-fields represent a left-to-right, MSB0-LSB0    reading). */
end_comment

begin_function
specifier|static
name|void
name|queue_fixup_recursively
parameter_list|(
specifier|const
name|int
name|opindex
parameter_list|,
specifier|const
name|int
name|opinfo
parameter_list|,
name|expressionS
modifier|*
name|expP
parameter_list|,
specifier|const
name|CGEN_MAYBE_MULTI_IFLD
modifier|*
name|field
parameter_list|,
specifier|const
name|int
name|signed_p
parameter_list|,
specifier|const
name|int
name|part_of_multi
parameter_list|)
block|{
if|if
condition|(
name|field
operator|&&
name|field
operator|->
name|count
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|field
operator|->
name|count
condition|;
operator|++
name|i
control|)
name|queue_fixup_recursively
argument_list|(
name|opindex
argument_list|,
name|opinfo
argument_list|,
name|expP
argument_list|,
operator|&
operator|(
name|field
operator|->
name|val
operator|.
name|multi
index|[
name|i
index|]
operator|)
argument_list|,
name|signed_p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expressionS
modifier|*
name|new_exp
init|=
name|expP
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"queueing fixup for field %s\n"
argument_list|,
operator|(
name|field
condition|?
name|field
operator|->
name|val
operator|.
name|leaf
operator|->
name|name
else|:
literal|"??"
operator|)
argument_list|)
expr_stmt|;
name|print_symbol_value
argument_list|(
name|expP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|field
operator|&&
name|part_of_multi
operator|!=
operator|-
literal|1
condition|)
block|{
name|rightshift
operator|-=
name|field
operator|->
name|val
operator|.
name|leaf
operator|->
name|length
expr_stmt|;
comment|/* Shift reloc value by number of bits remaining after this 	     field.  */
if|if
condition|(
name|rightshift
condition|)
name|new_exp
operator|=
name|make_right_shifted_expr
argument_list|(
name|expP
argument_list|,
name|rightshift
argument_list|,
name|signed_p
argument_list|)
expr_stmt|;
block|}
comment|/* Truncate reloc values to length, *after* leftmost one.  */
name|fixups
index|[
name|num_fixups
index|]
operator|.
name|msb_field_p
operator|=
operator|(
name|part_of_multi
operator|<=
literal|0
operator|)
expr_stmt|;
name|fixups
index|[
name|num_fixups
index|]
operator|.
name|field
operator|=
operator|(
name|CGEN_MAYBE_MULTI_IFLD
operator|*
operator|)
name|field
expr_stmt|;
name|queue_fixup
argument_list|(
name|opindex
argument_list|,
name|opinfo
argument_list|,
name|new_exp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Encode the self-describing RELC reloc format's addend.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|gas_cgen_encode_addend
parameter_list|(
specifier|const
name|unsigned
name|long
name|start
parameter_list|,
comment|/* in bits */
specifier|const
name|unsigned
name|long
name|len
parameter_list|,
comment|/* in bits */
specifier|const
name|unsigned
name|long
name|oplen
parameter_list|,
comment|/* in bits */
specifier|const
name|unsigned
name|long
name|wordsz
parameter_list|,
comment|/* in bytes */
specifier|const
name|unsigned
name|long
name|chunksz
parameter_list|,
comment|/* in bytes */
specifier|const
name|unsigned
name|long
name|signed_p
parameter_list|,
specifier|const
name|unsigned
name|long
name|trunc_p
parameter_list|)
block|{
name|unsigned
name|long
name|res
init|=
literal|0L
decl_stmt|;
name|res
operator||=
name|start
operator|&
literal|0x3F
expr_stmt|;
name|res
operator||=
operator|(
name|oplen
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
expr_stmt|;
name|res
operator||=
operator|(
name|len
operator|&
literal|0x3F
operator|)
operator|<<
literal|12
expr_stmt|;
name|res
operator||=
operator|(
name|wordsz
operator|&
literal|0xF
operator|)
operator|<<
literal|18
expr_stmt|;
name|res
operator||=
operator|(
name|chunksz
operator|&
literal|0xF
operator|)
operator|<<
literal|22
expr_stmt|;
name|res
operator||=
operator|(
name|CGEN_INSN_LSB0_P
condition|?
literal|1
else|:
literal|0
operator|)
operator|<<
literal|27
expr_stmt|;
name|res
operator||=
name|signed_p
operator|<<
literal|28
expr_stmt|;
name|res
operator||=
name|trunc_p
operator|<<
literal|29
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Purpose: make a weak check that the expression doesn't overflow the    operand it's to be inserted into.     Rationale: some insns used to use %operators to disambiguate during a    parse. when these %operators are translated to expressions by the macro    expander, the ambiguity returns. we attempt to disambiguate by field    size.        Method: check to see if the expression's top node is an O_and operator,    and the mask is larger than the operand length. This would be an    overflow, so signal it by returning an error string. Any other case is    ambiguous, so we assume it's OK and return NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|weak_operand_overflow_check
parameter_list|(
specifier|const
name|expressionS
modifier|*
name|exp
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|)
block|{
specifier|const
name|unsigned
name|long
name|len
init|=
name|operand
operator|->
name|length
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|unsigned
name|long
name|opmask
init|=
operator|(
operator|(
operator|(
literal|1L
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|exp
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_bit_and
condition|)
block|{
comment|/* Check for implicit overflow flag.  */
if|if
condition|(
name|CGEN_OPERAND_ATTR_VALUE
argument_list|(
name|operand
argument_list|,
name|CGEN_OPERAND_RELOC_IMPLIES_OVERFLOW
argument_list|)
condition|)
return|return
name|_
argument_list|(
literal|"a reloc on this operand implies an overflow"
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
name|mask
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|&&
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|mask
operator||=
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_value
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op_symbol
operator|&&
name|exp
operator|->
name|X_op_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|mask
operator||=
name|exp
operator|->
name|X_op_symbol
operator|->
name|sy_value
operator|.
name|X_add_number
expr_stmt|;
comment|/* Want to know if mask covers more bits than opmask.       this is the same as asking if mask has any bits not in opmask,      or whether (mask& ~opmask) is nonzero.  */
if|if
condition|(
name|mask
operator|&&
operator|(
name|mask
operator|&
operator|~
name|opmask
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"overflow: (mask = %8.8x, ~opmask = %8.8x, AND = %8.8x)\n"
argument_list|,
name|mask
argument_list|,
operator|~
name|opmask
argument_list|,
operator|(
name|mask
operator|&
operator|~
name|opmask
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|_
argument_list|(
literal|"operand mask overflow"
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|expressionS
modifier|*
name|make_right_shifted_expr
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
specifier|const
name|int
name|amount
parameter_list|,
specifier|const
name|int
name|signed_p
parameter_list|)
block|{
name|symbolS
modifier|*
name|stmp
init|=
literal|0
decl_stmt|;
name|expressionS
modifier|*
name|new_exp
decl_stmt|;
name|stmp
operator|=
name|expr_build_binary
argument_list|(
name|O_right_shift
argument_list|,
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
argument_list|,
name|expr_build_uconstant
argument_list|(
name|amount
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_p
condition|)
name|stmp
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_SRELC
expr_stmt|;
else|else
name|stmp
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_RELC
expr_stmt|;
comment|/* Then wrap that in a "symbol expr" for good measure.  */
name|new_exp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_exp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
name|new_exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|new_exp
operator|->
name|X_op_symbol
operator|=
literal|0
expr_stmt|;
name|new_exp
operator|->
name|X_add_symbol
operator|=
name|stmp
expr_stmt|;
name|new_exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
return|return
name|new_exp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Apply a fixup to the object code.  This is called for all the    fixups we generated by the call to fix_new_exp, above.  In the call    above we used a reloc code which was the largest legal reloc code    plus the operand index.  Here we undo that to recover the operand    index.  At this point all symbol values should be fully resolved,    and we attempt to completely resolve the reloc.  If we can not do    that, we determine the correct reloc code and put it back in the fixup.  */
end_comment

begin_comment
comment|/* FIXME: This function handles some of the fixups and bfd_install_relocation    handles the rest.  bfd_install_relocation (or some other bfd function)    should handle them all.  */
end_comment

begin_function
name|void
name|gas_cgen_md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|where
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valP
decl_stmt|;
comment|/* Canonical name, since used a lot.  */
name|CGEN_CPU_DESC
name|cd
init|=
name|gas_cgen_cpu_desc
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* We don't actually support subtracting a symbol.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|int
name|opindex
init|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
init|=
name|cgen_operand_lookup_by_num
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
name|CGEN_FIELDS
modifier|*
name|fields
init|=
name|alloca
argument_list|(
name|CGEN_CPU_SIZEOF_FIELDS
argument_list|(
name|cd
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
name|fixP
operator|->
name|fx_cgen
operator|.
name|insn
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|signed_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|field
condition|)
block|{
comment|/* Use the twisty little pointer path 	     back to the ifield if it exists.  */
name|start
operator|=
name|fixP
operator|->
name|fx_cgen
operator|.
name|field
operator|->
name|val
operator|.
name|leaf
operator|->
name|start
expr_stmt|;
name|length
operator|=
name|fixP
operator|->
name|fx_cgen
operator|.
name|field
operator|->
name|val
operator|.
name|leaf
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
comment|/* Or the far less useful operand-size guesstimate.  */
name|start
operator|=
name|operand
operator|->
name|start
expr_stmt|;
name|length
operator|=
name|operand
operator|->
name|length
expr_stmt|;
block|}
comment|/* FIXME: this is not a perfect heuristic for figuring out          whether an operand is signed: it only works when the operand          is an immediate. it's not terribly likely that any other          values will be signed relocs, but it's possible. */
if|if
condition|(
name|operand
operator|&&
operator|(
name|operand
operator|->
name|hw_type
operator|==
name|HW_H_SINT
operator|)
condition|)
name|signed_p
operator|=
literal|1
expr_stmt|;
comment|/* If the reloc has been fully resolved finish the operand here.  */
comment|/* FIXME: This duplicates the capabilities of code in BFD.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
comment|/* FIXME: If partial_inplace isn't set bfd_install_relocation won't 	     finish the job.  Testing for pcrel is a temporary hack.  */
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
name|CGEN_CPU_SET_FIELDS_BITSIZE
argument_list|(
name|cd
argument_list|)
argument_list|(
name|fields
argument_list|,
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|CGEN_CPU_SET_VMA_OPERAND
argument_list|(
name|cd
argument_list|)
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|,
name|fields
argument_list|,
operator|(
name|bfd_vma
operator|)
name|value
argument_list|)
expr_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
block|{
name|CGEN_INSN_INT
name|insn_value
init|=
name|cgen_get_insn_value
argument_list|(
name|cd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|,
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* ??? 0 is passed for `pc'.  */
name|errmsg
operator|=
name|CGEN_CPU_INSERT_OPERAND
argument_list|(
name|cd
argument_list|)
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|,
name|fields
argument_list|,
operator|&
name|insn_value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cgen_put_insn_value
argument_list|(
name|cd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|,
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn_value
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ??? 0 is passed for `pc'.  */
name|errmsg
operator|=
name|CGEN_CPU_INSERT_OPERAND
argument_list|(
name|cd
argument_list|)
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|,
name|fields
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|errmsg
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
return|return;
comment|/* The operand isn't fully resolved.  Determine a BFD reloc value 	 based on the operand information and leave it to 	 bfd_install_relocation.  Note that this doesn't work when 	 partial_inplace == false.  */
name|reloc_type
operator|=
name|md_cgen_lookup_reloc
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COMPLEX_RELC
if|if
condition|(
name|reloc_type
operator|==
name|BFD_RELOC_RELC
condition|)
block|{
comment|/* Change addend to "self-describing" form, 	     for BFD to handle in the linker.  */
name|value
operator|=
name|gas_cgen_encode_addend
argument_list|(
name|start
argument_list|,
name|operand
operator|->
name|length
argument_list|,
name|length
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|cd
operator|->
name|insn_chunk_bitsize
operator|/
literal|8
argument_list|,
name|signed_p
argument_list|,
operator|!
operator|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|msb_field_p
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reloc_type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|reloc_type
expr_stmt|;
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unresolved expression that must be resolved"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* We're finished with this fixup.  Install it because 	 bfd_install_relocation won't be called to do it.  */
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal error: can't install fix for reloc type %d (`%s')"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* else      bfd_install_relocation will be called to finish things up.  */
comment|/* Tuck `value' away for use by tc_gen_reloc.      See the comment describing fx_addnumber in write.h.      This field is misnamed (or misused :-).  */
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target format.     FIXME: To what extent can we get all relevant targets to use this?  */
end_comment

begin_function
name|arelent
modifier|*
name|gas_cgen_tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixP
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation is not supported"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|==
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
comment|/* Use fx_offset for these cases.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Perform any cgen specific initialisation.    Called after gas_cgen_cpu_desc has been created.  */
end_comment

begin_function
name|void
name|gas_cgen_begin
parameter_list|()
block|{
if|if
condition|(
name|flag_signed_overflow_ok
condition|)
name|cgen_set_signed_overflow_ok
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
else|else
name|cgen_clear_signed_overflow_ok
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

