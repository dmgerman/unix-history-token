begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GAS interface for targets using CGEN: Cpu tools GENerator.    Copyright (C) 1996, 1997 Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"cgen-opc.h"
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_comment
comment|/* Callback to insert a register into the symbol table.    A target may choose to let GAS parse the registers.    ??? Not currently used.  */
end_comment

begin_function
name|void
name|cgen_asm_record_register
parameter_list|(
name|name
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
comment|/* Use symbol_create here instead of symbol_new so we don't try to      output registers into the object file's symbol table.  */
name|symbol_table_insert
argument_list|(
name|symbol_create
argument_list|(
name|name
argument_list|,
name|reg_section
argument_list|,
name|number
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We need to keep a list of fixups.  We can't simply generate them as    we go, because that would require us to first create the frag, and    that would screw up references to ``.''.     This is used by cpu's with simple operands.  It keeps knowledge of what    an `expressionS' is and what a `fixup' is out of CGEN which for the time    being is preferable.     OPINDEX is the index in the operand table.    OPINFO is something the caller chooses to help in reloc determination.  */
end_comment

begin_struct
struct|struct
name|fixup
block|{
name|int
name|opindex
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_FIXUPS
value|5
end_define

begin_decl_stmt
specifier|static
name|struct
name|fixup
name|fixups
index|[
name|MAX_FIXUPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_fixups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prepare to parse an instruction.    ??? May wish to make this static and delete calls in md_assemble.  */
end_comment

begin_function
name|void
name|cgen_asm_init_parse
parameter_list|()
block|{
name|num_fixups
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Queue a fixup.  */
end_comment

begin_function
name|void
name|cgen_queue_fixup
parameter_list|(
name|opindex
parameter_list|,
name|opinfo
parameter_list|,
name|expP
parameter_list|)
name|int
name|opindex
decl_stmt|;
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|num_fixups
operator|>=
name|MAX_FIXUPS
condition|)
name|as_fatal
argument_list|(
literal|"too many fixups"
argument_list|)
expr_stmt|;
name|fixups
index|[
name|num_fixups
index|]
operator|.
name|exp
operator|=
operator|*
name|expP
expr_stmt|;
name|fixups
index|[
name|num_fixups
index|]
operator|.
name|opindex
operator|=
name|opindex
expr_stmt|;
name|fixups
index|[
name|num_fixups
index|]
operator|.
name|opinfo
operator|=
name|opinfo
expr_stmt|;
operator|++
name|num_fixups
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Default routine to record a fixup.    This is a cover function to fix_new.    It exists because we record INSN with the fixup.     FRAG and WHERE are their respective arguments to fix_new_exp.    LENGTH is in bits.    OPINFO is something the caller chooses to help in reloc determination.     At this point we do not use a bfd_reloc_code_real_type for    operands residing in the insn, but instead just use the    operand index.  This lets us easily handle fixups for any    operand type.  We pick a BFD reloc type in md_apply_fix.  */
end_comment

begin_function
name|fixS
modifier|*
name|cgen_record_fixup
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|insn
parameter_list|,
name|length
parameter_list|,
name|operand
parameter_list|,
name|opinfo
parameter_list|,
name|symbol
parameter_list|,
name|offset
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
specifier|const
name|struct
name|cgen_insn
modifier|*
name|insn
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|struct
name|cgen_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* It may seem strange to use operand->attrs and not insn->attrs here,      but it is the operand that has a pc relative relocation.  */
name|fixP
operator|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|length
operator|/
literal|8
argument_list|,
name|symbol
argument_list|,
name|offset
argument_list|,
name|CGEN_OPERAND_ATTR
argument_list|(
name|operand
argument_list|,
name|CGEN_OPERAND_PCREL_ADDR
argument_list|)
operator|!=
literal|0
argument_list|,
call|(
name|bfd_reloc_code_real_type
call|)
argument_list|(
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|CGEN_OPERAND_INDEX
argument_list|(
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|tc_fix_data
operator|.
name|insn
operator|=
operator|(
name|PTR
operator|)
name|insn
expr_stmt|;
name|fixP
operator|->
name|tc_fix_data
operator|.
name|opinfo
operator|=
name|opinfo
expr_stmt|;
return|return
name|fixP
return|;
block|}
end_function

begin_comment
comment|/* Default routine to record a fixup given an expression.    This is a cover function to fix_new_exp.    It exists because we record INSN with the fixup.     FRAG and WHERE are their respective arguments to fix_new_exp.    LENGTH is in bits.    OPINFO is something the caller chooses to help in reloc determination.     At this point we do not use a bfd_reloc_code_real_type for    operands residing in the insn, but instead just use the    operand index.  This lets us easily handle fixups for any    operand type.  We pick a BFD reloc type in md_apply_fix.  */
end_comment

begin_function
name|fixS
modifier|*
name|cgen_record_fixup_exp
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|insn
parameter_list|,
name|length
parameter_list|,
name|operand
parameter_list|,
name|opinfo
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
specifier|const
name|struct
name|cgen_insn
modifier|*
name|insn
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|struct
name|cgen_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* It may seem strange to use operand->attrs and not insn->attrs here,      but it is the operand that has a pc relative relocation.  */
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|length
operator|/
literal|8
argument_list|,
name|exp
argument_list|,
name|CGEN_OPERAND_ATTR
argument_list|(
name|operand
argument_list|,
name|CGEN_OPERAND_PCREL_ADDR
argument_list|)
operator|!=
literal|0
argument_list|,
call|(
name|bfd_reloc_code_real_type
call|)
argument_list|(
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|CGEN_OPERAND_INDEX
argument_list|(
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|tc_fix_data
operator|.
name|insn
operator|=
operator|(
name|PTR
operator|)
name|insn
expr_stmt|;
name|fixP
operator|->
name|tc_fix_data
operator|.
name|opinfo
operator|=
name|opinfo
expr_stmt|;
return|return
name|fixP
return|;
block|}
end_function

begin_comment
comment|/* Callback for cgen interface.  Parse the expression at *STRP.    The result is an error message or NULL for success (in which case    *STRP is advanced past the parsed text).    WANT is an indication of what the caller is looking for.    If WANT == CGEN_ASM_PARSE_INIT the caller is beginning to try to match    a table entry with the insn, reset the queued fixups counter.    An enum cgen_parse_operand_result is stored in RESULTP.    OPINDEX is the operand's table entry index.    OPINFO is something the caller chooses to help in reloc determination.    The resulting value is stored in VALUEP.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_parse_operand
parameter_list|(
name|want
parameter_list|,
name|strP
parameter_list|,
name|opindex
parameter_list|,
name|opinfo
parameter_list|,
name|resultP
parameter_list|,
name|valueP
parameter_list|)
name|enum
name|cgen_parse_operand_type
name|want
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|strP
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|enum
name|cgen_parse_operand_result
modifier|*
name|resultP
decl_stmt|;
name|bfd_vma
modifier|*
name|valueP
decl_stmt|;
block|{
name|char
modifier|*
name|hold
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
name|want
operator|==
name|CGEN_PARSE_OPERAND_INIT
condition|)
block|{
name|cgen_asm_init_parse
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|strP
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
operator|*
name|strP
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
comment|/* FIXME: Need to check `want'.  */
switch|switch
condition|(
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|errmsg
operator|=
literal|"illegal operand"
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_ERROR
expr_stmt|;
break|break;
case|case
name|O_absent
case|:
name|errmsg
operator|=
literal|"missing operand"
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_ERROR
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
operator|*
name|valueP
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_NUMBER
expr_stmt|;
break|break;
case|case
name|O_register
case|:
operator|*
name|valueP
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_REGISTER
expr_stmt|;
break|break;
default|default :
name|cgen_queue_fixup
argument_list|(
name|opindex
argument_list|,
name|opinfo
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
operator|*
name|valueP
operator|=
literal|0
expr_stmt|;
operator|*
name|resultP
operator|=
name|CGEN_PARSE_OPERAND_RESULT_QUEUED
expr_stmt|;
break|break;
block|}
return|return
name|errmsg
return|;
block|}
end_function

begin_comment
comment|/* Finish assembling instruction INSN.    BUF contains what we've built up so far.    LENGTH is the size of the insn in bits.  */
end_comment

begin_function
name|void
name|cgen_asm_finish_insn
parameter_list|(
name|insn
parameter_list|,
name|buf
parameter_list|,
name|length
parameter_list|)
specifier|const
name|struct
name|cgen_insn
modifier|*
name|insn
decl_stmt|;
name|cgen_insn_t
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|relax_operand
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|unsigned
name|int
name|byte_len
init|=
name|length
operator|/
literal|8
decl_stmt|;
comment|/* ??? Target foo issues various warnings here, so one might want to provide      a hook here.  However, our caller is defined in tc-foo.c so there      shouldn't be a need for a hook.  */
comment|/* Write out the instruction.      It is important to fetch enough space in one call to `frag_more'.      We use (f - frag_now->fr_literal) to compute where we are and we      don't want frag_now to change between calls.       Relaxable instructions: We need to ensure we allocate enough      space for the largest insn.  */
if|if
condition|(
name|CGEN_INSN_ATTR
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_RELAX
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* These currently shouldn't get here.  */
comment|/* Is there a relaxable insn with the relaxable operand needing a fixup?  */
name|relax_operand
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|CGEN_INSN_ATTR
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_RELAXABLE
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Scan the fixups for the operand affected by relaxing 	 (i.e. the branch address).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_fixups
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|CGEN_OPERAND_ATTR
argument_list|(
operator|&
name|CGEN_SYM
argument_list|(
name|operand_table
argument_list|)
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
argument_list|,
name|CGEN_OPERAND_RELAX
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|relax_operand
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|relax_operand
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|max_len
decl_stmt|;
name|fragS
modifier|*
name|old_frag
decl_stmt|;
ifdef|#
directive|ifdef
name|TC_CGEN_MAX_RELAX
name|max_len
operator|=
name|TC_CGEN_MAX_RELAX
argument_list|(
name|insn
argument_list|,
name|byte_len
argument_list|)
expr_stmt|;
else|#
directive|else
name|max_len
operator|=
name|CGEN_MAX_INSN_SIZE
expr_stmt|;
endif|#
directive|endif
comment|/* Ensure variable part and fixed part are in same fragment.  */
comment|/* FIXME: Having to do this seems like a hack.  */
name|frag_grow
argument_list|(
name|max_len
argument_list|)
expr_stmt|;
comment|/* Allocate space for the fixed part.  */
name|f
operator|=
name|frag_more
argument_list|(
name|byte_len
argument_list|)
expr_stmt|;
comment|/* Create a relaxable fragment for this instruction.  */
name|old_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|max_len
operator|-
name|byte_len
comment|/* max chars */
argument_list|,
literal|0
comment|/* variable part already allocated */
argument_list|,
comment|/* FIXME: When we machine generate the relax table, 		   machine generate a macro to compute subtype.  */
literal|1
comment|/* subtype */
argument_list|,
name|fixups
index|[
name|relax_operand
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|fixups
index|[
name|relax_operand
index|]
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Record the operand number with the fragment so md_convert_frag 	 can use cgen_md_record_fixup to record the appropriate reloc.  */
comment|/* FIXME: fr_targ.cgen is used pending deciding whether to 	 allow a target to add members to fragS.  For more info 	 see the comment above fr_targ in as.h.  */
name|old_frag
operator|->
name|fr_targ
operator|.
name|cgen
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|old_frag
operator|->
name|fr_targ
operator|.
name|cgen
operator|.
name|opindex
operator|=
name|fixups
index|[
name|relax_operand
index|]
operator|.
name|opindex
expr_stmt|;
name|old_frag
operator|->
name|fr_targ
operator|.
name|cgen
operator|.
name|opinfo
operator|=
name|fixups
index|[
name|relax_operand
index|]
operator|.
name|opinfo
expr_stmt|;
block|}
else|else
name|f
operator|=
name|frag_more
argument_list|(
name|byte_len
argument_list|)
expr_stmt|;
comment|/* If we're recording insns as numbers (rather than a string of bytes),      target byte order handling is deferred until now.  */
if|#
directive|if
literal|0
comment|/*def CGEN_INT_INSN*/
block|switch (length)     {     case 16:       if (cgen_big_endian_p) 	bfd_putb16 ((bfd_vma) *buf, f);       else 	bfd_putl16 ((bfd_vma) *buf, f);       break;     case 32:       if (cgen_big_endian_p) 	bfd_putb32 ((bfd_vma) *buf, f);       else 	bfd_putl32 ((bfd_vma) *buf, f);       break;     default:       abort ();     }
else|#
directive|else
name|memcpy
argument_list|(
name|f
argument_list|,
name|buf
argument_list|,
name|byte_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create any fixups.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_fixups
condition|;
operator|++
name|i
control|)
block|{
comment|/* Don't create fixups for these.  That's done during relaxation. 	 We don't need to test for CGEN_INSN_RELAX as they can't get here 	 (see above).  */
if|if
condition|(
name|CGEN_INSN_ATTR
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_RELAXABLE
argument_list|)
operator|!=
literal|0
operator|&&
name|CGEN_OPERAND_ATTR
argument_list|(
operator|&
name|CGEN_SYM
argument_list|(
name|operand_table
argument_list|)
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
argument_list|,
name|CGEN_OPERAND_RELAX
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
ifndef|#
directive|ifndef
name|md_cgen_record_fixup_exp
define|#
directive|define
name|md_cgen_record_fixup_exp
value|cgen_record_fixup_exp
endif|#
directive|endif
name|md_cgen_record_fixup_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|insn
argument_list|,
name|length
argument_list|,
operator|&
name|CGEN_SYM
argument_list|(
name|operand_table
argument_list|)
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|opinfo
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object code.  This is called for all the    fixups we generated by the call to fix_new_exp, above.  In the call    above we used a reloc code which was the largest legal reloc code    plus the operand index.  Here we undo that to recover the operand    index.  At this point all symbol values should be fully resolved,    and we attempt to completely resolve the reloc.  If we can not do    that, we determine the correct reloc code and put it back in the fixup.  */
end_comment

begin_comment
comment|/* FIXME: This function handles some of the fixups and bfd_install_relocation    handles the rest.  bfd_install_relocation (or some other bfd function)    should handle them all.  */
end_comment

begin_function
name|int
name|cgen_md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valueP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valueP
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|char
modifier|*
name|where
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|valueT
name|value
decl_stmt|;
comment|/* FIXME FIXME FIXME: The value we are passed in *valuep includes      the symbol values.  Since we are using BFD_ASSEMBLER, if we are      doing this relocation the code in write.c is going to call      bfd_install_relocation, which is also going to use the symbol      value.  That means that if the reloc is fully resolved we want to      use *valuep since bfd_install_relocation is not being used.      However, if the reloc is not fully resolved we do not want to use      *valuep, and must use fx_offset instead.  However, if the reloc      is PC relative, we do want to use *valuep since it includes the      result of md_pcrel_from.  This is confusing.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|value
operator|=
operator|*
name|valueP
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|value
operator|=
operator|*
name|valueP
expr_stmt|;
else|else
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|==
name|absolute_section
condition|)
name|value
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We don't actually support subtracting a symbol.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"expression too complex"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|int
name|opindex
init|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
decl_stmt|;
specifier|const
name|struct
name|cgen_operand
modifier|*
name|operand
init|=
operator|&
name|CGEN_SYM
argument_list|(
name|operand_table
argument_list|)
index|[
name|opindex
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
name|struct
name|cgen_fields
name|fields
decl_stmt|;
specifier|const
name|struct
name|cgen_insn
modifier|*
name|insn
init|=
operator|(
expr|struct
name|cgen_insn
operator|*
operator|)
name|fixP
operator|->
name|tc_fix_data
operator|.
name|insn
decl_stmt|;
comment|/* If the reloc has been fully resolved finish the operand here.  */
comment|/* FIXME: This duplicates the capabilities of code in BFD.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
comment|/* FIXME: If partial_inplace isn't set bfd_install_relocation won't 	     finish the job.  Testing for pcrel is a temporary hack.  */
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
comment|/* This may seem like overkill, and using bfd_install_relocation or 	     some such may be preferable, but this is simple.  */
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|fields
argument_list|)
operator|=
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CGEN_SYM
argument_list|(
name|set_operand
argument_list|)
argument_list|(
name|opindex
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|fields
argument_list|)
expr_stmt|;
name|errmsg
operator|=
name|CGEN_SYM
argument_list|(
name|validate_operand
argument_list|)
argument_list|(
name|opindex
argument_list|,
operator|&
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
condition|)
name|as_warn_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"%s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|CGEN_SYM
argument_list|(
name|insert_operand
argument_list|)
argument_list|(
name|opindex
argument_list|,
operator|&
name|fields
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
return|return
literal|1
return|;
comment|/* The operand isn't fully resolved.  Determine a BFD reloc value 	 based on the operand information and leave it to 	 bfd_install_relocation.  Note that this doesn't work when 	 partial_inplace == false.  */
name|reloc_type
operator|=
name|CGEN_SYM
argument_list|(
name|lookup_reloc
argument_list|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
name|fixP
operator|->
name|fx_r_type
operator|=
name|reloc_type
expr_stmt|;
block|}
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"unresolved expression that must be resolved"
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* We're finished with this fixup.  Install it because 	 bfd_install_relocation won't be called to do it.  */
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
comment|/* FIXME: later add support for 64 bits.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* bfd_install_relocation will be called to finish things up.  */
block|}
comment|/* Tuck `value' away for use by tc_gen_reloc.      See the comment describing fx_addnumber in write.h.      This field is misnamed (or misused :-).  */
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target format.     FIXME: To what extent can we get all relevant targets to use this?  */
end_comment

begin_function
name|arelent
modifier|*
name|cgen_tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixP
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|stdoutput
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"internal error: can't export reloc type %d (`%s')"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|==
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|fixP
operator|->
name|fx_addsy
operator|->
name|bsym
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

end_unit

