begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* listing.c - mainting assembly listings    Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_comment
comment|/*  Contributed by Steve Chamberlain  		sac@cygnus.com    A listing page looks like:   LISTING_HEADER  sourcefilename pagenumber  TITLE LINE  SUBTITLE LINE  linenumber address data  source  linenumber address data  source  linenumber address data  source  linenumber address data  source   If not overridden, the listing commands are:   .title  "stuff"  	Put "stuff" onto the title line  .sbttl  "stuff"         Put stuff onto the subtitle line    If these commands come within 10 lines of the top of the page, they   will affect the page they are on, as well as any subsequent page   .eject  	Thow a page  .list  	Increment the enable listing counter  .nolist  	Decrement the enable listing counter   .psize Y[,X]  	Set the paper size to X wide and Y high. Setting a psize Y of 	zero will suppress form feeds except where demanded by .eject   If the counter goes below zero, listing is suppressed.    Listings are a maintained by read calling various listing_<foo>  functions.  What happens most is that the macro NO_LISTING is not  defined (from the Makefile), then the macro LISTING_NEWLINE expands  into a call to listing_newline.  The call is done from read.c, every  time it sees a newline, and -l is on the command line.   The function listing_newline remembers the frag associated with the  newline, and creates a new frag - note that this is wasteful, but not  a big deal, since listing slows things down a lot anyway.  The  function also rememebers when the filename changes.   When all the input has finished, and gas has had a chance to settle  down, the listing is output. This is done by running down the list of  frag/source file records, and opening the files as needed and printing  out the bytes and chars associated with them.   The only things which the architecture can change about the listing  are defined in these macros:   LISTING_HEADER		The name of the architecture  LISTING_WORD_SIZE      The make of the number of bytes in a word, this determines  			the clumping of the output data. eg a value of 			2 makes words look like 1234 5678, whilst 1 			would make the same value look like 12 34 56 			78  LISTING_LHS_WIDTH      Number of words of above size for the lhs   LISTING_LHS_WIDTH_SECOND   Number of words for the data on the lhs  			for the second line   LISTING_LHS_CONT_LINES	Max number of lines to use up for a continutation  LISTING_RHS_WIDTH      Number of chars from the input file to print                         on a line */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|"input-file.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_LISTING
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_HEADER
end_ifndef

begin_define
define|#
directive|define
name|LISTING_HEADER
value|"GAS LISTING"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_WORD_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LISTING_WORD_SIZE
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_LHS_WIDTH
end_ifndef

begin_define
define|#
directive|define
name|LISTING_LHS_WIDTH
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_LHS_WIDTH_SECOND
end_ifndef

begin_define
define|#
directive|define
name|LISTING_LHS_WIDTH_SECOND
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_RHS_WIDTH
end_ifndef

begin_define
define|#
directive|define
name|LISTING_RHS_WIDTH
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_LHS_CONT_LINES
end_ifndef

begin_define
define|#
directive|define
name|LISTING_LHS_CONT_LINES
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure remembers which .s were used */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|file_info_struct
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|linenum
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|file_info_struct
modifier|*
name|next
decl_stmt|;
name|int
name|at_end
decl_stmt|;
block|}
name|file_info_type
typedef|;
end_typedef

begin_comment
comment|/* this structure rememebrs which line from which file goes into which    frag */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|list_info_struct
block|{
comment|/* Frag which this line of source is nearest to */
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* The actual line in the source file */
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* Pointer to the file info struct for the file which this line      belongs to */
name|file_info_type
modifier|*
name|file
decl_stmt|;
comment|/* Next in list */
name|struct
name|list_info_struct
modifier|*
name|next
decl_stmt|;
comment|/* Pointer to the file info struct for the high level language      source line that belongs here */
name|file_info_type
modifier|*
name|hll_file
decl_stmt|;
comment|/* High level language source line */
name|int
name|hll_line
decl_stmt|;
comment|/* Pointer to any error message associated with this line */
name|char
modifier|*
name|message
decl_stmt|;
enum|enum
block|{
name|EDICT_NONE
block|,
name|EDICT_SBTTL
block|,
name|EDICT_TITLE
block|,
name|EDICT_NOLIST
block|,
name|EDICT_LIST
block|,
name|EDICT_NOLIST_NEXT
block|,
name|EDICT_EJECT
block|}
name|edict
enum|;
name|char
modifier|*
name|edict_arg
decl_stmt|;
block|}
name|list_info_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|list_info_struct
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|list_info_struct
modifier|*
name|listing_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|listing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|paper_width
init|=
literal|200
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|paper_height
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File to output listings to.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|list_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this static array is used to keep the text of data to be printed    before the start of the line.     It is stored so we can give a bit more info on the next line.  To much, and large    initialized arrays will use up lots of paper.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|data_buffer
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|data_buffer_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|listing_message
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|message
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_info_type
modifier|*
name|file_info
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file_name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_frag
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer_line
name|PARAMS
argument_list|(
operator|(
name|file_info_type
operator|*
name|file
operator|,
name|char
operator|*
name|line
operator|,
name|unsigned
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|listing_page
name|PARAMS
argument_list|(
operator|(
name|list_info_type
operator|*
name|list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|calc_hex
name|PARAMS
argument_list|(
operator|(
name|list_info_type
operator|*
name|list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_lines
name|PARAMS
argument_list|(
operator|(
name|list_info_type
operator|*
operator|,
name|unsigned
name|int
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_symbol_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_source
name|PARAMS
argument_list|(
operator|(
name|file_info_type
operator|*
name|current_file
operator|,
name|list_info_type
operator|*
name|list
operator|,
name|char
operator|*
name|buffer
operator|,
name|unsigned
name|int
name|width
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debugging_pseudo
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|line
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|listing_listing
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|listing_message
parameter_list|(
name|name
parameter_list|,
name|message
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|unsigned
name|int
name|l
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|message
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|n
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|n
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|listing_tail
operator|!=
operator|(
name|list_info_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|listing_tail
operator|->
name|message
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|listing_warning
parameter_list|(
name|message
parameter_list|)
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|listing_message
argument_list|(
literal|"Warning:"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_error
parameter_list|(
name|message
parameter_list|)
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|listing_message
argument_list|(
literal|"Error:"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|file_info_type
modifier|*
name|file_info_head
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|file_info_type
modifier|*
name|file_info
parameter_list|(
name|file_name
parameter_list|)
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
comment|/* Find an entry with this file name */
name|file_info_type
modifier|*
name|p
init|=
name|file_info_head
decl_stmt|;
while|while
condition|(
name|p
operator|!=
operator|(
name|file_info_type
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|filename
argument_list|,
name|file_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
comment|/* Make new entry */
name|p
operator|=
operator|(
name|file_info_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|file_info_type
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|file_info_head
expr_stmt|;
name|file_info_head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|strlen
argument_list|(
name|file_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|filename
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|p
operator|->
name|linenum
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|at_end
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|file
operator|=
name|fopen
argument_list|(
name|p
operator|->
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|file
condition|)
name|fgetc
argument_list|(
name|p
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_frag
parameter_list|()
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_newline
parameter_list|(
name|ps
parameter_list|)
name|char
modifier|*
name|ps
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|static
name|unsigned
name|int
name|last_line
init|=
literal|0xffff
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_file
init|=
name|NULL
decl_stmt|;
name|list_info_type
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|listing
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
return|return;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|last_line
operator|||
operator|(
name|last_file
operator|&&
name|file
operator|&&
name|strcmp
argument_list|(
name|file
argument_list|,
name|last_file
argument_list|)
operator|)
condition|)
block|{
name|last_line
operator|=
name|line
expr_stmt|;
name|last_file
operator|=
name|file
expr_stmt|;
name|new_frag
argument_list|()
expr_stmt|;
name|new
operator|=
operator|(
name|list_info_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|list_info_type
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|new
operator|->
name|file
operator|=
name|file_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|listing_tail
condition|)
block|{
name|listing_tail
operator|->
name|next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
name|new
expr_stmt|;
block|}
name|listing_tail
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|next
operator|=
operator|(
name|list_info_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|message
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|edict
operator|=
name|EDICT_NONE
expr_stmt|;
name|new
operator|->
name|hll_file
operator|=
operator|(
name|file_info_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|hll_line
operator|=
literal|0
expr_stmt|;
name|new_frag
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Attach all current frags to the previous line instead of the    current line.  This is called by the MIPS backend when it discovers    that it needs to add some NOP instructions; the added NOP    instructions should go with the instruction that has the delay, not    with the new instruction.  */
end_comment

begin_function
name|void
name|listing_prev_line
parameter_list|()
block|{
name|list_info_type
modifier|*
name|l
decl_stmt|;
name|fragS
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|head
operator|==
operator|(
name|list_info_type
operator|*
operator|)
name|NULL
operator|||
name|head
operator|==
name|listing_tail
condition|)
return|return;
name|new_frag
argument_list|()
expr_stmt|;
for|for
control|(
name|l
operator|=
name|head
init|;
name|l
operator|->
name|next
operator|!=
name|listing_tail
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
empty_stmt|;
for|for
control|(
name|f
operator|=
name|frchain_now
operator|->
name|frch_root
init|;
name|f
operator|!=
operator|(
name|fragS
operator|*
operator|)
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
if|if
condition|(
name|f
operator|->
name|line
operator|==
name|listing_tail
condition|)
name|f
operator|->
name|line
operator|=
name|l
expr_stmt|;
name|listing_tail
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|new_frag
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  This function returns the next source line from the file supplied,  truncated to size.  It appends a fake line to the end of each input  file to make */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|buffer_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|size
parameter_list|)
name|file_info_type
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|line
decl_stmt|;
comment|/* If we couldn't open the file, return an empty line */
if|if
condition|(
name|file
operator|->
name|file
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|||
name|file
operator|->
name|at_end
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|file
operator|->
name|linenum
operator|==
literal|0
condition|)
name|rewind
argument_list|(
name|file
operator|->
name|file
argument_list|)
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|file
operator|->
name|file
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|1
expr_stmt|;
comment|/* leave room for null */
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|count
operator|<
name|size
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|file
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|file
operator|->
name|at_end
operator|=
literal|1
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
name|file
operator|->
name|linenum
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|eject
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Eject pending */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|page
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current page number */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|title
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current title */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subtitle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current subtitle */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|on_page
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines printed on current page */
end_comment

begin_function
specifier|static
name|void
name|listing_page
parameter_list|(
name|list
parameter_list|)
name|list_info_type
modifier|*
name|list
decl_stmt|;
block|{
comment|/* Grope around, see if we can see a title or subtitle edict coming up      soon  (we look down 10 lines of the page and see if it's there)*/
if|if
condition|(
operator|(
name|eject
operator|||
operator|(
name|on_page
operator|>=
name|paper_height
operator|)
operator|)
operator|&&
name|paper_height
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|c
init|=
literal|10
decl_stmt|;
name|int
name|had_title
init|=
literal|0
decl_stmt|;
name|int
name|had_subtitle
init|=
literal|0
decl_stmt|;
name|page
operator|++
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|0
operator|&&
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|edict
operator|==
name|EDICT_SBTTL
operator|&&
operator|!
name|had_subtitle
condition|)
block|{
name|had_subtitle
operator|=
literal|1
expr_stmt|;
name|subtitle
operator|=
name|list
operator|->
name|edict_arg
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|->
name|edict
operator|==
name|EDICT_TITLE
operator|&&
operator|!
name|had_title
condition|)
block|{
name|had_title
operator|=
literal|1
expr_stmt|;
name|title
operator|=
name|list
operator|->
name|edict_arg
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\f"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%s %s \t\t\tpage %d\n"
argument_list|,
name|LISTING_HEADER
argument_list|,
name|fn
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%s\n"
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%s\n"
argument_list|,
name|subtitle
argument_list|)
expr_stmt|;
name|on_page
operator|=
literal|3
expr_stmt|;
name|eject
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|calc_hex
parameter_list|(
name|list
parameter_list|)
name|list_info_type
modifier|*
name|list
decl_stmt|;
block|{
name|list_info_type
modifier|*
name|first
init|=
name|list
decl_stmt|;
name|unsigned
name|int
name|address
init|=
operator|(
name|unsigned
name|int
operator|)
operator|~
literal|0
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|fragS
modifier|*
name|frag_ptr
decl_stmt|;
name|unsigned
name|int
name|byte_in_frag
decl_stmt|;
comment|/* Find first frag which says it belongs to this line */
name|frag
operator|=
name|list
operator|->
name|frag
expr_stmt|;
while|while
condition|(
name|frag
operator|&&
name|frag
operator|->
name|line
operator|!=
name|list
condition|)
name|frag
operator|=
name|frag
operator|->
name|fr_next
expr_stmt|;
name|frag_ptr
operator|=
name|frag
expr_stmt|;
name|data_buffer_size
operator|=
literal|0
expr_stmt|;
comment|/* Dump all the frags which belong to this line */
while|while
condition|(
name|frag_ptr
operator|!=
operator|(
name|fragS
operator|*
operator|)
name|NULL
operator|&&
name|frag_ptr
operator|->
name|line
operator|==
name|first
condition|)
block|{
comment|/* Print as many bytes from the fixed part as is sensible */
name|byte_in_frag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|byte_in_frag
operator|<
name|frag_ptr
operator|->
name|fr_fix
operator|&&
name|data_buffer_size
operator|<
sizeof|sizeof
argument_list|(
name|data_buffer
argument_list|)
operator|-
literal|10
condition|)
block|{
if|if
condition|(
name|address
operator|==
operator|~
literal|0
condition|)
block|{
name|address
operator|=
name|frag_ptr
operator|->
name|fr_address
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|data_buffer
operator|+
name|data_buffer_size
argument_list|,
literal|"%02X"
argument_list|,
operator|(
name|frag_ptr
operator|->
name|fr_literal
index|[
name|byte_in_frag
index|]
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|data_buffer_size
operator|+=
literal|2
expr_stmt|;
name|byte_in_frag
operator|++
expr_stmt|;
block|}
block|{
name|unsigned
name|int
name|var_rep_max
init|=
name|byte_in_frag
decl_stmt|;
name|unsigned
name|int
name|var_rep_idx
init|=
name|byte_in_frag
decl_stmt|;
comment|/* Print as many bytes from the variable part as is sensible */
while|while
condition|(
operator|(
name|byte_in_frag
operator|<
name|frag_ptr
operator|->
name|fr_fix
operator|+
name|frag_ptr
operator|->
name|fr_var
operator|*
name|frag_ptr
operator|->
name|fr_offset
operator|)
operator|&&
name|data_buffer_size
operator|<
sizeof|sizeof
argument_list|(
name|data_buffer
argument_list|)
operator|-
literal|10
condition|)
block|{
if|if
condition|(
name|address
operator|==
operator|~
literal|0
condition|)
block|{
name|address
operator|=
name|frag_ptr
operator|->
name|fr_address
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|data_buffer
operator|+
name|data_buffer_size
argument_list|,
literal|"%02X"
argument_list|,
operator|(
name|frag_ptr
operator|->
name|fr_literal
index|[
name|var_rep_idx
index|]
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|data_buffer[data_buffer_size++] = '*'; 	    data_buffer[data_buffer_size++] = '*';
endif|#
directive|endif
name|data_buffer_size
operator|+=
literal|2
expr_stmt|;
name|var_rep_idx
operator|++
expr_stmt|;
name|byte_in_frag
operator|++
expr_stmt|;
if|if
condition|(
name|var_rep_idx
operator|>=
name|frag_ptr
operator|->
name|fr_fix
operator|+
name|frag_ptr
operator|->
name|fr_var
condition|)
name|var_rep_idx
operator|=
name|var_rep_max
expr_stmt|;
block|}
block|}
name|frag_ptr
operator|=
name|frag_ptr
operator|->
name|fr_next
expr_stmt|;
block|}
name|data_buffer
index|[
name|data_buffer_size
operator|++
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|address
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_lines
parameter_list|(
name|list
parameter_list|,
name|lineno
parameter_list|,
name|string
parameter_list|,
name|address
parameter_list|)
name|list_info_type
modifier|*
name|list
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|address
decl_stmt|;
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|nchars
decl_stmt|;
name|unsigned
name|int
name|lines
decl_stmt|;
name|unsigned
name|int
name|byte_in_word
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|data_buffer
decl_stmt|;
comment|/* Print the stuff on the first line */
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|nchars
operator|=
operator|(
name|LISTING_WORD_SIZE
operator|*
literal|2
operator|+
literal|1
operator|)
operator|*
name|LISTING_LHS_WIDTH
expr_stmt|;
comment|/* Print the hex for the first line */
if|if
condition|(
name|address
operator|==
operator|~
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"% 4d     "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nchars
condition|;
name|idx
operator|++
control|)
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|string
condition|?
name|string
else|:
literal|""
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|had_errors
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"% 4d ???? "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"% 4d %04x "
argument_list|,
name|lineno
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
comment|/* And the data to go along with it */
name|idx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|&&
name|idx
operator|<
name|nchars
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%c%c"
argument_list|,
name|src
index|[
literal|0
index|]
argument_list|,
name|src
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|byte_in_word
operator|++
expr_stmt|;
if|if
condition|(
name|byte_in_word
operator|==
name|LISTING_WORD_SIZE
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|byte_in_word
operator|=
literal|0
expr_stmt|;
block|}
name|idx
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
init|;
name|idx
operator|<
name|nchars
condition|;
name|idx
operator|++
control|)
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|string
condition|?
name|string
else|:
literal|""
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|message
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"****  %s\n"
argument_list|,
name|list
operator|->
name|message
argument_list|)
expr_stmt|;
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
block|}
for|for
control|(
name|lines
operator|=
literal|0
init|;
name|lines
operator|<
name|LISTING_LHS_CONT_LINES
operator|&&
operator|*
name|src
condition|;
name|lines
operator|++
control|)
block|{
name|nchars
operator|=
operator|(
operator|(
name|LISTING_WORD_SIZE
operator|*
literal|2
operator|)
operator|+
literal|1
operator|)
operator|*
name|LISTING_LHS_WIDTH_SECOND
operator|-
literal|1
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
comment|/* Print any more lines of data, but more compactly */
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"% 4d      "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|&&
name|idx
operator|<
name|nchars
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%c%c"
argument_list|,
name|src
index|[
literal|0
index|]
argument_list|,
name|src
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
name|byte_in_word
operator|++
expr_stmt|;
if|if
condition|(
name|byte_in_word
operator|==
name|LISTING_WORD_SIZE
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|byte_in_word
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|list_symbol_table
parameter_list|()
block|{
specifier|extern
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
name|int
name|got_some
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|ptr
decl_stmt|;
name|eject
operator|=
literal|1
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|symbol_rootP
init|;
name|ptr
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|;
name|ptr
operator|=
name|symbol_next
argument_list|(
name|ptr
argument_list|)
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|sy_frag
operator|->
name|line
condition|)
block|{
if|if
condition|(
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|,
name|fmt
index|[
literal|8
index|]
decl_stmt|;
name|valueT
name|val
init|=
name|S_GET_VALUE
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
comment|/* @@ Note that this is dependent on the compilation options, 		 not solely on the target characteristics.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|==
literal|4
operator|&&
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
literal|4
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|<=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%%0%lulx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|BFD64
argument_list|)
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|>
literal|4
condition|)
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|got_some
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"DEFINED SYMBOLS\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|got_some
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%20s:%-5d  %s:%s %s\n"
argument_list|,
name|ptr
operator|->
name|sy_frag
operator|->
name|line
operator|->
name|file
operator|->
name|filename
argument_list|,
name|ptr
operator|->
name|sy_frag
operator|->
name|line
operator|->
name|line
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|ptr
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|,
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|got_some
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"NO DEFINED SYMBOLS\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|got_some
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|symbol_rootP
init|;
name|ptr
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|;
name|ptr
operator|=
name|symbol_next
argument_list|(
name|ptr
argument_list|)
control|)
block|{
if|if
condition|(
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
operator|&&
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|sy_frag
operator|->
name|line
operator|==
literal|0
ifdef|#
directive|ifdef
name|S_IS_REGISTER
operator|&&
operator|!
name|S_IS_REGISTER
argument_list|(
name|ptr
argument_list|)
endif|#
directive|endif
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|ptr
argument_list|)
operator|!=
name|reg_section
condition|)
block|{
if|if
condition|(
operator|!
name|got_some
condition|)
block|{
name|got_some
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"UNDEFINED SYMBOLS\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%s\n"
argument_list|,
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|got_some
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"NO UNDEFINED SYMBOLS\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_source
parameter_list|(
name|current_file
parameter_list|,
name|list
parameter_list|,
name|buffer
parameter_list|,
name|width
parameter_list|)
name|file_info_type
modifier|*
name|current_file
decl_stmt|;
name|list_info_type
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
block|{
if|if
condition|(
name|current_file
operator|->
name|file
condition|)
block|{
while|while
condition|(
name|current_file
operator|->
name|linenum
operator|<
name|list
operator|->
name|hll_line
operator|&&
operator|!
name|current_file
operator|->
name|at_end
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|buffer_line
argument_list|(
name|current_file
argument_list|,
name|buffer
argument_list|,
name|width
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%4d:%-13s **** %s\n"
argument_list|,
name|current_file
operator|->
name|linenum
argument_list|,
name|current_file
operator|->
name|filename
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Sometimes the user doesn't want to be bothered by the debugging    records inserted by the compiler, see if the line is suspicious */
end_comment

begin_function
specifier|static
name|int
name|debugging_pseudo
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"def"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"val"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"scl"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"line"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"endef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"ln"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"size"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"dim"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"tag"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"stabs"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"stabn"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|listing_listing
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|list_info_type
modifier|*
name|list
init|=
name|head
decl_stmt|;
name|file_info_type
modifier|*
name|current_hll_file
init|=
operator|(
name|file_info_type
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|show_listing
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|LISTING_RHS_WIDTH
argument_list|)
expr_stmt|;
name|eject
operator|=
literal|1
expr_stmt|;
name|list
operator|=
name|head
expr_stmt|;
while|while
condition|(
name|list
operator|!=
operator|(
name|list_info_type
operator|*
operator|)
name|NULL
operator|&&
literal|0
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|next
condition|)
name|list
operator|->
name|frag
operator|=
name|list
operator|->
name|next
operator|->
name|frag
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|list
operator|=
name|head
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|width
operator|=
name|LISTING_RHS_WIDTH
operator|>
name|paper_width
condition|?
name|paper_width
else|:
name|LISTING_RHS_WIDTH
expr_stmt|;
switch|switch
condition|(
name|list
operator|->
name|edict
condition|)
block|{
case|case
name|EDICT_LIST
case|:
name|show_listing
operator|++
expr_stmt|;
break|break;
case|case
name|EDICT_NOLIST
case|:
name|show_listing
operator|--
expr_stmt|;
break|break;
case|case
name|EDICT_NOLIST_NEXT
case|:
break|break;
case|case
name|EDICT_EJECT
case|:
break|break;
case|case
name|EDICT_NONE
case|:
break|break;
case|case
name|EDICT_TITLE
case|:
name|title
operator|=
name|list
operator|->
name|edict_arg
expr_stmt|;
break|break;
case|case
name|EDICT_SBTTL
case|:
name|subtitle
operator|=
name|list
operator|->
name|edict_arg
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|show_listing
operator|>
literal|0
condition|)
block|{
comment|/* Scan down the list and print all the stuff which can be done 	     with this line (or lines).  */
name|message
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|hll_file
condition|)
block|{
name|current_hll_file
operator|=
name|list
operator|->
name|hll_file
expr_stmt|;
block|}
if|if
condition|(
name|current_hll_file
operator|&&
name|list
operator|->
name|hll_line
operator|&&
name|listing
operator|&
name|LISTING_HLL
condition|)
block|{
name|print_source
argument_list|(
name|current_hll_file
argument_list|,
name|list
argument_list|,
name|buffer
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list
operator|->
name|file
operator|->
name|file
operator|&&
name|list
operator|->
name|file
operator|->
name|linenum
operator|<
name|list
operator|->
name|line
operator|&&
operator|!
name|list
operator|->
name|file
operator|->
name|at_end
condition|)
block|{
name|unsigned
name|int
name|address
decl_stmt|;
name|p
operator|=
name|buffer_line
argument_list|(
name|list
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|file
operator|->
name|linenum
operator|<
name|list
operator|->
name|line
condition|)
name|address
operator|=
operator|~
operator|(
name|unsigned
name|int
operator|)
literal|0
expr_stmt|;
else|else
name|address
operator|=
name|calc_hex
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|listing
operator|&
name|LISTING_NODEBUG
operator|)
operator|&&
name|debugging_pseudo
argument_list|(
name|p
argument_list|)
operator|)
condition|)
name|print_lines
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|file
operator|->
name|linenum
argument_list|,
name|p
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|->
name|edict
operator|==
name|EDICT_EJECT
condition|)
block|{
name|eject
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|list
operator|->
name|file
operator|->
name|file
operator|&&
name|list
operator|->
name|file
operator|->
name|linenum
operator|<
name|list
operator|->
name|line
operator|&&
operator|!
name|list
operator|->
name|file
operator|->
name|at_end
condition|)
name|p
operator|=
name|buffer_line
argument_list|(
name|list
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|->
name|edict
operator|==
name|EDICT_NOLIST_NEXT
condition|)
operator|--
name|show_listing
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_print
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|using_stdout
decl_stmt|;
name|file_info_type
modifier|*
name|fi
decl_stmt|;
name|title
operator|=
literal|""
expr_stmt|;
name|subtitle
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|list_file
operator|=
name|stdout
expr_stmt|;
name|using_stdout
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|list_file
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_file
operator|!=
name|NULL
condition|)
name|using_stdout
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|as_perror
argument_list|(
literal|"can't open list file: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|list_file
operator|=
name|stdout
expr_stmt|;
name|using_stdout
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|listing
operator|&
name|LISTING_NOFORM
condition|)
block|{
name|paper_height
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|listing
operator|&
name|LISTING_LISTING
condition|)
block|{
name|listing_listing
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listing
operator|&
name|LISTING_SYMBOLS
condition|)
block|{
name|list_symbol_table
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|using_stdout
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|list_file
argument_list|)
operator|==
name|EOF
condition|)
name|as_perror
argument_list|(
literal|"error closing list file: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fi
operator|=
name|file_info_head
init|;
name|fi
operator|!=
name|NULL
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fi
operator|->
name|file
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fi
operator|->
name|file
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|listing_file
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fn
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_eject
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|listing
condition|)
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_EJECT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_flags
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|input_line_pointer
operator|++
operator|)
operator|&&
operator|(
operator|*
name|input_line_pointer
operator|!=
literal|'\n'
operator|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn listing on or off.  An argument of 0 means to turn off    listing.  An argument of 1 means to turn on listing.  An argument    of 2 means to turn off listing, but as of the next line; that is,    the current line should be listed, but the next line should not.  */
end_comment

begin_function
name|void
name|listing_list
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
if|if
condition|(
name|listing
condition|)
block|{
switch|switch
condition|(
name|on
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|listing_tail
operator|->
name|edict
operator|==
name|EDICT_LIST
condition|)
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_NONE
expr_stmt|;
else|else
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_NOLIST
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|listing_tail
operator|->
name|edict
operator|==
name|EDICT_NOLIST
operator|||
name|listing_tail
operator|->
name|edict
operator|==
name|EDICT_NOLIST_NEXT
condition|)
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_NONE
expr_stmt|;
else|else
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_LIST
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_NOLIST_NEXT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|listing_psize
parameter_list|(
name|width_only
parameter_list|)
name|int
name|width_only
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|width_only
condition|)
block|{
name|paper_height
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|paper_height
operator|<
literal|0
operator|||
name|paper_height
operator|>
literal|1000
condition|)
block|{
name|paper_height
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"strange paper height, set to no form"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|paper_width
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_nopage
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|paper_height
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_title
parameter_list|(
name|depth
parameter_list|)
name|int
name|depth
decl_stmt|;
block|{
name|int
name|quoted
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|ttl
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\"'
condition|)
name|quoted
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|start
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
if|if
condition|(
name|quoted
condition|?
operator|*
name|input_line_pointer
operator|==
literal|'\"'
else|:
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|listing
condition|)
block|{
name|length
operator|=
name|input_line_pointer
operator|-
name|start
expr_stmt|;
name|ttl
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ttl
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ttl
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|listing_tail
operator|->
name|edict
operator|=
name|depth
condition|?
name|EDICT_SBTTL
else|:
name|EDICT_TITLE
expr_stmt|;
name|listing_tail
operator|->
name|edict_arg
operator|=
name|ttl
expr_stmt|;
block|}
if|if
condition|(
name|quoted
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
name|as_bad
argument_list|(
literal|"New line in title"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|listing_source_line
parameter_list|(
name|line
parameter_list|)
name|unsigned
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|listing
condition|)
block|{
name|new_frag
argument_list|()
expr_stmt|;
name|listing_tail
operator|->
name|hll_line
operator|=
name|line
expr_stmt|;
name|new_frag
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|listing_source_file
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|listing
condition|)
name|listing_tail
operator|->
name|hll_file
operator|=
name|file_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Dummy functions for when compiled without listing enabled */
end_comment

begin_function
name|void
name|listing_flags
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_list
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_eject
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_psize
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_nopage
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_title
parameter_list|(
name|depth
parameter_list|)
name|int
name|depth
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_file
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{  }
end_function

begin_function
name|void
name|listing_newline
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{  }
end_function

begin_function
name|void
name|listing_source_line
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|int
name|n
decl_stmt|;
block|{  }
end_function

begin_function
name|void
name|listing_source_file
parameter_list|(
name|n
parameter_list|)
specifier|const
name|char
modifier|*
name|n
decl_stmt|;
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

