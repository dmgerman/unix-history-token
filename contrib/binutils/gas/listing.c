begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* listing.c - mainting assembly listings    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001    Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  Contributed by Steve Chamberlain<sac@cygnus.com>   A listing page looks like:   LISTING_HEADER  sourcefilename pagenumber  TITLE LINE  SUBTITLE LINE  linenumber address data  source  linenumber address data  source  linenumber address data  source  linenumber address data  source   If not overridden, the listing commands are:   .title  "stuff"  	Put "stuff" onto the title line  .sbttl  "stuff"         Put stuff onto the subtitle line    If these commands come within 10 lines of the top of the page, they   will affect the page they are on, as well as any subsequent page   .eject  	Thow a page  .list  	Increment the enable listing counter  .nolist  	Decrement the enable listing counter   .psize Y[,X]  	Set the paper size to X wide and Y high. Setting a psize Y of 	zero will suppress form feeds except where demanded by .eject   If the counter goes below zero, listing is suppressed.   Listings are a maintained by read calling various listing_<foo>  functions.  What happens most is that the macro NO_LISTING is not  defined (from the Makefile), then the macro LISTING_NEWLINE expands  into a call to listing_newline.  The call is done from read.c, every  time it sees a newline, and -l is on the command line.   The function listing_newline remembers the frag associated with the  newline, and creates a new frag - note that this is wasteful, but not  a big deal, since listing slows things down a lot anyway.  The  function also rememebers when the filename changes.   When all the input has finished, and gas has had a chance to settle  down, the listing is output. This is done by running down the list of  frag/source file records, and opening the files as needed and printing  out the bytes and chars associated with them.   The only things which the architecture can change about the listing  are defined in these macros:   LISTING_HEADER		The name of the architecture  LISTING_WORD_SIZE      The make of the number of bytes in a word, this determines  			the clumping of the output data. eg a value of 			2 makes words look like 1234 5678, whilst 1 			would make the same value look like 12 34 56 			78  LISTING_LHS_WIDTH      Number of words of above size for the lhs   LISTING_LHS_WIDTH_SECOND   Number of words for the data on the lhs  			for the second line   LISTING_LHS_CONT_LINES	Max number of lines to use up for a continutation  LISTING_RHS_WIDTH      Number of chars from the input file to print                         on a line */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|"input-file.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_LISTING
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_HEADER
end_ifndef

begin_define
define|#
directive|define
name|LISTING_HEADER
value|"GAS LISTING"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_WORD_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LISTING_WORD_SIZE
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_LHS_WIDTH
end_ifndef

begin_define
define|#
directive|define
name|LISTING_LHS_WIDTH
value|((LISTING_WORD_SIZE)> 4 ? 1 : 4 / (LISTING_WORD_SIZE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_LHS_WIDTH_SECOND
end_ifndef

begin_define
define|#
directive|define
name|LISTING_LHS_WIDTH_SECOND
value|LISTING_LHS_WIDTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_RHS_WIDTH
end_ifndef

begin_define
define|#
directive|define
name|LISTING_RHS_WIDTH
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LISTING_LHS_CONT_LINES
end_ifndef

begin_define
define|#
directive|define
name|LISTING_LHS_CONT_LINES
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure remembers which .s were used.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|file_info_struct
block|{
name|struct
name|file_info_struct
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|unsigned
name|int
name|linenum
decl_stmt|;
name|int
name|at_end
decl_stmt|;
block|}
name|file_info_type
typedef|;
end_typedef

begin_comment
comment|/* This structure rememebrs which line from which file goes into which    frag.  */
end_comment

begin_struct
struct|struct
name|list_info_struct
block|{
comment|/* Frag which this line of source is nearest to.  */
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* The actual line in the source file.  */
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* Pointer to the file info struct for the file which this line      belongs to.  */
name|file_info_type
modifier|*
name|file
decl_stmt|;
comment|/* The expanded text of any macro that may have been executing.  */
name|char
modifier|*
name|line_contents
decl_stmt|;
comment|/* Next in list.  */
name|struct
name|list_info_struct
modifier|*
name|next
decl_stmt|;
comment|/* Pointer to the file info struct for the high level language      source line that belongs here.  */
name|file_info_type
modifier|*
name|hll_file
decl_stmt|;
comment|/* High level language source line.  */
name|unsigned
name|int
name|hll_line
decl_stmt|;
comment|/* Pointer to any error message associated with this line.  */
name|char
modifier|*
name|message
decl_stmt|;
enum|enum
block|{
name|EDICT_NONE
block|,
name|EDICT_SBTTL
block|,
name|EDICT_TITLE
block|,
name|EDICT_NOLIST
block|,
name|EDICT_LIST
block|,
name|EDICT_NOLIST_NEXT
block|,
name|EDICT_EJECT
block|}
name|edict
enum|;
name|char
modifier|*
name|edict_arg
decl_stmt|;
comment|/* Nonzero if this line is to be omitted because it contains      debugging information.  This can become a flags field if we come      up with more information to store here.  */
name|int
name|debugging
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|list_info_struct
name|list_info_type
typedef|;
end_typedef

begin_decl_stmt
name|int
name|listing_lhs_width
init|=
name|LISTING_LHS_WIDTH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|listing_lhs_width_second
init|=
name|LISTING_LHS_WIDTH_SECOND
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|listing_lhs_cont_lines
init|=
name|LISTING_LHS_CONT_LINES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|listing_rhs_width
init|=
name|LISTING_RHS_WIDTH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|list_info_struct
modifier|*
name|listing_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_info_type
modifier|*
name|file_info_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_info_type
modifier|*
name|last_open_file_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|last_open_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|list_info_struct
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|paper_width
init|=
literal|200
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|paper_height
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|listing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File to output listings to.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|list_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This static array is used to keep the text of data to be printed    before the start of the line.  */
end_comment

begin_define
define|#
directive|define
name|MAX_BYTES
define|\
value|(((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width			\    + ((((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width_second)	\       * listing_lhs_cont_lines)						\    + 20)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|data_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|listing_message
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|message
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_info_type
modifier|*
name|file_info
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file_name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_frag
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer_line
name|PARAMS
argument_list|(
operator|(
name|file_info_type
operator|*
name|file
operator|,
name|char
operator|*
name|line
operator|,
name|unsigned
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|listing_page
name|PARAMS
argument_list|(
operator|(
name|list_info_type
operator|*
name|list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|calc_hex
name|PARAMS
argument_list|(
operator|(
name|list_info_type
operator|*
name|list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_lines
name|PARAMS
argument_list|(
operator|(
name|list_info_type
operator|*
operator|,
name|unsigned
name|int
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_symbol_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_source
name|PARAMS
argument_list|(
operator|(
name|file_info_type
operator|*
name|current_file
operator|,
name|list_info_type
operator|*
name|list
operator|,
name|char
operator|*
name|buffer
operator|,
name|unsigned
name|int
name|width
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debugging_pseudo
name|PARAMS
argument_list|(
operator|(
name|list_info_type
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|listing_listing
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|listing_message
parameter_list|(
name|name
parameter_list|,
name|message
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|{
if|if
condition|(
name|listing_tail
operator|!=
operator|(
name|list_info_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|unsigned
name|int
name|l
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|message
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|n
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|n
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|listing_tail
operator|->
name|message
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|listing_warning
parameter_list|(
name|message
parameter_list|)
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|listing_message
argument_list|(
name|_
argument_list|(
literal|"Warning:"
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_error
parameter_list|(
name|message
parameter_list|)
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|listing_message
argument_list|(
name|_
argument_list|(
literal|"Error:"
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|file_info_type
modifier|*
name|file_info
parameter_list|(
name|file_name
parameter_list|)
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
comment|/* Find an entry with this file name.  */
name|file_info_type
modifier|*
name|p
init|=
name|file_info_head
decl_stmt|;
while|while
condition|(
name|p
operator|!=
operator|(
name|file_info_type
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|filename
argument_list|,
name|file_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
comment|/* Make new entry.  */
name|p
operator|=
operator|(
name|file_info_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|file_info_type
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|file_info_head
expr_stmt|;
name|file_info_head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|strlen
argument_list|(
name|file_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|filename
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|p
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|linenum
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|at_end
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_frag
parameter_list|()
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_newline
parameter_list|(
name|ps
parameter_list|)
name|char
modifier|*
name|ps
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|static
name|unsigned
name|int
name|last_line
init|=
literal|0xffff
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_file
init|=
name|NULL
decl_stmt|;
name|list_info_type
modifier|*
name|new
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|listing
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
return|return;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* In ELF, anything in a section beginning with .debug or .line is      considered to be debugging information.  This includes the      statement which switches us into the debugging section, which we      can only set after we are already in the debugging section.  */
if|if
condition|(
operator|(
name|listing
operator|&
name|LISTING_NODEBUG
operator|)
operator|!=
literal|0
operator|&&
name|listing_tail
operator|!=
name|NULL
operator|&&
operator|!
name|listing_tail
operator|->
name|debugging
condition|)
block|{
specifier|const
name|char
modifier|*
name|segname
decl_stmt|;
name|segname
operator|=
name|segment_name
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".debug"
argument_list|,
sizeof|sizeof
expr|".debug"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".line"
argument_list|,
sizeof|sizeof
expr|".line"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|listing_tail
operator|->
name|debugging
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|line
operator|==
name|last_line
operator|&&
operator|!
operator|(
name|last_file
operator|&&
name|file
operator|&&
name|strcmp
argument_list|(
name|file
argument_list|,
name|last_file
argument_list|)
operator|)
condition|)
return|return;
name|new
operator|=
operator|(
name|list_info_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|list_info_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detect if we are reading from stdin by examining the file 	 name returned by as_where().  	 [FIXME: We rely upon the name in the strcmp below being the 	 same as the one used by input_scrub_new_file(), if that is 	 not true, then this code will fail].  	 If we are reading from stdin, then we need to save each input 	 line here (assuming of course that we actually have a line of 	 input to read), so that it can be displayed in the listing 	 that is produced at the end of the assembly.  */
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"{standard input}"
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|input_line_pointer
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|seen_quote
init|=
literal|0
decl_stmt|;
for|for
control|(
name|copy
operator|=
name|input_line_pointer
operator|-
literal|1
init|;
operator|*
name|copy
operator|&&
operator|(
name|seen_quote
operator|||
operator|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|copy
index|]
operator|)
operator|)
condition|;
name|copy
operator|++
control|)
if|if
condition|(
operator|*
name|copy
operator|==
literal|'"'
operator|&&
name|copy
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
name|seen_quote
operator|=
operator|!
name|seen_quote
expr_stmt|;
name|len
operator|=
operator|(
name|copy
operator|-
name|input_line_pointer
operator|)
operator|+
literal|2
expr_stmt|;
name|copy
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|src
init|=
name|input_line_pointer
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|dest
init|=
name|copy
decl_stmt|;
while|while
condition|(
operator|--
name|len
condition|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|src
operator|++
decl_stmt|;
comment|/* Omit control characters in the listing.  */
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
block|}
name|new
operator|->
name|line_contents
operator|=
name|copy
expr_stmt|;
block|}
else|else
name|new
operator|->
name|line_contents
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|new
operator|=
operator|(
name|list_info_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|list_info_type
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|line_contents
operator|=
name|ps
expr_stmt|;
block|}
name|last_line
operator|=
name|line
expr_stmt|;
name|last_file
operator|=
name|file
expr_stmt|;
name|new_frag
argument_list|()
expr_stmt|;
if|if
condition|(
name|listing_tail
condition|)
name|listing_tail
operator|->
name|next
operator|=
name|new
expr_stmt|;
else|else
name|head
operator|=
name|new
expr_stmt|;
name|listing_tail
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|new
operator|->
name|file
operator|=
name|file_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
operator|(
name|list_info_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|message
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|edict
operator|=
name|EDICT_NONE
expr_stmt|;
name|new
operator|->
name|hll_file
operator|=
operator|(
name|file_info_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|hll_line
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|debugging
operator|=
literal|0
expr_stmt|;
name|new_frag
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* In ELF, anything in a section beginning with .debug or .line is      considered to be debugging information.  */
if|if
condition|(
operator|(
name|listing
operator|&
name|LISTING_NODEBUG
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|segname
decl_stmt|;
name|segname
operator|=
name|segment_name
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".debug"
argument_list|,
sizeof|sizeof
expr|".debug"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".line"
argument_list|,
sizeof|sizeof
expr|".line"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|new
operator|->
name|debugging
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Attach all current frags to the previous line instead of the    current line.  This is called by the MIPS backend when it discovers    that it needs to add some NOP instructions; the added NOP    instructions should go with the instruction that has the delay, not    with the new instruction.  */
end_comment

begin_function
name|void
name|listing_prev_line
parameter_list|()
block|{
name|list_info_type
modifier|*
name|l
decl_stmt|;
name|fragS
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|head
operator|==
operator|(
name|list_info_type
operator|*
operator|)
name|NULL
operator|||
name|head
operator|==
name|listing_tail
condition|)
return|return;
name|new_frag
argument_list|()
expr_stmt|;
for|for
control|(
name|l
operator|=
name|head
init|;
name|l
operator|->
name|next
operator|!=
name|listing_tail
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
empty_stmt|;
for|for
control|(
name|f
operator|=
name|frchain_now
operator|->
name|frch_root
init|;
name|f
operator|!=
operator|(
name|fragS
operator|*
operator|)
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
if|if
condition|(
name|f
operator|->
name|line
operator|==
name|listing_tail
condition|)
name|f
operator|->
name|line
operator|=
name|l
expr_stmt|;
name|listing_tail
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|new_frag
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function returns the next source line from the file supplied,    truncated to size.  It appends a fake line to the end of each input    file to make.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|buffer_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|size
parameter_list|)
name|file_info_type
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|line
decl_stmt|;
comment|/* If we couldn't open the file, return an empty line.  */
if|if
condition|(
name|file
operator|->
name|at_end
condition|)
return|return
literal|""
return|;
comment|/* Check the cache and see if we last used this file.  */
if|if
condition|(
operator|!
name|last_open_file_info
operator|||
name|file
operator|!=
name|last_open_file_info
condition|)
block|{
if|if
condition|(
name|last_open_file
condition|)
block|{
name|last_open_file_info
operator|->
name|pos
operator|=
name|ftell
argument_list|(
name|last_open_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|last_open_file
argument_list|)
expr_stmt|;
block|}
name|last_open_file_info
operator|=
name|file
expr_stmt|;
name|last_open_file
operator|=
name|fopen
argument_list|(
name|file
operator|->
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_open_file
operator|==
name|NULL
condition|)
block|{
name|file
operator|->
name|at_end
operator|=
literal|1
expr_stmt|;
return|return
literal|""
return|;
block|}
comment|/* Seek to where we were last time this file was open.  */
if|if
condition|(
name|file
operator|->
name|pos
condition|)
name|fseek
argument_list|(
name|last_open_file
argument_list|,
name|file
operator|->
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|fgetc
argument_list|(
name|last_open_file
argument_list|)
expr_stmt|;
comment|/* Leave room for null.  */
name|size
operator|-=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|count
operator|<
name|size
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|last_open_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|file
operator|->
name|at_end
operator|=
literal|1
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
name|file
operator|->
name|linenum
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|eject
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Eject pending */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|page
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current page number */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|title
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current title */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subtitle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current subtitle */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|on_page
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines printed on current page */
end_comment

begin_function
specifier|static
name|void
name|listing_page
parameter_list|(
name|list
parameter_list|)
name|list_info_type
modifier|*
name|list
decl_stmt|;
block|{
comment|/* Grope around, see if we can see a title or subtitle edict coming up      soon.  (we look down 10 lines of the page and see if it's there)  */
if|if
condition|(
operator|(
name|eject
operator|||
operator|(
name|on_page
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|paper_height
operator|)
operator|)
operator|&&
name|paper_height
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|c
init|=
literal|10
decl_stmt|;
name|int
name|had_title
init|=
literal|0
decl_stmt|;
name|int
name|had_subtitle
init|=
literal|0
decl_stmt|;
name|page
operator|++
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|0
operator|&&
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|edict
operator|==
name|EDICT_SBTTL
operator|&&
operator|!
name|had_subtitle
condition|)
block|{
name|had_subtitle
operator|=
literal|1
expr_stmt|;
name|subtitle
operator|=
name|list
operator|->
name|edict_arg
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|->
name|edict
operator|==
name|EDICT_TITLE
operator|&&
operator|!
name|had_title
condition|)
block|{
name|had_title
operator|=
literal|1
expr_stmt|;
name|title
operator|=
name|list
operator|->
name|edict_arg
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\f"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%s %s \t\t\tpage %d\n"
argument_list|,
name|LISTING_HEADER
argument_list|,
name|fn
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%s\n"
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%s\n"
argument_list|,
name|subtitle
argument_list|)
expr_stmt|;
name|on_page
operator|=
literal|3
expr_stmt|;
name|eject
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|calc_hex
parameter_list|(
name|list
parameter_list|)
name|list_info_type
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|data_buffer_size
decl_stmt|;
name|list_info_type
modifier|*
name|first
init|=
name|list
decl_stmt|;
name|unsigned
name|int
name|address
init|=
operator|~
operator|(
name|unsigned
name|int
operator|)
literal|0
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|fragS
modifier|*
name|frag_ptr
decl_stmt|;
name|unsigned
name|int
name|octet_in_frag
decl_stmt|;
comment|/* Find first frag which says it belongs to this line.  */
name|frag
operator|=
name|list
operator|->
name|frag
expr_stmt|;
while|while
condition|(
name|frag
operator|&&
name|frag
operator|->
name|line
operator|!=
name|list
condition|)
name|frag
operator|=
name|frag
operator|->
name|fr_next
expr_stmt|;
name|frag_ptr
operator|=
name|frag
expr_stmt|;
name|data_buffer_size
operator|=
literal|0
expr_stmt|;
comment|/* Dump all the frags which belong to this line.  */
while|while
condition|(
name|frag_ptr
operator|!=
operator|(
name|fragS
operator|*
operator|)
name|NULL
operator|&&
name|frag_ptr
operator|->
name|line
operator|==
name|first
condition|)
block|{
comment|/* Print as many bytes from the fixed part as is sensible.  */
name|octet_in_frag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|offsetT
operator|)
name|octet_in_frag
operator|<
name|frag_ptr
operator|->
name|fr_fix
operator|&&
name|data_buffer_size
operator|<
name|MAX_BYTES
operator|-
literal|3
condition|)
block|{
if|if
condition|(
name|address
operator|==
operator|~
operator|(
name|unsigned
name|int
operator|)
literal|0
condition|)
block|{
name|address
operator|=
name|frag_ptr
operator|->
name|fr_address
operator|/
name|OCTETS_PER_BYTE
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|data_buffer
operator|+
name|data_buffer_size
argument_list|,
literal|"%02X"
argument_list|,
operator|(
name|frag_ptr
operator|->
name|fr_literal
index|[
name|octet_in_frag
index|]
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|data_buffer_size
operator|+=
literal|2
expr_stmt|;
name|octet_in_frag
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|frag_ptr
operator|->
name|fr_type
operator|==
name|rs_fill
condition|)
block|{
name|unsigned
name|int
name|var_rep_max
init|=
name|octet_in_frag
decl_stmt|;
name|unsigned
name|int
name|var_rep_idx
init|=
name|octet_in_frag
decl_stmt|;
comment|/* Print as many bytes from the variable part as is sensible.  */
while|while
condition|(
operator|(
operator|(
name|offsetT
operator|)
name|octet_in_frag
operator|<
operator|(
name|frag_ptr
operator|->
name|fr_fix
operator|+
name|frag_ptr
operator|->
name|fr_var
operator|*
name|frag_ptr
operator|->
name|fr_offset
operator|)
operator|)
operator|&&
name|data_buffer_size
operator|<
name|MAX_BYTES
operator|-
literal|3
condition|)
block|{
if|if
condition|(
name|address
operator|==
operator|~
operator|(
name|unsigned
name|int
operator|)
literal|0
condition|)
block|{
name|address
operator|=
name|frag_ptr
operator|->
name|fr_address
operator|/
name|OCTETS_PER_BYTE
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|data_buffer
operator|+
name|data_buffer_size
argument_list|,
literal|"%02X"
argument_list|,
operator|(
name|frag_ptr
operator|->
name|fr_literal
index|[
name|var_rep_idx
index|]
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|data_buffer[data_buffer_size++] = '*'; 	    data_buffer[data_buffer_size++] = '*';
endif|#
directive|endif
name|data_buffer_size
operator|+=
literal|2
expr_stmt|;
name|var_rep_idx
operator|++
expr_stmt|;
name|octet_in_frag
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|offsetT
operator|)
name|var_rep_idx
operator|>=
name|frag_ptr
operator|->
name|fr_fix
operator|+
name|frag_ptr
operator|->
name|fr_var
condition|)
name|var_rep_idx
operator|=
name|var_rep_max
expr_stmt|;
block|}
block|}
name|frag_ptr
operator|=
name|frag_ptr
operator|->
name|fr_next
expr_stmt|;
block|}
name|data_buffer
index|[
name|data_buffer_size
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|address
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_lines
parameter_list|(
name|list
parameter_list|,
name|lineno
parameter_list|,
name|string
parameter_list|,
name|address
parameter_list|)
name|list_info_type
modifier|*
name|list
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|address
decl_stmt|;
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|nchars
decl_stmt|;
name|unsigned
name|int
name|lines
decl_stmt|;
name|unsigned
name|int
name|octet_in_word
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|data_buffer
decl_stmt|;
name|int
name|cur
decl_stmt|;
comment|/* Print the stuff on the first line.  */
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|nchars
operator|=
operator|(
name|LISTING_WORD_SIZE
operator|*
literal|2
operator|+
literal|1
operator|)
operator|*
name|listing_lhs_width
expr_stmt|;
comment|/* Print the hex for the first line.  */
if|if
condition|(
name|address
operator|==
operator|~
operator|(
name|unsigned
name|int
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"% 4d     "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nchars
condition|;
name|idx
operator|++
control|)
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|string
condition|?
name|string
else|:
literal|""
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|had_errors
argument_list|()
condition|)
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"% 4d ???? "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"% 4d %04x "
argument_list|,
name|lineno
argument_list|,
name|address
argument_list|)
expr_stmt|;
comment|/* And the data to go along with it.  */
name|idx
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|src
index|[
name|cur
index|]
operator|&&
name|idx
operator|<
name|nchars
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|cur
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%c%c"
argument_list|,
name|src
index|[
name|offset
index|]
argument_list|,
name|src
index|[
name|offset
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|cur
operator|+=
literal|2
expr_stmt|;
name|octet_in_word
operator|++
expr_stmt|;
if|if
condition|(
name|octet_in_word
operator|==
name|LISTING_WORD_SIZE
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|octet_in_word
operator|=
literal|0
expr_stmt|;
block|}
name|idx
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
init|;
name|idx
operator|<
name|nchars
condition|;
name|idx
operator|++
control|)
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|string
condition|?
name|string
else|:
literal|""
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|message
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"****  %s\n"
argument_list|,
name|list
operator|->
name|message
argument_list|)
expr_stmt|;
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
block|}
for|for
control|(
name|lines
operator|=
literal|0
init|;
name|lines
operator|<
operator|(
name|unsigned
name|int
operator|)
name|listing_lhs_cont_lines
operator|&&
name|src
index|[
name|cur
index|]
condition|;
name|lines
operator|++
control|)
block|{
name|nchars
operator|=
operator|(
operator|(
name|LISTING_WORD_SIZE
operator|*
literal|2
operator|)
operator|+
literal|1
operator|)
operator|*
name|listing_lhs_width_second
operator|-
literal|1
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
comment|/* Print any more lines of data, but more compactly.  */
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"% 4d      "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
while|while
condition|(
name|src
index|[
name|cur
index|]
operator|&&
name|idx
operator|<
name|nchars
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|cur
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%c%c"
argument_list|,
name|src
index|[
name|offset
index|]
argument_list|,
name|src
index|[
name|offset
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|cur
operator|+=
literal|2
expr_stmt|;
name|idx
operator|+=
literal|2
expr_stmt|;
name|octet_in_word
operator|++
expr_stmt|;
if|if
condition|(
name|octet_in_word
operator|==
name|LISTING_WORD_SIZE
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|octet_in_word
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|list_symbol_table
parameter_list|()
block|{
specifier|extern
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
name|int
name|got_some
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|ptr
decl_stmt|;
name|eject
operator|=
literal|1
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|symbol_rootP
init|;
name|ptr
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|;
name|ptr
operator|=
name|symbol_next
argument_list|(
name|ptr
argument_list|)
control|)
block|{
if|if
condition|(
name|SEG_NORMAL
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|ptr
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* Don't report section symbols.  They are not interesting.  */
if|if
condition|(
name|symbol_section_p
argument_list|(
name|ptr
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|,
name|fmt
index|[
literal|8
index|]
decl_stmt|;
name|valueT
name|val
init|=
name|S_GET_VALUE
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
comment|/* @@ Note that this is dependent on the compilation options, 		 not solely on the target characteristics.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|==
literal|4
operator|&&
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
literal|4
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|<=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%%0%lulx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|BFD64
argument_list|)
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|>
literal|4
condition|)
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|got_some
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"DEFINED SYMBOLS\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|got_some
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|ptr
argument_list|)
operator|&&
name|symbol_get_frag
argument_list|(
name|ptr
argument_list|)
operator|->
name|line
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%20s:%-5d  %s:%s %s\n"
argument_list|,
name|symbol_get_frag
argument_list|(
name|ptr
argument_list|)
operator|->
name|line
operator|->
name|file
operator|->
name|filename
argument_list|,
name|symbol_get_frag
argument_list|(
name|ptr
argument_list|)
operator|->
name|line
operator|->
name|line
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|ptr
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|,
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%33s:%s %s\n"
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|ptr
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|,
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|got_some
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"NO DEFINED SYMBOLS\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|got_some
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|symbol_rootP
init|;
name|ptr
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|;
name|ptr
operator|=
name|symbol_next
argument_list|(
name|ptr
argument_list|)
control|)
block|{
if|if
condition|(
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
operator|&&
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|ptr
argument_list|)
operator|==
name|undefined_section
condition|)
block|{
if|if
condition|(
operator|!
name|got_some
condition|)
block|{
name|got_some
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"UNDEFINED SYMBOLS\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%s\n"
argument_list|,
name|S_GET_NAME
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|got_some
condition|)
block|{
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"NO UNDEFINED SYMBOLS\n"
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_source
parameter_list|(
name|current_file
parameter_list|,
name|list
parameter_list|,
name|buffer
parameter_list|,
name|width
parameter_list|)
name|file_info_type
modifier|*
name|current_file
decl_stmt|;
name|list_info_type
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|current_file
operator|->
name|at_end
condition|)
block|{
while|while
condition|(
name|current_file
operator|->
name|linenum
operator|<
name|list
operator|->
name|hll_line
operator|&&
operator|!
name|current_file
operator|->
name|at_end
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|buffer_line
argument_list|(
name|current_file
argument_list|,
name|buffer
argument_list|,
name|width
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|list_file
argument_list|,
literal|"%4u:%-13s **** %s\n"
argument_list|,
name|current_file
operator|->
name|linenum
argument_list|,
name|current_file
operator|->
name|filename
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|on_page
operator|++
expr_stmt|;
name|listing_page
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Sometimes the user doesn't want to be bothered by the debugging    records inserted by the compiler, see if the line is suspicious.  */
end_comment

begin_function
specifier|static
name|int
name|debugging_pseudo
parameter_list|(
name|list
parameter_list|,
name|line
parameter_list|)
name|list_info_type
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
block|{
specifier|static
name|int
name|in_debug
decl_stmt|;
name|int
name|was_debug
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|debugging
condition|)
block|{
name|in_debug
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
name|was_debug
operator|=
name|in_debug
expr_stmt|;
name|in_debug
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|!=
literal|'.'
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The ELF compiler sometimes emits blank lines after switching          out of a debugging section.  If the next line drops us back          into debugging information, then don't print the blank line.          This is a hack for a particular compiler behaviour, not a          general case.  */
if|if
condition|(
name|was_debug
operator|&&
operator|*
name|line
operator|==
literal|'\0'
operator|&&
name|list
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|list
operator|->
name|next
operator|->
name|debugging
condition|)
block|{
name|in_debug
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"def"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"val"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"scl"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"line"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"endef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"ln"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"size"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"dim"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"tag"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"stabs"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"stabn"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|listing_listing
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|list_info_type
modifier|*
name|list
init|=
name|head
decl_stmt|;
name|file_info_type
modifier|*
name|current_hll_file
init|=
operator|(
name|file_info_type
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|show_listing
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|listing_rhs_width
argument_list|)
expr_stmt|;
name|data_buffer
operator|=
name|xmalloc
argument_list|(
name|MAX_BYTES
argument_list|)
expr_stmt|;
name|eject
operator|=
literal|1
expr_stmt|;
name|list
operator|=
name|head
expr_stmt|;
while|while
condition|(
name|list
operator|!=
operator|(
name|list_info_type
operator|*
operator|)
name|NULL
operator|&&
literal|0
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|next
condition|)
name|list
operator|->
name|frag
operator|=
name|list
operator|->
name|next
operator|->
name|frag
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|list
operator|=
name|head
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|unsigned
name|int
name|list_line
decl_stmt|;
name|width
operator|=
name|listing_rhs_width
operator|>
name|paper_width
condition|?
name|paper_width
else|:
name|listing_rhs_width
expr_stmt|;
name|list_line
operator|=
name|list
operator|->
name|line
expr_stmt|;
switch|switch
condition|(
name|list
operator|->
name|edict
condition|)
block|{
case|case
name|EDICT_LIST
case|:
comment|/* Skip all lines up to the current.  */
name|list_line
operator|--
expr_stmt|;
break|break;
case|case
name|EDICT_NOLIST
case|:
name|show_listing
operator|--
expr_stmt|;
break|break;
case|case
name|EDICT_NOLIST_NEXT
case|:
if|if
condition|(
name|show_listing
operator|==
literal|0
condition|)
name|list_line
operator|--
expr_stmt|;
break|break;
case|case
name|EDICT_EJECT
case|:
break|break;
case|case
name|EDICT_NONE
case|:
break|break;
case|case
name|EDICT_TITLE
case|:
name|title
operator|=
name|list
operator|->
name|edict_arg
expr_stmt|;
break|break;
case|case
name|EDICT_SBTTL
case|:
name|subtitle
operator|=
name|list
operator|->
name|edict_arg
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|show_listing
operator|<=
literal|0
condition|)
block|{
while|while
condition|(
name|list
operator|->
name|file
operator|->
name|linenum
operator|<
name|list_line
operator|&&
operator|!
name|list
operator|->
name|file
operator|->
name|at_end
condition|)
name|p
operator|=
name|buffer_line
argument_list|(
name|list
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|->
name|edict
operator|==
name|EDICT_LIST
operator|||
operator|(
name|list
operator|->
name|edict
operator|==
name|EDICT_NOLIST_NEXT
operator|&&
name|show_listing
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Enable listing for the single line that caused the enable.  */
name|list_line
operator|++
expr_stmt|;
name|show_listing
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|show_listing
operator|>
literal|0
condition|)
block|{
comment|/* Scan down the list and print all the stuff which can be done 	     with this line (or lines).  */
name|message
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|hll_file
condition|)
block|{
name|current_hll_file
operator|=
name|list
operator|->
name|hll_file
expr_stmt|;
block|}
if|if
condition|(
name|current_hll_file
operator|&&
name|list
operator|->
name|hll_line
operator|&&
operator|(
name|listing
operator|&
name|LISTING_HLL
operator|)
condition|)
block|{
name|print_source
argument_list|(
name|current_hll_file
argument_list|,
name|list
argument_list|,
name|buffer
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|->
name|line_contents
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|listing
operator|&
name|LISTING_NODEBUG
operator|)
operator|&&
name|debugging_pseudo
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|line_contents
argument_list|)
operator|)
condition|)
block|{
name|print_lines
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|file
operator|->
name|linenum
operator|==
literal|0
condition|?
name|list
operator|->
name|line
else|:
name|list
operator|->
name|file
operator|->
name|linenum
argument_list|,
name|list
operator|->
name|line_contents
argument_list|,
name|calc_hex
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|list
operator|->
name|line_contents
argument_list|)
expr_stmt|;
name|list
operator|->
name|line_contents
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|list
operator|->
name|file
operator|->
name|linenum
operator|<
name|list_line
operator|&&
operator|!
name|list
operator|->
name|file
operator|->
name|at_end
condition|)
block|{
name|unsigned
name|int
name|address
decl_stmt|;
name|p
operator|=
name|buffer_line
argument_list|(
name|list
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|file
operator|->
name|linenum
operator|<
name|list_line
condition|)
name|address
operator|=
operator|~
operator|(
name|unsigned
name|int
operator|)
literal|0
expr_stmt|;
else|else
name|address
operator|=
name|calc_hex
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|listing
operator|&
name|LISTING_NODEBUG
operator|)
operator|&&
name|debugging_pseudo
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
operator|)
condition|)
name|print_lines
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|file
operator|->
name|linenum
argument_list|,
name|p
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|list
operator|->
name|edict
operator|==
name|EDICT_EJECT
condition|)
block|{
name|eject
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|list
operator|->
name|edict
operator|==
name|EDICT_NOLIST_NEXT
operator|&&
name|show_listing
operator|==
literal|1
condition|)
operator|--
name|show_listing
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data_buffer
argument_list|)
expr_stmt|;
name|data_buffer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_print
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|using_stdout
decl_stmt|;
name|title
operator|=
literal|""
expr_stmt|;
name|subtitle
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|list_file
operator|=
name|stdout
expr_stmt|;
name|using_stdout
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|list_file
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_file
operator|!=
name|NULL
condition|)
name|using_stdout
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|as_perror
argument_list|(
name|_
argument_list|(
literal|"can't open list file: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|list_file
operator|=
name|stdout
expr_stmt|;
name|using_stdout
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|listing
operator|&
name|LISTING_NOFORM
condition|)
block|{
name|paper_height
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|listing
operator|&
name|LISTING_LISTING
condition|)
block|{
name|listing_listing
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listing
operator|&
name|LISTING_SYMBOLS
condition|)
block|{
name|list_symbol_table
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|using_stdout
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|list_file
argument_list|)
operator|==
name|EOF
condition|)
name|as_perror
argument_list|(
name|_
argument_list|(
literal|"error closing list file: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_open_file
condition|)
block|{
name|fclose
argument_list|(
name|last_open_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|listing_file
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fn
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_eject
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|listing
condition|)
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_EJECT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_flags
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|input_line_pointer
operator|++
operator|)
operator|&&
operator|(
operator|*
name|input_line_pointer
operator|!=
literal|'\n'
operator|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn listing on or off.  An argument of 0 means to turn off    listing.  An argument of 1 means to turn on listing.  An argument    of 2 means to turn off listing, but as of the next line; that is,    the current line should be listed, but the next line should not.  */
end_comment

begin_function
name|void
name|listing_list
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
if|if
condition|(
name|listing
condition|)
block|{
switch|switch
condition|(
name|on
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|listing_tail
operator|->
name|edict
operator|==
name|EDICT_LIST
condition|)
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_NONE
expr_stmt|;
else|else
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_NOLIST
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|listing_tail
operator|->
name|edict
operator|==
name|EDICT_NOLIST
operator|||
name|listing_tail
operator|->
name|edict
operator|==
name|EDICT_NOLIST_NEXT
condition|)
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_NONE
expr_stmt|;
else|else
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_LIST
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|listing_tail
operator|->
name|edict
operator|=
name|EDICT_NOLIST_NEXT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|listing_psize
parameter_list|(
name|width_only
parameter_list|)
name|int
name|width_only
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|width_only
condition|)
block|{
name|paper_height
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|paper_height
operator|<
literal|0
operator|||
name|paper_height
operator|>
literal|1000
condition|)
block|{
name|paper_height
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"strange paper height, set to no form"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|paper_width
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_nopage
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|paper_height
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_title
parameter_list|(
name|depth
parameter_list|)
name|int
name|depth
decl_stmt|;
block|{
name|int
name|quoted
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|ttl
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\"'
condition|)
name|quoted
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|start
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
if|if
condition|(
name|quoted
condition|?
operator|*
name|input_line_pointer
operator|==
literal|'\"'
else|:
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|listing
condition|)
block|{
name|length
operator|=
name|input_line_pointer
operator|-
name|start
expr_stmt|;
name|ttl
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ttl
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ttl
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|listing_tail
operator|->
name|edict
operator|=
name|depth
condition|?
name|EDICT_SBTTL
else|:
name|EDICT_TITLE
expr_stmt|;
name|listing_tail
operator|->
name|edict_arg
operator|=
name|ttl
expr_stmt|;
block|}
if|if
condition|(
name|quoted
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"New line in title"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|listing_source_line
parameter_list|(
name|line
parameter_list|)
name|unsigned
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|listing
condition|)
block|{
name|new_frag
argument_list|()
expr_stmt|;
name|listing_tail
operator|->
name|hll_line
operator|=
name|line
expr_stmt|;
name|new_frag
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|listing_source_file
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|listing
condition|)
name|listing_tail
operator|->
name|hll_file
operator|=
name|file_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Dummy functions for when compiled without listing enabled.  */
end_comment

begin_function
name|void
name|listing_flags
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_list
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_eject
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_psize
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_nopage
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_title
parameter_list|(
name|depth
parameter_list|)
name|int
name|depth
decl_stmt|;
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listing_file
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{  }
end_function

begin_function
name|void
name|listing_newline
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{  }
end_function

begin_function
name|void
name|listing_source_line
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|int
name|n
decl_stmt|;
block|{  }
end_function

begin_function
name|void
name|listing_source_file
parameter_list|(
name|n
parameter_list|)
specifier|const
name|char
modifier|*
name|n
decl_stmt|;
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

