begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* expr.c -operands, expressions-    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is really a branch office of as-read.c. I split it out to clearly    distinguish the world of expressions from the world of statements.    (It also gives smaller files to re-compile.)    Here, "operand"s are of expressions, not instructions.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|floating_constant
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|valueT
name|generic_bignum_to_int32
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_decl_stmt
specifier|static
name|valueT
name|generic_bignum_to_int64
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|integer_constant
name|PARAMS
argument_list|(
operator|(
name|int
name|radix
operator|,
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mri_char_constant
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|current_location
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clean_up_expression
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|operand
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|operatorT
name|operator
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|EXP_CHARS
index|[]
decl_stmt|,
name|FLT_CHARS
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We keep a mapping of expression symbols to file positions, so that    we can provide better error messages.  */
end_comment

begin_struct
struct|struct
name|expr_symbol_line
block|{
name|struct
name|expr_symbol_line
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|expr_symbol_line
modifier|*
name|expr_symbol_lines
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Build a dummy symbol to hold a complex expression.  This is how we    build expressions up out of other expressions.  The symbol is put    into the fake section expr_section.  */
end_comment

begin_function
name|symbolS
modifier|*
name|make_expr_symbol
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|expressionS
name|zero
decl_stmt|;
specifier|const
name|char
modifier|*
name|fake
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|struct
name|expr_symbol_line
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|expressionP
operator|->
name|X_add_number
operator|==
literal|0
condition|)
return|return
name|expressionP
operator|->
name|X_add_symbol
return|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* This won't work, because the actual value is stored in          generic_floating_point_number or generic_bignum, and we are          going to lose it if we haven't already.  */
if|if
condition|(
name|expressionP
operator|->
name|X_add_number
operator|>
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bignum invalid"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"floating point number invalid"
argument_list|)
argument_list|)
expr_stmt|;
name|zero
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|zero
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|zero
operator|.
name|X_unsigned
operator|=
literal|0
expr_stmt|;
name|clean_up_expression
argument_list|(
operator|&
name|zero
argument_list|)
expr_stmt|;
name|expressionP
operator|=
operator|&
name|zero
expr_stmt|;
block|}
name|fake
operator|=
name|FAKE_LABEL_NAME
expr_stmt|;
comment|/* Putting constant symbols in absolute_section rather than      expr_section is convenient for the old a.out code, for which      S_GET_SEGMENT does not always retrieve the value put in by      S_SET_SEGMENT.  */
name|symbolP
operator|=
name|symbol_create
argument_list|(
name|fake
argument_list|,
operator|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_constant
condition|?
name|absolute_section
else|:
name|expr_section
operator|)
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|symbolP
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_constant
condition|)
name|resolve_symbol_value
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|expr_symbol_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|sym
operator|=
name|symbolP
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|n
operator|->
name|file
argument_list|,
operator|&
name|n
operator|->
name|line
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|expr_symbol_lines
expr_stmt|;
name|expr_symbol_lines
operator|=
name|n
expr_stmt|;
return|return
name|symbolP
return|;
block|}
end_function

begin_comment
comment|/* Return the file and line number for an expr symbol.  Return    non-zero if something was found, 0 if no information is known for    the symbol.  */
end_comment

begin_function
name|int
name|expr_symbol_where
parameter_list|(
name|sym
parameter_list|,
name|pfile
parameter_list|,
name|pline
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pline
decl_stmt|;
block|{
specifier|register
name|struct
name|expr_symbol_line
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|expr_symbol_lines
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|sym
operator|==
name|sym
condition|)
block|{
operator|*
name|pfile
operator|=
name|l
operator|->
name|file
expr_stmt|;
operator|*
name|pline
operator|=
name|l
operator|->
name|line
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utilities for building expressions.    Since complex expressions are recorded as symbols for use in other    expressions these return a symbolS * and not an expressionS *.    These explicitly do not take an "add_number" argument.  */
end_comment

begin_comment
comment|/* ??? For completeness' sake one might want expr_build_symbol.    It would just return its argument.  */
end_comment

begin_comment
comment|/* Build an expression for an unsigned constant.    The corresponding one for signed constants is missing because    there's currently no need for it.  One could add an unsigned_p flag    but that seems more clumsy.  */
end_comment

begin_function
name|symbolS
modifier|*
name|expr_build_uconstant
parameter_list|(
name|value
parameter_list|)
name|offsetT
name|value
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|e
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
name|value
expr_stmt|;
name|e
operator|.
name|X_unsigned
operator|=
literal|1
expr_stmt|;
return|return
name|make_expr_symbol
argument_list|(
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression for OP s1.  */
end_comment

begin_function
name|symbolS
modifier|*
name|expr_build_unary
parameter_list|(
name|op
parameter_list|,
name|s1
parameter_list|)
name|operatorT
name|op
decl_stmt|;
name|symbolS
modifier|*
name|s1
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|e
operator|.
name|X_op
operator|=
name|op
expr_stmt|;
name|e
operator|.
name|X_add_symbol
operator|=
name|s1
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
return|return
name|make_expr_symbol
argument_list|(
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression for s1 OP s2.  */
end_comment

begin_function
name|symbolS
modifier|*
name|expr_build_binary
parameter_list|(
name|op
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|operatorT
name|op
decl_stmt|;
name|symbolS
modifier|*
name|s1
decl_stmt|;
name|symbolS
modifier|*
name|s2
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|e
operator|.
name|X_op
operator|=
name|op
expr_stmt|;
name|e
operator|.
name|X_add_symbol
operator|=
name|s1
expr_stmt|;
name|e
operator|.
name|X_op_symbol
operator|=
name|s2
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
return|return
name|make_expr_symbol
argument_list|(
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression for the current location ('.').  */
end_comment

begin_function
name|symbolS
modifier|*
name|expr_build_dot
parameter_list|()
block|{
name|expressionS
name|e
decl_stmt|;
name|current_location
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
return|return
name|make_expr_symbol
argument_list|(
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build any floating-point literal here.    Also build any bignum literal here.  */
end_comment

begin_comment
comment|/* Seems atof_machine can backscan through generic_bignum and hit whatever    happens to be loaded before it in memory.  And its way too complicated    for me to fix right.  Thus a hack.  JF:  Just make generic_bignum bigger,    and never write into the early words, thus they'll always be zero.    I hate Dean's floating-point code.  Bleh.  */
end_comment

begin_decl_stmt
name|LITTLENUM_TYPE
name|generic_bignum
index|[
name|SIZE_OF_LARGE_NUMBER
operator|+
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FLONUM_TYPE
name|generic_floating_point_number
init|=
block|{
operator|&
name|generic_bignum
index|[
literal|6
index|]
block|,
comment|/* low.  (JF: Was 0)  */
operator|&
name|generic_bignum
index|[
name|SIZE_OF_LARGE_NUMBER
operator|+
literal|6
operator|-
literal|1
index|]
block|,
comment|/* high.  JF: (added +6)  */
literal|0
block|,
comment|/* leader.  */
literal|0
block|,
comment|/* exponent.  */
literal|0
comment|/* sign.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, we've been asked to assemble nan, +inf or -inf.  */
end_comment

begin_decl_stmt
name|int
name|generic_floating_point_magic
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|floating_constant
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
comment|/* input_line_pointer -> floating-point constant.  */
name|int
name|error_code
decl_stmt|;
name|error_code
operator|=
name|atof_generic
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
literal|"."
argument_list|,
name|EXP_CHARS
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
condition|)
block|{
if|if
condition|(
name|error_code
operator|==
name|ERROR_EXPONENT_OVERFLOW
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad floating-point constant: exponent overflow"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad floating-point constant: unknown error code=%d"
argument_list|)
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
block|}
block|}
name|expressionP
operator|->
name|X_op
operator|=
name|O_big
expr_stmt|;
comment|/* input_line_pointer -> just after constant, which may point to      whitespace.  */
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|valueT
name|generic_bignum_to_int32
parameter_list|()
block|{
name|valueT
name|number
init|=
operator|(
operator|(
name|generic_bignum
index|[
literal|1
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator||
operator|(
name|generic_bignum
index|[
literal|0
index|]
operator|&
name|LITTLENUM_MASK
operator|)
decl_stmt|;
name|number
operator|&=
literal|0xffffffff
expr_stmt|;
return|return
name|number
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_function
specifier|static
name|valueT
name|generic_bignum_to_int64
parameter_list|()
block|{
name|valueT
name|number
init|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|valueT
operator|)
name|generic_bignum
index|[
literal|3
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator||
operator|(
operator|(
name|valueT
operator|)
name|generic_bignum
index|[
literal|2
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator||
operator|(
operator|(
name|valueT
operator|)
name|generic_bignum
index|[
literal|1
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator||
operator|(
operator|(
name|valueT
operator|)
name|generic_bignum
index|[
literal|0
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|)
decl_stmt|;
return|return
name|number
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|integer_constant
parameter_list|(
name|radix
parameter_list|,
name|expressionP
parameter_list|)
name|int
name|radix
decl_stmt|;
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Start of number.  */
name|char
modifier|*
name|suffix
init|=
name|NULL
decl_stmt|;
name|char
name|c
decl_stmt|;
name|valueT
name|number
decl_stmt|;
comment|/* Offset or (absolute) value.  */
name|short
name|int
name|digit
decl_stmt|;
comment|/* Value of next digit in current radix.  */
name|short
name|int
name|maxdig
init|=
literal|0
decl_stmt|;
comment|/* Highest permitted digit value.  */
name|int
name|too_many_digits
init|=
literal|0
decl_stmt|;
comment|/* If we see>= this number of.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Points to name of symbol.  */
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Points to symbol.  */
name|int
name|small
decl_stmt|;
comment|/* True if fits in 32 bits.  */
comment|/* May be bignum, or may fit in 32 bits.  */
comment|/* Most numbers fit into 32 bits, and we want this case to be fast.      so we pretend it will fit into 32 bits.  If, after making up a 32      bit number, we realise that we have scanned more digits than      comfortably fit into 32 bits, we re-scan the digits coding them      into a bignum.  For decimal and octal numbers we are      conservative: Some numbers may be assumed bignums when in fact      they do fit into 32 bits.  Numbers of any radix can have excess      leading zeros: We strive to recognise this and cast them back      into 32 bits.  We must check that the bignum really is more than      32 bits, and change it back to a 32-bit number if it fits.  The      number we are looking for is expected to be positive, but if it      fits into 32 bits as an unsigned number, we let it be a 32-bit      number.  The cavalier approach is for speed in ordinary cases.  */
comment|/* This has been extended for 64 bits.  We blindly assume that if      you're compiling in 64-bit mode, the target is a 64-bit machine.      This should be cleaned up.  */
ifdef|#
directive|ifdef
name|BFD64
define|#
directive|define
name|valuesize
value|64
else|#
directive|else
comment|/* includes non-bfd case, mostly */
define|#
directive|define
name|valuesize
value|32
endif|#
directive|endif
if|if
condition|(
operator|(
name|NUMBERS_WITH_SUFFIX
operator|||
name|flag_m68k_mri
operator|)
operator|&&
name|radix
operator|==
literal|0
condition|)
block|{
name|int
name|flt
init|=
literal|0
decl_stmt|;
comment|/* In MRI mode, the number may have a suffix indicating the          radix.  For that matter, it might actually be a floating          point constant.  */
for|for
control|(
name|suffix
operator|=
name|input_line_pointer
init|;
name|ISALNUM
argument_list|(
operator|*
name|suffix
argument_list|)
condition|;
name|suffix
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|suffix
operator|==
literal|'e'
operator|||
operator|*
name|suffix
operator|==
literal|'E'
condition|)
name|flt
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|suffix
operator|==
name|input_line_pointer
condition|)
block|{
name|radix
operator|=
literal|10
expr_stmt|;
name|suffix
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
operator|--
name|suffix
expr_stmt|;
name|c
operator|=
name|TOUPPER
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
name|radix
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'D'
condition|)
name|radix
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'O'
operator|||
name|c
operator|==
literal|'Q'
condition|)
name|radix
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'H'
condition|)
name|radix
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|suffix
index|[
literal|1
index|]
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|flt
condition|)
block|{
name|floating_constant
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|radix
operator|=
literal|10
expr_stmt|;
name|suffix
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|2
case|:
name|maxdig
operator|=
literal|2
expr_stmt|;
name|too_many_digits
operator|=
name|valuesize
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|maxdig
operator|=
name|radix
operator|=
literal|8
expr_stmt|;
name|too_many_digits
operator|=
operator|(
name|valuesize
operator|+
literal|2
operator|)
operator|/
literal|3
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|maxdig
operator|=
name|radix
operator|=
literal|16
expr_stmt|;
name|too_many_digits
operator|=
operator|(
name|valuesize
operator|+
literal|3
operator|)
operator|/
literal|4
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|maxdig
operator|=
name|radix
operator|=
literal|10
expr_stmt|;
name|too_many_digits
operator|=
operator|(
name|valuesize
operator|+
literal|11
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* Very rough.  */
block|}
undef|#
directive|undef
name|valuesize
name|start
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
for|for
control|(
name|number
operator|=
literal|0
init|;
operator|(
name|digit
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
operator|)
operator|<
name|maxdig
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
control|)
block|{
name|number
operator|=
name|number
operator|*
name|radix
operator|+
name|digit
expr_stmt|;
block|}
comment|/* c contains character after number.  */
comment|/* input_line_pointer->char after c.  */
name|small
operator|=
operator|(
name|input_line_pointer
operator|-
name|start
operator|-
literal|1
operator|)
operator|<
name|too_many_digits
expr_stmt|;
if|if
condition|(
name|radix
operator|==
literal|16
operator|&&
name|c
operator|==
literal|'_'
condition|)
block|{
comment|/* This is literal of the form 0x333_0_12345678_1.          This example is equivalent to 0x00000333000000001234567800000001.  */
name|int
name|num_little_digits
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|input_line_pointer
operator|=
name|start
expr_stmt|;
comment|/* -> 1st digit.  */
name|know
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|==
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'_'
init|;
name|c
operator|==
literal|'_'
condition|;
name|num_little_digits
operator|+=
literal|2
control|)
block|{
comment|/* Convert one 64-bit word.  */
name|int
name|ndigit
init|=
literal|0
decl_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
init|;
operator|(
name|digit
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
operator|)
operator|<
name|maxdig
condition|;
name|c
operator|=
operator|*
operator|(
name|input_line_pointer
operator|++
operator|)
control|)
block|{
name|number
operator|=
name|number
operator|*
name|radix
operator|+
name|digit
expr_stmt|;
name|ndigit
operator|++
expr_stmt|;
block|}
comment|/* Check for 8 digit per word max.  */
if|if
condition|(
name|ndigit
operator|>
literal|8
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"a bignum with underscores may not have more than 8 hex digits in any word"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add this chunk to the bignum. 	     Shift things down 2 little digits.  */
name|know
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|==
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min
argument_list|(
name|num_little_digits
operator|+
literal|1
argument_list|,
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
argument_list|)
init|;
name|i
operator|>=
literal|2
condition|;
name|i
operator|--
control|)
name|generic_bignum
index|[
name|i
index|]
operator|=
name|generic_bignum
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
comment|/* Add the new digits as the least significant new ones.  */
name|generic_bignum
index|[
literal|0
index|]
operator|=
name|number
operator|&
literal|0xffffffff
expr_stmt|;
name|generic_bignum
index|[
literal|1
index|]
operator|=
name|number
operator|>>
literal|16
expr_stmt|;
block|}
comment|/* Again, c is char after number, input_line_pointer->after c.  */
if|if
condition|(
name|num_little_digits
operator|>
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
condition|)
name|num_little_digits
operator|=
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|num_little_digits
operator|>=
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_little_digits
operator|!=
literal|8
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"a bignum with underscores must have exactly 4 words"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We might have some leading zeros.  These can be trimmed to give 	 us a change to fit this constant into a small number.  */
while|while
condition|(
name|generic_bignum
index|[
name|num_little_digits
operator|-
literal|1
index|]
operator|==
literal|0
operator|&&
name|num_little_digits
operator|>
literal|1
condition|)
name|num_little_digits
operator|--
expr_stmt|;
if|if
condition|(
name|num_little_digits
operator|<=
literal|2
condition|)
block|{
comment|/* will fit into 32 bits.  */
name|number
operator|=
name|generic_bignum_to_int32
argument_list|()
expr_stmt|;
name|small
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BFD64
elseif|else
if|if
condition|(
name|num_little_digits
operator|<=
literal|4
condition|)
block|{
comment|/* Will fit into 64 bits.  */
name|number
operator|=
name|generic_bignum_to_int64
argument_list|()
expr_stmt|;
name|small
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|small
operator|=
literal|0
expr_stmt|;
comment|/* Number of littlenums in the bignum.  */
name|number
operator|=
name|num_little_digits
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|small
condition|)
block|{
comment|/* We saw a lot of digits. manufacture a bignum the hard way.  */
name|LITTLENUM_TYPE
modifier|*
name|leader
decl_stmt|;
comment|/* -> high order littlenum of the bignum.  */
name|LITTLENUM_TYPE
modifier|*
name|pointer
decl_stmt|;
comment|/* -> littlenum we are frobbing now.  */
name|long
name|carry
decl_stmt|;
name|leader
operator|=
name|generic_bignum
expr_stmt|;
name|generic_bignum
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|generic_bignum
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|generic_bignum
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|generic_bignum
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|input_line_pointer
operator|=
name|start
expr_stmt|;
comment|/* -> 1st digit.  */
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|(
name|carry
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
operator|)
operator|<
name|maxdig
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
control|)
block|{
for|for
control|(
name|pointer
operator|=
name|generic_bignum
init|;
name|pointer
operator|<=
name|leader
condition|;
name|pointer
operator|++
control|)
block|{
name|long
name|work
decl_stmt|;
name|work
operator|=
name|carry
operator|+
name|radix
operator|*
operator|*
name|pointer
expr_stmt|;
operator|*
name|pointer
operator|=
name|work
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
name|carry
condition|)
block|{
if|if
condition|(
name|leader
operator|<
name|generic_bignum
operator|+
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
condition|)
block|{
comment|/* Room to grow a longer bignum.  */
operator|*
operator|++
name|leader
operator|=
name|carry
expr_stmt|;
block|}
block|}
block|}
comment|/* Again, c is char after number.  */
comment|/* input_line_pointer -> after c.  */
name|know
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|==
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|leader
operator|<
name|generic_bignum
operator|+
literal|2
condition|)
block|{
comment|/* Will fit into 32 bits.  */
name|number
operator|=
name|generic_bignum_to_int32
argument_list|()
expr_stmt|;
name|small
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BFD64
elseif|else
if|if
condition|(
name|leader
operator|<
name|generic_bignum
operator|+
literal|4
condition|)
block|{
comment|/* Will fit into 64 bits.  */
name|number
operator|=
name|generic_bignum_to_int64
argument_list|()
expr_stmt|;
name|small
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
comment|/* Number of littlenums in the bignum.  */
name|number
operator|=
name|leader
operator|-
name|generic_bignum
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|NUMBERS_WITH_SUFFIX
operator|||
name|flag_m68k_mri
operator|)
operator|&&
name|suffix
operator|!=
name|NULL
operator|&&
name|input_line_pointer
operator|-
literal|1
operator|==
name|suffix
condition|)
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|small
condition|)
block|{
comment|/* Here with number, in correct radix. c is the next char. 	 Note that unlike un*x, we allow "011f" "0x9f" to both mean 	 the same as the (conventional) "9f". 	 This is simply easier than checking for strict canonical 	 form.  Syntax sux!  */
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
name|c
operator|==
literal|'b'
condition|)
block|{
comment|/* Backward ref to local label. 	     Because it is backward, expect it to be defined.  */
comment|/* Construct a local label.  */
name|name
operator|=
name|fb_label_name
argument_list|(
operator|(
name|int
operator|)
name|number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Seen before, or symbol is defined: OK.  */
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
comment|/* Local labels are never absolute.  Don't waste time 		 checking absoluteness.  */
name|know
argument_list|(
name|SEG_NORMAL
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
block|}
else|else
block|{
comment|/* Either not seen or not defined.  */
comment|/* @@ Should print out the original string instead of 		 the parsed number.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"backward ref to unknown label \"%d:\""
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|number
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
comment|/* case 'b' */
elseif|else
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
name|c
operator|==
literal|'f'
condition|)
block|{
comment|/* Forward reference.  Expect symbol to be undefined or 	     unknown.  undefined: seen it before.  unknown: never seen 	     it before.  	     Construct a local label name, then an undefined symbol. 	     Don't create a xseg frag for it: caller may do that. 	     Just return it as never seen before.  */
name|name
operator|=
name|fb_label_name
argument_list|(
operator|(
name|int
operator|)
name|number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* We have no need to check symbol properties.  */
ifndef|#
directive|ifndef
name|many_segments
comment|/* Since "know" puts its arg into a "string", we 	     can't have newlines in the argument.  */
name|know
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|undefined_section
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|text_section
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|data_section
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
comment|/* case 'f' */
elseif|else
if|if
condition|(
name|LOCAL_LABELS_DOLLAR
operator|&&
name|c
operator|==
literal|'$'
condition|)
block|{
comment|/* If the dollar label is *currently* defined, then this is just 	     another reference to it.  If it is not *currently* defined, 	     then this is a fresh instantiation of that number, so create 	     it.  */
if|if
condition|(
name|dollar_label_defined
argument_list|(
operator|(
name|long
operator|)
name|number
argument_list|)
condition|)
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
operator|(
name|long
operator|)
name|number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbolP
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
operator|(
name|long
operator|)
name|number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
comment|/* case '$' */
else|else
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_WORD_SIZE
comment|/* Sign extend NUMBER.  */
name|number
operator||=
operator|(
operator|-
operator|(
name|number
operator|>>
operator|(
name|TARGET_WORD_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
operator|<<
operator|(
name|TARGET_WORD_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
name|expressionP
operator|->
name|X_add_number
operator|=
name|number
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Restore following character.  */
block|}
comment|/* Really just a number.  */
block|}
else|else
block|{
comment|/* Not a small number.  */
name|expressionP
operator|->
name|X_op
operator|=
name|O_big
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|number
expr_stmt|;
comment|/* Number of littlenums.  */
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* -> char following number.  */
block|}
block|}
end_function

begin_comment
comment|/* Parse an MRI multi character constant.  */
end_comment

begin_function
specifier|static
name|void
name|mri_char_constant
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'\''
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* In order to get the correct byte ordering, we must build the      number in reverse.  */
for|for
control|(
name|i
operator|=
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
name|generic_bignum
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARS_PER_LITTLENUM
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'\''
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|generic_bignum
index|[
name|i
index|]
operator|<<=
literal|8
expr_stmt|;
name|generic_bignum
index|[
name|i
index|]
operator|+=
operator|*
name|input_line_pointer
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
condition|)
block|{
comment|/* If there is more than one littlenum, left justify the              last one to make it match the earlier ones.  If there is              only one, we can just use the value directly.  */
for|for
control|(
init|;
name|j
operator|<
name|CHARS_PER_LITTLENUM
condition|;
name|j
operator|++
control|)
name|generic_bignum
index|[
name|i
index|]
operator|<<=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'\''
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"character constant too large"
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|j
decl_stmt|;
name|c
operator|=
name|SIZE_OF_LARGE_NUMBER
operator|-
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c
condition|;
name|j
operator|++
control|)
name|generic_bignum
index|[
name|j
index|]
operator|=
name|generic_bignum
index|[
name|i
operator|+
name|j
index|]
expr_stmt|;
name|i
operator|=
name|c
expr_stmt|;
block|}
name|know
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|==
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_big
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
name|expressionP
operator|->
name|X_add_number
operator|=
name|generic_bignum
index|[
literal|0
index|]
operator|&
name|LITTLENUM_MASK
expr_stmt|;
else|else
name|expressionP
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|generic_bignum
index|[
literal|1
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator||
operator|(
name|generic_bignum
index|[
literal|0
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Skip the final closing quote.  */
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an expression representing the current location.  This    handles the magic symbol `.'.  */
end_comment

begin_function
specifier|static
name|void
name|current_location
parameter_list|(
name|expressionp
parameter_list|)
name|expressionS
modifier|*
name|expressionp
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|expressionp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionp
operator|->
name|X_add_number
operator|=
name|abs_section_offset
expr_stmt|;
block|}
else|else
block|{
name|symbolS
modifier|*
name|symbolp
decl_stmt|;
name|symbolp
operator|=
name|symbol_new
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|expressionp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionp
operator|->
name|X_add_symbol
operator|=
name|symbolp
expr_stmt|;
name|expressionp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* In:	Input_line_pointer points to 1st char of operand, which may 	be a space.     Out:	An expressionS. 	The operand may have been empty: in this case X_op == O_absent. 	Input_line_pointer->(next non-blank) char after operand.  */
end_comment

begin_function
specifier|static
name|segT
name|operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Points to symbol.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Points to name of symbol.  */
name|segT
name|segment
decl_stmt|;
comment|/* All integers are regarded as unsigned unless they are negated.      This is because the only thing which cares whether a number is      unsigned is the code in emit_expr which extends constants into      bignums.  It should only sign extend negative numbers, so that      something like ``.quad 0x80000000'' is not sign extended even      though it appears negative if valueT is 32 bits.  */
name|expressionP
operator|->
name|X_unsigned
operator|=
literal|1
expr_stmt|;
comment|/* Digits, assume it is a bignum.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Leading whitespace is part of operand.  */
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* input_line_pointer -> past char in c.  */
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
condition|)
goto|goto
name|eol
goto|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|input_line_pointer
operator|--
expr_stmt|;
name|integer_constant
argument_list|(
operator|(
name|NUMBERS_WITH_SUFFIX
operator|||
name|flag_m68k_mri
operator|)
condition|?
literal|0
else|:
literal|10
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LITERAL_PREFIXDOLLAR_HEX
case|case
literal|'$'
case|:
comment|/* $L is the start of a local label, not a hex constant.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'L'
condition|)
goto|goto
name|isname
goto|;
name|integer_constant
argument_list|(
literal|16
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LITERAL_PREFIXPERCENT_BIN
case|case
literal|'%'
case|:
name|integer_constant
argument_list|(
literal|2
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'0'
case|:
comment|/* Non-decimal radix.  */
if|if
condition|(
name|NUMBERS_WITH_SUFFIX
operator|||
name|flag_m68k_mri
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Check for a hex constant.  */
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
name|hex_p
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'h'
operator|||
operator|*
name|s
operator|==
literal|'H'
condition|)
block|{
operator|--
name|input_line_pointer
expr_stmt|;
name|integer_constant
argument_list|(
literal|0
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|NUMBERS_WITH_SUFFIX
operator|||
name|flag_m68k_mri
condition|)
block|{
name|integer_constant
argument_list|(
literal|0
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
default|default:
name|default_case
label|:
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|FLT_CHARS
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|floating_constant
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The string was only zero.  */
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
name|flag_m68k_mri
condition|)
goto|goto
name|default_case
goto|;
name|input_line_pointer
operator|++
expr_stmt|;
name|integer_constant
argument_list|(
literal|16
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
operator|!
operator|(
name|flag_m68k_mri
operator|||
name|NUMBERS_WITH_SUFFIX
operator|)
condition|)
block|{
comment|/* This code used to check for '+' and '-' here, and, in 		 some conditions, fall through to call 		 integer_constant.  However, that didn't make sense, 		 as integer_constant only accepts digits.  */
comment|/* Some of our code elsewhere does permit digits greater 		 than the expected base; for consistency, do the same 		 here.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|>
literal|'9'
condition|)
block|{
comment|/* Parse this as a back reference to label 0.  */
name|input_line_pointer
operator|--
expr_stmt|;
name|integer_constant
argument_list|(
literal|10
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Otherwise, parse this as a binary number.  */
block|}
comment|/* Fall through.  */
case|case
literal|'B'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|flag_m68k_mri
operator|||
name|NUMBERS_WITH_SUFFIX
condition|)
goto|goto
name|default_case
goto|;
name|integer_constant
argument_list|(
literal|2
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|integer_constant
argument_list|(
operator|(
name|flag_m68k_mri
operator|||
name|NUMBERS_WITH_SUFFIX
operator|)
condition|?
literal|0
else|:
literal|8
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|LOCAL_LABELS_FB
condition|)
block|{
comment|/* If it says "0f" and it could possibly be a floating point 		 number, make it one.  Otherwise, make it a local label, 		 and try to deal with parsing the rest later.  */
if|if
condition|(
operator|!
name|input_line_pointer
index|[
literal|1
index|]
operator|||
operator|(
name|is_end_of_line
index|[
literal|0xff
operator|&
name|input_line_pointer
index|[
literal|1
index|]
index|]
operator|)
operator|||
name|strchr
argument_list|(
name|FLT_CHARS
argument_list|,
literal|'f'
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|is_0f_label
goto|;
block|{
name|char
modifier|*
name|cp
init|=
name|input_line_pointer
operator|+
literal|1
decl_stmt|;
name|int
name|r
init|=
name|atof_generic
argument_list|(
operator|&
name|cp
argument_list|,
literal|"."
argument_list|,
name|EXP_CHARS
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
case|case
name|ERROR_EXPONENT_OVERFLOW
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|'f'
operator|||
operator|*
name|cp
operator|==
literal|'b'
condition|)
comment|/* Looks like a difference expression.  */
goto|goto
name|is_0f_label
goto|;
elseif|else
if|if
condition|(
name|cp
operator|==
name|input_line_pointer
operator|+
literal|1
condition|)
comment|/* No characters has been accepted -- looks like 			 end of operand.  */
goto|goto
name|is_0f_label
goto|;
else|else
goto|goto
name|is_0f_float
goto|;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"expr.c(operand): bad atof_generic return val %d"
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Okay, now we've sorted it out.  We resume at one of these 		 two labels, depending on what we've decided we're probably 		 looking at.  */
name|is_0f_label
label|:
name|input_line_pointer
operator|--
expr_stmt|;
name|integer_constant
argument_list|(
literal|10
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
name|is_0f_float
label|:
comment|/* Fall through.  */
empty_stmt|;
block|}
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
if|if
condition|(
name|flag_m68k_mri
operator|||
name|NUMBERS_WITH_SUFFIX
condition|)
block|{
name|integer_constant
argument_list|(
literal|0
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
literal|'F'
case|:
case|case
literal|'r'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
name|floating_constant
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|LOCAL_LABELS_DOLLAR
condition|)
block|{
name|integer_constant
argument_list|(
literal|10
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|default_case
goto|;
block|}
break|break;
case|case
literal|'('
case|:
ifndef|#
directive|ifndef
name|NEED_INDEX_OPERATOR
case|case
literal|'['
case|:
endif|#
directive|endif
comment|/* Didn't begin with digit& not a name.  */
name|segment
operator|=
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
comment|/* expression () will pass trailing whitespace.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|'('
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|')'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'['
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|']'
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RELAX_PAREN_GROUPING
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
endif|#
directive|endif
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing '%c'"
argument_list|)
argument_list|,
name|c
operator|==
literal|'('
condition|?
literal|')'
else|:
literal|']'
argument_list|)
expr_stmt|;
block|}
else|else
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Here with input_line_pointer -> char after "(...)".  */
return|return
name|segment
return|;
ifdef|#
directive|ifdef
name|TC_M68K
case|case
literal|'E'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|'\''
condition|)
goto|goto
name|de_fault
goto|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"EBCDIC constants are not supported"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'A'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|'\''
condition|)
goto|goto
name|de_fault
goto|;
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Fall through.  */
endif|#
directive|endif
case|case
literal|'\''
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
block|{
comment|/* Warning: to conform to other people's assemblers NO 	     ESCAPEMENT is permitted for a single quote.  The next 	     character, parity errors and all, is taken as the value 	     of the operand.  VERY KINKY.  */
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
block|}
name|mri_char_constant
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
operator|(
name|void
operator|)
name|operand
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TC_M68K
case|case
literal|'"'
case|:
comment|/* Double quote is the bitwise not operator in MRI mode.  */
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
comment|/* Fall through.  */
endif|#
directive|endif
case|case
literal|'~'
case|:
comment|/* '~' is permitted to start a label on the Delta.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|isname
goto|;
case|case
literal|'!'
case|:
case|case
literal|'-'
case|:
block|{
name|operand
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* input_line_pointer -> char after operand.  */
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
name|expressionP
operator|->
name|X_add_number
expr_stmt|;
comment|/* Notice: '-' may overflow: no warning is given. 		   This is compatible with other people's 		   assemblers.  Sigh.  */
name|expressionP
operator|->
name|X_unsigned
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'"'
condition|)
name|expressionP
operator|->
name|X_add_number
operator|=
operator|~
name|expressionP
operator|->
name|X_add_number
expr_stmt|;
else|else
name|expressionP
operator|->
name|X_add_number
operator|=
operator|!
name|expressionP
operator|->
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|!=
name|O_illegal
operator|&&
name|expressionP
operator|->
name|X_op
operator|!=
name|O_absent
condition|)
block|{
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|expressionP
operator|->
name|X_op
operator|=
name|O_uminus
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'"'
condition|)
name|expressionP
operator|->
name|X_op
operator|=
name|O_bit_not
expr_stmt|;
else|else
name|expressionP
operator|->
name|X_op
operator|=
name|O_logical_not
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Unary operator %c ignored because bad operand follows"
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|DOLLAR_DOT
argument_list|)
operator|||
name|defined
argument_list|(
name|TC_M68K
argument_list|)
case|case
literal|'$'
case|:
comment|/* '$' is the program counter when in MRI mode, or when          DOLLAR_DOT is defined.  */
ifndef|#
directive|ifndef
name|DOLLAR_DOT
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
endif|#
directive|endif
if|if
condition|(
name|flag_m68k_mri
operator|&&
name|hex_p
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
comment|/* In MRI mode, '$' is also used as the prefix for a              hexadecimal constant.  */
name|integer_constant
argument_list|(
literal|16
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
goto|goto
name|isname
goto|;
name|current_location
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'.'
case|:
if|if
condition|(
operator|!
name|is_part_of_name
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|current_location
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"startof."
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
literal|8
index|]
argument_list|)
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"sizeof."
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
literal|7
index|]
argument_list|)
operator|)
condition|)
block|{
name|int
name|start
decl_stmt|;
name|start
operator|=
operator|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'t'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'T'
operator|)
expr_stmt|;
name|input_line_pointer
operator|+=
name|start
condition|?
literal|8
else|:
literal|7
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'('
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error in .startof. or .sizeof."
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|buf
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".startof.%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".sizeof.%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_make
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|')'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error in .startof. or .sizeof."
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|++
name|input_line_pointer
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
goto|goto
name|isname
goto|;
block|}
case|case
literal|','
case|:
name|eol
label|:
comment|/* Can't imagine any other kind of operand.  */
name|expressionP
operator|->
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TC_M68K
case|case
literal|'%'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
name|integer_constant
argument_list|(
literal|2
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
name|integer_constant
argument_list|(
literal|8
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
comment|/* In MRI mode, this is a floating point constant represented          using hexadecimal digits.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|integer_constant
argument_list|(
literal|16
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
operator|||
name|is_part_of_name
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
goto|goto
name|de_fault
goto|;
name|current_location
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
ifdef|#
directive|ifdef
name|TC_M68K
name|de_fault
label|:
endif|#
directive|endif
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
argument_list|)
condition|)
comment|/* Here if did not begin with a digit.  */
block|{
comment|/* Identifier begins here. 	     This is kludged for speed, so code is repeated.  */
name|isname
label|:
name|name
operator|=
operator|--
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_parse_name
comment|/* This is a hook for the backend to parse certain names              specially in certain contexts.  If a name always has a              specific value, it can often be handled by simply              entering it in the symbol table.  */
if|if
condition|(
name|md_parse_name
argument_list|(
name|name
argument_list|,
name|expressionP
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_I960
comment|/* The MRI i960 assembler permits 	         lda sizeof code,g13 	     FIXME: This should use md_parse_name.  */
if|if
condition|(
name|flag_mri
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"sizeof"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"startof"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|start
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|start
operator|=
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
operator|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".startof.%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".sizeof.%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_make
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* If we have an absolute symbol or a reg, then we know its 	     value now.  */
name|segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|==
name|absolute_section
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|segment
operator|==
name|reg_section
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
comment|/* Let the target try to parse it.  Success is indicated by changing 	     the X_op field to something other than O_absent and pointing 	     input_line_pointer past the expression.  If it can't parse the 	     expression, X_op and input_line_pointer should be unchanged.  */
name|expressionP
operator|->
name|X_op
operator|=
name|O_absent
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|md_operand
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad expression"
argument_list|)
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* It is more 'efficient' to clean up the expressionS when they are      created.  Doing it here saves lines of code.  */
name|clean_up_expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* -> 1st char after operand.  */
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|!=
literal|' '
argument_list|)
expr_stmt|;
comment|/* The PA port needs this information.  */
if|if
condition|(
name|expressionP
operator|->
name|X_add_symbol
condition|)
name|symbol_mark_used
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|expressionP
operator|->
name|X_op
condition|)
block|{
default|default:
return|return
name|absolute_section
return|;
case|case
name|O_symbol
case|:
return|return
name|S_GET_SEGMENT
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
return|;
case|case
name|O_register
case|:
return|return
name|reg_section
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Internal.  Simplify a struct expression for use by expr ().  */
end_comment

begin_comment
comment|/* In:	address of an expressionS. 	The X_op field of the expressionS may only take certain values. 	Elsewise we waste time special-case testing. Sigh. Ditto SEG_ABSENT.     Out:	expressionS may have been modified: 	'foo-foo' symbol references cancelled to 0, which changes X_op 	from O_subtract to O_constant. 	Unused fields zeroed to help expr ().  */
end_comment

begin_function
specifier|static
name|void
name|clean_up_expression
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
switch|switch
condition|(
name|expressionP
operator|->
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
case|case
name|O_absent
case|:
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_big
case|:
case|case
name|O_constant
case|:
case|case
name|O_register
case|:
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_symbol
case|:
case|case
name|O_uminus
case|:
case|case
name|O_bit_not
case|:
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|O_subtract
case|:
if|if
condition|(
name|expressionP
operator|->
name|X_op_symbol
operator|==
name|expressionP
operator|->
name|X_add_symbol
operator|||
operator|(
operator|(
name|symbol_get_frag
argument_list|(
name|expressionP
operator|->
name|X_op_symbol
argument_list|)
operator|==
name|symbol_get_frag
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
operator|)
operator|&&
name|SEG_NORMAL
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
argument_list|)
operator|&&
operator|(
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_op_symbol
argument_list|)
operator|==
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
operator|)
operator|)
condition|)
block|{
name|addressT
name|diff
init|=
operator|(
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_op_symbol
argument_list|)
operator|)
decl_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|+=
name|diff
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expression parser.  */
end_comment

begin_comment
comment|/* We allow an empty expression, and just assume (absolute,0) silently.    Unary operators and parenthetical expressions are treated as operands.    As usual, Q==quantity==operand, O==operator, X==expression mnemonics.     We used to do an aho/ullman shift-reduce parser, but the logic got so    warped that I flushed it and wrote a recursive-descent parser instead.    Now things are stable, would anybody like to write a fast parser?    Most expressions are either register (which does not even reach here)    or 1 symbol. Then "symbol+constant" and "symbol-symbol" are common.    So I guess it doesn't really matter how inefficient more complex expressions    are parsed.     After expr(RANK,resultP) input_line_pointer->operator of rank<= RANK.    Also, we have consumed any leading or trailing spaces (operand does that)    and done all intervening operators.     This returns the segment of the result, which will be    absolute_section or the segment of a symbol.  */
end_comment

begin_undef
undef|#
directive|undef
name|__
end_undef

begin_define
define|#
directive|define
name|__
value|O_illegal
end_define

begin_comment
comment|/* Maps ASCII -> operators.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|operatorT
name|op_encoding
index|[
literal|256
index|]
init|=
block|{
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_bit_or_not
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_modulus
block|,
name|O_bit_and
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_multiply
block|,
name|O_add
block|,
name|__
block|,
name|O_subtract
block|,
name|__
block|,
name|O_divide
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_lt
block|,
name|__
block|,
name|O_gt
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
ifdef|#
directive|ifdef
name|NEED_INDEX_OPERATOR
name|O_index
block|,
else|#
directive|else
name|__
block|,
endif|#
directive|endif
name|__
block|,
name|__
block|,
name|O_bit_exclusive_or
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_bit_inclusive_or
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Rank	Examples    0	operand, (expression)    1	||    2&&    3	==<><<=>=>    4	+ -    5	used for * / % in MRI mode    6& ^ ! |    7	* / %<<>>    8	unary - unary ~ */
end_comment

begin_decl_stmt
specifier|static
name|operator_rankT
name|op_rank
index|[]
init|=
block|{
literal|0
block|,
comment|/* O_illegal */
literal|0
block|,
comment|/* O_absent */
literal|0
block|,
comment|/* O_constant */
literal|0
block|,
comment|/* O_symbol */
literal|0
block|,
comment|/* O_symbol_rva */
literal|0
block|,
comment|/* O_register */
literal|0
block|,
comment|/* O_big */
literal|9
block|,
comment|/* O_uminus */
literal|9
block|,
comment|/* O_bit_not */
literal|9
block|,
comment|/* O_logical_not */
literal|8
block|,
comment|/* O_multiply */
literal|8
block|,
comment|/* O_divide */
literal|8
block|,
comment|/* O_modulus */
literal|8
block|,
comment|/* O_left_shift */
literal|8
block|,
comment|/* O_right_shift */
literal|7
block|,
comment|/* O_bit_inclusive_or */
literal|7
block|,
comment|/* O_bit_or_not */
literal|7
block|,
comment|/* O_bit_exclusive_or */
literal|7
block|,
comment|/* O_bit_and */
literal|5
block|,
comment|/* O_add */
literal|5
block|,
comment|/* O_subtract */
literal|4
block|,
comment|/* O_eq */
literal|4
block|,
comment|/* O_ne */
literal|4
block|,
comment|/* O_lt */
literal|4
block|,
comment|/* O_le */
literal|4
block|,
comment|/* O_ge */
literal|4
block|,
comment|/* O_gt */
literal|3
block|,
comment|/* O_logical_and */
literal|2
block|,
comment|/* O_logical_or */
literal|1
block|,
comment|/* O_index */
literal|0
block|,
comment|/* O_md1 */
literal|0
block|,
comment|/* O_md2 */
literal|0
block|,
comment|/* O_md3 */
literal|0
block|,
comment|/* O_md4 */
literal|0
block|,
comment|/* O_md5 */
literal|0
block|,
comment|/* O_md6 */
literal|0
block|,
comment|/* O_md7 */
literal|0
block|,
comment|/* O_md8 */
literal|0
block|,
comment|/* O_md9 */
literal|0
block|,
comment|/* O_md10 */
literal|0
block|,
comment|/* O_md11 */
literal|0
block|,
comment|/* O_md12 */
literal|0
block|,
comment|/* O_md13 */
literal|0
block|,
comment|/* O_md14 */
literal|0
block|,
comment|/* O_md15 */
literal|0
block|,
comment|/* O_md16 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unfortunately, in MRI mode for the m68k, multiplication and    division have lower precedence than the bit wise operators.  This    function sets the operator precedences correctly for the current    mode.  Also, MRI uses a different bit_not operator, and this fixes    that as well.  */
end_comment

begin_define
define|#
directive|define
name|STANDARD_MUL_PRECEDENCE
value|8
end_define

begin_define
define|#
directive|define
name|MRI_MUL_PRECEDENCE
value|6
end_define

begin_function
name|void
name|expr_set_precedence
parameter_list|()
block|{
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|op_rank
index|[
name|O_multiply
index|]
operator|=
name|MRI_MUL_PRECEDENCE
expr_stmt|;
name|op_rank
index|[
name|O_divide
index|]
operator|=
name|MRI_MUL_PRECEDENCE
expr_stmt|;
name|op_rank
index|[
name|O_modulus
index|]
operator|=
name|MRI_MUL_PRECEDENCE
expr_stmt|;
block|}
else|else
block|{
name|op_rank
index|[
name|O_multiply
index|]
operator|=
name|STANDARD_MUL_PRECEDENCE
expr_stmt|;
name|op_rank
index|[
name|O_divide
index|]
operator|=
name|STANDARD_MUL_PRECEDENCE
expr_stmt|;
name|op_rank
index|[
name|O_modulus
index|]
operator|=
name|STANDARD_MUL_PRECEDENCE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the expression parser.  */
end_comment

begin_function
name|void
name|expr_begin
parameter_list|()
block|{
name|expr_set_precedence
argument_list|()
expr_stmt|;
comment|/* Verify that X_op field is wide enough.  */
block|{
name|expressionS
name|e
decl_stmt|;
name|e
operator|.
name|X_op
operator|=
name|O_max
expr_stmt|;
name|assert
argument_list|(
name|e
operator|.
name|X_op
operator|==
name|O_max
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the encoding for the operator at INPUT_LINE_POINTER, and    sets NUM_CHARS to the number of characters in the operator.    Does not advance INPUT_LINE_POINTER.  */
end_comment

begin_function
specifier|static
specifier|inline
name|operatorT
name|operator
parameter_list|(
name|num_chars
parameter_list|)
name|int
modifier|*
name|num_chars
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|operatorT
name|ret
decl_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|&
literal|0xff
expr_stmt|;
operator|*
name|num_chars
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
name|c
index|]
condition|)
return|return
name|O_illegal
return|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
name|op_encoding
index|[
name|c
index|]
return|;
case|case
literal|'<'
case|:
switch|switch
condition|(
name|input_line_pointer
index|[
literal|1
index|]
condition|)
block|{
default|default:
return|return
name|op_encoding
index|[
name|c
index|]
return|;
case|case
literal|'<'
case|:
name|ret
operator|=
name|O_left_shift
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|ret
operator|=
name|O_ne
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ret
operator|=
name|O_le
expr_stmt|;
break|break;
block|}
operator|*
name|num_chars
operator|=
literal|2
expr_stmt|;
return|return
name|ret
return|;
case|case
literal|'='
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
return|return
name|op_encoding
index|[
name|c
index|]
return|;
operator|*
name|num_chars
operator|=
literal|2
expr_stmt|;
return|return
name|O_eq
return|;
case|case
literal|'>'
case|:
switch|switch
condition|(
name|input_line_pointer
index|[
literal|1
index|]
condition|)
block|{
default|default:
return|return
name|op_encoding
index|[
name|c
index|]
return|;
case|case
literal|'>'
case|:
name|ret
operator|=
name|O_right_shift
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ret
operator|=
name|O_ge
expr_stmt|;
break|break;
block|}
operator|*
name|num_chars
operator|=
literal|2
expr_stmt|;
return|return
name|ret
return|;
case|case
literal|'!'
case|:
comment|/* We accept !! as equivalent to ^ for MRI compatibility.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'!'
condition|)
block|{
if|if
condition|(
name|flag_m68k_mri
condition|)
return|return
name|O_bit_inclusive_or
return|;
return|return
name|op_encoding
index|[
name|c
index|]
return|;
block|}
operator|*
name|num_chars
operator|=
literal|2
expr_stmt|;
return|return
name|O_bit_exclusive_or
return|;
case|case
literal|'|'
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'|'
condition|)
return|return
name|op_encoding
index|[
name|c
index|]
return|;
operator|*
name|num_chars
operator|=
literal|2
expr_stmt|;
return|return
name|O_logical_or
return|;
case|case
literal|'&'
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'&'
condition|)
return|return
name|op_encoding
index|[
name|c
index|]
return|;
operator|*
name|num_chars
operator|=
literal|2
expr_stmt|;
return|return
name|O_logical_and
return|;
block|}
comment|/* NOTREACHED  */
block|}
end_function

begin_comment
comment|/* Parse an expression.  */
end_comment

begin_function
name|segT
name|expr
parameter_list|(
name|rankarg
parameter_list|,
name|resultP
parameter_list|)
name|int
name|rankarg
decl_stmt|;
comment|/* Larger # is higher rank.  */
name|expressionS
modifier|*
name|resultP
decl_stmt|;
comment|/* Deliver result here.  */
block|{
name|operator_rankT
name|rank
init|=
operator|(
name|operator_rankT
operator|)
name|rankarg
decl_stmt|;
name|segT
name|retval
decl_stmt|;
name|expressionS
name|right
decl_stmt|;
name|operatorT
name|op_left
decl_stmt|;
name|operatorT
name|op_right
decl_stmt|;
name|int
name|op_chars
decl_stmt|;
name|know
argument_list|(
name|rank
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|operand
argument_list|(
name|resultP
argument_list|)
expr_stmt|;
comment|/* operand () gobbles spaces.  */
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|!=
literal|' '
argument_list|)
expr_stmt|;
name|op_left
operator|=
name|operator
argument_list|(
operator|&
name|op_chars
argument_list|)
expr_stmt|;
while|while
condition|(
name|op_left
operator|!=
name|O_illegal
operator|&&
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_left
index|]
operator|>
name|rank
condition|)
block|{
name|segT
name|rightseg
decl_stmt|;
name|input_line_pointer
operator|+=
name|op_chars
expr_stmt|;
comment|/* -> after operator.  */
name|rightseg
operator|=
name|expr
argument_list|(
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_left
index|]
argument_list|,
operator|&
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing operand; zero assumed"
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|right
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|right
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|right
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|!=
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_left
operator|==
name|O_index
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|']'
condition|)
name|as_bad
argument_list|(
literal|"missing right bracket"
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
block|}
name|op_right
operator|=
name|operator
argument_list|(
operator|&
name|op_chars
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|op_right
operator|==
name|O_illegal
operator|||
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_right
index|]
operator|<=
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_left
index|]
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|int
operator|)
name|op_left
operator|>=
operator|(
name|int
operator|)
name|O_multiply
operator|&&
operator|(
name|int
operator|)
name|op_left
operator|<=
operator|(
name|int
operator|)
name|O_logical_or
argument_list|)
expr_stmt|;
comment|/* input_line_pointer->after right-hand quantity.  */
comment|/* left-hand quantity in resultP.  */
comment|/* right-hand quantity in right.  */
comment|/* operator in op_left.  */
if|if
condition|(
name|resultP
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|resultP
operator|->
name|X_add_number
operator|>
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"left operand is a bignum; integer 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"left operand is a float; integer 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|resultP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|resultP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|right
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|right
operator|.
name|X_add_number
operator|>
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"right operand is a bignum; integer 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"right operand is a float; integer 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|right
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|right
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|right
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Optimize common cases.  */
ifdef|#
directive|ifdef
name|md_optimize_expr
if|if
condition|(
name|md_optimize_expr
argument_list|(
name|resultP
argument_list|,
name|op_left
argument_list|,
operator|&
name|right
argument_list|)
condition|)
block|{
comment|/* Skip.  */
empty_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|op_left
operator|==
name|O_add
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* X + constant.  */
name|resultP
operator|->
name|X_add_number
operator|+=
name|right
operator|.
name|X_add_number
expr_stmt|;
block|}
comment|/* This case comes up in PIC code.  */
elseif|else
if|if
condition|(
name|op_left
operator|==
name|O_subtract
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|resultP
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
name|symbol_get_frag
argument_list|(
name|right
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|symbol_get_frag
argument_list|(
name|resultP
operator|->
name|X_add_symbol
argument_list|)
operator|)
operator|&&
name|SEG_NORMAL
argument_list|(
name|rightseg
argument_list|)
condition|)
block|{
name|resultP
operator|->
name|X_add_number
operator|-=
name|right
operator|.
name|X_add_number
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|+=
operator|(
name|S_GET_VALUE
argument_list|(
name|resultP
operator|->
name|X_add_symbol
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|right
operator|.
name|X_add_symbol
argument_list|)
operator|)
expr_stmt|;
name|resultP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|resultP
operator|->
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_left
operator|==
name|O_subtract
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* X - constant.  */
name|resultP
operator|->
name|X_add_number
operator|-=
name|right
operator|.
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_left
operator|==
name|O_add
operator|&&
name|resultP
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Constant + X.  */
name|resultP
operator|->
name|X_op
operator|=
name|right
operator|.
name|X_op
expr_stmt|;
name|resultP
operator|->
name|X_add_symbol
operator|=
name|right
operator|.
name|X_add_symbol
expr_stmt|;
name|resultP
operator|->
name|X_op_symbol
operator|=
name|right
operator|.
name|X_op_symbol
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|+=
name|right
operator|.
name|X_add_number
expr_stmt|;
name|retval
operator|=
name|rightseg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultP
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Constant OP constant.  */
name|offsetT
name|v
init|=
name|right
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
operator|&&
operator|(
name|op_left
operator|==
name|O_divide
operator|||
name|op_left
operator|==
name|O_modulus
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"division by zero"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|op_left
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|O_multiply
case|:
name|resultP
operator|->
name|X_add_number
operator|*=
name|v
expr_stmt|;
break|break;
case|case
name|O_divide
case|:
name|resultP
operator|->
name|X_add_number
operator|/=
name|v
expr_stmt|;
break|break;
case|case
name|O_modulus
case|:
name|resultP
operator|->
name|X_add_number
operator|%=
name|v
expr_stmt|;
break|break;
case|case
name|O_left_shift
case|:
name|resultP
operator|->
name|X_add_number
operator|<<=
name|v
expr_stmt|;
break|break;
case|case
name|O_right_shift
case|:
comment|/* We always use unsigned shifts, to avoid relying on                  characteristics of the compiler used to compile gas.  */
name|resultP
operator|->
name|X_add_number
operator|=
call|(
name|offsetT
call|)
argument_list|(
operator|(
name|valueT
operator|)
name|resultP
operator|->
name|X_add_number
operator|>>
operator|(
name|valueT
operator|)
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_bit_inclusive_or
case|:
name|resultP
operator|->
name|X_add_number
operator||=
name|v
expr_stmt|;
break|break;
case|case
name|O_bit_or_not
case|:
name|resultP
operator|->
name|X_add_number
operator||=
operator|~
name|v
expr_stmt|;
break|break;
case|case
name|O_bit_exclusive_or
case|:
name|resultP
operator|->
name|X_add_number
operator|^=
name|v
expr_stmt|;
break|break;
case|case
name|O_bit_and
case|:
name|resultP
operator|->
name|X_add_number
operator|&=
name|v
expr_stmt|;
break|break;
case|case
name|O_add
case|:
name|resultP
operator|->
name|X_add_number
operator|+=
name|v
expr_stmt|;
break|break;
case|case
name|O_subtract
case|:
name|resultP
operator|->
name|X_add_number
operator|-=
name|v
expr_stmt|;
break|break;
case|case
name|O_eq
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|==
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_ne
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|!=
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_lt
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|<
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_le
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|<=
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_ge
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|>=
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_gt
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|>
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_logical_and
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|&&
name|v
expr_stmt|;
break|break;
case|case
name|O_logical_or
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|||
name|v
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|resultP
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
name|op_left
operator|==
name|O_add
operator|||
name|op_left
operator|==
name|O_subtract
operator|||
operator|(
name|resultP
operator|->
name|X_add_number
operator|==
literal|0
operator|&&
name|right
operator|.
name|X_add_number
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Symbol OP symbol.  */
name|resultP
operator|->
name|X_op
operator|=
name|op_left
expr_stmt|;
name|resultP
operator|->
name|X_op_symbol
operator|=
name|right
operator|.
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|op_left
operator|==
name|O_add
condition|)
name|resultP
operator|->
name|X_add_number
operator|+=
name|right
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|op_left
operator|==
name|O_subtract
condition|)
block|{
name|resultP
operator|->
name|X_add_number
operator|-=
name|right
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|rightseg
operator|&&
name|SEG_NORMAL
argument_list|(
name|retval
argument_list|)
condition|)
block|{
name|retval
operator|=
name|absolute_section
expr_stmt|;
name|rightseg
operator|=
name|absolute_section
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* The general case.  */
name|resultP
operator|->
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
name|resultP
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_op_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|right
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_op
operator|=
name|op_left
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|resultP
operator|->
name|X_unsigned
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|rightseg
condition|)
block|{
if|if
condition|(
operator|!
name|SEG_NORMAL
argument_list|(
name|retval
argument_list|)
condition|)
block|{
if|if
condition|(
name|retval
operator|!=
name|undefined_section
operator|||
name|SEG_NORMAL
argument_list|(
name|rightseg
argument_list|)
condition|)
name|retval
operator|=
name|rightseg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SEG_NORMAL
argument_list|(
name|rightseg
argument_list|)
ifdef|#
directive|ifdef
name|DIFF_EXPR_OK
operator|&&
name|op_left
operator|!=
name|O_subtract
endif|#
directive|endif
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operation combines symbols in different segments"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|op_left
operator|=
name|op_right
expr_stmt|;
block|}
comment|/* While next operator is>= this rank.  */
comment|/* The PA port needs this information.  */
if|if
condition|(
name|resultP
operator|->
name|X_add_symbol
condition|)
name|symbol_mark_used
argument_list|(
name|resultP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
return|return
name|resultP
operator|->
name|X_op
operator|==
name|O_constant
condition|?
name|absolute_section
else|:
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This lives here because it belongs equally in expr.c& read.c.    expr.c is just a branch office read.c anyway, and putting it    here lessens the crowd at read.c.     Assume input_line_pointer is at start of symbol name.    Advance input_line_pointer past symbol name.    Turn that character into a '\0', returning its former value.    This allows a string compare (RMS wants symbol names to be strings)    of the symbol name.    There will always be a char following symbol name, because all good    lines end in end-of-line.  */
end_comment

begin_function
name|char
name|get_symbol_end
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
comment|/* We accept \001 in a name in case this is being called with a      constructed string.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
argument_list|)
operator|||
name|c
operator|==
literal|'\001'
condition|)
block|{
while|while
condition|(
name|is_part_of_name
argument_list|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
argument_list|)
operator|||
name|c
operator|==
literal|'\001'
condition|)
empty_stmt|;
if|if
condition|(
name|is_name_ender
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
operator|*
operator|--
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|get_single_number
parameter_list|()
block|{
name|expressionS
name|exp
decl_stmt|;
name|operand
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
operator|.
name|X_add_number
return|;
block|}
end_function

end_unit

