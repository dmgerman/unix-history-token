begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* expr.c -operands, expressions-    Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1997    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA. */
end_comment

begin_comment
comment|/*  * This is really a branch office of as-read.c. I split it out to clearly  * distinguish the world of expressions from the world of statements.  * (It also gives smaller files to re-compile.)  * Here, "operand"s are of expressions, not instructions.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|floating_constant
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|integer_constant
name|PARAMS
argument_list|(
operator|(
name|int
name|radix
operator|,
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mri_char_constant
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|current_location
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clean_up_expression
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|operand
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|operatorT
name|operator
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|EXP_CHARS
index|[]
decl_stmt|,
name|FLT_CHARS
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We keep a mapping of expression symbols to file positions, so that    we can provide better error messages.  */
end_comment

begin_struct
struct|struct
name|expr_symbol_line
block|{
name|struct
name|expr_symbol_line
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|expr_symbol_line
modifier|*
name|expr_symbol_lines
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Build a dummy symbol to hold a complex expression.  This is how we    build expressions up out of other expressions.  The symbol is put    into the fake section expr_section.  */
end_comment

begin_function
name|symbolS
modifier|*
name|make_expr_symbol
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fake
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|struct
name|expr_symbol_line
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|expressionP
operator|->
name|X_add_number
operator|==
literal|0
condition|)
return|return
name|expressionP
operator|->
name|X_add_symbol
return|;
name|fake
operator|=
name|FAKE_LABEL_NAME
expr_stmt|;
comment|/* Putting constant symbols in absolute_section rather than      expr_section is convenient for the old a.out code, for which      S_GET_SEGMENT does not always retrieve the value put in by      S_SET_SEGMENT.  */
name|symbolP
operator|=
name|symbol_create
argument_list|(
name|fake
argument_list|,
operator|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_constant
condition|?
name|absolute_section
else|:
name|expr_section
operator|)
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|=
operator|*
name|expressionP
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_constant
condition|)
name|resolve_symbol_value
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|expr_symbol_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|sym
operator|=
name|symbolP
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|n
operator|->
name|file
argument_list|,
operator|&
name|n
operator|->
name|line
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|expr_symbol_lines
expr_stmt|;
name|expr_symbol_lines
operator|=
name|n
expr_stmt|;
return|return
name|symbolP
return|;
block|}
end_function

begin_comment
comment|/* Return the file and line number for an expr symbol.  Return    non-zero if something was found, 0 if no information is known for    the symbol.  */
end_comment

begin_function
name|int
name|expr_symbol_where
parameter_list|(
name|sym
parameter_list|,
name|pfile
parameter_list|,
name|pline
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pline
decl_stmt|;
block|{
specifier|register
name|struct
name|expr_symbol_line
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|expr_symbol_lines
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|sym
operator|==
name|sym
condition|)
block|{
operator|*
name|pfile
operator|=
name|l
operator|->
name|file
expr_stmt|;
operator|*
name|pline
operator|=
name|l
operator|->
name|line
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Build any floating-point literal here.  * Also build any bignum literal here.  */
end_comment

begin_comment
comment|/* Seems atof_machine can backscan through generic_bignum and hit whatever    happens to be loaded before it in memory.  And its way too complicated    for me to fix right.  Thus a hack.  JF:  Just make generic_bignum bigger,    and never write into the early words, thus they'll always be zero.    I hate Dean's floating-point code.  Bleh.  */
end_comment

begin_decl_stmt
name|LITTLENUM_TYPE
name|generic_bignum
index|[
name|SIZE_OF_LARGE_NUMBER
operator|+
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FLONUM_TYPE
name|generic_floating_point_number
init|=
block|{
operator|&
name|generic_bignum
index|[
literal|6
index|]
block|,
comment|/* low (JF: Was 0) */
operator|&
name|generic_bignum
index|[
name|SIZE_OF_LARGE_NUMBER
operator|+
literal|6
operator|-
literal|1
index|]
block|,
comment|/* high JF: (added +6) */
literal|0
block|,
comment|/* leader */
literal|0
block|,
comment|/* exponent */
literal|0
comment|/* sign */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, we've been asked to assemble nan, +inf or -inf */
end_comment

begin_decl_stmt
name|int
name|generic_floating_point_magic
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|floating_constant
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
comment|/* input_line_pointer->*/
comment|/* floating-point constant. */
name|int
name|error_code
decl_stmt|;
name|error_code
operator|=
name|atof_generic
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
literal|"."
argument_list|,
name|EXP_CHARS
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
condition|)
block|{
if|if
condition|(
name|error_code
operator|==
name|ERROR_EXPONENT_OVERFLOW
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad floating-point constant: exponent overflow, probably assembling junk"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"bad floating-point constant: unknown error code=%d."
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
block|}
block|}
name|expressionP
operator|->
name|X_op
operator|=
name|O_big
expr_stmt|;
comment|/* input_line_pointer->just after constant, */
comment|/* which may point to whitespace. */
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|integer_constant
parameter_list|(
name|radix
parameter_list|,
name|expressionP
parameter_list|)
name|int
name|radix
decl_stmt|;
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of number. */
name|char
modifier|*
name|suffix
init|=
name|NULL
decl_stmt|;
name|char
name|c
decl_stmt|;
name|valueT
name|number
decl_stmt|;
comment|/* offset or (absolute) value */
name|short
name|int
name|digit
decl_stmt|;
comment|/* value of next digit in current radix */
name|short
name|int
name|maxdig
init|=
literal|0
decl_stmt|;
comment|/* highest permitted digit value. */
name|int
name|too_many_digits
init|=
literal|0
decl_stmt|;
comment|/* if we see>= this number of */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* points to name of symbol */
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* points to symbol */
name|int
name|small
decl_stmt|;
comment|/* true if fits in 32 bits. */
comment|/* May be bignum, or may fit in 32 bits. */
comment|/* Most numbers fit into 32 bits, and we want this case to be fast.      so we pretend it will fit into 32 bits.  If, after making up a 32      bit number, we realise that we have scanned more digits than      comfortably fit into 32 bits, we re-scan the digits coding them      into a bignum.  For decimal and octal numbers we are      conservative: Some numbers may be assumed bignums when in fact      they do fit into 32 bits.  Numbers of any radix can have excess      leading zeros: We strive to recognise this and cast them back      into 32 bits.  We must check that the bignum really is more than      32 bits, and change it back to a 32-bit number if it fits.  The      number we are looking for is expected to be positive, but if it      fits into 32 bits as an unsigned number, we let it be a 32-bit      number.  The cavalier approach is for speed in ordinary cases. */
comment|/* This has been extended for 64 bits.  We blindly assume that if      you're compiling in 64-bit mode, the target is a 64-bit machine.      This should be cleaned up.  */
ifdef|#
directive|ifdef
name|BFD64
define|#
directive|define
name|valuesize
value|64
else|#
directive|else
comment|/* includes non-bfd case, mostly */
define|#
directive|define
name|valuesize
value|32
endif|#
directive|endif
if|if
condition|(
name|flag_m68k_mri
operator|&&
name|radix
operator|==
literal|0
condition|)
block|{
name|int
name|flt
init|=
literal|0
decl_stmt|;
comment|/* In MRI mode, the number may have a suffix indicating the          radix.  For that matter, it might actually be a floating          point constant.  */
for|for
control|(
name|suffix
operator|=
name|input_line_pointer
init|;
name|isalnum
argument_list|(
operator|*
name|suffix
argument_list|)
condition|;
name|suffix
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|suffix
operator|==
literal|'e'
operator|||
operator|*
name|suffix
operator|==
literal|'E'
condition|)
name|flt
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|suffix
operator|==
name|input_line_pointer
condition|)
block|{
name|radix
operator|=
literal|10
expr_stmt|;
name|suffix
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
operator|--
name|suffix
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
name|radix
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'D'
condition|)
name|radix
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'O'
operator|||
name|c
operator|==
literal|'Q'
condition|)
name|radix
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'H'
condition|)
name|radix
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|suffix
index|[
literal|1
index|]
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|flt
condition|)
block|{
name|floating_constant
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|radix
operator|=
literal|10
expr_stmt|;
name|suffix
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|2
case|:
name|maxdig
operator|=
literal|2
expr_stmt|;
name|too_many_digits
operator|=
name|valuesize
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|maxdig
operator|=
name|radix
operator|=
literal|8
expr_stmt|;
name|too_many_digits
operator|=
operator|(
name|valuesize
operator|+
literal|2
operator|)
operator|/
literal|3
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|maxdig
operator|=
name|radix
operator|=
literal|16
expr_stmt|;
name|too_many_digits
operator|=
operator|(
name|valuesize
operator|+
literal|3
operator|)
operator|/
literal|4
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|maxdig
operator|=
name|radix
operator|=
literal|10
expr_stmt|;
name|too_many_digits
operator|=
operator|(
name|valuesize
operator|+
literal|12
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* very rough */
block|}
undef|#
directive|undef
name|valuesize
name|start
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
for|for
control|(
name|number
operator|=
literal|0
init|;
operator|(
name|digit
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
operator|)
operator|<
name|maxdig
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
control|)
block|{
name|number
operator|=
name|number
operator|*
name|radix
operator|+
name|digit
expr_stmt|;
block|}
comment|/* c contains character after number. */
comment|/* input_line_pointer->char after c. */
name|small
operator|=
operator|(
name|input_line_pointer
operator|-
name|start
operator|-
literal|1
operator|)
operator|<
name|too_many_digits
expr_stmt|;
if|if
condition|(
operator|!
name|small
condition|)
block|{
comment|/*        * we saw a lot of digits. manufacture a bignum the hard way.        */
name|LITTLENUM_TYPE
modifier|*
name|leader
decl_stmt|;
comment|/*->high order littlenum of the bignum. */
name|LITTLENUM_TYPE
modifier|*
name|pointer
decl_stmt|;
comment|/*->littlenum we are frobbing now. */
name|long
name|carry
decl_stmt|;
name|leader
operator|=
name|generic_bignum
expr_stmt|;
name|generic_bignum
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|generic_bignum
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|input_line_pointer
operator|=
name|start
expr_stmt|;
comment|/*->1st digit. */
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|(
name|carry
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
operator|)
operator|<
name|maxdig
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
control|)
block|{
for|for
control|(
name|pointer
operator|=
name|generic_bignum
init|;
name|pointer
operator|<=
name|leader
condition|;
name|pointer
operator|++
control|)
block|{
name|long
name|work
decl_stmt|;
name|work
operator|=
name|carry
operator|+
name|radix
operator|*
operator|*
name|pointer
expr_stmt|;
operator|*
name|pointer
operator|=
name|work
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
name|carry
condition|)
block|{
if|if
condition|(
name|leader
operator|<
name|generic_bignum
operator|+
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
condition|)
block|{
comment|/* room to grow a longer bignum. */
operator|*
operator|++
name|leader
operator|=
name|carry
expr_stmt|;
block|}
block|}
block|}
comment|/* again, c is char after number, */
comment|/* input_line_pointer->after c. */
name|know
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|==
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|leader
operator|<
name|generic_bignum
operator|+
literal|2
condition|)
block|{
comment|/* will fit into 32 bits. */
name|number
operator|=
operator|(
operator|(
name|generic_bignum
index|[
literal|1
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator||
operator|(
name|generic_bignum
index|[
literal|0
index|]
operator|&
name|LITTLENUM_MASK
operator|)
expr_stmt|;
name|small
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|number
operator|=
name|leader
operator|-
name|generic_bignum
operator|+
literal|1
expr_stmt|;
comment|/* number of littlenums in the bignum. */
block|}
block|}
if|if
condition|(
name|flag_m68k_mri
operator|&&
name|suffix
operator|!=
name|NULL
operator|&&
name|input_line_pointer
operator|-
literal|1
operator|==
name|suffix
condition|)
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|small
condition|)
block|{
comment|/*        * here with number, in correct radix. c is the next char.        * note that unlike un*x, we allow "011f" "0x9f" to        * both mean the same as the (conventional) "9f". this is simply easier        * than checking for strict canonical form. syntax sux!        */
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
name|c
operator|==
literal|'b'
condition|)
block|{
comment|/* 	   * backward ref to local label. 	   * because it is backward, expect it to be defined. 	   */
comment|/* Construct a local label.  */
name|name
operator|=
name|fb_label_name
argument_list|(
operator|(
name|int
operator|)
name|number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* seen before, or symbol is defined: ok */
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
comment|/* local labels are never absolute. don't waste time 		 checking absoluteness. */
name|know
argument_list|(
name|SEG_NORMAL
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
block|}
else|else
block|{
comment|/* either not seen or not defined. */
comment|/* @@ Should print out the original string instead of 		 the parsed number.  */
name|as_bad
argument_list|(
literal|"backw. ref to unknown label \"%d:\", 0 assumed."
argument_list|,
operator|(
name|int
operator|)
name|number
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
comment|/* case 'b' */
elseif|else
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
name|c
operator|==
literal|'f'
condition|)
block|{
comment|/* 	   * forward reference. expect symbol to be undefined or 	   * unknown. undefined: seen it before. unknown: never seen 	   * it before. 	   * construct a local label name, then an undefined symbol. 	   * don't create a xseg frag for it: caller may do that. 	   * just return it as never seen before. 	   */
name|name
operator|=
name|fb_label_name
argument_list|(
operator|(
name|int
operator|)
name|number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* we have no need to check symbol properties. */
ifndef|#
directive|ifndef
name|many_segments
comment|/* since "know" puts its arg into a "string", we 	     can't have newlines in the argument.  */
name|know
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|undefined_section
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|text_section
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|data_section
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
comment|/* case 'f' */
elseif|else
if|if
condition|(
name|LOCAL_LABELS_DOLLAR
operator|&&
name|c
operator|==
literal|'$'
condition|)
block|{
comment|/* If the dollar label is *currently* defined, then this is just 	     another reference to it.  If it is not *currently* defined, 	     then this is a fresh instantiation of that number, so create 	     it.  */
if|if
condition|(
name|dollar_label_defined
argument_list|(
operator|(
name|long
operator|)
name|number
argument_list|)
condition|)
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
operator|(
name|long
operator|)
name|number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbolP
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
operator|(
name|long
operator|)
name|number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
comment|/* case '$' */
else|else
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_WORD_SIZE
comment|/* Sign extend NUMBER.  */
name|number
operator||=
operator|(
operator|-
operator|(
name|number
operator|>>
operator|(
name|TARGET_WORD_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
operator|<<
operator|(
name|TARGET_WORD_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
name|expressionP
operator|->
name|X_add_number
operator|=
name|number
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* restore following character. */
block|}
comment|/* really just a number */
block|}
else|else
block|{
comment|/* not a small number */
name|expressionP
operator|->
name|X_op
operator|=
name|O_big
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|number
expr_stmt|;
comment|/* number of littlenums */
name|input_line_pointer
operator|--
expr_stmt|;
comment|/*->char following number. */
block|}
block|}
end_function

begin_comment
comment|/* Parse an MRI multi character constant.  */
end_comment

begin_function
specifier|static
name|void
name|mri_char_constant
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'\''
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* In order to get the correct byte ordering, we must build the      number in reverse.  */
for|for
control|(
name|i
operator|=
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
name|generic_bignum
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARS_PER_LITTLENUM
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'\''
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|generic_bignum
index|[
name|i
index|]
operator|<<=
literal|8
expr_stmt|;
name|generic_bignum
index|[
name|i
index|]
operator|+=
operator|*
name|input_line_pointer
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
condition|)
block|{
comment|/* If there is more than one littlenum, left justify the              last one to make it match the earlier ones.  If there is              only one, we can just use the value directly.  */
for|for
control|(
init|;
name|j
operator|<
name|CHARS_PER_LITTLENUM
condition|;
name|j
operator|++
control|)
name|generic_bignum
index|[
name|i
index|]
operator|<<=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'\''
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"Character constant too large"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|j
decl_stmt|;
name|c
operator|=
name|SIZE_OF_LARGE_NUMBER
operator|-
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c
condition|;
name|j
operator|++
control|)
name|generic_bignum
index|[
name|j
index|]
operator|=
name|generic_bignum
index|[
name|i
operator|+
name|j
index|]
expr_stmt|;
name|i
operator|=
name|c
expr_stmt|;
block|}
name|know
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|==
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_big
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
name|expressionP
operator|->
name|X_add_number
operator|=
name|generic_bignum
index|[
literal|0
index|]
operator|&
name|LITTLENUM_MASK
expr_stmt|;
else|else
name|expressionP
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|generic_bignum
index|[
literal|1
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator||
operator|(
name|generic_bignum
index|[
literal|0
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Skip the final closing quote.  */
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an expression representing the current location.  This    handles the magic symbol `.'.  */
end_comment

begin_function
specifier|static
name|void
name|current_location
parameter_list|(
name|expressionp
parameter_list|)
name|expressionS
modifier|*
name|expressionp
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|expressionp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionp
operator|->
name|X_add_number
operator|=
name|abs_section_offset
expr_stmt|;
block|}
else|else
block|{
name|symbolS
modifier|*
name|symbolp
decl_stmt|;
name|symbolp
operator|=
name|symbol_new
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|expressionp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionp
operator|->
name|X_add_symbol
operator|=
name|symbolp
expr_stmt|;
name|expressionp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Summary of operand().  *  * in:	Input_line_pointer points to 1st char of operand, which may  *	be a space.  *  * out:	A expressionS.  *	The operand may have been empty: in this case X_op == O_absent.  *	Input_line_pointer->(next non-blank) char after operand.  */
end_comment

begin_function
specifier|static
name|segT
name|operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* points to symbol */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* points to name of symbol */
name|segT
name|segment
decl_stmt|;
comment|/* All integers are regarded as unsigned unless they are negated.      This is because the only thing which cares whether a number is      unsigned is the code in emit_expr which extends constants into      bignums.  It should only sign extend negative numbers, so that      something like ``.quad 0x80000000'' is not sign extended even      though it appears negative if valueT is 32 bits.  */
name|expressionP
operator|->
name|X_unsigned
operator|=
literal|1
expr_stmt|;
comment|/* digits, assume it is a bignum. */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* leading whitespace is part of operand. */
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* input_line_pointer->past char in c. */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|input_line_pointer
operator|--
expr_stmt|;
name|integer_constant
argument_list|(
name|flag_m68k_mri
condition|?
literal|0
else|:
literal|10
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* non-decimal radix */
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Check for a hex constant.  */
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
name|hex_p
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'h'
operator|||
operator|*
name|s
operator|==
literal|'H'
condition|)
block|{
operator|--
name|input_line_pointer
expr_stmt|;
name|integer_constant
argument_list|(
literal|0
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|integer_constant
argument_list|(
literal|0
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
default|default:
name|default_case
label|:
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|FLT_CHARS
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|floating_constant
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The string was only zero */
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
name|flag_m68k_mri
condition|)
goto|goto
name|default_case
goto|;
name|input_line_pointer
operator|++
expr_stmt|;
name|integer_constant
argument_list|(
literal|16
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
operator|!
name|flag_m68k_mri
condition|)
block|{
comment|/* This code used to check for '+' and '-' here, and, in 		 some conditions, fall through to call 		 integer_constant.  However, that didn't make sense, 		 as integer_constant only accepts digits.  */
comment|/* Some of our code elsewhere does permit digits greater 		 than the expected base; for consistency, do the same 		 here.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|>
literal|'9'
condition|)
block|{
comment|/* Parse this as a back reference to label 0.  */
name|input_line_pointer
operator|--
expr_stmt|;
name|integer_constant
argument_list|(
literal|10
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Otherwise, parse this as a binary number.  */
block|}
comment|/* Fall through.  */
case|case
literal|'B'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|flag_m68k_mri
condition|)
goto|goto
name|default_case
goto|;
name|integer_constant
argument_list|(
literal|2
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|integer_constant
argument_list|(
name|flag_m68k_mri
condition|?
literal|0
else|:
literal|8
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|LOCAL_LABELS_FB
condition|)
block|{
comment|/* If it says "0f" and it could possibly be a floating point 		 number, make it one.  Otherwise, make it a local label, 		 and try to deal with parsing the rest later.  */
if|if
condition|(
operator|!
name|input_line_pointer
index|[
literal|1
index|]
operator|||
operator|(
name|is_end_of_line
index|[
literal|0xff
operator|&
name|input_line_pointer
index|[
literal|1
index|]
index|]
operator|)
condition|)
goto|goto
name|is_0f_label
goto|;
block|{
name|char
modifier|*
name|cp
init|=
name|input_line_pointer
operator|+
literal|1
decl_stmt|;
name|int
name|r
init|=
name|atof_generic
argument_list|(
operator|&
name|cp
argument_list|,
literal|"."
argument_list|,
name|EXP_CHARS
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
case|case
name|ERROR_EXPONENT_OVERFLOW
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|'f'
operator|||
operator|*
name|cp
operator|==
literal|'b'
condition|)
comment|/* looks like a difference expression */
goto|goto
name|is_0f_label
goto|;
else|else
goto|goto
name|is_0f_float
goto|;
default|default:
name|as_fatal
argument_list|(
literal|"expr.c(operand): bad atof_generic return val %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Okay, now we've sorted it out.  We resume at one of these 		 two labels, depending on what we've decided we're probably 		 looking at.  */
name|is_0f_label
label|:
name|input_line_pointer
operator|--
expr_stmt|;
name|integer_constant
argument_list|(
literal|10
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
name|is_0f_float
label|:
comment|/* fall through */
empty_stmt|;
block|}
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|integer_constant
argument_list|(
literal|0
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
literal|'F'
case|:
case|case
literal|'r'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
name|floating_constant
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|LOCAL_LABELS_DOLLAR
condition|)
block|{
name|integer_constant
argument_list|(
literal|10
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|default_case
goto|;
block|}
break|break;
case|case
literal|'('
case|:
case|case
literal|'['
case|:
comment|/* didn't begin with digit& not a name */
name|segment
operator|=
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
comment|/* Expression() will pass trailing whitespace */
if|if
condition|(
operator|(
name|c
operator|==
literal|'('
operator|&&
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|')'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'['
operator|&&
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|']'
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing ')' assumed"
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* here with input_line_pointer->char after "(...)" */
return|return
name|segment
return|;
case|case
literal|'E'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|'\''
condition|)
goto|goto
name|de_fault
goto|;
name|as_bad
argument_list|(
literal|"EBCDIC constants are not supported"
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'A'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|'\''
condition|)
goto|goto
name|de_fault
goto|;
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'\''
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
block|{
comment|/* Warning: to conform to other people's assemblers NO 	     ESCAPEMENT is permitted for a single quote. The next 	     character, parity errors and all, is taken as the value 	     of the operand. VERY KINKY.  */
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
block|}
name|mri_char_constant
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
operator|(
name|void
operator|)
name|operand
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
comment|/* Double quote is the bitwise not operator in MRI mode.  */
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
comment|/* Fall through.  */
case|case
literal|'~'
case|:
comment|/* ~ is permitted to start a label on the Delta.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|isname
goto|;
case|case
literal|'!'
case|:
case|case
literal|'-'
case|:
block|{
name|operand
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* input_line_pointer -> char after operand */
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
name|expressionP
operator|->
name|X_add_number
expr_stmt|;
comment|/* Notice: '-' may overflow: no warning is given. This is 		   compatible with other people's assemblers. Sigh.  */
name|expressionP
operator|->
name|X_unsigned
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'"'
condition|)
name|expressionP
operator|->
name|X_add_number
operator|=
operator|~
name|expressionP
operator|->
name|X_add_number
expr_stmt|;
else|else
name|expressionP
operator|->
name|X_add_number
operator|=
operator|!
name|expressionP
operator|->
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|!=
name|O_illegal
operator|&&
name|expressionP
operator|->
name|X_op
operator|!=
name|O_absent
condition|)
block|{
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|expressionP
operator|->
name|X_op
operator|=
name|O_uminus
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'"'
condition|)
name|expressionP
operator|->
name|X_op
operator|=
name|O_bit_not
expr_stmt|;
else|else
name|expressionP
operator|->
name|X_op
operator|=
name|O_logical_not
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
literal|"Unary operator %c ignored because bad operand follows"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'$'
case|:
comment|/* $ is the program counter when in MRI mode, or when DOLLAR_DOT          is defined.  */
ifndef|#
directive|ifndef
name|DOLLAR_DOT
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
endif|#
directive|endif
if|if
condition|(
name|flag_m68k_mri
operator|&&
name|hex_p
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
comment|/* In MRI mode, $ is also used as the prefix for a              hexadecimal constant.  */
name|integer_constant
argument_list|(
literal|16
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
goto|goto
name|isname
goto|;
name|current_location
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
operator|!
name|is_part_of_name
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|current_location
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"startof."
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
literal|8
index|]
argument_list|)
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"sizeof."
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
literal|7
index|]
argument_list|)
operator|)
condition|)
block|{
name|int
name|start
decl_stmt|;
name|start
operator|=
operator|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'t'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'T'
operator|)
expr_stmt|;
name|input_line_pointer
operator|+=
name|start
condition|?
literal|8
else|:
literal|7
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'('
condition|)
name|as_bad
argument_list|(
literal|"syntax error in .startof. or .sizeof."
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|buf
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".startof.%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".sizeof.%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_make
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|')'
condition|)
name|as_bad
argument_list|(
literal|"syntax error in .startof. or .sizeof."
argument_list|)
expr_stmt|;
else|else
operator|++
name|input_line_pointer
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
goto|goto
name|isname
goto|;
block|}
case|case
literal|','
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\0'
case|:
name|eol
label|:
comment|/* can't imagine any other kind of operand */
name|expressionP
operator|->
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
name|integer_constant
argument_list|(
literal|2
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
name|integer_constant
argument_list|(
literal|8
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
goto|goto
name|de_fault
goto|;
comment|/* In MRI mode, this is a floating point constant represented          using hexadecimal digits.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|integer_constant
argument_list|(
literal|16
argument_list|,
name|expressionP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
name|flag_m68k_mri
operator|||
name|is_part_of_name
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
goto|goto
name|de_fault
goto|;
name|current_location
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|de_fault
label|:
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
condition|)
goto|goto
name|eol
goto|;
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
argument_list|)
condition|)
comment|/* here if did not begin with a digit */
block|{
comment|/* 	   * Identifier begins here. 	   * This is kludged for speed, so code is repeated. 	   */
name|isname
label|:
name|name
operator|=
operator|--
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_parse_name
comment|/* This is a hook for the backend to parse certain names              specially in certain contexts.  If a name always has a              specific value, it can often be handled by simply              entering it in the symbol table.  */
if|if
condition|(
name|md_parse_name
argument_list|(
name|name
argument_list|,
name|expressionP
argument_list|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_I960
comment|/* The MRI i960 assembler permits 	         lda sizeof code,g13 	     FIXME: This should use md_parse_name.  */
if|if
condition|(
name|flag_mri
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"sizeof"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"startof"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|start
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|start
operator|=
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
operator|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".startof.%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".sizeof.%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_make
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* If we have an absolute symbol or a reg, then we know its 	     value now.  */
name|segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|==
name|absolute_section
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|segment
operator|==
name|reg_section
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
comment|/* Let the target try to parse it.  Success is indicated by changing 	     the X_op field to something other than O_absent and pointing 	     input_line_pointer passed the expression.  If it can't parse the 	     expression, X_op and input_line_pointer should be unchanged.  */
name|expressionP
operator|->
name|X_op
operator|=
name|O_absent
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|md_operand
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|as_bad
argument_list|(
literal|"Bad expression"
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/*    * It is more 'efficient' to clean up the expressionS when they are created.    * Doing it here saves lines of code.    */
name|clean_up_expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/*->1st char after operand. */
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|!=
literal|' '
argument_list|)
expr_stmt|;
comment|/* The PA port needs this information.  */
if|if
condition|(
name|expressionP
operator|->
name|X_add_symbol
condition|)
name|expressionP
operator|->
name|X_add_symbol
operator|->
name|sy_used
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|expressionP
operator|->
name|X_op
condition|)
block|{
default|default:
return|return
name|absolute_section
return|;
case|case
name|O_symbol
case|:
return|return
name|S_GET_SEGMENT
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
return|;
case|case
name|O_register
case|:
return|return
name|reg_section
return|;
block|}
block|}
end_function

begin_comment
comment|/* operand() */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Internal. Simplify a struct expression for use by expr() */
end_comment

begin_comment
comment|/*  * In:	address of a expressionS.  *	The X_op field of the expressionS may only take certain values.  *	Elsewise we waste time special-case testing. Sigh. Ditto SEG_ABSENT.  * Out:	expressionS may have been modified:  *	'foo-foo' symbol references cancelled to 0,  *		which changes X_op from O_subtract to O_constant.  *	Unused fields zeroed to help expr().  */
end_comment

begin_function
specifier|static
name|void
name|clean_up_expression
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
switch|switch
condition|(
name|expressionP
operator|->
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
case|case
name|O_absent
case|:
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_big
case|:
case|case
name|O_constant
case|:
case|case
name|O_register
case|:
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_symbol
case|:
case|case
name|O_uminus
case|:
case|case
name|O_bit_not
case|:
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|O_subtract
case|:
if|if
condition|(
name|expressionP
operator|->
name|X_op_symbol
operator|==
name|expressionP
operator|->
name|X_add_symbol
operator|||
operator|(
operator|(
name|expressionP
operator|->
name|X_op_symbol
operator|->
name|sy_frag
operator|==
name|expressionP
operator|->
name|X_add_symbol
operator|->
name|sy_frag
operator|)
operator|&&
name|SEG_NORMAL
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
argument_list|)
operator|&&
operator|(
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_op_symbol
argument_list|)
operator|==
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
operator|)
operator|)
condition|)
block|{
name|addressT
name|diff
init|=
operator|(
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_op_symbol
argument_list|)
operator|)
decl_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|+=
name|diff
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expression parser. */
end_comment

begin_comment
comment|/*  * We allow an empty expression, and just assume (absolute,0) silently.  * Unary operators and parenthetical expressions are treated as operands.  * As usual, Q==quantity==operand, O==operator, X==expression mnemonics.  *  * We used to do a aho/ullman shift-reduce parser, but the logic got so  * warped that I flushed it and wrote a recursive-descent parser instead.  * Now things are stable, would anybody like to write a fast parser?  * Most expressions are either register (which does not even reach here)  * or 1 symbol. Then "symbol+constant" and "symbol-symbol" are common.  * So I guess it doesn't really matter how inefficient more complex expressions  * are parsed.  *  * After expr(RANK,resultP) input_line_pointer->operator of rank<= RANK.  * Also, we have consumed any leading or trailing spaces (operand does that)  * and done all intervening operators.  *  * This returns the segment of the result, which will be  * absolute_section or the segment of a symbol.  */
end_comment

begin_undef
undef|#
directive|undef
name|__
end_undef

begin_define
define|#
directive|define
name|__
value|O_illegal
end_define

begin_decl_stmt
specifier|static
name|operatorT
name|op_encoding
index|[
literal|256
index|]
init|=
block|{
comment|/* maps ASCII->operators */
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_bit_or_not
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_modulus
block|,
name|O_bit_and
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_multiply
block|,
name|O_add
block|,
name|__
block|,
name|O_subtract
block|,
name|__
block|,
name|O_divide
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_lt
block|,
name|__
block|,
name|O_gt
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_bit_exclusive_or
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_bit_inclusive_or
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Rank	Examples  *	0	operand, (expression)  *	1	||  *	2&&  *	3	=<><<=>=>  *	4	+ -  *	5	used for * / % in MRI mode  *	6& ^ ! |  *	7	* / %<<>>  *	8	unary - unary ~  */
end_comment

begin_decl_stmt
specifier|static
name|operator_rankT
name|op_rank
index|[]
init|=
block|{
literal|0
block|,
comment|/* O_illegal */
literal|0
block|,
comment|/* O_absent */
literal|0
block|,
comment|/* O_constant */
literal|0
block|,
comment|/* O_symbol */
literal|0
block|,
comment|/* O_symbol_rva */
literal|0
block|,
comment|/* O_register */
literal|0
block|,
comment|/* O_bit */
literal|8
block|,
comment|/* O_uminus */
literal|8
block|,
comment|/* O_bit_not */
literal|8
block|,
comment|/* O_logical_not */
literal|7
block|,
comment|/* O_multiply */
literal|7
block|,
comment|/* O_divide */
literal|7
block|,
comment|/* O_modulus */
literal|7
block|,
comment|/* O_left_shift */
literal|7
block|,
comment|/* O_right_shift */
literal|6
block|,
comment|/* O_bit_inclusive_or */
literal|6
block|,
comment|/* O_bit_or_not */
literal|6
block|,
comment|/* O_bit_exclusive_or */
literal|6
block|,
comment|/* O_bit_and */
literal|4
block|,
comment|/* O_add */
literal|4
block|,
comment|/* O_subtract */
literal|3
block|,
comment|/* O_eq */
literal|3
block|,
comment|/* O_ne */
literal|3
block|,
comment|/* O_lt */
literal|3
block|,
comment|/* O_le */
literal|3
block|,
comment|/* O_ge */
literal|3
block|,
comment|/* O_gt */
literal|2
block|,
comment|/* O_logical_and */
literal|1
comment|/* O_logical_or */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the expression parser.  */
end_comment

begin_function
name|void
name|expr_begin
parameter_list|()
block|{
comment|/* In MRI mode for the m68k, multiplication and division have lower      precedence than the bit wise operators.  */
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|op_rank
index|[
name|O_multiply
index|]
operator|=
literal|5
expr_stmt|;
name|op_rank
index|[
name|O_divide
index|]
operator|=
literal|5
expr_stmt|;
name|op_rank
index|[
name|O_modulus
index|]
operator|=
literal|5
expr_stmt|;
name|op_encoding
index|[
literal|'"'
index|]
operator|=
name|O_bit_not
expr_stmt|;
block|}
comment|/* Verify that X_op field is wide enough.  */
block|{
name|expressionS
name|e
decl_stmt|;
name|e
operator|.
name|X_op
operator|=
name|O_max
expr_stmt|;
name|assert
argument_list|(
name|e
operator|.
name|X_op
operator|==
name|O_max
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the encoding for the operator at INPUT_LINE_POINTER.    Advance INPUT_LINE_POINTER to the last character in the operator    (i.e., don't change it for a single character operator).  */
end_comment

begin_function
specifier|static
specifier|inline
name|operatorT
name|operator
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|operatorT
name|ret
decl_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
name|op_encoding
index|[
name|c
index|]
return|;
case|case
literal|'<'
case|:
switch|switch
condition|(
name|input_line_pointer
index|[
literal|1
index|]
condition|)
block|{
default|default:
return|return
name|op_encoding
index|[
name|c
index|]
return|;
case|case
literal|'<'
case|:
name|ret
operator|=
name|O_left_shift
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|ret
operator|=
name|O_ne
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ret
operator|=
name|O_le
expr_stmt|;
break|break;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
return|return
name|ret
return|;
case|case
literal|'>'
case|:
switch|switch
condition|(
name|input_line_pointer
index|[
literal|1
index|]
condition|)
block|{
default|default:
return|return
name|op_encoding
index|[
name|c
index|]
return|;
case|case
literal|'>'
case|:
name|ret
operator|=
name|O_right_shift
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ret
operator|=
name|O_ge
expr_stmt|;
break|break;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
return|return
name|ret
return|;
case|case
literal|'!'
case|:
comment|/* We accept !! as equivalent to ^ for MRI compatibility.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'!'
condition|)
block|{
if|if
condition|(
name|flag_m68k_mri
condition|)
return|return
name|O_bit_inclusive_or
return|;
return|return
name|op_encoding
index|[
name|c
index|]
return|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
return|return
name|O_bit_exclusive_or
return|;
case|case
literal|'|'
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'|'
condition|)
return|return
name|op_encoding
index|[
name|c
index|]
return|;
operator|++
name|input_line_pointer
expr_stmt|;
return|return
name|O_logical_or
return|;
case|case
literal|'&'
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'&'
condition|)
return|return
name|op_encoding
index|[
name|c
index|]
return|;
operator|++
name|input_line_pointer
expr_stmt|;
return|return
name|O_logical_and
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Parse an expression.  */
end_comment

begin_function
name|segT
name|expr
parameter_list|(
name|rank
parameter_list|,
name|resultP
parameter_list|)
name|operator_rankT
name|rank
decl_stmt|;
comment|/* Larger # is higher rank. */
name|expressionS
modifier|*
name|resultP
decl_stmt|;
comment|/* Deliver result here. */
block|{
name|segT
name|retval
decl_stmt|;
name|expressionS
name|right
decl_stmt|;
name|operatorT
name|op_left
decl_stmt|;
name|operatorT
name|op_right
decl_stmt|;
name|know
argument_list|(
name|rank
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|operand
argument_list|(
name|resultP
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|!=
literal|' '
argument_list|)
expr_stmt|;
comment|/* Operand() gobbles spaces. */
name|op_left
operator|=
name|operator
argument_list|()
expr_stmt|;
while|while
condition|(
name|op_left
operator|!=
name|O_illegal
operator|&&
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_left
index|]
operator|>
name|rank
condition|)
block|{
name|segT
name|rightseg
decl_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
comment|/*->after 1st character of operator. */
name|rightseg
operator|=
name|expr
argument_list|(
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_left
index|]
argument_list|,
operator|&
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_warn
argument_list|(
literal|"missing operand; zero assumed"
argument_list|)
expr_stmt|;
name|right
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|right
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|right
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|right
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|!=
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|undefined_section
condition|)
block|{
if|if
condition|(
name|SEG_NORMAL
argument_list|(
name|rightseg
argument_list|)
condition|)
name|retval
operator|=
name|rightseg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|SEG_NORMAL
argument_list|(
name|retval
argument_list|)
condition|)
name|retval
operator|=
name|rightseg
expr_stmt|;
elseif|else
if|if
condition|(
name|SEG_NORMAL
argument_list|(
name|rightseg
argument_list|)
operator|&&
name|retval
operator|!=
name|rightseg
ifdef|#
directive|ifdef
name|DIFF_EXPR_OK
operator|&&
name|op_left
operator|!=
name|O_subtract
endif|#
directive|endif
condition|)
name|as_bad
argument_list|(
literal|"operation combines symbols in different segments"
argument_list|)
expr_stmt|;
name|op_right
operator|=
name|operator
argument_list|()
expr_stmt|;
name|know
argument_list|(
name|op_right
operator|==
name|O_illegal
operator|||
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_right
index|]
operator|<=
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_left
index|]
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|int
operator|)
name|op_left
operator|>=
operator|(
name|int
operator|)
name|O_multiply
operator|&&
operator|(
name|int
operator|)
name|op_left
operator|<=
operator|(
name|int
operator|)
name|O_logical_or
argument_list|)
expr_stmt|;
comment|/* input_line_pointer->after right-hand quantity. */
comment|/* left-hand quantity in resultP */
comment|/* right-hand quantity in right. */
comment|/* operator in op_left. */
if|if
condition|(
name|resultP
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
name|as_warn
argument_list|(
literal|"left operand is a %s; integer 0 assumed"
argument_list|,
name|resultP
operator|->
name|X_add_number
operator|>
literal|0
condition|?
literal|"bignum"
else|:
literal|"float"
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|resultP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|resultP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|right
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
name|as_warn
argument_list|(
literal|"right operand is a %s; integer 0 assumed"
argument_list|,
name|right
operator|.
name|X_add_number
operator|>
literal|0
condition|?
literal|"bignum"
else|:
literal|"float"
argument_list|)
expr_stmt|;
name|right
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|right
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|right
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|right
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Optimize common cases.  */
if|if
condition|(
name|op_left
operator|==
name|O_add
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* X + constant.  */
name|resultP
operator|->
name|X_add_number
operator|+=
name|right
operator|.
name|X_add_number
expr_stmt|;
block|}
comment|/* This case comes up in PIC code.  */
elseif|else
if|if
condition|(
name|op_left
operator|==
name|O_subtract
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|resultP
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
name|right
operator|.
name|X_add_symbol
operator|->
name|sy_frag
operator|==
name|resultP
operator|->
name|X_add_symbol
operator|->
name|sy_frag
operator|)
operator|&&
name|SEG_NORMAL
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|right
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
condition|)
block|{
name|resultP
operator|->
name|X_add_number
operator|-=
name|right
operator|.
name|X_add_number
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|+=
operator|(
name|S_GET_VALUE
argument_list|(
name|resultP
operator|->
name|X_add_symbol
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|right
operator|.
name|X_add_symbol
argument_list|)
operator|)
expr_stmt|;
name|resultP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|resultP
operator|->
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_left
operator|==
name|O_subtract
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* X - constant.  */
name|resultP
operator|->
name|X_add_number
operator|-=
name|right
operator|.
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_left
operator|==
name|O_add
operator|&&
name|resultP
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Constant + X.  */
name|resultP
operator|->
name|X_op
operator|=
name|right
operator|.
name|X_op
expr_stmt|;
name|resultP
operator|->
name|X_add_symbol
operator|=
name|right
operator|.
name|X_add_symbol
expr_stmt|;
name|resultP
operator|->
name|X_op_symbol
operator|=
name|right
operator|.
name|X_op_symbol
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|+=
name|right
operator|.
name|X_add_number
expr_stmt|;
name|retval
operator|=
name|rightseg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultP
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Constant OP constant.  */
name|offsetT
name|v
init|=
name|right
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
operator|&&
operator|(
name|op_left
operator|==
name|O_divide
operator|||
name|op_left
operator|==
name|O_modulus
operator|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"division by zero"
argument_list|)
expr_stmt|;
name|v
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|op_left
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|O_multiply
case|:
name|resultP
operator|->
name|X_add_number
operator|*=
name|v
expr_stmt|;
break|break;
case|case
name|O_divide
case|:
name|resultP
operator|->
name|X_add_number
operator|/=
name|v
expr_stmt|;
break|break;
case|case
name|O_modulus
case|:
name|resultP
operator|->
name|X_add_number
operator|%=
name|v
expr_stmt|;
break|break;
case|case
name|O_left_shift
case|:
name|resultP
operator|->
name|X_add_number
operator|<<=
name|v
expr_stmt|;
break|break;
case|case
name|O_right_shift
case|:
comment|/* We always use unsigned shifts, to avoid relying on                  characteristics of the compiler used to compile gas.  */
name|resultP
operator|->
name|X_add_number
operator|=
call|(
name|offsetT
call|)
argument_list|(
operator|(
name|valueT
operator|)
name|resultP
operator|->
name|X_add_number
operator|>>
operator|(
name|valueT
operator|)
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_bit_inclusive_or
case|:
name|resultP
operator|->
name|X_add_number
operator||=
name|v
expr_stmt|;
break|break;
case|case
name|O_bit_or_not
case|:
name|resultP
operator|->
name|X_add_number
operator||=
operator|~
name|v
expr_stmt|;
break|break;
case|case
name|O_bit_exclusive_or
case|:
name|resultP
operator|->
name|X_add_number
operator|^=
name|v
expr_stmt|;
break|break;
case|case
name|O_bit_and
case|:
name|resultP
operator|->
name|X_add_number
operator|&=
name|v
expr_stmt|;
break|break;
case|case
name|O_add
case|:
name|resultP
operator|->
name|X_add_number
operator|+=
name|v
expr_stmt|;
break|break;
case|case
name|O_subtract
case|:
name|resultP
operator|->
name|X_add_number
operator|-=
name|v
expr_stmt|;
break|break;
case|case
name|O_eq
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|==
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_ne
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|!=
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_lt
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|<
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_le
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|<=
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_ge
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|>=
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_gt
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|>
name|v
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_logical_and
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|&&
name|v
expr_stmt|;
break|break;
case|case
name|O_logical_or
case|:
name|resultP
operator|->
name|X_add_number
operator|=
name|resultP
operator|->
name|X_add_number
operator|||
name|v
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|resultP
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|right
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
name|op_left
operator|==
name|O_add
operator|||
name|op_left
operator|==
name|O_subtract
operator|||
operator|(
name|resultP
operator|->
name|X_add_number
operator|==
literal|0
operator|&&
name|right
operator|.
name|X_add_number
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Symbol OP symbol.  */
name|resultP
operator|->
name|X_op
operator|=
name|op_left
expr_stmt|;
name|resultP
operator|->
name|X_op_symbol
operator|=
name|right
operator|.
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|op_left
operator|==
name|O_add
condition|)
name|resultP
operator|->
name|X_add_number
operator|+=
name|right
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|op_left
operator|==
name|O_subtract
condition|)
name|resultP
operator|->
name|X_add_number
operator|-=
name|right
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
comment|/* The general case.  */
name|resultP
operator|->
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
name|resultP
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_op_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|right
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_op
operator|=
name|op_left
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|resultP
operator|->
name|X_unsigned
operator|=
literal|1
expr_stmt|;
block|}
name|op_left
operator|=
name|op_right
expr_stmt|;
block|}
comment|/* While next operator is>= this rank. */
comment|/* The PA port needs this information.  */
if|if
condition|(
name|resultP
operator|->
name|X_add_symbol
condition|)
name|resultP
operator|->
name|X_add_symbol
operator|->
name|sy_used
operator|=
literal|1
expr_stmt|;
return|return
name|resultP
operator|->
name|X_op
operator|==
name|O_constant
condition|?
name|absolute_section
else|:
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			get_symbol_end()  *  * This lives here because it belongs equally in expr.c& read.c.  * Expr.c is just a branch office read.c anyway, and putting it  * here lessens the crowd at read.c.  *  * Assume input_line_pointer is at start of symbol name.  * Advance input_line_pointer past symbol name.  * Turn that character into a '\0', returning its former value.  * This allows a string compare (RMS wants symbol names to be strings)  * of the symbol name.  * There will always be a char following symbol name, because all good  * lines end in end-of-line.  */
end_comment

begin_function
name|char
name|get_symbol_end
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
comment|/* We accept \001 in a name in case this is being called with a      constructed string.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
argument_list|)
operator|||
name|c
operator|==
literal|'\001'
condition|)
while|while
condition|(
name|is_part_of_name
argument_list|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
argument_list|)
operator|||
name|c
operator|==
literal|'\001'
condition|)
empty_stmt|;
operator|*
operator|--
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|get_single_number
parameter_list|()
block|{
name|expressionS
name|exp
decl_stmt|;
name|operand
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
operator|.
name|X_add_number
return|;
block|}
end_function

begin_comment
comment|/* end of expr.c */
end_comment

end_unit

