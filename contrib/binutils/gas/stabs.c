begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic stabs parsing for gas.    Copyright (C) 1989, 90, 91, 93, 94, 95, 96, 1997    Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"ecoff.h"
end_include

begin_comment
comment|/* We need this, despite the apparent object format dependency, since    it defines stab types, which all object formats can use now. */
end_comment

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|s_stab_generic
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allow backends to override the names used for the stab sections.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STAB_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|STAB_SECTION_NAME
value|".stab"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STAB_STRING_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|STAB_STRING_SECTION_NAME
value|".stabstr"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle .stabX directives, which used to be open-coded.  * So much creeping featurism overloaded the semantics that we decided  * to put all .stabX thinking in one place. Here.  *  * We try to make any .stabX directive legal. Other people's AS will often  * do assembly-time consistency checks: eg assigning meaning to n_type bits  * and "protecting" you from setting them to certain values. (They also zero  * certain bits before emitting symbols. Tut tut.)  *  * If an expression is not absolute we either gripe or use the relocation  * information. Other people's assemblers silently forget information they  * don't need and invent information they need that you didn't supply.  */
end_comment

begin_comment
comment|/*  * Build a string dictionary entry for a .stabX symbol.  * The symbol is added to the .<secname>str section.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEPARATE_STAB_SECTIONS
end_ifndef

begin_define
define|#
directive|define
name|SEPARATE_STAB_SECTIONS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|int
name|get_stab_string_offset
parameter_list|(
name|string
parameter_list|,
name|stabstr_secname
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|stabstr_secname
decl_stmt|;
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|SEPARATE_STAB_SECTIONS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/* Ordinary case. */
name|segT
name|save_seg
decl_stmt|;
name|subsegT
name|save_subseg
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|save_seg
operator|=
name|now_seg
expr_stmt|;
name|save_subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* Create the stab string section.  */
name|seg
operator|=
name|subseg_new
argument_list|(
name|stabstr_secname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|stabu
operator|.
name|stab_string_size
expr_stmt|;
if|if
condition|(
name|retval
operator|<=
literal|0
condition|)
block|{
comment|/* Make sure the first string is empty.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|stabu
operator|.
name|stab_string_size
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|name
operator|==
name|stabstr_secname
condition|)
name|seg
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|stabstr_secname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|stabu
operator|.
name|stab_string_size
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
name|subseg_set
argument_list|(
name|save_seg
argument_list|,
name|save_subseg
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AOUT_STABS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_PROCESS_STAB
end_ifndef

begin_define
define|#
directive|define
name|OBJ_PROCESS_STAB
parameter_list|(
name|SEG
parameter_list|,
name|W
parameter_list|,
name|S
parameter_list|,
name|T
parameter_list|,
name|O
parameter_list|,
name|D
parameter_list|)
value|aout_process_stab(W,S,T,O,D)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|aout_process_stab
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|aout_process_stab
parameter_list|(
name|what
parameter_list|,
name|string
parameter_list|,
name|type
parameter_list|,
name|other
parameter_list|,
name|desc
parameter_list|)
name|int
name|what
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|type
decl_stmt|,
name|other
decl_stmt|,
name|desc
decl_stmt|;
block|{
comment|/* Put the stab information in the symbol table.  */
name|symbolS
modifier|*
name|symbol
decl_stmt|;
comment|/* Create the symbol now, but only insert it into the symbol chain      after any symbols mentioned in the value expression get into the      symbol chain.  This is to avoid "continuation symbols" (where one      ends in "\" and the debug info is continued in the next .stabs      directive) from being separated by other random symbols.  */
name|symbol
operator|=
name|symbol_create
argument_list|(
name|string
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|frag
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
condition|)
block|{
comment|/* Pick up the value from the input line.  */
name|symbol
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* .stabd sets the name to NULL.  Why?  */
name|S_SET_NAME
argument_list|(
name|symbol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbol
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|symbol_append
argument_list|(
name|symbol
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|S_SET_TYPE
argument_list|(
name|symbol
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|S_SET_OTHER
argument_list|(
name|symbol
argument_list|,
name|other
argument_list|)
expr_stmt|;
name|S_SET_DESC
argument_list|(
name|symbol
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This can handle different kinds of stabs (s,n,d) and different    kinds of stab sections. */
end_comment

begin_function
specifier|static
name|void
name|s_stab_generic
parameter_list|(
name|what
parameter_list|,
name|stab_secname
parameter_list|,
name|stabstr_secname
parameter_list|)
name|int
name|what
decl_stmt|;
name|char
modifier|*
name|stab_secname
decl_stmt|;
name|char
modifier|*
name|stabstr_secname
decl_stmt|;
block|{
name|long
name|longint
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|other
decl_stmt|;
name|int
name|desc
decl_stmt|;
comment|/* The general format is:      .stabs "STRING",TYPE,OTHER,DESC,VALUE      .stabn TYPE,OTHER,DESC,VALUE      .stabd TYPE,OTHER,DESC      At this point input_line_pointer points after the pseudo-op and      any trailing whitespace.  The argument what is one of 's', 'n' or      'd' indicating which type of .stab this is.  */
if|if
condition|(
name|what
operator|!=
literal|'s'
condition|)
name|string
operator|=
literal|""
expr_stmt|;
else|else
block|{
name|int
name|length
decl_stmt|;
name|string
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|length
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
block|{
name|as_warn
argument_list|(
literal|".stabs: Missing comma"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|".stab%c: Missing comma"
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|type
operator|=
name|longint
expr_stmt|;
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|".stab%c: Missing comma"
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|other
operator|=
name|longint
expr_stmt|;
name|desc
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|".stab%c: Missing comma"
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TC_PPC
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Solaris on PowerPC has decided that .stabd can take 4 arguments, so if we were      given 4 arguments, make it a .stabn */
elseif|else
if|if
condition|(
name|what
operator|==
literal|'d'
condition|)
block|{
name|char
modifier|*
name|save_location
init|=
name|input_line_pointer
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|what
operator|=
literal|'n'
expr_stmt|;
block|}
else|else
name|input_line_pointer
operator|=
name|save_location
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_ELF */
endif|#
directive|endif
comment|/* TC_PPC */
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|listing
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_SLINE
case|:
name|listing_source_line
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SO
case|:
case|case
name|N_SOL
case|:
name|listing_source_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* ! NO_LISTING */
comment|/* We have now gathered the type, other, and desc information.  For      .stabs or .stabn, input_line_pointer is now pointing at the      value.  */
if|if
condition|(
name|SEPARATE_STAB_SECTIONS
condition|)
comment|/* Output the stab information in a separate section.  This is used        at least for COFF and ELF.  */
block|{
name|segT
name|saved_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|saved_subseg
init|=
name|now_subseg
decl_stmt|;
name|fragS
modifier|*
name|saved_frag
init|=
name|frag_now
decl_stmt|;
name|valueT
name|dot
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|unsigned
name|int
name|stroff
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|segT
name|cached_sec
decl_stmt|;
specifier|static
name|char
modifier|*
name|cached_secname
decl_stmt|;
name|dot
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
if|if
condition|(
name|cached_secname
operator|&&
operator|!
name|strcmp
argument_list|(
name|cached_secname
argument_list|,
name|stab_secname
argument_list|)
condition|)
block|{
name|seg
operator|=
name|cached_sec
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seg
operator|=
name|subseg_new
argument_list|(
name|stab_secname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_secname
condition|)
name|free
argument_list|(
name|cached_secname
argument_list|)
expr_stmt|;
name|cached_secname
operator|=
name|xstrdup
argument_list|(
name|stab_secname
argument_list|)
expr_stmt|;
name|cached_sec
operator|=
name|seg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|hadone
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_RELOC
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_STAB_SECTION
name|INIT_STAB_SECTION
argument_list|(
name|seg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|hadone
operator|=
literal|1
expr_stmt|;
block|}
name|stroff
operator|=
name|get_stab_string_offset
argument_list|(
name|string
argument_list|,
name|stabstr_secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
condition|)
block|{
comment|/* release the string */
name|obstack_free
argument_list|(
operator|&
name|notes
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
comment|/* At least for now, stabs in a special stab section are always 	 output as 12 byte blocks of information.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|stroff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|4
argument_list|,
operator|(
name|valueT
operator|)
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|5
argument_list|,
operator|(
name|valueT
operator|)
name|other
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|6
argument_list|,
operator|(
name|valueT
operator|)
name|desc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
condition|)
block|{
comment|/* Pick up the value from the input line.  */
name|cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|fake
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
comment|/* Arrange for a value representing the current location.  */
name|fake
operator|=
name|FAKE_LABEL_NAME
expr_stmt|;
name|symbol
operator|=
name|symbol_new
argument_list|(
name|fake
argument_list|,
name|saved_seg
argument_list|,
name|dot
argument_list|,
name|saved_frag
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|symbol
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_PROCESS_STAB
name|OBJ_PROCESS_STAB
argument_list|(
name|seg
argument_list|,
name|what
argument_list|,
name|string
argument_list|,
name|type
argument_list|,
name|other
argument_list|,
name|desc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OBJ_PROCESS_STAB
name|OBJ_PROCESS_STAB
argument_list|(
literal|0
argument_list|,
name|what
argument_list|,
name|string
argument_list|,
name|type
argument_list|,
name|other
argument_list|,
name|desc
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Regular stab directive. */
end_comment

begin_function
name|void
name|s_stab
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
name|s_stab_generic
argument_list|(
name|what
argument_list|,
name|STAB_SECTION_NAME
argument_list|,
name|STAB_STRING_SECTION_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* "Extended stabs", used in Solaris only now. */
end_comment

begin_function
name|void
name|s_xstab
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|stab_secname
decl_stmt|,
modifier|*
name|stabstr_secname
decl_stmt|;
specifier|static
name|char
modifier|*
name|saved_secname
decl_stmt|,
modifier|*
name|saved_strsecname
decl_stmt|;
comment|/* @@ MEMORY LEAK: This allocates a copy of the string, but in most      cases it will be the same string, so we could release the storage      back to the obstack it came from.  */
name|stab_secname
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|length
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
literal|"comma missing in .xstabs"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* To get the name of the stab string section, simply add "str" to      the stab section name.  */
if|if
condition|(
name|saved_secname
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|saved_secname
argument_list|,
name|stab_secname
argument_list|)
condition|)
block|{
name|stabstr_secname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|stab_secname
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stabstr_secname
argument_list|,
name|stab_secname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stabstr_secname
argument_list|,
literal|"str"
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_secname
condition|)
block|{
name|free
argument_list|(
name|saved_secname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|saved_strsecname
argument_list|)
expr_stmt|;
block|}
name|saved_secname
operator|=
name|stab_secname
expr_stmt|;
name|saved_strsecname
operator|=
name|stabstr_secname
expr_stmt|;
block|}
name|s_stab_generic
argument_list|(
name|what
argument_list|,
name|saved_secname
argument_list|,
name|saved_strsecname
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|S_SET_DESC
end_ifdef

begin_comment
comment|/* Frob invented at RMS' request. Set the n_desc of a symbol.  */
end_comment

begin_function
name|void
name|s_desc
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|S_SET_DESC
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_desc() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (S_SET_DESC) */
end_comment

end_unit

