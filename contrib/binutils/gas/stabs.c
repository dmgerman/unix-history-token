begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic stabs parsing for gas.    Copyright (C) 1989, 90, 91, 93, 94, 95, 96, 97, 98, 1999    Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"ecoff.h"
end_include

begin_comment
comment|/* We need this, despite the apparent object format dependency, since    it defines stab types, which all object formats can use now. */
end_comment

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|s_stab_generic
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_asm_file
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allow backends to override the names used for the stab sections.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STAB_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|STAB_SECTION_NAME
value|".stab"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STAB_STRING_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|STAB_STRING_SECTION_NAME
value|".stabstr"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non-zero if we're in the middle of a .func function, in which case    stabs_generate_asm_lineno emits function relative line number stabs.    Otherwise it emits line number stabs with absolute addresses.  Note that    both cases only apply to assembler code assembled with -gstabs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_dot_func_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label at start of current function if in_dot_func_p != 0.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_function_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle .stabX directives, which used to be open-coded.  * So much creeping featurism overloaded the semantics that we decided  * to put all .stabX thinking in one place. Here.  *  * We try to make any .stabX directive legal. Other people's AS will often  * do assembly-time consistency checks: eg assigning meaning to n_type bits  * and "protecting" you from setting them to certain values. (They also zero  * certain bits before emitting symbols. Tut tut.)  *  * If an expression is not absolute we either gripe or use the relocation  * information. Other people's assemblers silently forget information they  * don't need and invent information they need that you didn't supply.  */
end_comment

begin_comment
comment|/*  * Build a string dictionary entry for a .stabX symbol.  * The symbol is added to the .<secname>str section.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEPARATE_STAB_SECTIONS
end_ifndef

begin_define
define|#
directive|define
name|SEPARATE_STAB_SECTIONS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|int
name|get_stab_string_offset
parameter_list|(
name|string
parameter_list|,
name|stabstr_secname
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|stabstr_secname
decl_stmt|;
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|retval
decl_stmt|;
name|segT
name|save_seg
decl_stmt|;
name|subsegT
name|save_subseg
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|SEPARATE_STAB_SECTIONS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|save_seg
operator|=
name|now_seg
expr_stmt|;
name|save_subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* Create the stab string section.  */
name|seg
operator|=
name|subseg_new
argument_list|(
name|stabstr_secname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|stabu
operator|.
name|stab_string_size
expr_stmt|;
if|if
condition|(
name|retval
operator|<=
literal|0
condition|)
block|{
comment|/* Make sure the first string is empty.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|stabu
operator|.
name|stab_string_size
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|name
operator|==
name|stabstr_secname
condition|)
name|seg
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|stabstr_secname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/* Ordinary case. */
name|p
operator|=
name|frag_more
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|stabu
operator|.
name|stab_string_size
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|retval
operator|=
literal|0
expr_stmt|;
name|subseg_set
argument_list|(
name|save_seg
argument_list|,
name|save_subseg
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AOUT_STABS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_PROCESS_STAB
end_ifndef

begin_define
define|#
directive|define
name|OBJ_PROCESS_STAB
parameter_list|(
name|SEG
parameter_list|,
name|W
parameter_list|,
name|S
parameter_list|,
name|T
parameter_list|,
name|O
parameter_list|,
name|D
parameter_list|)
value|aout_process_stab(W,S,T,O,D)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|aout_process_stab
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|aout_process_stab
parameter_list|(
name|what
parameter_list|,
name|string
parameter_list|,
name|type
parameter_list|,
name|other
parameter_list|,
name|desc
parameter_list|)
name|int
name|what
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|type
decl_stmt|,
name|other
decl_stmt|,
name|desc
decl_stmt|;
block|{
comment|/* Put the stab information in the symbol table.  */
name|symbolS
modifier|*
name|symbol
decl_stmt|;
comment|/* Create the symbol now, but only insert it into the symbol chain      after any symbols mentioned in the value expression get into the      symbol chain.  This is to avoid "continuation symbols" (where one      ends in "\" and the debug info is continued in the next .stabs      directive) from being separated by other random symbols.  */
name|symbol
operator|=
name|symbol_create
argument_list|(
name|string
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|frag
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
condition|)
block|{
comment|/* Pick up the value from the input line.  */
name|symbol_set_frag
argument_list|(
name|symbol
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* .stabd sets the name to NULL.  Why?  */
name|S_SET_NAME
argument_list|(
name|symbol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbol
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbol
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|symbol_append
argument_list|(
name|symbol
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|S_SET_TYPE
argument_list|(
name|symbol
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|S_SET_OTHER
argument_list|(
name|symbol
argument_list|,
name|other
argument_list|)
expr_stmt|;
name|S_SET_DESC
argument_list|(
name|symbol
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This can handle different kinds of stabs (s,n,d) and different    kinds of stab sections. */
end_comment

begin_function
specifier|static
name|void
name|s_stab_generic
parameter_list|(
name|what
parameter_list|,
name|stab_secname
parameter_list|,
name|stabstr_secname
parameter_list|)
name|int
name|what
decl_stmt|;
name|char
modifier|*
name|stab_secname
decl_stmt|;
name|char
modifier|*
name|stabstr_secname
decl_stmt|;
block|{
name|long
name|longint
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|other
decl_stmt|;
name|int
name|desc
decl_stmt|;
comment|/* The general format is:      .stabs "STRING",TYPE,OTHER,DESC,VALUE      .stabn TYPE,OTHER,DESC,VALUE      .stabd TYPE,OTHER,DESC      At this point input_line_pointer points after the pseudo-op and      any trailing whitespace.  The argument what is one of 's', 'n' or      'd' indicating which type of .stab this is.  */
if|if
condition|(
name|what
operator|!=
literal|'s'
condition|)
name|string
operator|=
literal|""
expr_stmt|;
else|else
block|{
name|int
name|length
decl_stmt|;
name|string
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|length
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".stabs: Missing comma"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".stab%c: Missing comma"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|type
operator|=
name|longint
expr_stmt|;
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".stab%c: Missing comma"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|other
operator|=
name|longint
expr_stmt|;
name|desc
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".stab%c: Missing comma"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TC_PPC
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Solaris on PowerPC has decided that .stabd can take 4 arguments, so if we were      given 4 arguments, make it a .stabn */
elseif|else
if|if
condition|(
name|what
operator|==
literal|'d'
condition|)
block|{
name|char
modifier|*
name|save_location
init|=
name|input_line_pointer
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|what
operator|=
literal|'n'
expr_stmt|;
block|}
else|else
name|input_line_pointer
operator|=
name|save_location
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_ELF */
endif|#
directive|endif
comment|/* TC_PPC */
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|listing
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_SLINE
case|:
name|listing_source_line
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SO
case|:
case|case
name|N_SOL
case|:
name|listing_source_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* ! NO_LISTING */
comment|/* We have now gathered the type, other, and desc information.  For      .stabs or .stabn, input_line_pointer is now pointing at the      value.  */
if|if
condition|(
name|SEPARATE_STAB_SECTIONS
condition|)
comment|/* Output the stab information in a separate section.  This is used        at least for COFF and ELF.  */
block|{
name|segT
name|saved_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|saved_subseg
init|=
name|now_subseg
decl_stmt|;
name|fragS
modifier|*
name|saved_frag
init|=
name|frag_now
decl_stmt|;
name|valueT
name|dot
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|unsigned
name|int
name|stroff
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|segT
name|cached_sec
decl_stmt|;
specifier|static
name|char
modifier|*
name|cached_secname
decl_stmt|;
name|dot
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cached_secname
operator|&&
operator|!
name|strcmp
argument_list|(
name|cached_secname
argument_list|,
name|stab_secname
argument_list|)
condition|)
block|{
name|seg
operator|=
name|cached_sec
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seg
operator|=
name|subseg_new
argument_list|(
name|stab_secname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_secname
condition|)
name|free
argument_list|(
name|cached_secname
argument_list|)
expr_stmt|;
name|cached_secname
operator|=
name|xstrdup
argument_list|(
name|stab_secname
argument_list|)
expr_stmt|;
name|cached_sec
operator|=
name|seg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|hadone
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_RELOC
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_STAB_SECTION
name|INIT_STAB_SECTION
argument_list|(
name|seg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|hadone
operator|=
literal|1
expr_stmt|;
block|}
name|stroff
operator|=
name|get_stab_string_offset
argument_list|(
name|string
argument_list|,
name|stabstr_secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
condition|)
block|{
comment|/* release the string */
name|obstack_free
argument_list|(
operator|&
name|notes
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
comment|/* At least for now, stabs in a special stab section are always 	 output as 12 byte blocks of information.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|stroff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|4
argument_list|,
operator|(
name|valueT
operator|)
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|5
argument_list|,
operator|(
name|valueT
operator|)
name|other
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|6
argument_list|,
operator|(
name|valueT
operator|)
name|desc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
condition|)
block|{
comment|/* Pick up the value from the input line.  */
name|cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|fake
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
comment|/* Arrange for a value representing the current location.  */
name|fake
operator|=
name|FAKE_LABEL_NAME
expr_stmt|;
name|symbol
operator|=
name|symbol_new
argument_list|(
name|fake
argument_list|,
name|saved_seg
argument_list|,
name|dot
argument_list|,
name|saved_frag
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|symbol
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_PROCESS_STAB
name|OBJ_PROCESS_STAB
argument_list|(
name|seg
argument_list|,
name|what
argument_list|,
name|string
argument_list|,
name|type
argument_list|,
name|other
argument_list|,
name|desc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OBJ_PROCESS_STAB
name|OBJ_PROCESS_STAB
argument_list|(
literal|0
argument_list|,
name|what
argument_list|,
name|string
argument_list|,
name|type
argument_list|,
name|other
argument_list|,
name|desc
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Regular stab directive. */
end_comment

begin_function
name|void
name|s_stab
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
name|s_stab_generic
argument_list|(
name|what
argument_list|,
name|STAB_SECTION_NAME
argument_list|,
name|STAB_STRING_SECTION_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* "Extended stabs", used in Solaris only now. */
end_comment

begin_function
name|void
name|s_xstab
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|stab_secname
decl_stmt|,
modifier|*
name|stabstr_secname
decl_stmt|;
specifier|static
name|char
modifier|*
name|saved_secname
decl_stmt|,
modifier|*
name|saved_strsecname
decl_stmt|;
comment|/* @@ MEMORY LEAK: This allocates a copy of the string, but in most      cases it will be the same string, so we could release the storage      back to the obstack it came from.  */
name|stab_secname
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|length
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"comma missing in .xstabs"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* To get the name of the stab string section, simply add "str" to      the stab section name.  */
if|if
condition|(
name|saved_secname
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|saved_secname
argument_list|,
name|stab_secname
argument_list|)
condition|)
block|{
name|stabstr_secname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|stab_secname
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stabstr_secname
argument_list|,
name|stab_secname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stabstr_secname
argument_list|,
literal|"str"
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_secname
condition|)
block|{
name|free
argument_list|(
name|saved_secname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|saved_strsecname
argument_list|)
expr_stmt|;
block|}
name|saved_secname
operator|=
name|stab_secname
expr_stmt|;
name|saved_strsecname
operator|=
name|stabstr_secname
expr_stmt|;
block|}
name|s_stab_generic
argument_list|(
name|what
argument_list|,
name|saved_secname
argument_list|,
name|saved_strsecname
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|S_SET_DESC
end_ifdef

begin_comment
comment|/* Frob invented at RMS' request. Set the n_desc of a symbol.  */
end_comment

begin_function
name|void
name|s_desc
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|S_SET_DESC
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_desc() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (S_SET_DESC) */
end_comment

begin_comment
comment|/* Generate stabs debugging information to denote the main source file.  */
end_comment

begin_function
name|void
name|stabs_generate_asm_file
parameter_list|()
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
name|generate_asm_file
argument_list|(
name|N_SO
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate stabs debugging information to denote the source file.    TYPE is one of N_SO, N_SOL.  */
end_comment

begin_function
specifier|static
name|void
name|generate_asm_file
parameter_list|(
name|type
parameter_list|,
name|file
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|last_file
decl_stmt|;
specifier|static
name|int
name|label_count
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
literal|2
operator|*
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
name|char
name|sym
index|[
literal|30
index|]
decl_stmt|;
comment|/* Rather than try to do this in some efficient fashion, we just      generate a string and then parse it again.  That lets us use the      existing stabs hook, which expect to see a string, rather than      inventing new ones.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|last_file
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|last_file
argument_list|,
name|file
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|file
decl_stmt|;
name|char
modifier|*
name|endp
init|=
name|file
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|char
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
name|sprintf
argument_list|(
name|sym
argument_list|,
literal|"%sF%d"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
argument_list|)
expr_stmt|;
operator|++
name|label_count
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
literal|'"'
expr_stmt|;
while|while
condition|(
name|tmp
operator|<
name|endp
condition|)
block|{
name|char
modifier|*
name|bslash
init|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
name|int
name|len
init|=
operator|(
name|bslash
condition|?
operator|(
name|bslash
operator|-
name|tmp
operator|+
literal|1
operator|)
else|:
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|)
decl_stmt|;
comment|/* double all backslashes, since demand_copy_C_string (used by              s_stab to extract the part in quotes) will try to replace them as              escape sequences.  backslash may appear in a filespec. */
name|strncpy
argument_list|(
name|bufp
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|len
expr_stmt|;
name|bufp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|bslash
operator|!=
name|NULL
condition|)
operator|*
name|bufp
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"\",%d,0,0,%s\n"
argument_list|,
name|type
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|buf
expr_stmt|;
name|s_stab
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_file
argument_list|)
expr_stmt|;
name|last_file
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate stabs debugging information for the current line.  This is    used to produce debugging information for an assembler file.  */
end_comment

begin_function
name|void
name|stabs_generate_asm_lineno
parameter_list|()
block|{
specifier|static
name|int
name|label_count
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|sym
index|[
literal|30
index|]
decl_stmt|;
comment|/* Rather than try to do this in some efficient fashion, we just      generate a string and then parse it again.  That lets us use the      existing stabs hook, which expect to see a string, rather than      inventing new ones.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
name|generate_asm_file
argument_list|(
name|N_SOL
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sym
argument_list|,
literal|"%sL%d"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
argument_list|)
expr_stmt|;
operator|++
name|label_count
expr_stmt|;
if|if
condition|(
name|in_dot_func_p
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|100
operator|+
name|strlen
argument_list|(
name|current_function_label
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d,0,%d,%s-%s\n"
argument_list|,
name|N_SLINE
argument_list|,
name|lineno
argument_list|,
name|sym
argument_list|,
name|current_function_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d,0,%d,%s\n"
argument_list|,
name|N_SLINE
argument_list|,
name|lineno
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|buf
expr_stmt|;
name|s_stab
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a function stab.    All assembler functions are assumed to have return type `void'.  */
end_comment

begin_function
name|void
name|stabs_generate_asm_func
parameter_list|(
name|funcname
parameter_list|,
name|startlabname
parameter_list|)
specifier|const
name|char
modifier|*
name|funcname
decl_stmt|;
specifier|const
name|char
modifier|*
name|startlabname
decl_stmt|;
block|{
specifier|static
name|int
name|void_emitted_p
decl_stmt|;
name|char
modifier|*
name|hold
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
if|if
condition|(
operator|!
name|void_emitted_p
condition|)
block|{
name|input_line_pointer
operator|=
literal|"\"void:t1=1\",128,0,0,0"
expr_stmt|;
name|s_stab
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|void_emitted_p
operator|=
literal|1
expr_stmt|;
block|}
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"\"%s:F1\",%d,0,%d,%s"
argument_list|,
name|funcname
argument_list|,
name|N_FUN
argument_list|,
name|lineno
operator|+
literal|1
argument_list|,
name|startlabname
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|buf
expr_stmt|;
name|s_stab
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|current_function_label
operator|=
name|xstrdup
argument_list|(
name|startlabname
argument_list|)
expr_stmt|;
name|in_dot_func_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a stab to record the end of a function.  */
end_comment

begin_function
name|void
name|stabs_generate_asm_endfunc
parameter_list|(
name|funcname
parameter_list|,
name|startlabname
parameter_list|)
specifier|const
name|char
modifier|*
name|funcname
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|startlabname
decl_stmt|;
block|{
specifier|static
name|int
name|label_count
decl_stmt|;
name|char
modifier|*
name|hold
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|sym
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|sym
argument_list|,
literal|"%sendfunc%d"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
argument_list|)
expr_stmt|;
operator|++
name|label_count
expr_stmt|;
name|colon
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"\"\",%d,0,0,%s-%s"
argument_list|,
name|N_FUN
argument_list|,
name|sym
argument_list|,
name|startlabname
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|buf
expr_stmt|;
name|s_stab
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|in_dot_func_p
operator|=
literal|0
expr_stmt|;
name|current_function_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

