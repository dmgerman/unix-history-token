begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* subsegs.c - subsegments -    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* Segments& sub-segments.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
name|frchainS
modifier|*
name|frchain_now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|frchains
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fragS
name|dummy_frag
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|subsegs_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|obstack_begin
argument_list|(
operator|&
name|frchains
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
name|obstack_alignment_mask
argument_list|(
operator|&
name|frchains
argument_list|)
operator|=
name|__alignof__
argument_list|(
name|frchainS
argument_list|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|frchain_now
operator|=
name|NULL
expr_stmt|;
comment|/* Warn new_subseg() that we are booting.  */
name|frag_now
operator|=
operator|&
name|dummy_frag
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			subseg_change()  *  * Change the subsegment we are in, BUT DO NOT MAKE A NEW FRAG for the  * subsegment. If we are already in the correct subsegment, change nothing.  * This is used eg as a worker for subseg_set [which does make a new frag_now]  * and for changing segments after we have read the source. We construct eg  * fixSs even after the source file is read, so we do have to keep the  * segment context correct.  */
end_comment

begin_function
name|void
name|subseg_change
parameter_list|(
specifier|register
name|segT
name|seg
parameter_list|,
specifier|register
name|int
name|subseg
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|seg
argument_list|)
decl_stmt|;
name|now_seg
operator|=
name|seg
expr_stmt|;
name|now_subseg
operator|=
name|subseg
expr_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
block|{
name|seginfo
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|bfd_section
operator|=
name|seg
expr_stmt|;
name|bfd_set_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|subseg_set_rest
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|frchainS
modifier|*
name|frcP
decl_stmt|;
comment|/* crawl frchain chain */
name|frchainS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
comment|/* address of last pointer */
name|frchainS
modifier|*
name|newP
decl_stmt|;
comment|/* address of new frchain */
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|mri_common_symbol
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|frag_now
operator|&&
name|frchain_now
condition|)
name|frchain_now
operator|->
name|frch_frag_now
operator|=
name|frag_now
expr_stmt|;
name|assert
argument_list|(
name|frchain_now
operator|==
literal|0
operator|||
name|frchain_now
operator|->
name|frch_last
operator|==
name|frag_now
argument_list|)
expr_stmt|;
name|subseg_change
argument_list|(
name|seg
argument_list|,
operator|(
name|int
operator|)
name|subseg
argument_list|)
expr_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|seg
argument_list|)
expr_stmt|;
comment|/* Attempt to find or make a frchain for that subsection.      We keep the list sorted by subsection number.  */
for|for
control|(
name|frcP
operator|=
operator|*
operator|(
name|lastPP
operator|=
operator|&
name|seginfo
operator|->
name|frchainP
operator|)
init|;
name|frcP
operator|!=
name|NULL
condition|;
name|frcP
operator|=
operator|*
operator|(
name|lastPP
operator|=
operator|&
name|frcP
operator|->
name|frch_next
operator|)
control|)
if|if
condition|(
name|frcP
operator|->
name|frch_subseg
operator|>=
name|subseg
condition|)
break|break;
if|if
condition|(
name|frcP
operator|==
name|NULL
operator|||
name|frcP
operator|->
name|frch_subseg
operator|!=
name|subseg
condition|)
block|{
comment|/* This should be the only code that creates a frchainS.  */
name|newP
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|frchains
argument_list|,
sizeof|sizeof
argument_list|(
name|frchainS
argument_list|)
argument_list|)
expr_stmt|;
name|newP
operator|->
name|frch_subseg
operator|=
name|subseg
expr_stmt|;
name|newP
operator|->
name|fix_root
operator|=
name|NULL
expr_stmt|;
name|newP
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|newP
operator|->
name|frch_obstack
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
name|obstack_alignment_mask
argument_list|(
operator|&
name|newP
operator|->
name|frch_obstack
argument_list|)
operator|=
name|__alignof__
argument_list|(
name|fragS
argument_list|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|newP
operator|->
name|frch_frag_now
operator|=
name|frag_alloc
argument_list|(
operator|&
name|newP
operator|->
name|frch_obstack
argument_list|)
expr_stmt|;
name|newP
operator|->
name|frch_frag_now
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|newP
operator|->
name|frch_cfi_data
operator|=
name|NULL
expr_stmt|;
name|newP
operator|->
name|frch_root
operator|=
name|newP
operator|->
name|frch_last
operator|=
name|newP
operator|->
name|frch_frag_now
expr_stmt|;
operator|*
name|lastPP
operator|=
name|newP
expr_stmt|;
name|newP
operator|->
name|frch_next
operator|=
name|frcP
expr_stmt|;
name|frcP
operator|=
name|newP
expr_stmt|;
block|}
name|frchain_now
operator|=
name|frcP
expr_stmt|;
name|frag_now
operator|=
name|frcP
operator|->
name|frch_frag_now
expr_stmt|;
name|assert
argument_list|(
name|frchain_now
operator|->
name|frch_last
operator|==
name|frag_now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			subseg_set(segT, subsegT)  *  * If you attempt to change to the current subsegment, nothing happens.  *  * In:	segT, subsegT code for new subsegment.  *	frag_now -> incomplete frag for current subsegment.  *	If frag_now==NULL, then there is no old, incomplete frag, so  *	the old frag is not closed off.  *  * Out:	now_subseg, now_seg updated.  *	Frchain_now points to the (possibly new) struct frchain for this  *	sub-segment.  */
end_comment

begin_function
name|segT
name|subseg_get
parameter_list|(
specifier|const
name|char
modifier|*
name|segname
parameter_list|,
name|int
name|force_new
parameter_list|)
block|{
name|segT
name|secptr
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|now_seg_name
init|=
operator|(
name|now_seg
condition|?
name|bfd_get_section_name
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|force_new
operator|&&
name|now_seg_name
operator|&&
operator|(
name|now_seg_name
operator|==
name|segname
operator|||
operator|!
name|strcmp
argument_list|(
name|now_seg_name
argument_list|,
name|segname
argument_list|)
operator|)
condition|)
return|return
name|now_seg
return|;
if|if
condition|(
operator|!
name|force_new
condition|)
name|secptr
operator|=
name|bfd_make_section_old_way
argument_list|(
name|stdoutput
argument_list|,
name|segname
argument_list|)
expr_stmt|;
else|else
name|secptr
operator|=
name|bfd_make_section_anyway
argument_list|(
name|stdoutput
argument_list|,
name|segname
argument_list|)
expr_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|secptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
block|{
name|secptr
operator|->
name|output_section
operator|=
name|secptr
expr_stmt|;
name|seginfo
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|bfd_section
operator|=
name|secptr
expr_stmt|;
name|bfd_set_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|secptr
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
block|}
return|return
name|secptr
return|;
block|}
end_function

begin_function
name|segT
name|subseg_new
parameter_list|(
specifier|const
name|char
modifier|*
name|segname
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|segT
name|secptr
decl_stmt|;
name|secptr
operator|=
name|subseg_get
argument_list|(
name|segname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subseg_set_rest
argument_list|(
name|secptr
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
return|return
name|secptr
return|;
block|}
end_function

begin_comment
comment|/* Like subseg_new, except a new section is always created, even if    a section with that name already exists.  */
end_comment

begin_function
name|segT
name|subseg_force_new
parameter_list|(
specifier|const
name|char
modifier|*
name|segname
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|segT
name|secptr
decl_stmt|;
name|secptr
operator|=
name|subseg_get
argument_list|(
name|segname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|subseg_set_rest
argument_list|(
name|secptr
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
return|return
name|secptr
return|;
block|}
end_function

begin_function
name|void
name|subseg_set
parameter_list|(
name|segT
name|secptr
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|secptr
operator|==
name|now_seg
operator|&&
name|subseg
operator|==
name|now_subseg
operator|)
condition|)
name|subseg_set_rest
argument_list|(
name|secptr
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
name|mri_common_symbol
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|obj_sec_sym_ok_for_reloc
end_ifndef

begin_define
define|#
directive|define
name|obj_sec_sym_ok_for_reloc
parameter_list|(
name|SEC
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|symbolS
modifier|*
name|section_symbol
parameter_list|(
name|segT
name|sec
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|symbolS
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|seginfo
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|seginfo
operator|->
name|sym
condition|)
return|return
name|seginfo
operator|->
name|sym
return|;
ifndef|#
directive|ifndef
name|EMIT_SECTION_SYMBOLS
define|#
directive|define
name|EMIT_SECTION_SYMBOLS
value|1
endif|#
directive|endif
if|if
condition|(
operator|!
name|EMIT_SECTION_SYMBOLS
operator|||
name|symbol_table_frozen
condition|)
block|{
comment|/* Here we know it won't be going into the symbol table.  */
name|s
operator|=
name|symbol_create
argument_list|(
name|sec
operator|->
name|symbol
operator|->
name|name
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|segT
name|seg
decl_stmt|;
name|s
operator|=
name|symbol_find
argument_list|(
name|sec
operator|->
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* We have to make sure it is the right symbol when we 	 have multiple sections with the same section name.  */
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|(
operator|(
name|seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|sec
operator|&&
name|seg
operator|!=
name|undefined_section
operator|)
condition|)
name|s
operator|=
name|symbol_new
argument_list|(
name|sec
operator|->
name|symbol
operator|->
name|name
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seg
operator|==
name|undefined_section
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|s
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|s
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
block|}
name|S_CLEAR_EXTERNAL
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Use the BFD section symbol, if possible.  */
if|if
condition|(
name|obj_sec_sym_ok_for_reloc
argument_list|(
name|sec
argument_list|)
condition|)
name|symbol_set_bfdsym
argument_list|(
name|s
argument_list|,
name|sec
operator|->
name|symbol
argument_list|)
expr_stmt|;
else|else
name|symbol_get_bfdsym
argument_list|(
name|s
argument_list|)
operator|->
name|flags
operator||=
name|BSF_SECTION_SYM
expr_stmt|;
name|seginfo
operator|->
name|sym
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return whether the specified segment is thought to hold text.  */
end_comment

begin_function
name|int
name|subseg_text_p
parameter_list|(
name|segT
name|sec
parameter_list|)
block|{
return|return
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non zero if SEC has at least one byte of data.  It is    possible that we'll return zero even on a non-empty section because    we don't know all the fragment types, and it is possible that an    fr_fix == 0 one still contributes data.  Think of this as    seg_definitely_not_empty_p.  */
end_comment

begin_function
name|int
name|seg_not_empty_p
parameter_list|(
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|frchainS
modifier|*
name|chain
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
return|return
literal|0
return|;
for|for
control|(
name|chain
operator|=
name|seginfo
operator|->
name|frchainP
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|frch_next
control|)
block|{
for|for
control|(
name|frag
operator|=
name|chain
operator|->
name|frch_root
init|;
name|frag
condition|;
name|frag
operator|=
name|frag
operator|->
name|fr_next
control|)
if|if
condition|(
name|frag
operator|->
name|fr_fix
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|obstack_next_free
argument_list|(
operator|&
name|chain
operator|->
name|frch_obstack
argument_list|)
operator|!=
name|chain
operator|->
name|frch_last
operator|->
name|fr_literal
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|subsegs_print_statistics
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchp
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"frag chains:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
comment|/* Skip gas-internal sections.  */
if|if
condition|(
name|segment_name
argument_list|(
name|s
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
continue|continue;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
continue|continue;
for|for
control|(
name|frchp
operator|=
name|seginfo
operator|->
name|frchainP
init|;
name|frchp
condition|;
name|frchp
operator|=
name|frchp
operator|->
name|frch_next
control|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|fragp
decl_stmt|;
for|for
control|(
name|fragp
operator|=
name|frchp
operator|->
name|frch_root
init|;
name|fragp
condition|;
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
control|)
name|count
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%p %-10s\t%10d frags\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|frchp
argument_list|,
name|segment_name
argument_list|(
name|s
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end of subsegs.c */
end_comment

end_unit

