begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cond.c - conditional assembly pseudo-ops, and .include    Copyright (C) 1990, 91, 92, 93, 95, 96, 97, 98, 99, 2000    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* This is allocated to grow and shrink as .ifdef/.endif pairs are scanned. */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|cond_obstack
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|file_line
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We push one of these structures for each .if, and pop it at the    .endif.  */
end_comment

begin_struct
struct|struct
name|conditional_frame
block|{
comment|/* The source file& line number of the "if".  */
name|struct
name|file_line
name|if_file_line
decl_stmt|;
comment|/* The source file& line of the "else".  */
name|struct
name|file_line
name|else_file_line
decl_stmt|;
comment|/* The previous conditional.  */
name|struct
name|conditional_frame
modifier|*
name|previous_cframe
decl_stmt|;
comment|/* Have we seen an else yet?  */
name|int
name|else_seen
decl_stmt|;
comment|/* Whether we are currently ignoring input.  */
name|int
name|ignoring
decl_stmt|;
comment|/* Whether a conditional at a higher level is ignoring input.  */
name|int
name|dead_tree
decl_stmt|;
comment|/* Macro nesting level at which this conditional was created.  */
name|int
name|macro_nest
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|initialize_cframe
name|PARAMS
argument_list|(
operator|(
expr|struct
name|conditional_frame
operator|*
name|cframe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_mri_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|conditional_frame
modifier|*
name|current_cframe
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|s_ifdef
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
comment|/* points to name of symbol */
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Points to symbol */
name|struct
name|conditional_frame
name|cframe
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Leading whitespace is part of operand. */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|name
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid identifier for \".ifdef\""
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|cond_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|initialize_cframe
argument_list|(
operator|&
name|cframe
argument_list|)
expr_stmt|;
name|cframe
operator|.
name|ignoring
operator|=
name|cframe
operator|.
name|dead_tree
operator|||
operator|!
operator|(
operator|(
name|symbolP
operator|!=
literal|0
operator|)
operator|^
name|arg
operator|)
expr_stmt|;
name|current_cframe
operator|=
operator|(
operator|(
expr|struct
name|conditional_frame
operator|*
operator|)
name|obstack_copy
argument_list|(
operator|&
name|cond_obstack
argument_list|,
operator|&
name|cframe
argument_list|,
sizeof|sizeof
argument_list|(
name|cframe
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|LISTING_SKIP_COND
argument_list|()
operator|&&
name|cframe
operator|.
name|ignoring
operator|&&
operator|(
name|cframe
operator|.
name|previous_cframe
operator|==
name|NULL
operator|||
operator|!
name|cframe
operator|.
name|previous_cframe
operator|->
name|ignoring
operator|)
condition|)
name|listing_list
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* if a valid identifyer name */
block|}
end_function

begin_comment
comment|/* s_ifdef() */
end_comment

begin_function
name|void
name|s_if
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|expressionS
name|operand
decl_stmt|;
name|struct
name|conditional_frame
name|cframe
decl_stmt|;
name|int
name|t
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Leading whitespace is part of operand. */
if|if
condition|(
name|current_cframe
operator|!=
name|NULL
operator|&&
name|current_cframe
operator|->
name|ignoring
condition|)
block|{
name|operand
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|expression
argument_list|(
operator|&
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"non-constant expression in \".if\" statement"
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|operatorT
operator|)
name|arg
condition|)
block|{
case|case
name|O_eq
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|O_ne
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|O_lt
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|<
literal|0
expr_stmt|;
break|break;
case|case
name|O_le
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|<=
literal|0
expr_stmt|;
break|break;
case|case
name|O_ge
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|>=
literal|0
expr_stmt|;
break|break;
case|case
name|O_gt
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|>
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* If the above error is signaled, this will dispatch      using an undefined result.  No big deal.  */
name|initialize_cframe
argument_list|(
operator|&
name|cframe
argument_list|)
expr_stmt|;
name|cframe
operator|.
name|ignoring
operator|=
name|cframe
operator|.
name|dead_tree
operator|||
operator|!
name|t
expr_stmt|;
name|current_cframe
operator|=
operator|(
operator|(
expr|struct
name|conditional_frame
operator|*
operator|)
name|obstack_copy
argument_list|(
operator|&
name|cond_obstack
argument_list|,
operator|&
name|cframe
argument_list|,
sizeof|sizeof
argument_list|(
name|cframe
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|LISTING_SKIP_COND
argument_list|()
operator|&&
name|cframe
operator|.
name|ignoring
operator|&&
operator|(
name|cframe
operator|.
name|previous_cframe
operator|==
name|NULL
operator|||
operator|!
name|cframe
operator|.
name|previous_cframe
operator|->
name|ignoring
operator|)
condition|)
name|listing_list
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_if() */
end_comment

begin_comment
comment|/* Get a string for the MRI IFC or IFNC pseudo-ops.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_mri_string
parameter_list|(
name|terminator
parameter_list|,
name|len
parameter_list|)
name|int
name|terminator
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|s
operator|=
name|ret
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
condition|)
block|{
operator|++
name|s
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
operator|*
name|s
operator|++
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\''
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|input_line_pointer
operator|!=
name|terminator
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|s
operator|>
name|ret
operator|&&
operator|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
operator|--
name|s
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|s
operator|-
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* The MRI IFC and IFNC pseudo-ops.  */
end_comment

begin_function
name|void
name|s_ifc
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|int
name|res
decl_stmt|;
name|struct
name|conditional_frame
name|cframe
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|s1
operator|=
name|get_mri_string
argument_list|(
literal|','
argument_list|,
operator|&
name|len1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad format for ifc or ifnc"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|++
name|input_line_pointer
expr_stmt|;
name|s2
operator|=
name|get_mri_string
argument_list|(
literal|';'
argument_list|,
operator|&
name|len2
argument_list|)
expr_stmt|;
name|res
operator|=
name|len1
operator|==
name|len2
operator|&&
name|strncmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
expr_stmt|;
name|initialize_cframe
argument_list|(
operator|&
name|cframe
argument_list|)
expr_stmt|;
name|cframe
operator|.
name|ignoring
operator|=
name|cframe
operator|.
name|dead_tree
operator|||
operator|!
operator|(
name|res
operator|^
name|arg
operator|)
expr_stmt|;
name|current_cframe
operator|=
operator|(
operator|(
expr|struct
name|conditional_frame
operator|*
operator|)
name|obstack_copy
argument_list|(
operator|&
name|cond_obstack
argument_list|,
operator|&
name|cframe
argument_list|,
sizeof|sizeof
argument_list|(
name|cframe
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|LISTING_SKIP_COND
argument_list|()
operator|&&
name|cframe
operator|.
name|ignoring
operator|&&
operator|(
name|cframe
operator|.
name|previous_cframe
operator|==
name|NULL
operator|||
operator|!
name|cframe
operator|.
name|previous_cframe
operator|->
name|ignoring
operator|)
condition|)
name|listing_list
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_elseif
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|expressionS
name|operand
decl_stmt|;
name|int
name|t
decl_stmt|;
if|if
condition|(
name|current_cframe
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"\".elseif\" without matching \".if\" - ignored"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_cframe
operator|->
name|else_seen
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"\".elseif\" after \".else\" - ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|current_cframe
operator|->
name|else_file_line
operator|.
name|file
argument_list|,
name|current_cframe
operator|->
name|else_file_line
operator|.
name|line
argument_list|,
name|_
argument_list|(
literal|"here is the previous \"else\""
argument_list|)
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|current_cframe
operator|->
name|if_file_line
operator|.
name|file
argument_list|,
name|current_cframe
operator|->
name|if_file_line
operator|.
name|line
argument_list|,
name|_
argument_list|(
literal|"here is the previous \"if\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_where
argument_list|(
operator|&
name|current_cframe
operator|->
name|else_file_line
operator|.
name|file
argument_list|,
operator|&
name|current_cframe
operator|->
name|else_file_line
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_cframe
operator|->
name|dead_tree
condition|)
block|{
name|current_cframe
operator|->
name|ignoring
operator|=
operator|!
name|current_cframe
operator|->
name|ignoring
expr_stmt|;
if|if
condition|(
name|LISTING_SKIP_COND
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|current_cframe
operator|->
name|ignoring
condition|)
name|listing_list
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|listing_list
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if not a dead tree */
block|}
comment|/* if error else do it */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Leading whitespace is part of operand. */
if|if
condition|(
name|current_cframe
operator|!=
name|NULL
operator|&&
name|current_cframe
operator|->
name|ignoring
condition|)
block|{
name|operand
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|expression
argument_list|(
operator|&
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"non-constant expression in \".elseif\" statement"
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|operatorT
operator|)
name|arg
condition|)
block|{
case|case
name|O_eq
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|O_ne
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|O_lt
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|<
literal|0
expr_stmt|;
break|break;
case|case
name|O_le
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|<=
literal|0
expr_stmt|;
break|break;
case|case
name|O_ge
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|>=
literal|0
expr_stmt|;
break|break;
case|case
name|O_gt
case|:
name|t
operator|=
name|operand
operator|.
name|X_add_number
operator|>
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
name|current_cframe
operator|->
name|ignoring
operator|=
name|current_cframe
operator|->
name|dead_tree
operator|||
operator|!
name|t
expr_stmt|;
if|if
condition|(
name|LISTING_SKIP_COND
argument_list|()
operator|&&
name|current_cframe
operator|->
name|ignoring
operator|&&
operator|(
name|current_cframe
operator|->
name|previous_cframe
operator|==
name|NULL
operator|||
operator|!
name|current_cframe
operator|->
name|previous_cframe
operator|->
name|ignoring
operator|)
condition|)
name|listing_list
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_endif
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|conditional_frame
modifier|*
name|hold
decl_stmt|;
if|if
condition|(
name|current_cframe
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"\".endif\" without \".if\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LISTING_SKIP_COND
argument_list|()
operator|&&
name|current_cframe
operator|->
name|ignoring
operator|&&
operator|(
name|current_cframe
operator|->
name|previous_cframe
operator|==
name|NULL
operator|||
operator|!
name|current_cframe
operator|->
name|previous_cframe
operator|->
name|ignoring
operator|)
condition|)
name|listing_list
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hold
operator|=
name|current_cframe
expr_stmt|;
name|current_cframe
operator|=
name|current_cframe
operator|->
name|previous_cframe
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|cond_obstack
argument_list|,
name|hold
argument_list|)
expr_stmt|;
block|}
comment|/* if one pop too many */
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_endif() */
end_comment

begin_function
name|void
name|s_else
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|current_cframe
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".else without matching .if - ignored"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_cframe
operator|->
name|else_seen
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"duplicate \"else\" - ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|current_cframe
operator|->
name|else_file_line
operator|.
name|file
argument_list|,
name|current_cframe
operator|->
name|else_file_line
operator|.
name|line
argument_list|,
name|_
argument_list|(
literal|"here is the previous \"else\""
argument_list|)
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|current_cframe
operator|->
name|if_file_line
operator|.
name|file
argument_list|,
name|current_cframe
operator|->
name|if_file_line
operator|.
name|line
argument_list|,
name|_
argument_list|(
literal|"here is the previous \"if\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_where
argument_list|(
operator|&
name|current_cframe
operator|->
name|else_file_line
operator|.
name|file
argument_list|,
operator|&
name|current_cframe
operator|->
name|else_file_line
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_cframe
operator|->
name|dead_tree
condition|)
block|{
name|current_cframe
operator|->
name|ignoring
operator|=
operator|!
name|current_cframe
operator|->
name|ignoring
expr_stmt|;
if|if
condition|(
name|LISTING_SKIP_COND
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|current_cframe
operator|->
name|ignoring
condition|)
name|listing_list
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|listing_list
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if not a dead tree */
name|current_cframe
operator|->
name|else_seen
operator|=
literal|1
expr_stmt|;
block|}
comment|/* if error else do it */
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_else() */
end_comment

begin_function
name|void
name|s_ifeqs
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|int
name|res
decl_stmt|;
name|struct
name|conditional_frame
name|cframe
decl_stmt|;
name|s1
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len1
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".ifeqs syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|s2
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len2
argument_list|)
expr_stmt|;
name|res
operator|=
name|len1
operator|==
name|len2
operator|&&
name|strncmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
expr_stmt|;
name|initialize_cframe
argument_list|(
operator|&
name|cframe
argument_list|)
expr_stmt|;
name|cframe
operator|.
name|ignoring
operator|=
name|cframe
operator|.
name|dead_tree
operator|||
operator|!
operator|(
name|res
operator|^
name|arg
operator|)
expr_stmt|;
name|current_cframe
operator|=
operator|(
operator|(
expr|struct
name|conditional_frame
operator|*
operator|)
name|obstack_copy
argument_list|(
operator|&
name|cond_obstack
argument_list|,
operator|&
name|cframe
argument_list|,
sizeof|sizeof
argument_list|(
name|cframe
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|LISTING_SKIP_COND
argument_list|()
operator|&&
name|cframe
operator|.
name|ignoring
operator|&&
operator|(
name|cframe
operator|.
name|previous_cframe
operator|==
name|NULL
operator|||
operator|!
name|cframe
operator|.
name|previous_cframe
operator|->
name|ignoring
operator|)
condition|)
name|listing_list
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_ifeqs() */
end_comment

begin_function
name|int
name|ignore_input
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|NO_PSEUDO_DOT
operator|||
name|flag_m68k_mri
condition|)
block|{
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
operator|--
name|s
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
return|return
operator|(
name|current_cframe
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|current_cframe
operator|->
name|ignoring
operator|)
return|;
block|}
comment|/* We cannot ignore certain pseudo ops.  */
if|if
condition|(
operator|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'i'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'I'
operator|)
operator|&&
operator|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"if"
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"ifdef"
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"ifndef"
argument_list|,
literal|6
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'e'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'E'
operator|)
operator|&&
operator|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"else"
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"endif"
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"endc"
argument_list|,
literal|4
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|current_cframe
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|current_cframe
operator|->
name|ignoring
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ignore_input() */
end_comment

begin_function
specifier|static
name|void
name|initialize_cframe
parameter_list|(
name|cframe
parameter_list|)
name|struct
name|conditional_frame
modifier|*
name|cframe
decl_stmt|;
block|{
name|memset
argument_list|(
name|cframe
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cframe
argument_list|)
argument_list|)
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|cframe
operator|->
name|if_file_line
operator|.
name|file
argument_list|,
operator|&
name|cframe
operator|->
name|if_file_line
operator|.
name|line
argument_list|)
expr_stmt|;
name|cframe
operator|->
name|previous_cframe
operator|=
name|current_cframe
expr_stmt|;
name|cframe
operator|->
name|dead_tree
operator|=
name|current_cframe
operator|!=
name|NULL
operator|&&
name|current_cframe
operator|->
name|ignoring
expr_stmt|;
name|cframe
operator|->
name|macro_nest
operator|=
name|macro_nest
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Give an error if a conditional is unterminated inside a macro or    the assembly as a whole.  If NEST is non negative, we are being    called because of the end of a macro expansion.  If NEST is    negative, we are being called at the of the input files.  */
end_comment

begin_function
name|void
name|cond_finish_check
parameter_list|(
name|nest
parameter_list|)
name|int
name|nest
decl_stmt|;
block|{
if|if
condition|(
name|current_cframe
operator|!=
name|NULL
operator|&&
name|current_cframe
operator|->
name|macro_nest
operator|>=
name|nest
condition|)
block|{
if|if
condition|(
name|nest
operator|>=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"end of macro inside conditional"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"end of file inside conditional"
argument_list|)
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|current_cframe
operator|->
name|if_file_line
operator|.
name|file
argument_list|,
name|current_cframe
operator|->
name|if_file_line
operator|.
name|line
argument_list|,
name|_
argument_list|(
literal|"here is the start of the unterminated conditional"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_cframe
operator|->
name|else_seen
condition|)
name|as_bad_where
argument_list|(
name|current_cframe
operator|->
name|else_file_line
operator|.
name|file
argument_list|,
name|current_cframe
operator|->
name|else_file_line
operator|.
name|line
argument_list|,
name|_
argument_list|(
literal|"here is the \"else\" of the unterminated conditional"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called when we exit out of a macro.  We assume    that any conditionals which began within the macro are correctly    nested, and just pop them off the stack.  */
end_comment

begin_function
name|void
name|cond_exit_macro
parameter_list|(
name|nest
parameter_list|)
name|int
name|nest
decl_stmt|;
block|{
while|while
condition|(
name|current_cframe
operator|!=
name|NULL
operator|&&
name|current_cframe
operator|->
name|macro_nest
operator|>=
name|nest
condition|)
block|{
name|struct
name|conditional_frame
modifier|*
name|hold
decl_stmt|;
name|hold
operator|=
name|current_cframe
expr_stmt|;
name|current_cframe
operator|=
name|current_cframe
operator|->
name|previous_cframe
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|cond_obstack
argument_list|,
name|hold
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end of cond.c */
end_comment

end_unit

