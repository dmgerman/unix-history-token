begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ehopt.c--optimize gcc exception frame information.    Copyright 1998, 2000, 2001 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@cygnus.com>.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_comment
comment|/* We include this ELF file, even though we may not be assembling for    ELF, since the exception frame information is always in a format    derived from DWARF.  */
end_comment

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_comment
comment|/* Try to optimize gcc 2.8 exception frame information.     Exception frame information is emitted for every function in the    .eh_frame or .debug_frame sections.  Simple information for a function    with no exceptions looks like this:  __FRAME_BEGIN__: 	.4byte	.LLCIE1	/ Length of Common Information Entry .LSCIE1: #if .eh_frame 	.4byte	0x0	/ CIE Identifier Tag #elif .debug_frame 	.4byte	0xffffffff / CIE Identifier Tag #endif 	.byte	0x1	/ CIE Version 	.byte	0x0	/ CIE Augmentation (none) 	.byte	0x1	/ ULEB128 0x1 (CIE Code Alignment Factor) 	.byte	0x7c	/ SLEB128 -4 (CIE Data Alignment Factor) 	.byte	0x8	/ CIE RA Column 	.byte	0xc	/ DW_CFA_def_cfa 	.byte	0x4	/ ULEB128 0x4 	.byte	0x4	/ ULEB128 0x4 	.byte	0x88	/ DW_CFA_offset, column 0x8 	.byte	0x1	/ ULEB128 0x1 	.align 4 .LECIE1: 	.set	.LLCIE1,.LECIE1-.LSCIE1	/ CIE Length Symbol 	.4byte	.LLFDE1	/ FDE Length .LSFDE1: 	.4byte	.LSFDE1-__FRAME_BEGIN__	/ FDE CIE offset 	.4byte	.LFB1	/ FDE initial location 	.4byte	.LFE1-.LFB1	/ FDE address range 	.byte	0x4	/ DW_CFA_advance_loc4 	.4byte	.LCFI0-.LFB1 	.byte	0xe	/ DW_CFA_def_cfa_offset 	.byte	0x8	/ ULEB128 0x8 	.byte	0x85	/ DW_CFA_offset, column 0x5 	.byte	0x2	/ ULEB128 0x2 	.byte	0x4	/ DW_CFA_advance_loc4 	.4byte	.LCFI1-.LCFI0 	.byte	0xd	/ DW_CFA_def_cfa_register 	.byte	0x5	/ ULEB128 0x5 	.byte	0x4	/ DW_CFA_advance_loc4 	.4byte	.LCFI2-.LCFI1 	.byte	0x2e	/ DW_CFA_GNU_args_size 	.byte	0x4	/ ULEB128 0x4 	.byte	0x4	/ DW_CFA_advance_loc4 	.4byte	.LCFI3-.LCFI2 	.byte	0x2e	/ DW_CFA_GNU_args_size 	.byte	0x0	/ ULEB128 0x0 	.align 4 .LEFDE1: 	.set	.LLFDE1,.LEFDE1-.LSFDE1	/ FDE Length Symbol     The immediate issue we can address in the assembler is the    DW_CFA_advance_loc4 followed by a four byte value.  The value is    the difference of two addresses in the function.  Since gcc does    not know this value, it always uses four bytes.  We will know the    value at the end of assembly, so we can do better.  */
end_comment

begin_struct
struct|struct
name|cie_info
block|{
name|unsigned
name|code_alignment
decl_stmt|;
name|int
name|z_augmentation
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|get_cie_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cie_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extract information from the CIE.  */
end_comment

begin_function
specifier|static
name|int
name|get_cie_info
parameter_list|(
name|info
parameter_list|)
name|struct
name|cie_info
modifier|*
name|info
decl_stmt|;
block|{
name|fragS
modifier|*
name|f
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
name|CIE_id
decl_stmt|;
name|char
name|augmentation
index|[
literal|10
index|]
decl_stmt|;
name|int
name|iaug
decl_stmt|;
name|int
name|code_alignment
init|=
literal|0
decl_stmt|;
comment|/* We should find the CIE at the start of the section.  */
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
name|defined
argument_list|(
name|MANY_SEGMENTS
argument_list|)
name|f
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
else|#
directive|else
name|f
operator|=
name|frchain_now
operator|->
name|frch_root
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|fix
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|frchainP
operator|->
name|fix_root
expr_stmt|;
else|#
directive|else
name|fix
operator|=
operator|*
name|seg_fix_rootP
expr_stmt|;
endif|#
directive|endif
comment|/* Look through the frags of the section to find the code alignment.  */
comment|/* First make sure that the CIE Identifier Tag is 0/-1.  */
if|if
condition|(
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
literal|".debug_frame"
argument_list|)
operator|==
literal|0
condition|)
name|CIE_id
operator|=
operator|(
name|char
operator|)
literal|0xff
expr_stmt|;
else|else
name|CIE_id
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|f
operator|->
name|fr_fix
operator|-
name|offset
operator|<
literal|4
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|!=
name|CIE_id
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|!=
name|CIE_id
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|2
index|]
operator|!=
name|CIE_id
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
operator|!=
name|CIE_id
condition|)
return|return
literal|0
return|;
comment|/* Next make sure the CIE version number is 1.  */
name|offset
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|f
operator|->
name|fr_fix
operator|-
name|offset
operator|<
literal|1
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Skip the augmentation (a null terminated string).  */
name|iaug
operator|=
literal|0
expr_stmt|;
operator|++
name|offset
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|offset
operator|<
name|f
operator|->
name|fr_fix
operator|&&
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|iaug
operator|<
operator|(
sizeof|sizeof
name|augmentation
operator|)
operator|-
literal|1
condition|)
block|{
name|augmentation
index|[
name|iaug
index|]
operator|=
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
expr_stmt|;
operator|++
name|iaug
expr_stmt|;
block|}
operator|++
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
name|f
operator|->
name|fr_fix
condition|)
break|break;
block|}
operator|++
name|offset
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|augmentation
index|[
name|iaug
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* No augmentation.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|augmentation
argument_list|,
literal|"eh"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We have to skip a pointer.  Unfortunately, we don't know how 	 large it is.  We find out by looking for a matching fixup.  */
while|while
condition|(
name|fix
operator|!=
name|NULL
operator|&&
operator|(
name|fix
operator|->
name|fx_frag
operator|!=
name|f
operator|||
name|fix
operator|->
name|fx_where
operator|!=
name|offset
operator|)
condition|)
name|fix
operator|=
name|fix
operator|->
name|fx_next
expr_stmt|;
if|if
condition|(
name|fix
operator|==
name|NULL
condition|)
name|offset
operator|+=
literal|4
expr_stmt|;
else|else
name|offset
operator|+=
name|fix
operator|->
name|fx_size
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|augmentation
index|[
literal|0
index|]
operator|!=
literal|'z'
condition|)
return|return
literal|0
return|;
comment|/* We're now at the code alignment factor, which is a ULEB128.  If      it isn't a single byte, forget it.  */
name|code_alignment
operator|=
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|code_alignment
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|code_alignment
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|code_alignment
operator|=
name|code_alignment
expr_stmt|;
name|info
operator|->
name|z_augmentation
operator|=
operator|(
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function is called from emit_expr.  It looks for cases which    we can optimize.     Rather than try to parse all this information as we read it, we    look for a single byte DW_CFA_advance_loc4 followed by a 4 byte    difference.  We turn that into a rs_cfa_advance frag, and handle    those frags at the end of the assembly.  If the gcc output changes    somewhat, this optimization may stop working.     This function returns non-zero if it handled the expression and    emit_expr should not do anything, or zero otherwise.  It can also    change *EXP and *PNBYTES.  */
end_comment

begin_function
name|int
name|check_eh_frame
parameter_list|(
name|exp
parameter_list|,
name|pnbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pnbytes
decl_stmt|;
block|{
struct|struct
name|frame_data
block|{
enum|enum
name|frame_state
block|{
name|state_idle
block|,
name|state_saw_size
block|,
name|state_saw_cie_offset
block|,
name|state_saw_pc_begin
block|,
name|state_seeing_aug_size
block|,
name|state_skipping_aug
block|,
name|state_wait_loc4
block|,
name|state_saw_loc4
block|,
name|state_error
block|,     }
name|state
enum|;
name|int
name|cie_info_ok
decl_stmt|;
name|struct
name|cie_info
name|cie_info
decl_stmt|;
name|symbolS
modifier|*
name|size_end_sym
decl_stmt|;
name|fragS
modifier|*
name|loc4_frag
decl_stmt|;
name|int
name|loc4_fix
decl_stmt|;
name|int
name|aug_size
decl_stmt|;
name|int
name|aug_shift
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|frame_data
name|eh_frame_data
decl_stmt|;
specifier|static
name|struct
name|frame_data
name|debug_frame_data
decl_stmt|;
name|struct
name|frame_data
modifier|*
name|d
decl_stmt|;
comment|/* Don't optimize.  */
if|if
condition|(
name|flag_traditional_format
condition|)
return|return
literal|0
return|;
comment|/* Select the proper section data.  */
if|if
condition|(
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
literal|".eh_frame"
argument_list|)
operator|==
literal|0
condition|)
name|d
operator|=
operator|&
name|eh_frame_data
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
literal|".debug_frame"
argument_list|)
operator|==
literal|0
condition|)
name|d
operator|=
operator|&
name|debug_frame_data
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|state
operator|>=
name|state_saw_size
operator|&&
name|S_IS_DEFINED
argument_list|(
name|d
operator|->
name|size_end_sym
argument_list|)
condition|)
block|{
comment|/* We have come to the end of the CIE or FDE.  See below where          we set saw_size.  We must check this first because we may now          be looking at the next size.  */
name|d
operator|->
name|state
operator|=
name|state_idle
expr_stmt|;
block|}
switch|switch
condition|(
name|d
operator|->
name|state
condition|)
block|{
case|case
name|state_idle
case|:
if|if
condition|(
operator|*
name|pnbytes
operator|==
literal|4
condition|)
block|{
comment|/* This might be the size of the CIE or FDE.  We want to know 	     the size so that we don't accidentally optimize across an FDE 	     boundary.  We recognize the size in one of two forms: a 	     symbol which will later be defined as a difference, or a 	     subtraction of two symbols.  Either way, we can tell when we 	     are at the end of the FDE because the symbol becomes defined 	     (in the case of a subtraction, the end symbol, from which the 	     start symbol is being subtracted).  Other ways of describing 	     the size will not be optimized.  */
if|if
condition|(
operator|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_subtract
operator|)
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
condition|)
block|{
name|d
operator|->
name|state
operator|=
name|state_saw_size
expr_stmt|;
name|d
operator|->
name|size_end_sym
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
block|}
block|}
break|break;
case|case
name|state_saw_size
case|:
case|case
name|state_saw_cie_offset
case|:
comment|/* Assume whatever form it appears in, it appears atomically.  */
name|d
operator|->
name|state
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|state_saw_pc_begin
case|:
comment|/* Decide whether we should see an augmentation.  */
if|if
condition|(
operator|!
name|d
operator|->
name|cie_info_ok
operator|&&
operator|!
operator|(
name|d
operator|->
name|cie_info_ok
operator|=
name|get_cie_info
argument_list|(
operator|&
name|d
operator|->
name|cie_info
argument_list|)
operator|)
condition|)
name|d
operator|->
name|state
operator|=
name|state_error
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|cie_info
operator|.
name|z_augmentation
condition|)
block|{
name|d
operator|->
name|state
operator|=
name|state_seeing_aug_size
expr_stmt|;
name|d
operator|->
name|aug_size
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|aug_shift
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|d
operator|->
name|state
operator|=
name|state_wait_loc4
expr_stmt|;
break|break;
case|case
name|state_seeing_aug_size
case|:
comment|/* Bytes == -1 means this comes from an leb128 directive.  */
if|if
condition|(
operator|(
name|int
operator|)
operator|*
name|pnbytes
operator|==
operator|-
literal|1
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|d
operator|->
name|aug_size
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|state_skipping_aug
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pnbytes
operator|==
literal|1
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|unsigned
name|char
name|byte
init|=
name|exp
operator|->
name|X_add_number
decl_stmt|;
name|d
operator|->
name|aug_size
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|d
operator|->
name|aug_shift
expr_stmt|;
name|d
operator|->
name|aug_shift
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|state
operator|=
name|state_skipping_aug
expr_stmt|;
block|}
else|else
name|d
operator|->
name|state
operator|=
name|state_error
expr_stmt|;
break|break;
case|case
name|state_skipping_aug
case|:
if|if
condition|(
operator|(
name|int
operator|)
operator|*
name|pnbytes
operator|<
literal|0
condition|)
name|d
operator|->
name|state
operator|=
name|state_error
expr_stmt|;
else|else
block|{
name|int
name|left
init|=
operator|(
name|d
operator|->
name|aug_size
operator|-=
operator|*
name|pnbytes
operator|)
decl_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
name|d
operator|->
name|state
operator|=
name|state_wait_loc4
expr_stmt|;
elseif|else
if|if
condition|(
name|left
operator|<
literal|0
condition|)
name|d
operator|->
name|state
operator|=
name|state_error
expr_stmt|;
block|}
break|break;
case|case
name|state_wait_loc4
case|:
if|if
condition|(
operator|*
name|pnbytes
operator|==
literal|1
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
operator|->
name|X_add_number
operator|==
name|DW_CFA_advance_loc4
condition|)
block|{
comment|/* This might be a DW_CFA_advance_loc4.  Record the frag and the 	     position within the frag, so that we can change it later.  */
name|frag_grow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|state_saw_loc4
expr_stmt|;
name|d
operator|->
name|loc4_frag
operator|=
name|frag_now
expr_stmt|;
name|d
operator|->
name|loc4_fix
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|state_saw_loc4
case|:
name|d
operator|->
name|state
operator|=
name|state_wait_loc4
expr_stmt|;
if|if
condition|(
operator|*
name|pnbytes
operator|!=
literal|4
condition|)
break|break;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* This is a case which we can optimize.  The two symbols being 	     subtracted were in the same frag and the expression was 	     reduced to a constant.  We can do the optimization entirely 	     in this function.  */
if|if
condition|(
name|d
operator|->
name|cie_info
operator|.
name|code_alignment
operator|>
literal|0
operator|&&
name|exp
operator|->
name|X_add_number
operator|%
name|d
operator|->
name|cie_info
operator|.
name|code_alignment
operator|==
literal|0
operator|&&
name|exp
operator|->
name|X_add_number
operator|/
name|d
operator|->
name|cie_info
operator|.
name|code_alignment
operator|<
literal|0x40
condition|)
block|{
name|d
operator|->
name|loc4_frag
operator|->
name|fr_literal
index|[
name|d
operator|->
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc
operator||
operator|(
name|exp
operator|->
name|X_add_number
operator|/
name|d
operator|->
name|cie_info
operator|.
name|code_alignment
operator|)
expr_stmt|;
comment|/* No more bytes needed.  */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
literal|0x100
condition|)
block|{
name|d
operator|->
name|loc4_frag
operator|->
name|fr_literal
index|[
name|d
operator|->
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc1
expr_stmt|;
operator|*
name|pnbytes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
name|d
operator|->
name|loc4_frag
operator|->
name|fr_literal
index|[
name|d
operator|->
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc2
expr_stmt|;
operator|*
name|pnbytes
operator|=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_subtract
condition|)
block|{
comment|/* This is a case we can optimize.  The expression was not 	     reduced, so we can not finish the optimization until the end 	     of the assembly.  We set up a variant frag which we handle 	     later.  */
name|int
name|fr_subtype
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|cie_info
operator|.
name|code_alignment
operator|>
literal|0
condition|)
name|fr_subtype
operator|=
name|d
operator|->
name|cie_info
operator|.
name|code_alignment
operator|<<
literal|3
expr_stmt|;
else|else
name|fr_subtype
operator|=
literal|0
expr_stmt|;
name|frag_var
argument_list|(
name|rs_cfa
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|fr_subtype
argument_list|,
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
argument_list|,
name|d
operator|->
name|loc4_fix
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|loc4_frag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|state_error
case|:
comment|/* Just skipping everything.  */
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The function estimates the size of a rs_cfa variant frag based on    the current values of the symbols.  It is called before the    relaxation loop.  We set fr_subtype{0:2} to the expected length.  */
end_comment

begin_function
name|int
name|eh_frame_estimate_size_before_relax
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|offsetT
name|diff
decl_stmt|;
name|int
name|ca
init|=
name|frag
operator|->
name|fr_subtype
operator|>>
literal|3
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|diff
operator|=
name|resolve_symbol_value
argument_list|(
name|frag
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|>
literal|0
operator|&&
name|diff
operator|%
name|ca
operator|==
literal|0
operator|&&
name|diff
operator|/
name|ca
operator|<
literal|0x40
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|diff
operator|<
literal|0x100
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|diff
operator|<
literal|0x10000
condition|)
name|ret
operator|=
literal|2
expr_stmt|;
else|else
name|ret
operator|=
literal|4
expr_stmt|;
name|frag
operator|->
name|fr_subtype
operator|=
operator|(
name|frag
operator|->
name|fr_subtype
operator|&
operator|~
literal|7
operator|)
operator||
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This function relaxes a rs_cfa variant frag based on the current    values of the symbols.  fr_subtype{0:2} is the current length of    the frag.  This returns the change in frag length.  */
end_comment

begin_function
name|int
name|eh_frame_relax_frag
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|int
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|oldsize
operator|=
name|frag
operator|->
name|fr_subtype
operator|&
literal|7
expr_stmt|;
name|newsize
operator|=
name|eh_frame_estimate_size_before_relax
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
name|newsize
operator|-
name|oldsize
return|;
block|}
end_function

begin_comment
comment|/* This function converts a rs_cfa variant frag into a normal fill    frag.  This is called after all relaxation has been done.    fr_subtype{0:2} will be the desired length of the frag.  */
end_comment

begin_function
name|void
name|eh_frame_convert_frag
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|offsetT
name|diff
decl_stmt|;
name|fragS
modifier|*
name|loc4_frag
decl_stmt|;
name|int
name|loc4_fix
decl_stmt|;
name|loc4_frag
operator|=
operator|(
name|fragS
operator|*
operator|)
name|frag
operator|->
name|fr_opcode
expr_stmt|;
name|loc4_fix
operator|=
operator|(
name|int
operator|)
name|frag
operator|->
name|fr_offset
expr_stmt|;
name|diff
operator|=
name|resolve_symbol_value
argument_list|(
name|frag
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|frag
operator|->
name|fr_subtype
operator|&
literal|7
condition|)
block|{
case|case
literal|0
case|:
block|{
name|int
name|ca
init|=
name|frag
operator|->
name|fr_subtype
operator|>>
literal|3
decl_stmt|;
name|assert
argument_list|(
name|ca
operator|>
literal|0
operator|&&
name|diff
operator|%
name|ca
operator|==
literal|0
operator|&&
name|diff
operator|/
name|ca
operator|<
literal|0x40
argument_list|)
expr_stmt|;
name|loc4_frag
operator|->
name|fr_literal
index|[
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc
operator||
operator|(
name|diff
operator|/
name|ca
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|assert
argument_list|(
name|diff
operator|<
literal|0x100
argument_list|)
expr_stmt|;
name|loc4_frag
operator|->
name|fr_literal
index|[
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc1
expr_stmt|;
name|frag
operator|->
name|fr_literal
index|[
name|frag
operator|->
name|fr_fix
index|]
operator|=
name|diff
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|assert
argument_list|(
name|diff
operator|<
literal|0x10000
argument_list|)
expr_stmt|;
name|loc4_frag
operator|->
name|fr_literal
index|[
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc2
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|frag
operator|->
name|fr_literal
operator|+
name|frag
operator|->
name|fr_fix
argument_list|,
name|diff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|md_number_to_chars
argument_list|(
name|frag
operator|->
name|fr_literal
operator|+
name|frag
operator|->
name|fr_fix
argument_list|,
name|diff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
name|frag
operator|->
name|fr_fix
operator|+=
name|frag
operator|->
name|fr_subtype
operator|&
literal|7
expr_stmt|;
name|frag
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|frag
operator|->
name|fr_subtype
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|fr_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

