begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ehopt.c--optimize gcc exception frame information.    Copyright (C) 1998 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@cygnus.com>.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_comment
comment|/* We include this ELF file, even though we may not be assembling for    ELF, since the exception frame information is always in a format    derived from DWARF.  */
end_comment

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_comment
comment|/* Try to optimize gcc 2.8 exception frame information.     Exception frame information is emitted for every function in the    .eh_frame section.  Simple information for a function with no    exceptions looks like this:  __FRAME_BEGIN__: 	.4byte	.LLCIE1	/ Length of Common Information Entry .LSCIE1: 	.4byte	0x0	/ CIE Identifier Tag 	.byte	0x1	/ CIE Version 	.byte	0x0	/ CIE Augmentation (none) 	.byte	0x1	/ ULEB128 0x1 (CIE Code Alignment Factor) 	.byte	0x7c	/ SLEB128 -4 (CIE Data Alignment Factor) 	.byte	0x8	/ CIE RA Column 	.byte	0xc	/ DW_CFA_def_cfa 	.byte	0x4	/ ULEB128 0x4 	.byte	0x4	/ ULEB128 0x4 	.byte	0x88	/ DW_CFA_offset, column 0x8 	.byte	0x1	/ ULEB128 0x1 	.align 4 .LECIE1: 	.set	.LLCIE1,.LECIE1-.LSCIE1	/ CIE Length Symbol 	.4byte	.LLFDE1	/ FDE Length .LSFDE1: 	.4byte	.LSFDE1-__FRAME_BEGIN__	/ FDE CIE offset 	.4byte	.LFB1	/ FDE initial location 	.4byte	.LFE1-.LFB1	/ FDE address range 	.byte	0x4	/ DW_CFA_advance_loc4 	.4byte	.LCFI0-.LFB1 	.byte	0xe	/ DW_CFA_def_cfa_offset 	.byte	0x8	/ ULEB128 0x8 	.byte	0x85	/ DW_CFA_offset, column 0x5 	.byte	0x2	/ ULEB128 0x2 	.byte	0x4	/ DW_CFA_advance_loc4 	.4byte	.LCFI1-.LCFI0 	.byte	0xd	/ DW_CFA_def_cfa_register 	.byte	0x5	/ ULEB128 0x5 	.byte	0x4	/ DW_CFA_advance_loc4 	.4byte	.LCFI2-.LCFI1 	.byte	0x2e	/ DW_CFA_GNU_args_size 	.byte	0x4	/ ULEB128 0x4 	.byte	0x4	/ DW_CFA_advance_loc4 	.4byte	.LCFI3-.LCFI2 	.byte	0x2e	/ DW_CFA_GNU_args_size 	.byte	0x0	/ ULEB128 0x0 	.align 4 .LEFDE1: 	.set	.LLFDE1,.LEFDE1-.LSFDE1	/ FDE Length Symbol     The immediate issue we can address in the assembler is the    DW_CFA_advance_loc4 followed by a four byte value.  The value is    the difference of two addresses in the function.  Since gcc does    not know this value, it always uses four bytes.  We will know the    value at the end of assembly, so we can do better.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|eh_frame_code_alignment
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the code alignment factor from the CIE.  */
end_comment

begin_function
specifier|static
name|int
name|eh_frame_code_alignment
parameter_list|()
block|{
specifier|static
name|int
name|code_alignment
decl_stmt|;
name|segT
name|current_seg
decl_stmt|;
name|subsegT
name|current_subseg
decl_stmt|;
name|fragS
modifier|*
name|f
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
name|augmentation
index|[
literal|10
index|]
decl_stmt|;
name|int
name|iaug
decl_stmt|;
if|if
condition|(
name|code_alignment
operator|!=
literal|0
condition|)
return|return
name|code_alignment
return|;
comment|/* We should find the CIE at the start of the .eh_frame section.  */
name|current_seg
operator|=
name|now_seg
expr_stmt|;
name|current_subseg
operator|=
name|now_subseg
expr_stmt|;
name|subseg_new
argument_list|(
literal|".eh_frame"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
name|defined
argument_list|(
name|MANY_SEGMENTS
argument_list|)
name|f
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
else|#
directive|else
name|f
operator|=
name|frchain_now
operator|->
name|frch_root
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|fix
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|frchainP
operator|->
name|fix_root
expr_stmt|;
else|#
directive|else
name|fix
operator|=
operator|*
name|seg_fix_rootP
expr_stmt|;
endif|#
directive|endif
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
comment|/* Look through the frags of the section to find the code alignment.  */
comment|/* First make sure that the CIE Identifier Tag is 0.  */
name|offset
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|f
operator|->
name|fr_fix
operator|-
name|offset
operator|<
literal|4
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|!=
literal|0
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|!=
literal|0
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|2
index|]
operator|!=
literal|0
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
operator|!=
literal|0
condition|)
block|{
name|code_alignment
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Next make sure the CIE version number is 1.  */
name|offset
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|f
operator|->
name|fr_fix
operator|-
name|offset
operator|<
literal|1
operator|||
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|!=
literal|1
condition|)
block|{
name|code_alignment
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Skip the augmentation (a null terminated string).  */
name|iaug
operator|=
literal|0
expr_stmt|;
operator|++
name|offset
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|code_alignment
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|offset
operator|<
name|f
operator|->
name|fr_fix
operator|&&
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|iaug
operator|<
operator|(
sizeof|sizeof
name|augmentation
operator|)
operator|-
literal|1
condition|)
block|{
name|augmentation
index|[
name|iaug
index|]
operator|=
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
expr_stmt|;
operator|++
name|iaug
expr_stmt|;
block|}
operator|++
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
name|f
operator|->
name|fr_fix
condition|)
break|break;
block|}
operator|++
name|offset
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|code_alignment
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|augmentation
index|[
name|iaug
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* No augmentation.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|augmentation
argument_list|,
literal|"eh"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We have to skip a pointer.  Unfortunately, we don't know how 	 large it is.  We find out by looking for a matching fixup.  */
while|while
condition|(
name|fix
operator|!=
name|NULL
operator|&&
operator|(
name|fix
operator|->
name|fx_frag
operator|!=
name|f
operator|||
name|fix
operator|->
name|fx_where
operator|!=
name|offset
operator|)
condition|)
name|fix
operator|=
name|fix
operator|->
name|fx_next
expr_stmt|;
if|if
condition|(
name|fix
operator|==
name|NULL
condition|)
name|offset
operator|+=
literal|4
expr_stmt|;
else|else
name|offset
operator|+=
name|fix
operator|->
name|fx_size
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|offset
operator|>=
name|f
operator|->
name|fr_fix
condition|)
block|{
name|offset
operator|-=
name|f
operator|->
name|fr_fix
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|code_alignment
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|code_alignment
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* We're now at the code alignment factor, which is a ULEB128.  If      it isn't a single byte, forget it.  */
name|code_alignment
operator|=
name|f
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|code_alignment
operator|&
literal|0x80
operator|)
operator|!=
literal|0
operator|||
name|code_alignment
operator|==
literal|0
condition|)
block|{
name|code_alignment
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|code_alignment
return|;
block|}
end_function

begin_comment
comment|/* This function is called from emit_expr.  It looks for cases which    we can optimize.     Rather than try to parse all this information as we read it, we    look for a single byte DW_CFA_advance_loc4 followed by a 4 byte    difference.  We turn that into a rs_cfa_advance frag, and handle    those frags at the end of the assembly.  If the gcc output changes    somewhat, this optimization may stop working.     This function returns non-zero if it handled the expression and    emit_expr should not do anything, or zero otherwise.  It can also    change *EXP and *PNBYTES.  */
end_comment

begin_function
name|int
name|check_eh_frame
parameter_list|(
name|exp
parameter_list|,
name|pnbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pnbytes
decl_stmt|;
block|{
specifier|static
name|int
name|saw_advance_loc4
decl_stmt|;
specifier|static
name|fragS
modifier|*
name|loc4_frag
decl_stmt|;
specifier|static
name|int
name|loc4_fix
decl_stmt|;
if|if
condition|(
name|flag_traditional_format
condition|)
block|{
comment|/* Don't optimize.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
literal|".eh_frame"
argument_list|)
operator|!=
literal|0
condition|)
name|saw_advance_loc4
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|pnbytes
operator|==
literal|1
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
operator|->
name|X_add_number
operator|==
name|DW_CFA_advance_loc4
condition|)
block|{
comment|/* This might be a DW_CFA_advance_loc4.  Record the frag and the          position within the frag, so that we can change it later.  */
name|saw_advance_loc4
operator|=
literal|1
expr_stmt|;
name|frag_grow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|loc4_frag
operator|=
name|frag_now
expr_stmt|;
name|loc4_fix
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|saw_advance_loc4
operator|&&
operator|*
name|pnbytes
operator|==
literal|4
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|ca
decl_stmt|;
comment|/* This is a case which we can optimize.  The two symbols being          subtracted were in the same frag and the expression was          reduced to a constant.  We can do the optimization entirely          in this function.  */
name|saw_advance_loc4
operator|=
literal|0
expr_stmt|;
name|ca
operator|=
name|eh_frame_code_alignment
argument_list|()
expr_stmt|;
if|if
condition|(
name|ca
operator|<
literal|0
condition|)
block|{
comment|/* Don't optimize.  */
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|%
name|ca
operator|==
literal|0
operator|&&
name|exp
operator|->
name|X_add_number
operator|/
name|ca
operator|<
literal|0x40
condition|)
block|{
name|loc4_frag
operator|->
name|fr_literal
index|[
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc
operator||
operator|(
name|exp
operator|->
name|X_add_number
operator|/
name|ca
operator|)
expr_stmt|;
comment|/* No more bytes needed.  */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
literal|0x100
condition|)
block|{
name|loc4_frag
operator|->
name|fr_literal
index|[
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc1
expr_stmt|;
operator|*
name|pnbytes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
name|loc4_frag
operator|->
name|fr_literal
index|[
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc2
expr_stmt|;
operator|*
name|pnbytes
operator|=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|saw_advance_loc4
operator|&&
operator|*
name|pnbytes
operator|==
literal|4
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_subtract
condition|)
block|{
comment|/* This is a case we can optimize.  The expression was not          reduced, so we can not finish the optimization until the end          of the assembly.  We set up a variant frag which we handle          later.  */
name|saw_advance_loc4
operator|=
literal|0
expr_stmt|;
name|frag_var
argument_list|(
name|rs_cfa
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
argument_list|,
name|loc4_fix
argument_list|,
operator|(
name|char
operator|*
operator|)
name|loc4_frag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|saw_advance_loc4
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The function estimates the size of a rs_cfa variant frag based on    the current values of the symbols.  It is called before the    relaxation loop.  We set fr_subtype to the expected length.  */
end_comment

begin_function
name|int
name|eh_frame_estimate_size_before_relax
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|int
name|ca
decl_stmt|;
name|offsetT
name|diff
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ca
operator|=
name|eh_frame_code_alignment
argument_list|()
expr_stmt|;
name|diff
operator|=
name|resolve_symbol_value
argument_list|(
name|frag
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|<
literal|0
condition|)
name|ret
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|diff
operator|%
name|ca
operator|==
literal|0
operator|&&
name|diff
operator|/
name|ca
operator|<
literal|0x40
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|diff
operator|<
literal|0x100
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|diff
operator|<
literal|0x10000
condition|)
name|ret
operator|=
literal|2
expr_stmt|;
else|else
name|ret
operator|=
literal|4
expr_stmt|;
name|frag
operator|->
name|fr_subtype
operator|=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This function relaxes a rs_cfa variant frag based on the current    values of the symbols.  fr_subtype is the current length of the    frag.  This returns the change in frag length.  */
end_comment

begin_function
name|int
name|eh_frame_relax_frag
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|int
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|oldsize
operator|=
name|frag
operator|->
name|fr_subtype
expr_stmt|;
name|newsize
operator|=
name|eh_frame_estimate_size_before_relax
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
name|newsize
operator|-
name|oldsize
return|;
block|}
end_function

begin_comment
comment|/* This function converts a rs_cfa variant frag into a normal fill    frag.  This is called after all relaxation has been done.    fr_subtype will be the desired length of the frag.  */
end_comment

begin_function
name|void
name|eh_frame_convert_frag
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|offsetT
name|diff
decl_stmt|;
name|fragS
modifier|*
name|loc4_frag
decl_stmt|;
name|int
name|loc4_fix
decl_stmt|;
name|loc4_frag
operator|=
operator|(
name|fragS
operator|*
operator|)
name|frag
operator|->
name|fr_opcode
expr_stmt|;
name|loc4_fix
operator|=
operator|(
name|int
operator|)
name|frag
operator|->
name|fr_offset
expr_stmt|;
name|diff
operator|=
name|resolve_symbol_value
argument_list|(
name|frag
operator|->
name|fr_symbol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|fr_subtype
operator|==
literal|0
condition|)
block|{
name|int
name|ca
decl_stmt|;
name|ca
operator|=
name|eh_frame_code_alignment
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|ca
operator|>
literal|0
operator|&&
name|diff
operator|%
name|ca
operator|==
literal|0
operator|&&
name|diff
operator|/
name|ca
operator|<
literal|0x40
argument_list|)
expr_stmt|;
name|loc4_frag
operator|->
name|fr_literal
index|[
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc
operator||
operator|(
name|diff
operator|/
name|ca
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frag
operator|->
name|fr_subtype
operator|==
literal|1
condition|)
block|{
name|assert
argument_list|(
name|diff
operator|<
literal|0x100
argument_list|)
expr_stmt|;
name|loc4_frag
operator|->
name|fr_literal
index|[
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc1
expr_stmt|;
name|frag
operator|->
name|fr_literal
index|[
name|frag
operator|->
name|fr_fix
index|]
operator|=
name|diff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frag
operator|->
name|fr_subtype
operator|==
literal|2
condition|)
block|{
name|assert
argument_list|(
name|diff
operator|<
literal|0x10000
argument_list|)
expr_stmt|;
name|loc4_frag
operator|->
name|fr_literal
index|[
name|loc4_fix
index|]
operator|=
name|DW_CFA_advance_loc2
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|frag
operator|->
name|fr_literal
operator|+
name|frag
operator|->
name|fr_fix
argument_list|,
name|diff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|md_number_to_chars
argument_list|(
name|frag
operator|->
name|fr_literal
operator|+
name|frag
operator|->
name|fr_fix
argument_list|,
name|diff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|frag
operator|->
name|fr_fix
operator|+=
name|frag
operator|->
name|fr_subtype
expr_stmt|;
name|frag
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|frag
operator|->
name|fr_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

