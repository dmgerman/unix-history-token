begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* messages.c - error reporter -    Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.    This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_VARARGS
end_ifdef

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_STDARG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_VARARGS
argument_list|)
end_if

begin_comment
comment|/* Roll our own.  */
end_comment

begin_define
define|#
directive|define
name|va_alist
value|REST
end_define

begin_define
define|#
directive|define
name|va_dcl
end_define

begin_typedef
typedef|typedef
name|int
modifier|*
name|va_list
typedef|;
end_typedef

begin_define
define|#
directive|define
name|va_start
parameter_list|(
name|ARGS
parameter_list|)
value|ARGS =&REST
end_define

begin_define
define|#
directive|define
name|va_end
parameter_list|(
name|ARGS
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|identify
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|as_show_where
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|as_warn_internal
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|as_bad_internal
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Despite the rest of the comments in this file, (FIXME-SOON),  * here is the current scheme for error messages etc:  *  * as_fatal() is used when gas is quite confused and  * continuing the assembly is pointless.  In this case we  * exit immediately with error status.  *  * as_bad() is used to mark errors that result in what we  * presume to be a useless object file.  Say, we ignored  * something that might have been vital.  If we see any of  * these, assembly will continue to the end of the source,  * no object file will be produced, and we will terminate  * with error status.  The new option, -Z, tells us to  * produce an object file anyway but we still exit with  * error status.  The assumption here is that you don't want  * this object file but we could be wrong.  *  * as_warn() is used when we have an error from which we  * have a plausible error recovery.  eg, masking the top  * bits of a constant that is longer than will fit in the  * destination.  In this case we will continue to assemble  * the source, although we may have made a bad assumption,  * and we will produce an object file and return normal exit  * status (ie, no error).  The new option -X tells us to  * treat all as_warn() errors as as_bad() errors.  That is,  * no object file will be produced and we will exit with  * error status.  The idea here is that we don't kill an  * entire make because of an error that we knew how to  * correct.  On the other hand, sometimes you might want to  * stop the make at these points.  *  * as_tsktsk() is used when we see a minor error for which  * our error recovery action is almost certainly correct.  * In this case, we print a message and then assembly  * continues as though no error occurred.  */
end_comment

begin_function
specifier|static
name|void
name|identify
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|static
name|int
name|identified
decl_stmt|;
if|if
condition|(
name|identified
condition|)
return|return;
name|identified
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|unsigned
name|int
name|x
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Assembler messages:\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|warning_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of number of warnings issued */
end_comment

begin_function
name|int
name|had_warnings
parameter_list|()
block|{
return|return
operator|(
name|warning_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we've hit a 'bad error', and should not write an obj file,    and exit with a nonzero error code */
end_comment

begin_decl_stmt
specifier|static
name|int
name|error_count
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|had_errors
parameter_list|()
block|{
return|return
operator|(
name|error_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print the current location to stderr.  */
end_comment

begin_function
specifier|static
name|void
name|as_show_where
parameter_list|()
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|identify
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			a s _ p e r r o r  *  * Like perror(3), but with more info.  */
end_comment

begin_function
name|void
name|as_perror
parameter_list|(
name|gripe
parameter_list|,
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|gripe
decl_stmt|;
comment|/* Unpunctuated error theme. */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|errtxt
decl_stmt|;
name|as_show_where
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gripe
argument_list|,
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|errtxt
operator|=
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|errtxt
operator|=
name|xstrerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|errtxt
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *			a s _ t s k t s k ()  *  * Send to stderr a string as a warning, and locate warning  * in input file(s).  * Please only use this for when we have some recovery action.  * Please explain in string (which may have '\n's) what recovery was done.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_tsktsk
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|as_show_where
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* as_tsktsk() */
end_comment

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|as_tsktsk
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|as_show_where
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* as_tsktsk() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* The common portion of as_warn and as_warn_where.  */
end_comment

begin_function
specifier|static
name|void
name|as_warn_internal
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|buffer
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
operator|++
name|warning_count
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|identify
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Warning: "
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
name|listing_warning
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *			a s _ w a r n ()  *  * Send to stderr a string as a warning, and locate warning  * in input file(s).  * Please only use this for when we have some recovery action.  * Please explain in string (which may have '\n's) what recovery was done.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_no_warnings
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_warn_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* as_warn() */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*VARARGS1 */
end_comment

begin_function
name|void
name|as_warn
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_no_warnings
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_warn_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* as_warn() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* as_warn_where, like as_bad but the file name and line number are    passed in.  Unfortunately, we have to repeat the function in order    to handle the varargs correctly and portably.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_warn_where
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_no_warnings
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_warn_internal
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* as_warn() */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*VARARGS1 */
end_comment

begin_function
name|void
name|as_warn_where
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_no_warnings
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_warn_internal
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* as_warn() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* The common portion of as_bad and as_bad_where.  */
end_comment

begin_function
specifier|static
name|void
name|as_bad_internal
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|buffer
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
operator|++
name|error_count
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|identify
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Error: "
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
name|listing_error
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *			a s _ b a d ()  *  * Send to stderr a string as a warning, and locate warning in input file(s).  * Please us when there is no recovery, but we want to continue processing  * but not produce an object file.  * Please explain in string (which may have '\n's) what recovery was done.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_bad
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_bad_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*VARARGS1 */
end_comment

begin_function
name|void
name|as_bad
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_bad_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* as_bad_where, like as_bad but the file name and line number are    passed in.  Unfortunately, we have to repeat the function in order    to handle the varargs correctly and portably.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_bad_where
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_bad_internal
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*VARARGS1 */
end_comment

begin_function
name|void
name|as_bad_where
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_bad_internal
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/*  *			a s _ f a t a l ()  *  * Send to stderr a string as a fatal message, and print location of error in  * input file(s).  * Please only use this for when we DON'T have some recovery action.  * It xexit()s with a warning status.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|as_show_where
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Fatal error: "
argument_list|)
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* as_fatal() */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|as_fatal
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|as_show_where
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Fatal error: "
argument_list|)
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* as_fatal() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/*  * as_assert: Indicate assertion failure.  * Arguments: Filename, line number, optional function name.  */
end_comment

begin_function
name|void
name|as_assert
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|fn
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|fn
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|as_show_where
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Internal error!\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Assertion failure in %s at %s line %d.\n"
argument_list|)
argument_list|,
name|fn
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Assertion failure at %s line %d.\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Please report this bug.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* as_abort: Print a friendly message saying how totally hosed we are,    and exit without producing a core file.  */
end_comment

begin_function
name|void
name|as_abort
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|fn
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|fn
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|as_show_where
argument_list|()
expr_stmt|;
if|if
condition|(
name|fn
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Internal error, aborting at %s line %d in %s\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Internal error, aborting at %s line %d\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Please report this bug.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Support routines.  */
end_comment

begin_function
name|void
name|fprint_value
parameter_list|(
name|file
parameter_list|,
name|val
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|valueT
name|val
decl_stmt|;
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
block|{
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sprint_value
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
block|{
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of messages.c */
end_comment

end_unit

