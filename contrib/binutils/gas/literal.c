begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* as.c - GAS literal pool management.    Copyright (C) 1994 Free Software Foundation, Inc.    Written by Ken Raeburn (raeburn@cygnus.com).     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_comment
comment|/* This isn't quite a "constant" pool.  Some of the values may get    adjusted at run time, e.g., for symbolic relocations when shared    libraries are in use.  It's more of a "literal" pool.     On the Alpha, this should be used for .lita and .lit8.  (Is there    ever a .lit4?)  On the MIPS, it could be used for .lit4 as well.     The expressions passed here should contain either constants or symbols,    not a combination of both.  Typically, the constant pool is accessed    with some sort of GP register, so the size of the pool must be kept down    if possible.  The exception is section offsets -- if you're storing a    pointer to the start of .data, for example, and your machine provides    for 16-bit signed addends, you might want to store .data+32K, so that    you can access all of the first 64K of .data with the one pointer.     This isn't a requirement, just a guideline that can help keep .o file    size down.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
name|defined
argument_list|(
name|NEED_LITERAL_POOL
argument_list|)
end_if

begin_function
name|valueT
name|add_to_literal_pool
parameter_list|(
name|sym
parameter_list|,
name|addend
parameter_list|,
name|sec
parameter_list|,
name|size
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|valueT
name|addend
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|segT
name|current_section
init|=
name|now_seg
decl_stmt|;
name|int
name|current_subsec
init|=
name|now_subseg
decl_stmt|;
name|valueT
name|offset
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* @@ This assumes all entries in a given section will be of the same      size...  Probably correct, but unwise to rely on.  */
comment|/* This must always be called with the same subsegment.  */
if|if
condition|(
name|seginfo
operator|->
name|frchainP
condition|)
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|fix_root
init|;
name|fixp
operator|!=
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
operator|,
name|offset
operator|+=
name|size
control|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|==
name|sym
operator|&&
name|fixp
operator|->
name|fx_offset
operator|==
name|addend
condition|)
return|return
name|offset
return|;
block|}
name|subseg_set
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|reloc_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|reloc_type
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|sym
argument_list|,
name|addend
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_section
argument_list|,
name|current_subsec
argument_list|)
expr_stmt|;
name|offset
operator|=
name|seginfo
operator|->
name|literal_pool_size
expr_stmt|;
name|seginfo
operator|->
name|literal_pool_size
operator|+=
name|size
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

end_unit

