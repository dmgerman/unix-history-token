begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dw2gencfi.c - Support for generating Dwarf2 CFI information.    Copyright 2003 Free Software Foundation, Inc.    Contributed by Michal Ludvig<mludvig@suse.cz>     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"dw2gencfi.h"
end_include

begin_comment
comment|/* We re-use DWARF2_LINE_MIN_INSN_LENGTH for the code alignment field    of the CIE.  Default to 1 if not otherwise specified.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_LINE_MIN_INSN_LENGTH
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_LINE_MIN_INSN_LENGTH
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If TARGET_USE_CFIPOP is defined, it is required that the target    provide the following definitions.  Otherwise provide them to     allow compilation to continue.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_USE_CFIPOP
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_DEFAULT_RETURN_COLUMN
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_DEFAULT_RETURN_COLUMN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_CIE_DATA_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_CIE_DATA_ALIGNMENT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EH_FRAME_ALIGNMENT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_define
define|#
directive|define
name|EH_FRAME_ALIGNMENT
value|(bfd_get_arch_size (stdoutput) == 64 ? 3 : 2)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EH_FRAME_ALIGNMENT
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|tc_cfi_frame_initial_instructions
end_ifndef

begin_define
define|#
directive|define
name|tc_cfi_frame_initial_instructions
parameter_list|()
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|cfi_insn_data
block|{
name|struct
name|cfi_insn_data
modifier|*
name|next
decl_stmt|;
name|int
name|insn
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|unsigned
name|reg
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
block|}
name|ri
struct|;
struct|struct
block|{
name|unsigned
name|reg1
decl_stmt|;
name|unsigned
name|reg2
decl_stmt|;
block|}
name|rr
struct|;
name|unsigned
name|r
decl_stmt|;
name|offsetT
name|i
decl_stmt|;
struct|struct
block|{
name|symbolS
modifier|*
name|lab1
decl_stmt|;
name|symbolS
modifier|*
name|lab2
decl_stmt|;
block|}
name|ll
struct|;
struct|struct
name|cfi_escape_data
block|{
name|struct
name|cfi_escape_data
modifier|*
name|next
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
block|}
modifier|*
name|esc
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fde_entry
block|{
name|struct
name|fde_entry
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|start_address
decl_stmt|;
name|symbolS
modifier|*
name|end_address
decl_stmt|;
name|struct
name|cfi_insn_data
modifier|*
name|data
decl_stmt|;
name|struct
name|cfi_insn_data
modifier|*
modifier|*
name|last
decl_stmt|;
name|unsigned
name|int
name|return_column
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cie_entry
block|{
name|struct
name|cie_entry
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|start_address
decl_stmt|;
name|unsigned
name|int
name|return_column
decl_stmt|;
name|struct
name|cfi_insn_data
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Current open FDE entry.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fde_entry
modifier|*
name|cur_fde_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|last_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|offsetT
name|cur_cfa_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of FDE entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fde_entry
modifier|*
name|all_fde_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fde_entry
modifier|*
modifier|*
name|last_fde_data
init|=
operator|&
name|all_fde_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of CIEs so that they could be reused.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cie_entry
modifier|*
name|cie_root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of old CFI data, for save/restore.  */
end_comment

begin_struct
struct|struct
name|cfa_save_data
block|{
name|struct
name|cfa_save_data
modifier|*
name|next
decl_stmt|;
name|offsetT
name|cfa_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cfa_save_data
modifier|*
name|cfa_save_stack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Construct a new FDE structure and add it to the end of the fde list.  */
end_comment

begin_function
specifier|static
name|struct
name|fde_entry
modifier|*
name|alloc_fde_entry
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|fde_entry
modifier|*
name|fde
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fde_entry
argument_list|)
argument_list|)
decl_stmt|;
name|cur_fde_data
operator|=
name|fde
expr_stmt|;
operator|*
name|last_fde_data
operator|=
name|fde
expr_stmt|;
name|last_fde_data
operator|=
operator|&
name|fde
operator|->
name|next
expr_stmt|;
name|fde
operator|->
name|last
operator|=
operator|&
name|fde
operator|->
name|data
expr_stmt|;
name|fde
operator|->
name|return_column
operator|=
name|DWARF2_DEFAULT_RETURN_COLUMN
expr_stmt|;
return|return
name|fde
return|;
block|}
end_function

begin_comment
comment|/* The following functions are available for a backend to construct its    own unwind information, usually from legacy unwind directives.  */
end_comment

begin_comment
comment|/* Construct a new INSN structure and add it to the end of the insn list    for the currently active FDE.  */
end_comment

begin_function
specifier|static
name|struct
name|cfi_insn_data
modifier|*
name|alloc_cfi_insn_data
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cfi_insn_data
modifier|*
name|insn
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cfi_insn_data
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|cur_fde_data
operator|->
name|last
operator|=
name|insn
expr_stmt|;
name|cur_fde_data
operator|->
name|last
operator|=
operator|&
name|insn
operator|->
name|next
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Construct a new FDE structure that begins at LABEL.  */
end_comment

begin_function
name|void
name|cfi_new_fde
parameter_list|(
name|symbolS
modifier|*
name|label
parameter_list|)
block|{
name|struct
name|fde_entry
modifier|*
name|fde
init|=
name|alloc_fde_entry
argument_list|()
decl_stmt|;
name|fde
operator|->
name|start_address
operator|=
name|label
expr_stmt|;
name|last_address
operator|=
name|label
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End the currently open FDE.  */
end_comment

begin_function
name|void
name|cfi_end_fde
parameter_list|(
name|symbolS
modifier|*
name|label
parameter_list|)
block|{
name|cur_fde_data
operator|->
name|end_address
operator|=
name|label
expr_stmt|;
name|cur_fde_data
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the return column for the current FDE.  */
end_comment

begin_function
name|void
name|cfi_set_return_column
parameter_list|(
name|unsigned
name|regno
parameter_list|)
block|{
name|cur_fde_data
operator|->
name|return_column
operator|=
name|regno
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Universal functions to store new instructions.  */
end_comment

begin_function
specifier|static
name|void
name|cfi_add_CFA_insn
parameter_list|(
name|int
name|insn
parameter_list|)
block|{
name|struct
name|cfi_insn_data
modifier|*
name|insn_ptr
init|=
name|alloc_cfi_insn_data
argument_list|()
decl_stmt|;
name|insn_ptr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfi_add_CFA_insn_reg
parameter_list|(
name|int
name|insn
parameter_list|,
name|unsigned
name|regno
parameter_list|)
block|{
name|struct
name|cfi_insn_data
modifier|*
name|insn_ptr
init|=
name|alloc_cfi_insn_data
argument_list|()
decl_stmt|;
name|insn_ptr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|insn_ptr
operator|->
name|u
operator|.
name|r
operator|=
name|regno
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfi_add_CFA_insn_offset
parameter_list|(
name|int
name|insn
parameter_list|,
name|offsetT
name|offset
parameter_list|)
block|{
name|struct
name|cfi_insn_data
modifier|*
name|insn_ptr
init|=
name|alloc_cfi_insn_data
argument_list|()
decl_stmt|;
name|insn_ptr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|insn_ptr
operator|->
name|u
operator|.
name|i
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfi_add_CFA_insn_reg_reg
parameter_list|(
name|int
name|insn
parameter_list|,
name|unsigned
name|reg1
parameter_list|,
name|unsigned
name|reg2
parameter_list|)
block|{
name|struct
name|cfi_insn_data
modifier|*
name|insn_ptr
init|=
name|alloc_cfi_insn_data
argument_list|()
decl_stmt|;
name|insn_ptr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|insn_ptr
operator|->
name|u
operator|.
name|rr
operator|.
name|reg1
operator|=
name|reg1
expr_stmt|;
name|insn_ptr
operator|->
name|u
operator|.
name|rr
operator|.
name|reg2
operator|=
name|reg2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfi_add_CFA_insn_reg_offset
parameter_list|(
name|int
name|insn
parameter_list|,
name|unsigned
name|regno
parameter_list|,
name|offsetT
name|offset
parameter_list|)
block|{
name|struct
name|cfi_insn_data
modifier|*
name|insn_ptr
init|=
name|alloc_cfi_insn_data
argument_list|()
decl_stmt|;
name|insn_ptr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|insn_ptr
operator|->
name|u
operator|.
name|ri
operator|.
name|reg
operator|=
name|regno
expr_stmt|;
name|insn_ptr
operator|->
name|u
operator|.
name|ri
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a CFI insn to advance the PC from the last address to LABEL.  */
end_comment

begin_function
name|void
name|cfi_add_advance_loc
parameter_list|(
name|symbolS
modifier|*
name|label
parameter_list|)
block|{
name|struct
name|cfi_insn_data
modifier|*
name|insn
init|=
name|alloc_cfi_insn_data
argument_list|()
decl_stmt|;
name|insn
operator|->
name|insn
operator|=
name|DW_CFA_advance_loc
expr_stmt|;
name|insn
operator|->
name|u
operator|.
name|ll
operator|.
name|lab1
operator|=
name|last_address
expr_stmt|;
name|insn
operator|->
name|u
operator|.
name|ll
operator|.
name|lab2
operator|=
name|label
expr_stmt|;
name|last_address
operator|=
name|label
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a DW_CFA_offset record to the CFI data.  */
end_comment

begin_function
name|void
name|cfi_add_CFA_offset
parameter_list|(
name|unsigned
name|regno
parameter_list|,
name|offsetT
name|offset
parameter_list|)
block|{
name|unsigned
name|int
name|abs_data_align
decl_stmt|;
name|cfi_add_CFA_insn_reg_offset
argument_list|(
name|DW_CFA_offset
argument_list|,
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|abs_data_align
operator|=
operator|(
name|DWARF2_CIE_DATA_ALIGNMENT
operator|<
literal|0
condition|?
operator|-
name|DWARF2_CIE_DATA_ALIGNMENT
else|:
name|DWARF2_CIE_DATA_ALIGNMENT
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|%
name|abs_data_align
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register save offset not a multiple of %u"
argument_list|)
argument_list|,
name|abs_data_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a DW_CFA_def_cfa record to the CFI data.  */
end_comment

begin_function
name|void
name|cfi_add_CFA_def_cfa
parameter_list|(
name|unsigned
name|regno
parameter_list|,
name|offsetT
name|offset
parameter_list|)
block|{
name|cfi_add_CFA_insn_reg_offset
argument_list|(
name|DW_CFA_def_cfa
argument_list|,
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|cur_cfa_offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a DW_CFA_register record to the CFI data.  */
end_comment

begin_function
name|void
name|cfi_add_CFA_register
parameter_list|(
name|unsigned
name|reg1
parameter_list|,
name|unsigned
name|reg2
parameter_list|)
block|{
name|cfi_add_CFA_insn_reg_reg
argument_list|(
name|DW_CFA_register
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a DW_CFA_def_cfa_register record to the CFI data.  */
end_comment

begin_function
name|void
name|cfi_add_CFA_def_cfa_register
parameter_list|(
name|unsigned
name|regno
parameter_list|)
block|{
name|cfi_add_CFA_insn_reg
argument_list|(
name|DW_CFA_def_cfa_register
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a DW_CFA_def_cfa_offset record to the CFI data.  */
end_comment

begin_function
name|void
name|cfi_add_CFA_def_cfa_offset
parameter_list|(
name|offsetT
name|offset
parameter_list|)
block|{
name|cfi_add_CFA_insn_offset
argument_list|(
name|DW_CFA_def_cfa_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|cur_cfa_offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfi_add_CFA_restore
parameter_list|(
name|unsigned
name|regno
parameter_list|)
block|{
name|cfi_add_CFA_insn_reg
argument_list|(
name|DW_CFA_restore
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfi_add_CFA_undefined
parameter_list|(
name|unsigned
name|regno
parameter_list|)
block|{
name|cfi_add_CFA_insn_reg
argument_list|(
name|DW_CFA_undefined
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfi_add_CFA_same_value
parameter_list|(
name|unsigned
name|regno
parameter_list|)
block|{
name|cfi_add_CFA_insn_reg
argument_list|(
name|DW_CFA_same_value
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfi_add_CFA_remember_state
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cfa_save_data
modifier|*
name|p
decl_stmt|;
name|cfi_add_CFA_insn
argument_list|(
name|DW_CFA_remember_state
argument_list|)
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|cfa_offset
operator|=
name|cur_cfa_offset
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|cfa_save_stack
expr_stmt|;
name|cfa_save_stack
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfi_add_CFA_restore_state
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cfa_save_data
modifier|*
name|p
decl_stmt|;
name|cfi_add_CFA_insn
argument_list|(
name|DW_CFA_restore_state
argument_list|)
expr_stmt|;
name|p
operator|=
name|cfa_save_stack
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|cur_cfa_offset
operator|=
name|p
operator|->
name|cfa_offset
expr_stmt|;
name|cfa_save_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse CFI assembler directives.  */
end_comment

begin_function_decl
specifier|static
name|void
name|dot_cfi
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dot_cfi_escape
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dot_cfi_startproc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dot_cfi_endproc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Fake CFI type; outside the byte range of any real CFI insn.  */
end_comment

begin_define
define|#
directive|define
name|CFI_adjust_cfa_offset
value|0x100
end_define

begin_define
define|#
directive|define
name|CFI_return_column
value|0x101
end_define

begin_define
define|#
directive|define
name|CFI_rel_offset
value|0x102
end_define

begin_define
define|#
directive|define
name|CFI_escape
value|0x103
end_define

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|cfi_pseudo_table
index|[]
init|=
block|{
block|{
literal|"cfi_startproc"
block|,
name|dot_cfi_startproc
block|,
literal|0
block|}
block|,
block|{
literal|"cfi_endproc"
block|,
name|dot_cfi_endproc
block|,
literal|0
block|}
block|,
block|{
literal|"cfi_def_cfa"
block|,
name|dot_cfi
block|,
name|DW_CFA_def_cfa
block|}
block|,
block|{
literal|"cfi_def_cfa_register"
block|,
name|dot_cfi
block|,
name|DW_CFA_def_cfa_register
block|}
block|,
block|{
literal|"cfi_def_cfa_offset"
block|,
name|dot_cfi
block|,
name|DW_CFA_def_cfa_offset
block|}
block|,
block|{
literal|"cfi_adjust_cfa_offset"
block|,
name|dot_cfi
block|,
name|CFI_adjust_cfa_offset
block|}
block|,
block|{
literal|"cfi_offset"
block|,
name|dot_cfi
block|,
name|DW_CFA_offset
block|}
block|,
block|{
literal|"cfi_rel_offset"
block|,
name|dot_cfi
block|,
name|CFI_rel_offset
block|}
block|,
block|{
literal|"cfi_register"
block|,
name|dot_cfi
block|,
name|DW_CFA_register
block|}
block|,
block|{
literal|"cfi_return_column"
block|,
name|dot_cfi
block|,
name|CFI_return_column
block|}
block|,
block|{
literal|"cfi_restore"
block|,
name|dot_cfi
block|,
name|DW_CFA_restore
block|}
block|,
block|{
literal|"cfi_undefined"
block|,
name|dot_cfi
block|,
name|DW_CFA_undefined
block|}
block|,
block|{
literal|"cfi_same_value"
block|,
name|dot_cfi
block|,
name|DW_CFA_same_value
block|}
block|,
block|{
literal|"cfi_remember_state"
block|,
name|dot_cfi
block|,
name|DW_CFA_remember_state
block|}
block|,
block|{
literal|"cfi_restore_state"
block|,
name|dot_cfi
block|,
name|DW_CFA_restore_state
block|}
block|,
block|{
literal|"cfi_window_save"
block|,
name|dot_cfi
block|,
name|DW_CFA_GNU_window_save
block|}
block|,
block|{
literal|"cfi_escape"
block|,
name|dot_cfi_escape
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cfi_parse_separator
parameter_list|(
name|void
parameter_list|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing separator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|cfi_parse_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|tc_regname_to_dw2regnum
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|(
operator|*
name|input_line_pointer
operator|==
literal|'%'
operator|&&
name|is_name_beginner
argument_list|(
operator|*
operator|++
name|input_line_pointer
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|=
name|tc_regname_to_dw2regnum
argument_list|(
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register expression"
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
return|return
name|regno
return|;
block|}
endif|#
directive|endif
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
name|regno
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register expression"
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|regno
return|;
block|}
end_function

begin_function
specifier|static
name|offsetT
name|cfi_parse_const
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|get_absolute_expression
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_cfi
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
name|offsetT
name|offset
decl_stmt|;
name|unsigned
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
if|if
condition|(
operator|!
name|cur_fde_data
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"CFI instruction used without previous .cfi_startproc"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the last address was not at the current PC, advance to current.  */
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|last_address
argument_list|)
operator|!=
name|frag_now
operator|||
name|S_GET_VALUE
argument_list|(
name|last_address
argument_list|)
operator|!=
name|frag_now_fix
argument_list|()
condition|)
name|cfi_add_advance_loc
argument_list|(
name|symbol_temp_new_now
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|arg
condition|)
block|{
case|case
name|DW_CFA_offset
case|:
name|reg1
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_parse_separator
argument_list|()
expr_stmt|;
name|offset
operator|=
name|cfi_parse_const
argument_list|()
expr_stmt|;
name|cfi_add_CFA_offset
argument_list|(
name|reg1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFI_rel_offset
case|:
name|reg1
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_parse_separator
argument_list|()
expr_stmt|;
name|offset
operator|=
name|cfi_parse_const
argument_list|()
expr_stmt|;
name|cfi_add_CFA_offset
argument_list|(
name|reg1
argument_list|,
name|offset
operator|-
name|cur_cfa_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|reg1
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_parse_separator
argument_list|()
expr_stmt|;
name|offset
operator|=
name|cfi_parse_const
argument_list|()
expr_stmt|;
name|cfi_add_CFA_def_cfa
argument_list|(
name|reg1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|reg1
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_parse_separator
argument_list|()
expr_stmt|;
name|reg2
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_add_CFA_register
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|reg1
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_add_CFA_def_cfa_register
argument_list|(
name|reg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|offset
operator|=
name|cfi_parse_const
argument_list|()
expr_stmt|;
name|cfi_add_CFA_def_cfa_offset
argument_list|(
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFI_adjust_cfa_offset
case|:
name|offset
operator|=
name|cfi_parse_const
argument_list|()
expr_stmt|;
name|cfi_add_CFA_def_cfa_offset
argument_list|(
name|cur_cfa_offset
operator|+
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore
case|:
name|reg1
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_add_CFA_restore
argument_list|(
name|reg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
name|reg1
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_add_CFA_undefined
argument_list|(
name|reg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_same_value
case|:
name|reg1
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_add_CFA_same_value
argument_list|(
name|reg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFI_return_column
case|:
name|reg1
operator|=
name|cfi_parse_reg
argument_list|()
expr_stmt|;
name|cfi_set_return_column
argument_list|(
name|reg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_remember_state
case|:
name|cfi_add_CFA_remember_state
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_state
case|:
name|cfi_add_CFA_restore_state
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_window_save
case|:
name|cfi_add_CFA_insn
argument_list|(
name|DW_CFA_GNU_window_save
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_cfi_escape
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|cfi_escape_data
modifier|*
name|head
decl_stmt|,
modifier|*
modifier|*
name|tail
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|struct
name|cfi_insn_data
modifier|*
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|cur_fde_data
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"CFI instruction used without previous .cfi_startproc"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the last address was not at the current PC, advance to current.  */
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|last_address
argument_list|)
operator|!=
name|frag_now
operator|||
name|S_GET_VALUE
argument_list|(
name|last_address
argument_list|)
operator|!=
name|frag_now_fix
argument_list|()
condition|)
name|cfi_add_advance_loc
argument_list|(
name|symbol_temp_new_now
argument_list|()
argument_list|)
expr_stmt|;
name|tail
operator|=
operator|&
name|head
expr_stmt|;
do|do
block|{
name|e
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|do_parse_cons_expression
argument_list|(
operator|&
name|e
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tail
operator|=
name|e
expr_stmt|;
name|tail
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
operator|*
name|tail
operator|=
name|NULL
expr_stmt|;
name|insn
operator|=
name|alloc_cfi_insn_data
argument_list|()
expr_stmt|;
name|insn
operator|->
name|insn
operator|=
name|CFI_escape
expr_stmt|;
name|insn
operator|->
name|u
operator|.
name|esc
operator|=
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_cfi_startproc
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|simple
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cur_fde_data
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"previous CFI entry not closed (missing .cfi_endproc)"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|cfi_new_fde
argument_list|(
name|symbol_temp_new_now
argument_list|()
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"simple"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|simple
operator|=
literal|1
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
else|else
name|input_line_pointer
operator|=
name|name
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|simple
condition|)
name|tc_cfi_frame_initial_instructions
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_cfi_endproc
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cur_fde_data
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".cfi_endproc without corresponding .cfi_startproc"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|cfi_end_fde
argument_list|(
name|symbol_temp_new_now
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a single byte into the current segment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|out_one
parameter_list|(
name|int
name|byte
parameter_list|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a two-byte word into the current segment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|out_two
parameter_list|(
name|int
name|data
parameter_list|)
block|{
name|md_number_to_chars
argument_list|(
name|frag_more
argument_list|(
literal|2
argument_list|)
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a four byte word into the current segment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|out_four
parameter_list|(
name|int
name|data
parameter_list|)
block|{
name|md_number_to_chars
argument_list|(
name|frag_more
argument_list|(
literal|4
argument_list|)
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an unsigned "little-endian base 128" number.  */
end_comment

begin_function
specifier|static
name|void
name|out_uleb128
parameter_list|(
name|addressT
name|value
parameter_list|)
block|{
name|output_leb128
argument_list|(
name|frag_more
argument_list|(
name|sizeof_leb128
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an unsigned "little-endian base 128" number.  */
end_comment

begin_function
specifier|static
name|void
name|out_sleb128
parameter_list|(
name|offsetT
name|value
parameter_list|)
block|{
name|output_leb128
argument_list|(
name|frag_more
argument_list|(
name|sizeof_leb128
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_cfi_insn
parameter_list|(
name|struct
name|cfi_insn_data
modifier|*
name|insn
parameter_list|)
block|{
name|offsetT
name|offset
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
switch|switch
condition|(
name|insn
operator|->
name|insn
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
block|{
name|symbolS
modifier|*
name|from
init|=
name|insn
operator|->
name|u
operator|.
name|ll
operator|.
name|lab1
decl_stmt|;
name|symbolS
modifier|*
name|to
init|=
name|insn
operator|->
name|u
operator|.
name|ll
operator|.
name|lab2
decl_stmt|;
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|to
argument_list|)
operator|==
name|symbol_get_frag
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|addressT
name|delta
init|=
name|S_GET_VALUE
argument_list|(
name|to
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|addressT
name|scaled
init|=
name|delta
operator|/
name|DWARF2_LINE_MIN_INSN_LENGTH
decl_stmt|;
if|if
condition|(
name|scaled
operator|<=
literal|0x3F
condition|)
name|out_one
argument_list|(
name|DW_CFA_advance_loc
operator|+
name|scaled
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<=
literal|0xFF
condition|)
block|{
name|out_one
argument_list|(
name|DW_CFA_advance_loc1
argument_list|)
expr_stmt|;
name|out_one
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delta
operator|<=
literal|0xFFFF
condition|)
block|{
name|out_one
argument_list|(
name|DW_CFA_advance_loc2
argument_list|)
expr_stmt|;
name|out_two
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out_one
argument_list|(
name|DW_CFA_advance_loc4
argument_list|)
expr_stmt|;
name|out_four
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|expressionS
name|exp
decl_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|to
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|from
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* The code in ehopt.c expects that one byte of the encoding 	       is already allocated to the frag.  This comes from the way 	       that it scans the .eh_frame section looking first for the 	       .byte DW_CFA_advance_loc4.  */
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_cfa
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|DWARF2_LINE_MIN_INSN_LENGTH
operator|<<
literal|3
argument_list|,
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|frag_now
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|offset
operator|=
name|insn
operator|->
name|u
operator|.
name|ri
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|out_one
argument_list|(
name|DW_CFA_def_cfa_sf
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|insn
operator|->
name|u
operator|.
name|ri
operator|.
name|reg
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out_one
argument_list|(
name|DW_CFA_def_cfa
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|insn
operator|->
name|u
operator|.
name|ri
operator|.
name|reg
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
name|out_one
argument_list|(
name|insn
operator|->
name|insn
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|insn
operator|->
name|u
operator|.
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|offset
operator|=
name|insn
operator|->
name|u
operator|.
name|i
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|out_one
argument_list|(
name|DW_CFA_def_cfa_offset_sf
argument_list|)
expr_stmt|;
name|out_sleb128
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out_one
argument_list|(
name|DW_CFA_def_cfa_offset
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_restore
case|:
name|regno
operator|=
name|insn
operator|->
name|u
operator|.
name|r
expr_stmt|;
if|if
condition|(
name|regno
operator|<=
literal|0x3F
condition|)
block|{
name|out_one
argument_list|(
name|DW_CFA_restore
operator|+
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out_one
argument_list|(
name|DW_CFA_restore_extended
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_offset
case|:
name|regno
operator|=
name|insn
operator|->
name|u
operator|.
name|ri
operator|.
name|reg
expr_stmt|;
name|offset
operator|=
name|insn
operator|->
name|u
operator|.
name|ri
operator|.
name|offset
operator|/
name|DWARF2_CIE_DATA_ALIGNMENT
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|out_one
argument_list|(
name|DW_CFA_offset_extended_sf
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|out_sleb128
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|<=
literal|0x3F
condition|)
block|{
name|out_one
argument_list|(
name|DW_CFA_offset
operator|+
name|regno
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out_one
argument_list|(
name|DW_CFA_offset_extended
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_register
case|:
name|out_one
argument_list|(
name|DW_CFA_register
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|insn
operator|->
name|u
operator|.
name|rr
operator|.
name|reg1
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|insn
operator|->
name|u
operator|.
name|rr
operator|.
name|reg2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_remember_state
case|:
case|case
name|DW_CFA_restore_state
case|:
name|out_one
argument_list|(
name|insn
operator|->
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_window_save
case|:
name|out_one
argument_list|(
name|DW_CFA_GNU_window_save
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFI_escape
case|:
block|{
name|struct
name|cfi_escape_data
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|insn
operator|->
name|u
operator|.
name|esc
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
name|emit_expr
argument_list|(
operator|&
name|e
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_cie
parameter_list|(
name|struct
name|cie_entry
modifier|*
name|cie
parameter_list|)
block|{
name|symbolS
modifier|*
name|after_size_address
decl_stmt|,
modifier|*
name|end_address
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|struct
name|cfi_insn_data
modifier|*
name|i
decl_stmt|;
name|cie
operator|->
name|start_address
operator|=
name|symbol_temp_new_now
argument_list|()
expr_stmt|;
name|after_size_address
operator|=
name|symbol_temp_make
argument_list|()
expr_stmt|;
name|end_address
operator|=
name|symbol_temp_make
argument_list|()
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|end_address
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|after_size_address
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Length */
name|symbol_set_value_now
argument_list|(
name|after_size_address
argument_list|)
expr_stmt|;
name|out_four
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* CIE id */
name|out_one
argument_list|(
name|DW_CIE_VERSION
argument_list|)
expr_stmt|;
comment|/* Version */
name|out_one
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
comment|/* Augmentation */
name|out_one
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
name|out_one
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|DWARF2_LINE_MIN_INSN_LENGTH
argument_list|)
expr_stmt|;
comment|/* Code alignment */
name|out_sleb128
argument_list|(
name|DWARF2_CIE_DATA_ALIGNMENT
argument_list|)
expr_stmt|;
comment|/* Data alignment */
name|out_one
argument_list|(
name|cie
operator|->
name|return_column
argument_list|)
expr_stmt|;
comment|/* Return column */
name|out_uleb128
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Augmentation size */
if|#
directive|if
name|defined
name|DIFF_EXPR_OK
operator|||
name|defined
name|tc_cfi_emit_pcrel_expr
name|out_one
argument_list|(
name|DW_EH_PE_pcrel
operator||
name|DW_EH_PE_sdata4
argument_list|)
expr_stmt|;
else|#
directive|else
name|out_one
argument_list|(
name|DW_EH_PE_sdata4
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cie
operator|->
name|first
condition|)
for|for
control|(
name|i
operator|=
name|cie
operator|->
name|first
init|;
name|i
operator|!=
name|cie
operator|->
name|last
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
name|output_cfi_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbol_set_value_now
argument_list|(
name|end_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_fde
parameter_list|(
name|struct
name|fde_entry
modifier|*
name|fde
parameter_list|,
name|struct
name|cie_entry
modifier|*
name|cie
parameter_list|,
name|struct
name|cfi_insn_data
modifier|*
name|first
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|symbolS
modifier|*
name|after_size_address
decl_stmt|,
modifier|*
name|end_address
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|after_size_address
operator|=
name|symbol_temp_make
argument_list|()
expr_stmt|;
name|end_address
operator|=
name|symbol_temp_make
argument_list|()
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|end_address
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|after_size_address
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Length */
name|symbol_set_value_now
argument_list|(
name|after_size_address
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|after_size_address
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|cie
operator|->
name|start_address
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* CIE offset */
ifdef|#
directive|ifdef
name|DIFF_EXPR_OK
name|exp
operator|.
name|X_add_symbol
operator|=
name|fde
operator|->
name|start_address
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|symbol_temp_new_now
argument_list|()
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Code offset */
else|#
directive|else
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|fde
operator|->
name|start_address
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_cfi_emit_pcrel_expr
name|tc_cfi_emit_pcrel_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Code offset */
else|#
directive|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Code offset */
endif|#
directive|endif
name|exp
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
endif|#
directive|endif
name|exp
operator|.
name|X_add_symbol
operator|=
name|fde
operator|->
name|end_address
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|fde
operator|->
name|start_address
expr_stmt|;
comment|/* Code length */
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Augmentation size */
for|for
control|(
init|;
name|first
condition|;
name|first
operator|=
name|first
operator|->
name|next
control|)
name|output_cfi_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbol_set_value_now
argument_list|(
name|end_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cie_entry
modifier|*
name|select_cie_for_fde
parameter_list|(
name|struct
name|fde_entry
modifier|*
name|fde
parameter_list|,
name|struct
name|cfi_insn_data
modifier|*
modifier|*
name|pfirst
parameter_list|)
block|{
name|struct
name|cfi_insn_data
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|;
name|struct
name|cie_entry
modifier|*
name|cie
decl_stmt|;
for|for
control|(
name|cie
operator|=
name|cie_root
init|;
name|cie
condition|;
name|cie
operator|=
name|cie
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cie
operator|->
name|return_column
operator|!=
name|fde
operator|->
name|return_column
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|cie
operator|->
name|first
operator|,
name|j
operator|=
name|fde
operator|->
name|data
init|;
name|i
operator|!=
name|cie
operator|->
name|last
operator|&&
name|j
operator|!=
name|NULL
condition|;
name|i
operator|=
name|i
operator|->
name|next
operator|,
name|j
operator|=
name|j
operator|->
name|next
control|)
block|{
if|if
condition|(
name|i
operator|->
name|insn
operator|!=
name|j
operator|->
name|insn
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
name|i
operator|->
name|insn
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
comment|/* We reached the first advance in the FDE, but did not 		 reach the end of the CIE list.  */
goto|goto
name|fail
goto|;
case|case
name|DW_CFA_offset
case|:
case|case
name|DW_CFA_def_cfa
case|:
if|if
condition|(
name|i
operator|->
name|u
operator|.
name|ri
operator|.
name|reg
operator|!=
name|j
operator|->
name|u
operator|.
name|ri
operator|.
name|reg
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|i
operator|->
name|u
operator|.
name|ri
operator|.
name|offset
operator|!=
name|j
operator|->
name|u
operator|.
name|ri
operator|.
name|offset
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|DW_CFA_register
case|:
if|if
condition|(
name|i
operator|->
name|u
operator|.
name|rr
operator|.
name|reg1
operator|!=
name|j
operator|->
name|u
operator|.
name|rr
operator|.
name|reg1
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|i
operator|->
name|u
operator|.
name|rr
operator|.
name|reg2
operator|!=
name|j
operator|->
name|u
operator|.
name|rr
operator|.
name|reg2
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
case|case
name|DW_CFA_restore
case|:
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
if|if
condition|(
name|i
operator|->
name|u
operator|.
name|r
operator|!=
name|j
operator|->
name|u
operator|.
name|r
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
if|if
condition|(
name|i
operator|->
name|u
operator|.
name|i
operator|!=
name|j
operator|->
name|u
operator|.
name|i
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|CFI_escape
case|:
comment|/* Don't bother matching these for now.  */
goto|goto
name|fail
goto|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Success if we reached the end of the CIE list, and we've either 	 run out of FDE entries or we've encountered an advance.  */
if|if
condition|(
name|i
operator|==
name|cie
operator|->
name|last
operator|&&
operator|(
operator|!
name|j
operator|||
name|j
operator|->
name|insn
operator|==
name|DW_CFA_advance_loc
operator|)
condition|)
block|{
operator|*
name|pfirst
operator|=
name|j
expr_stmt|;
return|return
name|cie
return|;
block|}
name|fail
label|:
empty_stmt|;
block|}
name|cie
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cie_entry
argument_list|)
argument_list|)
expr_stmt|;
name|cie
operator|->
name|next
operator|=
name|cie_root
expr_stmt|;
name|cie_root
operator|=
name|cie
expr_stmt|;
name|cie
operator|->
name|return_column
operator|=
name|fde
operator|->
name|return_column
expr_stmt|;
name|cie
operator|->
name|first
operator|=
name|fde
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cie
operator|->
name|first
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
if|if
condition|(
name|i
operator|->
name|insn
operator|==
name|DW_CFA_advance_loc
condition|)
break|break;
name|cie
operator|->
name|last
operator|=
name|i
expr_stmt|;
operator|*
name|pfirst
operator|=
name|i
expr_stmt|;
name|output_cie
argument_list|(
name|cie
argument_list|)
expr_stmt|;
return|return
name|cie
return|;
block|}
end_function

begin_function
name|void
name|cfi_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|segT
name|cfi_seg
decl_stmt|;
name|struct
name|fde_entry
modifier|*
name|fde
decl_stmt|;
name|int
name|save_flag_traditional_format
decl_stmt|;
if|if
condition|(
name|cur_fde_data
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"open CFI at the end of file; missing .cfi_endproc directive"
argument_list|)
argument_list|)
expr_stmt|;
name|cur_fde_data
operator|->
name|end_address
operator|=
name|cur_fde_data
operator|->
name|start_address
expr_stmt|;
block|}
if|if
condition|(
name|all_fde_data
operator|==
literal|0
condition|)
return|return;
comment|/* Open .eh_frame section.  */
name|cfi_seg
operator|=
name|subseg_new
argument_list|(
literal|".eh_frame"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|cfi_seg
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|subseg_set
argument_list|(
name|cfi_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|cfi_seg
argument_list|,
name|EH_FRAME_ALIGNMENT
argument_list|)
expr_stmt|;
comment|/* Make sure check_eh_frame doesn't do anything with our output.  */
name|save_flag_traditional_format
operator|=
name|flag_traditional_format
expr_stmt|;
name|flag_traditional_format
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|fde
operator|=
name|all_fde_data
init|;
name|fde
condition|;
name|fde
operator|=
name|fde
operator|->
name|next
control|)
block|{
name|struct
name|cfi_insn_data
modifier|*
name|first
decl_stmt|;
name|struct
name|cie_entry
modifier|*
name|cie
decl_stmt|;
name|cie
operator|=
name|select_cie_for_fde
argument_list|(
name|fde
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|output_fde
argument_list|(
name|fde
argument_list|,
name|cie
argument_list|,
name|first
argument_list|,
name|fde
operator|->
name|next
operator|==
name|NULL
condition|?
name|EH_FRAME_ALIGNMENT
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
name|flag_traditional_format
operator|=
name|save_flag_traditional_format
expr_stmt|;
block|}
end_function

end_unit

