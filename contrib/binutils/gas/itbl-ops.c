begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* itbl-ops.c    Copyright (C) 1997  Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/*======================================================================*/
end_comment

begin_comment
comment|/*  * Herein lies the support for dynamic specification of processor  * instructions and registers.  Mnemonics, values, and formats for each  * instruction and register are specified in an ascii file consisting of  * table entries.  The grammar for the table is defined in the document  * "Processor instruction table specification".  *  * Instructions use the gnu assembler syntax, with the addition of  * allowing mnemonics for register.  * Eg. "func $2,reg3,0x100,symbol ; comment"  * 	func - opcode name  * 	$n - register n  * 	reg3 - mnemonic for processor's register defined in table  * 	0xddd..d - immediate value  * 	symbol - address of label or external symbol  *  * First, itbl_parse reads in the table of register and instruction  * names and formats, and builds a list of entries for each  * processor/type combination.  lex and yacc are used to parse  * the entries in the table and call functions defined here to  * add each entry to our list.  *  * Then, when assembling or disassembling, these functions are called to  * 1) get information on a processor's registers and  * 2) assemble/disassemble an instruction.  * To assemble(disassemble) an instruction, the function  * itbl_assemble(itbl_disassemble) is called to search the list of  * instruction entries, and if a match is found, uses the format  * described in the instruction entry structure to complete the action.  *  * Eg. Suppose we have a Mips coprocessor "cop3" with data register "d2"  * and we want to define function "pig" which takes two operands.  *  * Given the table entries:  * 	"p3 insn pig 0x1:24-21 dreg:20-16 immed:15-0"  * 	"p3 dreg d2 0x2"  * and that the instruction encoding for coprocessor pz has encoding:  * 	#define MIPS_ENCODE_COP_NUM(z) ((0x21|(z<<1))<<25)  * 	#define ITBL_ENCODE_PNUM(pnum) MIPS_ENCODE_COP_NUM(pnum)  *  * a structure to describe the instruction might look something like:  *      struct itbl_entry = {  *      e_processor processor = e_p3  *      e_type type = e_insn  *      char *name = "pig"  *      uint value = 0x1  *      uint flags = 0  *      struct itbl_range range = 24-21  *      struct itbl_field *field = {  *              e_type type = e_dreg  *              struct itbl_range range = 20-16  *              struct itbl_field *next = {  *                      e_type type = e_immed  *                      struct itbl_range range = 15-0  *                      struct itbl_field *next = 0  *                      };  *              };  *      struct itbl_entry *next = 0  *      };  *  * And the assembler instructions:  * 	"pig d2,0x100"  * 	"pig $2,0x100"  *  * would both assemble to the hex value:  * 	"0x4e220100"  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"itbl-ops.h"
end_include

begin_include
include|#
directive|include
file|"itbl-parse.h"
end_include

begin_comment
comment|/* #define DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|x
parameter_list|)
value|assert(x)
end_define

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a<b?a:b)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|itbl_have_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*======================================================================*/
end_comment

begin_comment
comment|/* structures for keeping itbl format entries */
end_comment

begin_struct
struct|struct
name|itbl_range
block|{
name|int
name|sbit
decl_stmt|;
comment|/* mask starting bit position */
name|int
name|ebit
decl_stmt|;
comment|/* mask ending bit position */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|itbl_field
block|{
name|e_type
name|type
decl_stmt|;
comment|/* dreg/creg/greg/immed/symb */
name|struct
name|itbl_range
name|range
decl_stmt|;
comment|/* field's bitfield range within instruction */
name|unsigned
name|long
name|flags
decl_stmt|;
comment|/* field flags */
name|struct
name|itbl_field
modifier|*
name|next
decl_stmt|;
comment|/* next field in list */
block|}
struct|;
end_struct

begin_comment
comment|/* These structures define the instructions and registers for a processor.  * If the type is an instruction, the structure defines the format of an  * instruction where the fields are the list of operands.  * The flags field below uses the same values as those defined in the  * gnu assembler and are machine specific. */
end_comment

begin_struct
struct|struct
name|itbl_entry
block|{
name|e_processor
name|processor
decl_stmt|;
comment|/* processor number */
name|e_type
name|type
decl_stmt|;
comment|/* dreg/creg/greg/insn */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* mnemionic name for insn/register */
name|unsigned
name|long
name|value
decl_stmt|;
comment|/* opcode/instruction mask/register number */
name|unsigned
name|long
name|flags
decl_stmt|;
comment|/* effects of the instruction */
name|struct
name|itbl_range
name|range
decl_stmt|;
comment|/* bit range within instruction for value */
name|struct
name|itbl_field
modifier|*
name|fields
decl_stmt|;
comment|/* list of operand definitions (if any) */
name|struct
name|itbl_entry
modifier|*
name|next
decl_stmt|;
comment|/* next entry */
block|}
struct|;
end_struct

begin_comment
comment|/* local data and structures */
end_comment

begin_decl_stmt
specifier|static
name|int
name|itbl_num_opcodes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of entries for each processor and entry type */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|itbl_entry
modifier|*
name|entries
index|[
name|e_nprocs
index|]
index|[
name|e_ntypes
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local prototypes */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|build_opcode
name|PARAMS
argument_list|(
operator|(
expr|struct
name|itbl_entry
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|e_type
name|get_type
name|PARAMS
argument_list|(
operator|(
name|int
name|yytype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|e_processor
name|get_processor
name|PARAMS
argument_list|(
operator|(
name|int
name|yyproc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|itbl_entry
modifier|*
modifier|*
name|get_entries
name|PARAMS
argument_list|(
operator|(
name|e_processor
name|processor
operator|,
name|e_type
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|itbl_entry
modifier|*
name|find_entry_byname
name|PARAMS
argument_list|(
operator|(
name|e_processor
name|processor
operator|,
name|e_type
name|type
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|itbl_entry
modifier|*
name|find_entry_byval
name|PARAMS
argument_list|(
operator|(
name|e_processor
name|processor
operator|,
name|e_type
name|type
operator|,
name|unsigned
name|long
name|val
operator|,
expr|struct
name|itbl_range
operator|*
name|r
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|itbl_entry
modifier|*
name|alloc_entry
name|PARAMS
argument_list|(
operator|(
name|e_processor
name|processor
operator|,
name|e_type
name|type
operator|,
name|char
operator|*
name|name
operator|,
name|unsigned
name|long
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|apply_range
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
name|value
operator|,
expr|struct
name|itbl_range
name|r
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|extract_range
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
name|value
operator|,
expr|struct
name|itbl_range
name|r
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|itbl_field
modifier|*
name|alloc_field
name|PARAMS
argument_list|(
operator|(
name|e_type
name|type
operator|,
name|int
name|sbit
operator|,
name|int
name|ebit
operator|,
name|unsigned
name|long
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*======================================================================*/
end_comment

begin_comment
comment|/* Interfaces to the parser */
end_comment

begin_comment
comment|/* Open the table and use lex and yacc to parse the entries.  * Return 1 for failure; 0 for success.  */
end_comment

begin_function
name|int
name|itbl_parse
parameter_list|(
name|char
modifier|*
name|insntbl
parameter_list|)
block|{
specifier|extern
name|FILE
modifier|*
name|yyin
decl_stmt|;
specifier|extern
name|int
name|yyparse
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|yyin
operator|=
name|fopen
argument_list|(
name|insntbl
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyin
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Can't open processor instruction specification file \"%s\"\n"
argument_list|,
name|insntbl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
while|while
condition|(
name|yyparse
argument_list|()
condition|)
empty_stmt|;
block|}
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|itbl_have_entries
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a register entry */
end_comment

begin_function
name|struct
name|itbl_entry
modifier|*
name|itbl_add_reg
parameter_list|(
name|int
name|yyprocessor
parameter_list|,
name|int
name|yytype
parameter_list|,
name|char
modifier|*
name|regname
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
if|#
directive|if
literal|0
include|#
directive|include
file|"as.h"
include|#
directive|include
file|"symbols.h"
comment|/* Since register names don't have a prefix, we put them in the symbol table so      they can't be used as symbols.  This also simplifies argument parsing as      we can let gas parse registers for us.  The recorded register number is      regnum.  */
comment|/* Use symbol_create here instead of symbol_new so we don't try to      output registers into the object file's symbol table.  */
block|symbol_table_insert (symbol_create (regname, reg_section, 				      regnum,&zero_address_frag));
endif|#
directive|endif
return|return
name|alloc_entry
argument_list|(
name|get_processor
argument_list|(
name|yyprocessor
argument_list|)
argument_list|,
name|get_type
argument_list|(
name|yytype
argument_list|)
argument_list|,
name|regname
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add an instruction entry */
end_comment

begin_function
name|struct
name|itbl_entry
modifier|*
name|itbl_add_insn
parameter_list|(
name|int
name|yyprocessor
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|long
name|value
parameter_list|,
name|int
name|sbit
parameter_list|,
name|int
name|ebit
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
name|struct
name|itbl_entry
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|alloc_entry
argument_list|(
name|get_processor
argument_list|(
name|yyprocessor
argument_list|)
argument_list|,
name|e_insn
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|e
operator|->
name|range
operator|.
name|sbit
operator|=
name|sbit
expr_stmt|;
name|e
operator|->
name|range
operator|.
name|ebit
operator|=
name|ebit
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|itbl_num_opcodes
operator|++
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Add an operand to an instruction entry */
end_comment

begin_function
name|struct
name|itbl_field
modifier|*
name|itbl_add_operand
parameter_list|(
name|struct
name|itbl_entry
modifier|*
name|e
parameter_list|,
name|int
name|yytype
parameter_list|,
name|int
name|sbit
parameter_list|,
name|int
name|ebit
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
name|struct
name|itbl_field
modifier|*
name|f
decl_stmt|,
modifier|*
modifier|*
name|last_f
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
comment|/* Add to end of fields' list. */
name|f
operator|=
name|alloc_field
argument_list|(
name|get_type
argument_list|(
name|yytype
argument_list|)
argument_list|,
name|sbit
argument_list|,
name|ebit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|last_f
operator|=
operator|&
name|e
operator|->
name|fields
expr_stmt|;
while|while
condition|(
operator|*
name|last_f
condition|)
name|last_f
operator|=
operator|&
operator|(
operator|*
name|last_f
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|last_f
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/*======================================================================*/
end_comment

begin_comment
comment|/* Interfaces for assembler and disassembler */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STAND_ALONE
end_ifndef

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_function_decl
specifier|static
name|void
name|append_insns_as_macros
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* initialize for gas */
end_comment

begin_function
name|void
name|itbl_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|itbl_entry
modifier|*
name|e
decl_stmt|,
modifier|*
modifier|*
name|es
decl_stmt|;
name|e_processor
name|procn
decl_stmt|;
name|e_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|itbl_have_entries
condition|)
return|return;
comment|/* Since register names don't have a prefix, put them in the symbol table so      they can't be used as symbols.  This simplifies argument parsing as      we can let gas parse registers for us. */
comment|/* Use symbol_create instead of symbol_new so we don't try to      output registers into the object file's symbol table.  */
for|for
control|(
name|type
operator|=
name|e_regtype0
init|;
name|type
operator|<
name|e_nregtypes
condition|;
name|type
operator|++
control|)
for|for
control|(
name|procn
operator|=
name|e_p0
init|;
name|procn
operator|<
name|e_nprocs
condition|;
name|procn
operator|++
control|)
block|{
name|es
operator|=
name|get_entries
argument_list|(
name|procn
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
operator|*
name|es
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
name|symbol_table_insert
argument_list|(
name|symbol_create
argument_list|(
name|e
operator|->
name|name
argument_list|,
name|reg_section
argument_list|,
name|e
operator|->
name|value
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|append_insns_as_macros
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append insns to opcodes table and increase number of opcodes   * Structure of opcodes table:   * struct itbl_opcode  * {  *   const char *name;  *   const char *args; 		- string describing the arguments.    *   unsigned long match; 	- opcode, or ISA level if pinfo=INSN_MACRO   *   unsigned long mask; 	- opcode mask, or macro id if pinfo=INSN_MACRO   *   unsigned long pinfo; 	- insn flags, or INSN_MACRO   * };  * examples:  *	{"li",      "t,i",  0x34000000, 0xffe00000, WR_t    },  *	{"li",      "t,I",  0,    (int) M_LI,   INSN_MACRO  },  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|form_args
parameter_list|(
name|struct
name|itbl_entry
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|append_insns_as_macros
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ITBL_OPCODE_STRUCT
modifier|*
name|new_opcodes
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|struct
name|itbl_entry
modifier|*
name|e
decl_stmt|,
modifier|*
modifier|*
name|es
decl_stmt|;
name|int
name|n
decl_stmt|,
name|id
decl_stmt|,
name|size
decl_stmt|,
name|new_size
decl_stmt|,
name|new_num_opcodes
decl_stmt|;
if|if
condition|(
operator|!
name|itbl_have_entries
condition|)
return|return;
if|if
condition|(
operator|!
name|itbl_num_opcodes
condition|)
comment|/* no new instructions to add! */
block|{
return|return;
block|}
name|DBG
argument_list|(
operator|(
literal|"previous num_opcodes=%d\n"
operator|,
name|ITBL_NUM_OPCODES
operator|)
argument_list|)
expr_stmt|;
name|new_num_opcodes
operator|=
name|ITBL_NUM_OPCODES
operator|+
name|itbl_num_opcodes
expr_stmt|;
name|ASSERT
argument_list|(
name|new_num_opcodes
operator|>=
name|itbl_num_opcodes
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ITBL_OPCODE_STRUCT
argument_list|)
operator|*
name|ITBL_NUM_OPCODES
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
operator|(
literal|"I get=%d\n"
operator|,
name|size
operator|/
sizeof|sizeof
argument_list|(
name|ITBL_OPCODES
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|new_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ITBL_OPCODE_STRUCT
argument_list|)
operator|*
name|new_num_opcodes
expr_stmt|;
name|ASSERT
argument_list|(
name|new_size
operator|>
name|size
argument_list|)
expr_stmt|;
comment|/* FIXME since ITBL_OPCODES culd be a static table, 		we can't realloc or delete the old memory. */
name|new_opcodes
operator|=
operator|(
expr|struct
name|ITBL_OPCODE_STRUCT
operator|*
operator|)
name|malloc
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_opcodes
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to allocate memory for new instructions\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
condition|)
comment|/* copy prexisting opcodes table */
name|memcpy
argument_list|(
name|new_opcodes
argument_list|,
name|ITBL_OPCODES
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* FIXME! some NUMOPCODES are calculated expressions. 		These need to be changed before itbls can be supported. */
name|id
operator|=
name|ITBL_NUM_MACROS
expr_stmt|;
comment|/* begin the next macro id after the last */
name|o
operator|=
operator|&
name|new_opcodes
index|[
name|ITBL_NUM_OPCODES
index|]
expr_stmt|;
comment|/* append macro to opcodes list */
for|for
control|(
name|n
operator|=
name|e_p0
init|;
name|n
operator|<
name|e_nprocs
condition|;
name|n
operator|++
control|)
block|{
name|es
operator|=
name|get_entries
argument_list|(
name|n
argument_list|,
name|e_insn
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
operator|*
name|es
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
comment|/* name,    args,   mask,       match,  pinfo 		 * {"li",      "t,i",  0x34000000, 0xffe00000, WR_t    }, 		 * {"li",      "t,I",  0,    (int) M_LI,   INSN_MACRO  }, 		 * Construct args from itbl_fields. 		*/
name|o
operator|->
name|name
operator|=
name|e
operator|->
name|name
expr_stmt|;
name|o
operator|->
name|args
operator|=
name|strdup
argument_list|(
name|form_args
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|mask
operator|=
name|apply_range
argument_list|(
name|e
operator|->
name|value
argument_list|,
name|e
operator|->
name|range
argument_list|)
expr_stmt|;
comment|/* FIXME how to catch durring assembly? */
comment|/* mask to identify this insn */
name|o
operator|->
name|match
operator|=
name|apply_range
argument_list|(
name|e
operator|->
name|value
argument_list|,
name|e
operator|->
name|range
argument_list|)
expr_stmt|;
name|o
operator|->
name|pinfo
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MACROS
name|o
operator|->
name|mask
operator|=
name|id
operator|++
expr_stmt|;
comment|/* FIXME how to catch durring assembly? */
name|o
operator|->
name|match
operator|=
literal|0
expr_stmt|;
comment|/* for macros, the insn_isa number */
name|o
operator|->
name|pinfo
operator|=
name|INSN_MACRO
expr_stmt|;
endif|#
directive|endif
comment|/* Don't add instructions which caused an error */
if|if
condition|(
name|o
operator|->
name|args
condition|)
name|o
operator|++
expr_stmt|;
else|else
name|new_num_opcodes
operator|--
expr_stmt|;
block|}
block|}
name|ITBL_OPCODES
operator|=
name|new_opcodes
expr_stmt|;
name|ITBL_NUM_OPCODES
operator|=
name|new_num_opcodes
expr_stmt|;
comment|/* FIXME 		At this point, we can free the entries, as they should have 		been added to the assembler's tables. 		Don't free name though, since name is being used by the new 		opcodes table.  		Eventually, we should also free the new opcodes table itself  		on exit. 	*/
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|form_args
parameter_list|(
name|struct
name|itbl_entry
modifier|*
name|e
parameter_list|)
block|{
specifier|static
name|char
name|s
index|[
literal|31
index|]
decl_stmt|;
name|char
name|c
init|=
literal|0
decl_stmt|,
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|struct
name|itbl_field
modifier|*
name|f
decl_stmt|;
name|ASSERT
argument_list|(
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|e
operator|->
name|fields
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|f
operator|->
name|type
condition|)
block|{
case|case
name|e_dreg
case|:
name|c
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|e_creg
case|:
name|c
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
name|e_greg
case|:
name|c
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|e_immed
case|:
name|c
operator|=
literal|'i'
expr_stmt|;
break|break;
case|case
name|e_addr
case|:
name|c
operator|=
literal|'a'
expr_stmt|;
break|break;
default|default:
name|c
operator|=
literal|0
expr_stmt|;
comment|/* ignore; unknown field type */
block|}
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|s
condition|)
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !STAND_ALONE */
end_comment

begin_comment
comment|/* Get processor's register name from val */
end_comment

begin_function
name|unsigned
name|long
name|itbl_get_reg_val
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|e_type
name|t
decl_stmt|;
name|e_processor
name|p
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|e_p0
init|;
name|p
operator|<
name|e_nprocs
condition|;
name|p
operator|++
control|)
for|for
control|(
name|t
operator|=
name|e_regtype0
init|;
name|t
operator|<
name|e_nregtypes
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|r
operator|=
name|itbl_get_val
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
name|name
argument_list|)
operator|,
name|r
condition|)
return|return
name|r
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|itbl_get_name
parameter_list|(
name|e_processor
name|processor
parameter_list|,
name|e_type
name|type
parameter_list|,
name|unsigned
name|long
name|val
parameter_list|)
block|{
name|struct
name|itbl_entry
modifier|*
name|r
decl_stmt|;
comment|/* type depends on instruction passed */
name|r
operator|=
name|find_entry_byval
argument_list|(
name|processor
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
operator|->
name|name
return|;
else|else
return|return
literal|0
return|;
comment|/* error; invalid operand */
block|}
end_function

begin_comment
comment|/* Get processor's register value from name */
end_comment

begin_function
name|unsigned
name|long
name|itbl_get_val
parameter_list|(
name|e_processor
name|processor
parameter_list|,
name|e_type
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|itbl_entry
modifier|*
name|r
decl_stmt|;
comment|/* type depends on instruction passed */
name|r
operator|=
name|find_entry_byname
argument_list|(
name|processor
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
operator|->
name|value
return|;
else|else
return|return
literal|0
return|;
comment|/* error; invalid operand */
block|}
end_function

begin_comment
comment|/* Assemble instruction "name" with operands "s".  * name - name of instruction  * s - operands  * returns - long word for assembled instruction */
end_comment

begin_function
name|unsigned
name|long
name|itbl_assemble
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|long
name|opcode
decl_stmt|;
name|struct
name|itbl_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|itbl_field
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|int
name|processor
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
return|return
literal|0
return|;
comment|/* error!  must have a opcode name/expr */
comment|/* find entry in list of instructions for all processors */
for|for
control|(
name|processor
operator|=
literal|0
init|;
name|processor
operator|<
name|e_nprocs
condition|;
name|processor
operator|++
control|)
block|{
name|e
operator|=
name|find_entry_byname
argument_list|(
name|processor
argument_list|,
name|e_insn
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
comment|/* opcode not in table; invalid instrustion */
name|opcode
operator|=
name|build_opcode
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* parse opcode's args (if any) */
for|for
control|(
name|f
operator|=
name|e
operator|->
name|fields
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
comment|/* for each arg, ... */
block|{
name|struct
name|itbl_entry
modifier|*
name|r
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
operator|*
name|s
condition|)
return|return
literal|0
return|;
comment|/* error - not enough operands */
name|n
operator|=
name|itbl_get_field
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* n should be in form $n or 0xhhh (are symbol names valid?? */
switch|switch
condition|(
name|f
operator|->
name|type
condition|)
block|{
case|case
name|e_dreg
case|:
case|case
name|e_creg
case|:
case|case
name|e_greg
case|:
comment|/* Accept either a string name 			 * or '$' followed by the register number */
if|if
condition|(
operator|*
name|n
operator|==
literal|'$'
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|value
operator|=
name|strtol
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* FIXME! could have "0l"... then what?? */
if|if
condition|(
name|value
operator|==
literal|0
operator|&&
operator|*
name|n
operator|!=
literal|'0'
condition|)
return|return
literal|0
return|;
comment|/* error; invalid operand */
block|}
else|else
block|{
name|r
operator|=
name|find_entry_byname
argument_list|(
name|e
operator|->
name|processor
argument_list|,
name|f
operator|->
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|value
operator|=
name|r
operator|->
name|value
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* error; invalid operand */
block|}
break|break;
case|case
name|e_addr
case|:
comment|/* use assembler's symbol table to find symbol */
comment|/* FIXME!! Do we need this? 				if so, what about relocs?? 				my_getExpression (&imm_expr, s); 				return 0;	/-* error; invalid operand *-/ 				break; 			*/
comment|/* If not a symbol, fall thru to IMMED */
case|case
name|e_immed
case|:
if|if
condition|(
operator|*
name|n
operator|==
literal|'0'
operator|&&
operator|*
operator|(
name|n
operator|+
literal|1
operator|)
operator|==
literal|'x'
condition|)
comment|/* hex begins 0x... */
block|{
name|n
operator|+=
literal|2
expr_stmt|;
name|value
operator|=
name|strtol
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* FIXME! could have "0xl"... then what?? */
block|}
else|else
block|{
name|value
operator|=
name|strtol
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* FIXME! could have "0l"... then what?? */
if|if
condition|(
name|value
operator|==
literal|0
operator|&&
operator|*
name|n
operator|!=
literal|'0'
condition|)
return|return
literal|0
return|;
comment|/* error; invalid operand */
block|}
break|break;
default|default:
return|return
literal|0
return|;
comment|/* error; invalid field spec */
block|}
name|opcode
operator||=
name|apply_range
argument_list|(
name|value
argument_list|,
name|f
operator|->
name|range
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|&&
operator|*
name|s
condition|)
return|return
literal|0
return|;
comment|/* error - too many operands */
return|return
name|opcode
return|;
comment|/* done! */
block|}
end_function

begin_comment
comment|/* Disassemble instruction "insn".  * insn - instruction  * s - buffer to hold disassembled instruction  * returns - 1 if succeeded; 0 if failed  */
end_comment

begin_function
name|int
name|itbl_disassemble
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|long
name|insn
parameter_list|)
block|{
name|e_processor
name|processor
decl_stmt|;
name|struct
name|itbl_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|itbl_field
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|ITBL_IS_INSN
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* error*/
name|processor
operator|=
name|get_processor
argument_list|(
name|ITBL_DECODE_PNUM
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find entry in list */
name|e
operator|=
name|find_entry_byval
argument_list|(
name|processor
argument_list|,
name|e_insn
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
comment|/* opcode not in table; invalid instrustion */
name|strcpy
argument_list|(
name|s
argument_list|,
name|e
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* parse insn's args (if any) */
for|for
control|(
name|f
operator|=
name|e
operator|->
name|fields
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
comment|/* for each arg, ... */
block|{
name|struct
name|itbl_entry
modifier|*
name|r
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|e
operator|->
name|fields
condition|)
comment|/* first operand is preceeded by tab */
name|strcat
argument_list|(
name|s
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
else|else
comment|/* ','s separate following operands */
name|strcat
argument_list|(
name|s
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|value
operator|=
name|extract_range
argument_list|(
name|insn
argument_list|,
name|f
operator|->
name|range
argument_list|)
expr_stmt|;
comment|/* n should be in form $n or 0xhhh (are symbol names valid?? */
switch|switch
condition|(
name|f
operator|->
name|type
condition|)
block|{
case|case
name|e_dreg
case|:
case|case
name|e_creg
case|:
case|case
name|e_greg
case|:
comment|/* Accept either a string name 			 * or '$' followed by the register number */
name|r
operator|=
name|find_entry_byval
argument_list|(
name|e
operator|->
name|processor
argument_list|,
name|f
operator|->
name|type
argument_list|,
name|value
argument_list|,
operator|&
name|f
operator|->
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|strcat
argument_list|(
name|s
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s$%d"
argument_list|,
name|s
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_addr
case|:
comment|/* use assembler's symbol table to find symbol */
comment|/* FIXME!! Do we need this? 			 *   if so, what about relocs?? 			*/
comment|/* If not a symbol, fall thru to IMMED */
case|case
name|e_immed
case|:
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s0x%x"
argument_list|,
name|s
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
comment|/* error; invalid field spec */
block|}
block|}
return|return
literal|1
return|;
comment|/* done! */
block|}
end_function

begin_comment
comment|/*======================================================================*/
end_comment

begin_comment
comment|/*  * Local functions for manipulating private structures containing  * the names and format for the new instructions and registers  * for each processor.  */
end_comment

begin_comment
comment|/* Calculate instruction's opcode and function values from entry */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|build_opcode
parameter_list|(
name|struct
name|itbl_entry
modifier|*
name|e
parameter_list|)
block|{
name|unsigned
name|long
name|opcode
decl_stmt|;
name|opcode
operator|=
name|apply_range
argument_list|(
name|e
operator|->
name|value
argument_list|,
name|e
operator|->
name|range
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|ITBL_ENCODE_PNUM
argument_list|(
name|e
operator|->
name|processor
argument_list|)
expr_stmt|;
return|return
name|opcode
return|;
block|}
end_function

begin_comment
comment|/* Calculate absolute value given the relative value and bit position range  * within the instruction.  * The range is inclusive where 0 is least significant bit.  * A range of { 24, 20 } will have a mask of  * bit   3           2            1  * pos: 1098 7654 3210 9876 5432 1098 7654 3210  * bin: 0000 0001 1111 0000 0000 0000 0000 0000  * hex:    0    1    f    0    0    0    0    0  * mask: 0x01f00000.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|apply_range
parameter_list|(
name|unsigned
name|long
name|rval
parameter_list|,
name|struct
name|itbl_range
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|unsigned
name|long
name|aval
decl_stmt|;
name|int
name|len
init|=
name|MAX_BITPOS
operator|-
name|r
operator|.
name|sbit
decl_stmt|;
name|ASSERT
argument_list|(
name|r
operator|.
name|sbit
operator|>=
name|r
operator|.
name|ebit
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MAX_BITPOS
operator|>=
name|r
operator|.
name|sbit
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|r
operator|.
name|ebit
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* create mask by truncating 1s by shifting */
name|mask
operator|=
literal|0xffffffff
operator|<<
name|len
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
name|len
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
name|r
operator|.
name|ebit
expr_stmt|;
name|mask
operator|=
name|mask
operator|<<
name|r
operator|.
name|ebit
expr_stmt|;
name|aval
operator|=
operator|(
name|rval
operator|<<
name|r
operator|.
name|ebit
operator|)
operator|&
name|mask
expr_stmt|;
return|return
name|aval
return|;
block|}
end_function

begin_comment
comment|/* Calculate relative value given the absolute value and bit position range  * within the instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|extract_range
parameter_list|(
name|unsigned
name|long
name|aval
parameter_list|,
name|struct
name|itbl_range
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|unsigned
name|long
name|rval
decl_stmt|;
name|int
name|len
init|=
name|MAX_BITPOS
operator|-
name|r
operator|.
name|sbit
decl_stmt|;
comment|/* create mask by truncating 1s by shifting */
name|mask
operator|=
literal|0xffffffff
operator|<<
name|len
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
name|len
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
name|r
operator|.
name|ebit
expr_stmt|;
name|mask
operator|=
name|mask
operator|<<
name|r
operator|.
name|ebit
expr_stmt|;
name|rval
operator|=
operator|(
name|aval
operator|&
name|mask
operator|)
operator|>>
name|r
operator|.
name|ebit
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Extract processor's assembly instruction field name from s;  * forms are "n args" "n,args" or "n" */
end_comment

begin_comment
comment|/* Return next argument from string pointer "s" and advance s.  * delimiters are " ,\0" */
end_comment

begin_function
name|char
modifier|*
name|itbl_get_field
parameter_list|(
name|char
modifier|*
modifier|*
name|S
parameter_list|)
block|{
specifier|static
name|char
name|n
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ps
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|s
operator|=
operator|*
name|S
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
operator|*
name|s
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|,
name|ps
condition|)
name|p
operator|=
name|ps
expr_stmt|;
if|if
condition|(
name|ps
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|' '
argument_list|)
operator|,
name|ps
condition|)
name|p
operator|=
name|min
argument_list|(
name|p
argument_list|,
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\0'
argument_list|)
operator|,
name|ps
condition|)
name|p
operator|=
name|min
argument_list|(
name|p
argument_list|,
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* error! */
name|len
operator|=
name|p
operator|-
name|s
expr_stmt|;
name|ASSERT
argument_list|(
literal|128
operator|>
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|n
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
name|s
operator|=
literal|0
expr_stmt|;
comment|/* no more args */
else|else
name|s
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* advance to next arg */
operator|*
name|S
operator|=
name|s
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Search entries for a given processor and type  * to find one matching the name "n".  * Return a pointer to the entry */
end_comment

begin_function
specifier|static
name|struct
name|itbl_entry
modifier|*
name|find_entry_byname
parameter_list|(
name|e_processor
name|processor
parameter_list|,
name|e_type
name|type
parameter_list|,
name|char
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|itbl_entry
modifier|*
name|e
decl_stmt|,
modifier|*
modifier|*
name|es
decl_stmt|;
name|es
operator|=
name|get_entries
argument_list|(
name|processor
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
operator|*
name|es
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
comment|/* for each entry, ... */
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|e
operator|->
name|name
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|e
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search entries for a given processor and type  * to find one matching the value "val" for the range "r".  * Return a pointer to the entry.  * This function is used for disassembling fields of an instruction.  */
end_comment

begin_function
specifier|static
name|struct
name|itbl_entry
modifier|*
name|find_entry_byval
parameter_list|(
name|e_processor
name|processor
parameter_list|,
name|e_type
name|type
parameter_list|,
name|unsigned
name|long
name|val
parameter_list|,
name|struct
name|itbl_range
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|itbl_entry
modifier|*
name|e
decl_stmt|,
modifier|*
modifier|*
name|es
decl_stmt|;
name|unsigned
name|long
name|eval
decl_stmt|;
name|es
operator|=
name|get_entries
argument_list|(
name|processor
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
operator|*
name|es
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
comment|/* for each entry, ... */
block|{
if|if
condition|(
name|processor
operator|!=
name|e
operator|->
name|processor
condition|)
continue|continue;
comment|/* For insns, we might not know the range of the opcode, 	 * so a range of 0 will allow this routine to match against 	 * the range of the entry to be compared with. 	 * This could cause ambiguities. 	 * For operands, we get an extracted value and a range. 	 */
comment|/* if range is 0, mask val against the range of the compared entry. */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
comment|/* if no range passed, must be whole 32-bits 			 * so create 32-bit value from entry's range */
block|{
name|eval
operator|=
name|apply_range
argument_list|(
name|e
operator|->
name|value
argument_list|,
name|e
operator|->
name|range
argument_list|)
expr_stmt|;
name|val
operator|&=
name|apply_range
argument_list|(
literal|0xffffffff
argument_list|,
name|e
operator|->
name|range
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|sbit
operator|==
name|e
operator|->
name|range
operator|.
name|sbit
operator|&&
name|r
operator|->
name|ebit
operator|==
name|e
operator|->
name|range
operator|.
name|ebit
operator|||
name|e
operator|->
name|range
operator|.
name|sbit
operator|==
literal|0
operator|&&
name|e
operator|->
name|range
operator|.
name|ebit
operator|==
literal|0
condition|)
block|{
name|eval
operator|=
name|apply_range
argument_list|(
name|e
operator|->
name|value
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
name|val
operator|=
name|apply_range
argument_list|(
name|val
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|val
operator|==
name|eval
condition|)
return|return
name|e
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the list of entries for a given processor and type. */
end_comment

begin_function
specifier|static
name|struct
name|itbl_entry
modifier|*
modifier|*
name|get_entries
parameter_list|(
name|e_processor
name|processor
parameter_list|,
name|e_type
name|type
parameter_list|)
block|{
return|return
operator|&
name|entries
index|[
name|processor
index|]
index|[
name|type
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return an integral value for the processor passed from yyparse. */
end_comment

begin_function
specifier|static
name|e_processor
name|get_processor
parameter_list|(
name|int
name|yyproc
parameter_list|)
block|{
comment|/* translate from yacc's processor to enum */
if|if
condition|(
name|yyproc
operator|>=
name|e_p0
operator|&&
name|yyproc
operator|<
name|e_nprocs
condition|)
return|return
operator|(
name|e_processor
operator|)
name|yyproc
return|;
return|return
name|e_invproc
return|;
comment|/* error; invalid processor */
block|}
end_function

begin_comment
comment|/* Return an integral value for the entry type passed from yyparse. */
end_comment

begin_function
specifier|static
name|e_type
name|get_type
parameter_list|(
name|int
name|yytype
parameter_list|)
block|{
switch|switch
condition|(
name|yytype
condition|)
block|{
comment|/* translate from yacc's type to enum */
case|case
name|INSN
case|:
return|return
name|e_insn
return|;
case|case
name|DREG
case|:
return|return
name|e_dreg
return|;
case|case
name|CREG
case|:
return|return
name|e_creg
return|;
case|case
name|GREG
case|:
return|return
name|e_greg
return|;
case|case
name|ADDR
case|:
return|return
name|e_addr
return|;
case|case
name|IMMED
case|:
return|return
name|e_immed
return|;
default|default:
return|return
name|e_invtype
return|;
comment|/* error; invalid type */
block|}
block|}
end_function

begin_comment
comment|/* Allocate and initialize an entry */
end_comment

begin_function
specifier|static
name|struct
name|itbl_entry
modifier|*
name|alloc_entry
parameter_list|(
name|e_processor
name|processor
parameter_list|,
name|e_type
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|struct
name|itbl_entry
modifier|*
name|e
decl_stmt|,
modifier|*
modifier|*
name|es
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
name|e
operator|=
operator|(
expr|struct
name|itbl_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|itbl_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|memset
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|itbl_entry
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|name
condition|)
name|strcpy
argument_list|(
name|e
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|e
operator|->
name|processor
operator|=
name|processor
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|e
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|es
operator|=
name|get_entries
argument_list|(
name|e
operator|->
name|processor
argument_list|,
name|e
operator|->
name|type
argument_list|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
operator|*
name|es
expr_stmt|;
operator|*
name|es
operator|=
name|e
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize an entry's field */
end_comment

begin_function
specifier|static
name|struct
name|itbl_field
modifier|*
name|alloc_field
parameter_list|(
name|e_type
name|type
parameter_list|,
name|int
name|sbit
parameter_list|,
name|int
name|ebit
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
name|struct
name|itbl_field
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|(
expr|struct
name|itbl_field
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|itbl_field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|itbl_field
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|f
operator|->
name|range
operator|.
name|sbit
operator|=
name|sbit
expr_stmt|;
name|f
operator|->
name|range
operator|.
name|ebit
operator|=
name|ebit
expr_stmt|;
name|f
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

end_unit

