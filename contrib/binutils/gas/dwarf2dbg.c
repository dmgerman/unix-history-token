begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dwarf2dbg.c - DWARF2 debug support    Copyright (C) 1999, 2000 Free Software Foundation, Inc.    Contributed by David Mosberger-Tang<davidm@hpl.hp.com>     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Logical line numbers can be controlled by the compiler via the    following two directives:  	.file FILENO "file.c" 	.loc  FILENO LINENO [COLUMN]     FILENO is the filenumber.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_comment
comment|/* Since we can't generate the prolog until the body is complete, we    use three different subsegments for .debug_line: one holding the    prolog, one for the directory and filename info, and one for the    body ("statement program").  */
end_comment

begin_define
define|#
directive|define
name|DL_PROLOG
value|0
end_define

begin_define
define|#
directive|define
name|DL_FILES
value|1
end_define

begin_define
define|#
directive|define
name|DL_BODY
value|2
end_define

begin_comment
comment|/* First special line opcde - leave room for the standard opcodes.    Note: If you want to change this, you'll have to update the    "standard_opcode_lengths" table that is emitted below in    dwarf2_finish().  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_LINE_OPCODE_BASE
value|10
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_LINE_BASE
end_ifndef

begin_comment
comment|/* Minimum line offset in a special line info. opcode.  This value      was chosen to give a reasonable range of values.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_LINE_BASE
value|-5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Range of line offsets in a special line info. opcode.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_LINE_RANGE
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_LINE_RANGE
value|14
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_LINE_MIN_INSN_LENGTH
end_ifndef

begin_comment
comment|/* Define the architecture-dependent minimum instruction length (in      bytes).  This value should be rather too small than too big.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_LINE_MIN_INSN_LENGTH
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Flag that indicates the initial value of the is_stmt_start flag.    In the present implementation, we do not mark any lines as    the beginning of a source statement, because that information    is not made available by the GCC front-end.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_LINE_DEFAULT_IS_STMT
value|1
end_define

begin_comment
comment|/* Flag that indicates the initial value of the is_stmt_start flag.    In the present implementation, we do not mark any lines as    the beginning of a source statement, because that information    is not made available by the GCC front-end.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_LINE_DEFAULT_IS_STMT
value|1
end_define

begin_comment
comment|/* Given a special op, return the line skip amount.  */
end_comment

begin_define
define|#
directive|define
name|SPECIAL_LINE
parameter_list|(
name|op
parameter_list|)
define|\
value|(((op) - DWARF2_LINE_OPCODE_BASE)%DWARF2_LINE_RANGE + DWARF2_LINE_BASE)
end_define

begin_comment
comment|/* Given a special op, return the address skip amount (in units of    DWARF2_LINE_MIN_INSN_LENGTH.  */
end_comment

begin_define
define|#
directive|define
name|SPECIAL_ADDR
parameter_list|(
name|op
parameter_list|)
value|(((op) - DWARF2_LINE_OPCODE_BASE)/DWARF2_LINE_RANGE)
end_define

begin_comment
comment|/* The maximum address skip amount that can be encoded with a special op.  */
end_comment

begin_define
define|#
directive|define
name|MAX_SPECIAL_ADDR_DELTA
value|SPECIAL_ADDR(255)
end_define

begin_define
define|#
directive|define
name|INITIAL_STATE
define|\
comment|/* Initialize as per DWARF2.0 standard.  */
define|\
value|0,
comment|/* address */
value|\   1,
comment|/* file */
value|\   1,
comment|/* line */
value|\   0,
comment|/* column */
value|\   DWARF2_LINE_DEFAULT_IS_STMT,
comment|/* is_stmt */
value|\   0,
comment|/* basic_block */
value|\   1
end_define

begin_comment
comment|/* empty_sequence */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* state machine state as per DWARF2 manual: */
struct|struct
name|dwarf2_sm
block|{
name|addressT
name|addr
decl_stmt|;
name|unsigned
name|int
name|filenum
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|unsigned
name|int
name|is_stmt
range|:
literal|1
decl_stmt|,
name|basic_block
range|:
literal|1
decl_stmt|,
name|empty_sequence
range|:
literal|1
decl_stmt|;
comment|/* current code sequence has no DWARF2 directives? */
block|}
name|sm
struct|;
name|unsigned
name|int
name|any_dwarf2_directives
range|:
literal|1
decl_stmt|;
comment|/* did we emit any DWARF2 line debug directives? */
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* frag that "addr" is relative to */
name|segT
name|text_seg
decl_stmt|;
comment|/* text segment "addr" is relative to */
name|subsegT
name|text_subseg
decl_stmt|;
name|segT
name|line_seg
decl_stmt|;
comment|/* ".debug_line" segment */
name|int
name|last_filename
decl_stmt|;
comment|/* index of last filename that was used */
name|int
name|num_filenames
decl_stmt|;
comment|/* index of last filename in use */
name|int
name|filename_len
decl_stmt|;
comment|/* length of the filename array */
struct|struct
block|{
name|int
name|dir
decl_stmt|;
comment|/* valid after gen_dir_list() only */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full path before gen_dir_list(), filename afterwards */
block|}
modifier|*
name|file
struct|;
name|struct
name|dwarf2_line_info
name|current
decl_stmt|;
comment|/* current source info: */
comment|/* counters for statistical purposes: */
name|unsigned
name|int
name|num_line_entries
decl_stmt|;
name|unsigned
name|int
name|opcode_hist
index|[
literal|256
index|]
decl_stmt|;
comment|/* histogram of opcode frequencies */
block|}
name|ls
init|=
block|{
block|{
name|INITIAL_STATE
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Function prototypes: */
end_comment

begin_decl_stmt
specifier|static
name|void
name|out_uleb128
name|PARAMS
argument_list|(
operator|(
name|addressT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|out_sleb128
name|PARAMS
argument_list|(
operator|(
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_addr_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|addressT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_state_machine
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|out_set_addr
name|PARAMS
argument_list|(
operator|(
name|addressT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|out_end_sequence
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_filenum
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_dir_list
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_file_list
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_stats
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|out_byte
parameter_list|(
name|byte
parameter_list|)
value|FRAG_APPEND_1_CHAR(byte)
end_define

begin_define
define|#
directive|define
name|out_opcode
parameter_list|(
name|opc
parameter_list|)
value|(out_byte ((opc)), ++ls.opcode_hist[(opc)& 0xff])
end_define

begin_comment
comment|/* Output an unsigned "little-endian base 128" number.  */
end_comment

begin_function
specifier|static
name|void
name|out_uleb128
parameter_list|(
name|value
parameter_list|)
name|addressT
name|value
decl_stmt|;
block|{
name|unsigned
name|char
name|byte
decl_stmt|,
name|more
init|=
literal|0x80
decl_stmt|;
do|do
block|{
name|byte
operator|=
name|value
operator|&
literal|0x7f
expr_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|more
operator|=
literal|0
expr_stmt|;
name|out_byte
argument_list|(
name|more
operator||
name|byte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|more
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Output a signed "little-endian base 128" number.  */
end_comment

begin_function
specifier|static
name|void
name|out_sleb128
parameter_list|(
name|value
parameter_list|)
name|offsetT
name|value
decl_stmt|;
block|{
name|unsigned
name|char
name|byte
decl_stmt|,
name|more
init|=
literal|0x80
decl_stmt|;
do|do
block|{
name|byte
operator|=
name|value
operator|&
literal|0x7f
expr_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|value
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|value
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|more
operator|=
literal|0
expr_stmt|;
name|out_byte
argument_list|(
name|more
operator||
name|byte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|more
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Encode a pair of line and address skips as efficiently as possible.    Note that the line skip is signed, whereas the address skip is    unsigned.  */
end_comment

begin_function
specifier|static
name|void
name|gen_addr_line
parameter_list|(
name|line_delta
parameter_list|,
name|addr_delta
parameter_list|)
name|int
name|line_delta
decl_stmt|;
name|addressT
name|addr_delta
decl_stmt|;
block|{
name|unsigned
name|int
name|tmp
decl_stmt|,
name|opcode
decl_stmt|;
name|tmp
operator|=
name|line_delta
operator|-
name|DWARF2_LINE_BASE
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|DWARF2_LINE_RANGE
condition|)
block|{
name|out_opcode
argument_list|(
name|DW_LNS_advance_line
argument_list|)
expr_stmt|;
name|out_sleb128
argument_list|(
name|line_delta
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
operator|-
name|DWARF2_LINE_BASE
expr_stmt|;
name|line_delta
operator|=
literal|0
expr_stmt|;
block|}
name|tmp
operator|+=
name|DWARF2_LINE_OPCODE_BASE
expr_stmt|;
comment|/* try using a special opcode: */
name|opcode
operator|=
name|tmp
operator|+
name|addr_delta
operator|*
name|DWARF2_LINE_RANGE
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
literal|255
condition|)
block|{
name|out_opcode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try using DW_LNS_const_add_pc followed by special op: */
name|opcode
operator|=
name|tmp
operator|+
operator|(
name|addr_delta
operator|-
name|MAX_SPECIAL_ADDR_DELTA
operator|)
operator|*
name|DWARF2_LINE_RANGE
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
literal|255
condition|)
block|{
name|out_opcode
argument_list|(
name|DW_LNS_const_add_pc
argument_list|)
expr_stmt|;
name|out_opcode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
return|return;
block|}
name|out_opcode
argument_list|(
name|DW_LNS_advance_pc
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|addr_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_delta
condition|)
name|out_opcode
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* output line-delta */
else|else
name|out_opcode
argument_list|(
name|DW_LNS_copy
argument_list|)
expr_stmt|;
comment|/* append new row with current info */
block|}
end_function

begin_function
specifier|static
name|void
name|reset_state_machine
parameter_list|()
block|{
specifier|static
specifier|const
name|struct
name|dwarf2_sm
name|initial_state
init|=
block|{
name|INITIAL_STATE
block|}
decl_stmt|;
name|ls
operator|.
name|sm
operator|=
name|initial_state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set an absolute address (may results in a relocation entry): */
end_comment

begin_function
specifier|static
name|void
name|out_set_addr
parameter_list|(
name|addr
parameter_list|)
name|addressT
name|addr
decl_stmt|;
block|{
name|subsegT
name|saved_subseg
decl_stmt|;
name|segT
name|saved_seg
decl_stmt|;
name|expressionS
name|expr
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|bytes_per_address
decl_stmt|;
name|saved_seg
operator|=
name|now_seg
expr_stmt|;
name|saved_subseg
operator|=
name|now_subseg
expr_stmt|;
name|subseg_set
argument_list|(
name|ls
operator|.
name|text_seg
argument_list|,
name|ls
operator|.
name|text_subseg
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".L0\001"
argument_list|,
name|now_seg
argument_list|,
name|addr
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bytes_per_address
operator|=
name|bfd_arch_bits_per_address
argument_list|(
name|stdoutput
argument_list|)
operator|/
literal|8
expr_stmt|;
else|#
directive|else
comment|/* FIXME.  */
name|bytes_per_address
operator|=
literal|4
expr_stmt|;
endif|#
directive|endif
name|out_opcode
argument_list|(
name|DW_LNS_extended_op
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|bytes_per_address
operator|+
literal|1
argument_list|)
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNE_set_address
argument_list|)
expr_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|bytes_per_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit DW_LNS_end_sequence and reset state machine.  Does not    preserve the current segment/sub-segment!  */
end_comment

begin_function
specifier|static
name|void
name|out_end_sequence
parameter_list|()
block|{
name|addressT
name|addr
decl_stmt|,
name|delta
decl_stmt|;
name|fragS
modifier|*
name|text_frag
decl_stmt|;
if|if
condition|(
name|ls
operator|.
name|text_seg
condition|)
block|{
name|subseg_set
argument_list|(
name|ls
operator|.
name|text_seg
argument_list|,
name|ls
operator|.
name|text_subseg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_current_text_addr
name|addr
operator|=
name|md_current_text_addr
argument_list|()
expr_stmt|;
else|#
directive|else
name|addr
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|text_frag
operator|=
name|frag_now
expr_stmt|;
name|subseg_set
argument_list|(
name|ls
operator|.
name|line_seg
argument_list|,
name|DL_BODY
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_frag
operator|!=
name|ls
operator|.
name|frag
condition|)
block|{
name|out_set_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ls
operator|.
name|sm
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|ls
operator|.
name|frag
operator|=
name|text_frag
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
operator|(
name|addr
operator|-
name|ls
operator|.
name|sm
operator|.
name|addr
operator|)
operator|/
name|DWARF2_LINE_MIN_INSN_LENGTH
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
comment|/* Advance address without updating the line-debug 		 matrix---the end_sequence entry is used only to tell 		 the debugger the end of the sequence.*/
name|out_opcode
argument_list|(
name|DW_LNS_advance_pc
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|subseg_set
argument_list|(
name|ls
operator|.
name|line_seg
argument_list|,
name|DL_BODY
argument_list|)
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_extended_op
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out_byte
argument_list|(
name|DW_LNE_end_sequence
argument_list|)
expr_stmt|;
name|reset_state_machine
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up a filenumber either by filename or by filenumber.  If both    a filenumber and a filename are specified, lookup by filename takes    precedence.  If the filename cannot be found, it is added to the    filetable and the filenumber for the new entry is returned.  */
end_comment

begin_function
specifier|static
name|int
name|get_filenum
parameter_list|(
name|filenum
parameter_list|,
name|file
parameter_list|)
name|int
name|filenum
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|last
init|=
name|filenum
operator|-
literal|1
decl_stmt|;
name|char
name|char0
init|=
name|file
index|[
literal|0
index|]
decl_stmt|;
comment|/* If filenum is out of range of the filename table, then try using the      table entry returned from the previous call.  */
if|if
condition|(
name|last
operator|>=
name|ls
operator|.
name|num_filenames
operator|||
name|last
operator|<
literal|0
condition|)
name|last
operator|=
name|ls
operator|.
name|last_filename
expr_stmt|;
comment|/* Do a quick check against the specified or previously used filenum.  */
if|if
condition|(
name|ls
operator|.
name|num_filenames
operator|>
literal|0
operator|&&
name|ls
operator|.
name|file
index|[
name|last
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
name|char0
operator|&&
name|strcmp
argument_list|(
name|ls
operator|.
name|file
index|[
name|last
index|]
operator|.
name|name
operator|+
literal|1
argument_list|,
name|file
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|last
operator|+
literal|1
return|;
comment|/* no match, fall back to simple linear scan: */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ls
operator|.
name|num_filenames
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ls
operator|.
name|file
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
name|char0
operator|&&
name|strcmp
argument_list|(
name|ls
operator|.
name|file
index|[
name|i
index|]
operator|.
name|name
operator|+
literal|1
argument_list|,
name|file
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ls
operator|.
name|last_filename
operator|=
name|i
expr_stmt|;
return|return
name|i
operator|+
literal|1
return|;
block|}
block|}
comment|/* no match: enter new filename */
if|if
condition|(
name|ls
operator|.
name|num_filenames
operator|>=
name|ls
operator|.
name|filename_len
condition|)
block|{
name|ls
operator|.
name|filename_len
operator|+=
literal|13
expr_stmt|;
name|ls
operator|.
name|file
operator|=
name|xrealloc
argument_list|(
name|ls
operator|.
name|file
argument_list|,
name|ls
operator|.
name|filename_len
operator|*
sizeof|sizeof
argument_list|(
name|ls
operator|.
name|file
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ls
operator|.
name|file
index|[
name|ls
operator|.
name|num_filenames
index|]
operator|.
name|dir
operator|=
literal|0
expr_stmt|;
name|ls
operator|.
name|file
index|[
name|ls
operator|.
name|num_filenames
index|]
operator|.
name|name
operator|=
name|file
expr_stmt|;
name|ls
operator|.
name|last_filename
operator|=
name|ls
operator|.
name|num_filenames
expr_stmt|;
return|return
operator|++
name|ls
operator|.
name|num_filenames
return|;
block|}
end_function

begin_comment
comment|/* Emit an entry in the line number table if the address or line has changed.    ADDR is relative to the current frag in the text section.  */
end_comment

begin_function
name|void
name|dwarf2_gen_line_info
parameter_list|(
name|addr
parameter_list|,
name|l
parameter_list|)
name|addressT
name|addr
decl_stmt|;
name|struct
name|dwarf2_line_info
modifier|*
name|l
decl_stmt|;
block|{
name|unsigned
name|int
name|filenum
init|=
name|l
operator|->
name|filenum
decl_stmt|;
name|unsigned
name|int
name|any_output
init|=
literal|0
decl_stmt|;
name|subsegT
name|saved_subseg
decl_stmt|;
name|segT
name|saved_seg
decl_stmt|;
name|fragS
modifier|*
name|saved_frag
decl_stmt|;
if|if
condition|(
name|flag_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line: addr %lx file `%s' line %u col %u flags %x\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
name|l
operator|->
name|filename
argument_list|,
name|l
operator|->
name|line
argument_list|,
name|l
operator|->
name|column
argument_list|,
name|l
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|filenum
operator|>
literal|0
operator|&&
operator|!
name|l
operator|->
name|filename
condition|)
block|{
if|if
condition|(
name|filenum
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|ls
operator|.
name|num_filenames
condition|)
block|{
name|as_warn
argument_list|(
literal|"Encountered bad file number in line number debug info!"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|l
operator|->
name|filename
condition|)
name|filenum
operator|=
name|get_filenum
argument_list|(
name|filenum
argument_list|,
name|l
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
return|return;
comment|/* no filename, no filnum => no play */
comment|/* Must save these before the subseg_new call, as that call will change      them.  */
name|saved_seg
operator|=
name|now_seg
expr_stmt|;
name|saved_subseg
operator|=
name|now_subseg
expr_stmt|;
name|saved_frag
operator|=
name|frag_now
expr_stmt|;
if|if
condition|(
operator|!
name|ls
operator|.
name|line_seg
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|symbolS
modifier|*
name|secsym
decl_stmt|;
endif|#
directive|endif
name|ls
operator|.
name|line_seg
operator|=
name|subseg_new
argument_list|(
literal|".debug_line"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|ls
operator|.
name|line_seg
argument_list|,
name|SEC_READONLY
argument_list|)
expr_stmt|;
comment|/* We're going to need this symbol.  */
name|secsym
operator|=
name|symbol_find
argument_list|(
literal|".debug_line"
argument_list|)
expr_stmt|;
if|if
condition|(
name|secsym
operator|!=
name|NULL
condition|)
name|symbol_set_bfdsym
argument_list|(
name|secsym
argument_list|,
name|ls
operator|.
name|line_seg
operator|->
name|symbol
argument_list|)
expr_stmt|;
else|else
name|symbol_table_insert
argument_list|(
name|section_symbol
argument_list|(
name|ls
operator|.
name|line_seg
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|subseg_set
argument_list|(
name|ls
operator|.
name|line_seg
argument_list|,
name|DL_BODY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|.
name|text_seg
operator|!=
name|saved_seg
operator|||
name|ls
operator|.
name|text_subseg
operator|!=
name|saved_subseg
condition|)
block|{
if|if
condition|(
operator|!
name|ls
operator|.
name|sm
operator|.
name|empty_sequence
condition|)
block|{
name|out_end_sequence
argument_list|()
expr_stmt|;
comment|/* terminate previous sequence */
name|ls
operator|.
name|sm
operator|.
name|empty_sequence
operator|=
literal|1
expr_stmt|;
block|}
name|any_output
operator|=
literal|1
expr_stmt|;
name|ls
operator|.
name|text_seg
operator|=
name|saved_seg
expr_stmt|;
name|ls
operator|.
name|text_subseg
operator|=
name|saved_subseg
expr_stmt|;
name|out_set_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ls
operator|.
name|sm
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|ls
operator|.
name|frag
operator|=
name|saved_frag
expr_stmt|;
block|}
if|if
condition|(
name|ls
operator|.
name|sm
operator|.
name|filenum
operator|!=
name|filenum
condition|)
block|{
name|any_output
operator|=
literal|1
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_set_file
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|filenum
argument_list|)
expr_stmt|;
name|ls
operator|.
name|sm
operator|.
name|filenum
operator|=
name|filenum
expr_stmt|;
block|}
if|if
condition|(
name|ls
operator|.
name|sm
operator|.
name|column
operator|!=
name|l
operator|->
name|column
condition|)
block|{
name|any_output
operator|=
literal|1
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_set_column
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|l
operator|->
name|column
argument_list|)
expr_stmt|;
name|ls
operator|.
name|sm
operator|.
name|column
operator|=
name|l
operator|->
name|column
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|l
operator|->
name|flags
operator|&
name|DWARF2_FLAG_BEGIN_STMT
operator|)
operator|!=
literal|0
operator|)
operator|!=
name|ls
operator|.
name|sm
operator|.
name|is_stmt
condition|)
block|{
name|any_output
operator|=
literal|1
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_negate_stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|->
name|flags
operator|&
name|DWARF2_FLAG_BEGIN_BLOCK
condition|)
block|{
name|any_output
operator|=
literal|1
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_set_basic_block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ls
operator|.
name|sm
operator|.
name|line
operator|!=
name|l
operator|->
name|line
condition|)
block|{
name|any_output
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|saved_frag
operator|!=
name|ls
operator|.
name|frag
condition|)
block|{
comment|/* If a new frag got allocated (for whatever reason), then 	     deal with it by generating a reference symbol.  Note: no 	     end_sequence needs to be generated because the address did 	     not really decrease (only the reference point changed).  */
name|out_set_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ls
operator|.
name|sm
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|ls
operator|.
name|frag
operator|=
name|saved_frag
expr_stmt|;
block|}
name|gen_addr_line
argument_list|(
name|l
operator|->
name|line
operator|-
name|ls
operator|.
name|sm
operator|.
name|line
argument_list|,
operator|(
name|addr
operator|-
name|ls
operator|.
name|sm
operator|.
name|addr
operator|)
operator|/
name|DWARF2_LINE_MIN_INSN_LENGTH
argument_list|)
expr_stmt|;
name|ls
operator|.
name|sm
operator|.
name|basic_block
operator|=
literal|0
expr_stmt|;
name|ls
operator|.
name|sm
operator|.
name|line
operator|=
name|l
operator|->
name|line
expr_stmt|;
name|ls
operator|.
name|sm
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
block|}
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
name|ls
operator|.
name|num_line_entries
operator|+=
name|any_output
expr_stmt|;
if|if
condition|(
name|any_output
condition|)
name|ls
operator|.
name|sm
operator|.
name|empty_sequence
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_dir_list
parameter_list|()
block|{
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|dir_list
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|num_dirs
decl_stmt|;
name|dir_list
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|num_dirs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ls
operator|.
name|num_filenames
condition|;
operator|++
name|i
control|)
block|{
name|str
operator|=
name|ls
operator|.
name|file
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|str
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|dp
operator|=
name|dir_list
init|;
name|j
operator|<
name|num_dirs
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|dp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ls
operator|.
name|file
index|[
name|i
index|]
operator|.
name|dir
operator|=
name|j
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|dp
operator|+=
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>=
name|num_dirs
condition|)
block|{
comment|/* didn't find this directory: append it to the list */
name|size_t
name|size
init|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
decl_stmt|;
name|cp
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ls
operator|.
name|file
index|[
name|i
index|]
operator|.
name|dir
operator|=
operator|++
name|num_dirs
expr_stmt|;
block|}
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
name|ls
operator|.
name|file
index|[
name|i
index|]
operator|.
name|name
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|out_byte
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* terminate directory list */
block|}
end_function

begin_function
specifier|static
name|void
name|gen_file_list
parameter_list|()
block|{
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ls
operator|.
name|num_filenames
condition|;
operator|++
name|i
control|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|ls
operator|.
name|file
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|ls
operator|.
name|file
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|ls
operator|.
name|file
index|[
name|i
index|]
operator|.
name|dir
argument_list|)
expr_stmt|;
comment|/* directory number */
name|out_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* last modification timestamp */
name|out_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* filesize */
block|}
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* terminate filename list */
block|}
end_function

begin_function
specifier|static
name|void
name|print_stats
parameter_list|(
name|total_size
parameter_list|)
name|unsigned
name|long
name|total_size
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|opc_name
index|[]
init|=
block|{
literal|"extended"
block|,
literal|"copy"
block|,
literal|"advance_pc"
block|,
literal|"advance_line"
block|,
literal|"set_file"
block|,
literal|"set_column"
block|,
literal|"negate_stmt"
block|,
literal|"set_basic_block"
block|,
literal|"const_add_pc"
block|,
literal|"fixed_advance_pc"
block|}
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Average size: %g bytes/line\n"
argument_list|,
name|total_size
operator|/
operator|(
name|double
operator|)
name|ls
operator|.
name|num_line_entries
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nStandard opcode histogram:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|opc_name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|opc_name
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|opc_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|strlen
argument_list|(
name|opc_name
index|[
name|i
index|]
argument_list|)
init|;
name|j
operator|<
literal|16
condition|;
operator|++
name|j
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %u\n"
argument_list|,
name|ls
operator|.
name|opcode_hist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSpecial opcodes:\naddr\t\t\t\tline skip\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"skip: "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|DWARF2_LINE_BASE
init|;
name|j
operator|<
name|DWARF2_LINE_BASE
operator|+
name|DWARF2_LINE_RANGE
condition|;
operator|++
name|j
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n-----"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
name|j
operator|=
name|SPECIAL_LINE
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|DWARF2_LINE_BASE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%4u: "
argument_list|,
operator|(
operator|(
name|unsigned
name|int
operator|)
name|DWARF2_LINE_MIN_INSN_LENGTH
operator|*
name|SPECIAL_ADDR
argument_list|(
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %2u"
argument_list|,
name|ls
operator|.
name|opcode_hist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarf2_finish
parameter_list|()
block|{
name|addressT
name|body_size
decl_stmt|,
name|total_size
decl_stmt|,
name|prolog_size
decl_stmt|;
name|subsegT
name|saved_subseg
decl_stmt|;
name|segT
name|saved_seg
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|ls
operator|.
name|line_seg
condition|)
comment|/* no .debug_line segment, no work to do... */
return|return;
name|saved_seg
operator|=
name|now_seg
expr_stmt|;
name|saved_subseg
operator|=
name|now_subseg
expr_stmt|;
if|if
condition|(
operator|!
name|ls
operator|.
name|sm
operator|.
name|empty_sequence
condition|)
name|out_end_sequence
argument_list|()
expr_stmt|;
name|total_size
operator|=
name|body_size
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
comment|/* now generate the directory and file lists: */
name|subseg_set
argument_list|(
name|ls
operator|.
name|line_seg
argument_list|,
name|DL_FILES
argument_list|)
expr_stmt|;
name|gen_dir_list
argument_list|()
expr_stmt|;
name|gen_file_list
argument_list|()
expr_stmt|;
name|total_size
operator|+=
name|frag_now_fix
argument_list|()
expr_stmt|;
comment|/* and now the header ("statement program prolog", in DWARF2 lingo...) */
name|subseg_set
argument_list|(
name|ls
operator|.
name|line_seg
argument_list|,
name|DL_PROLOG
argument_list|)
expr_stmt|;
name|cp
operator|=
name|frag_more
argument_list|(
literal|15
operator|+
name|DWARF2_LINE_OPCODE_BASE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_size
operator|+=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|prolog_size
operator|=
name|total_size
operator|-
name|body_size
operator|-
literal|10
expr_stmt|;
define|#
directive|define
name|STUFF
parameter_list|(
name|val
parameter_list|,
name|size
parameter_list|)
value|md_number_to_chars (cp, val, size); cp += size;
name|STUFF
argument_list|(
name|total_size
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* length */
name|STUFF
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* version */
name|STUFF
argument_list|(
name|prolog_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* prologue_length */
name|STUFF
argument_list|(
name|DWARF2_LINE_MIN_INSN_LENGTH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STUFF
argument_list|(
name|DWARF2_LINE_DEFAULT_IS_STMT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STUFF
argument_list|(
name|DWARF2_LINE_BASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STUFF
argument_list|(
name|DWARF2_LINE_RANGE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STUFF
argument_list|(
name|DWARF2_LINE_OPCODE_BASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* standard_opcode_lengths: */
name|STUFF
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_copy */
name|STUFF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_advance_pc */
name|STUFF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_advance_line */
name|STUFF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_set_file */
name|STUFF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_set_column */
name|STUFF
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_negate_stmt */
name|STUFF
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_set_basic_block */
name|STUFF
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_const_add_pc */
name|STUFF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_fixed_advance_pc */
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug
condition|)
name|print_stats
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarf2_directive_file
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
comment|/* Continue to accept a bare string and pass it off.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|s_app_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|ls
operator|.
name|any_dwarf2_directives
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_NONE
condition|)
comment|/* Automatically turn on DWARF2 debug info unless something else        has been selected.  */
name|debug_type
operator|=
name|DEBUG_DWARF2
expr_stmt|;
name|ls
operator|.
name|current
operator|.
name|filenum
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|ls
operator|.
name|current
operator|.
name|filename
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarf2_directive_loc
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ls
operator|.
name|any_dwarf2_directives
operator|=
literal|1
expr_stmt|;
name|ls
operator|.
name|current
operator|.
name|filenum
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|ls
operator|.
name|current
operator|.
name|line
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|ls
operator|.
name|current
operator|.
name|column
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|ls
operator|.
name|current
operator|.
name|flags
operator|=
name|DWARF2_FLAG_BEGIN_STMT
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_line
argument_list|(
name|ls
operator|.
name|current
operator|.
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|dwarf2_where
parameter_list|(
name|line
parameter_list|)
name|struct
name|dwarf2_line_info
modifier|*
name|line
decl_stmt|;
block|{
if|if
condition|(
name|ls
operator|.
name|any_dwarf2_directives
condition|)
operator|*
name|line
operator|=
name|ls
operator|.
name|current
expr_stmt|;
else|else
block|{
name|as_where
argument_list|(
operator|&
name|line
operator|->
name|filename
argument_list|,
operator|&
name|line
operator|->
name|line
argument_list|)
expr_stmt|;
name|line
operator|->
name|filenum
operator|=
literal|0
expr_stmt|;
name|line
operator|->
name|column
operator|=
literal|0
expr_stmt|;
name|line
operator|->
name|flags
operator|=
name|DWARF2_FLAG_BEGIN_STMT
expr_stmt|;
block|}
block|}
end_function

end_unit

