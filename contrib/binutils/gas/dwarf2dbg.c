begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dwarf2dbg.c - DWARF2 debug support    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by David Mosberger-Tang<davidm@hpl.hp.com>     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* Logical line numbers can be controlled by the compiler via the    following directives:  	.file FILENO "file.c" 	.loc  FILENO LINENO [COLUMN] [basic_block] [prologue_end] \ 	      [epilogue_begin] [is_stmt VALUE] [isa VALUE] */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_MAX
end_ifndef

begin_define
define|#
directive|define
name|INT_MAX
value|(int) (((unsigned) (-1))>> 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|<filenames.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
end_ifdef

begin_comment
comment|/* We need to decide which character to use as a directory separator.    Just because HAVE_DOS_BASED_FILE_SYSTEM is defined, it does not    necessarily mean that the backslash character is the one to use.    Some environments, eg Cygwin, can support both naming conventions.    So we use the heuristic that we only need to use the backslash if    the path is an absolute path starting with a DOS style drive    selector.  eg C: or D:  */
end_comment

begin_define
define|#
directive|define
name|INSERT_DIR_SEPARATOR
parameter_list|(
name|string
parameter_list|,
name|offset
parameter_list|)
define|\
value|do \     { \       if (offset> 1 \&& string[0] != 0 \&& string[1] == ':') \        string [offset] = '\\'; \       else \        string [offset] = '/'; \     } \   while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INSERT_DIR_SEPARATOR
parameter_list|(
name|string
parameter_list|,
name|offset
parameter_list|)
value|string[offset] = '/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_FORMAT
parameter_list|()
value|dwarf2_format_32bit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_ADDR_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_ADDR_SIZE
parameter_list|(
name|bfd
parameter_list|)
value|(bfd_arch_bits_per_address (bfd) / 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_comment
comment|/* Since we can't generate the prolog until the body is complete, we    use three different subsegments for .debug_line: one holding the    prolog, one for the directory and filename info, and one for the    body ("statement program").  */
end_comment

begin_define
define|#
directive|define
name|DL_PROLOG
value|0
end_define

begin_define
define|#
directive|define
name|DL_FILES
value|1
end_define

begin_define
define|#
directive|define
name|DL_BODY
value|2
end_define

begin_comment
comment|/* If linker relaxation might change offsets in the code, the DWARF special    opcodes and variable-length operands cannot be used.  If this macro is    nonzero, use the DW_LNS_fixed_advance_pc opcode instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_USE_FIXED_ADVANCE_PC
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_USE_FIXED_ADVANCE_PC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* First special line opcde - leave room for the standard opcodes.    Note: If you want to change this, you'll have to update the    "standard_opcode_lengths" table that is emitted below in    out_debug_line().  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_LINE_OPCODE_BASE
value|13
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_LINE_BASE
end_ifndef

begin_comment
comment|/* Minimum line offset in a special line info. opcode.  This value      was chosen to give a reasonable range of values.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_LINE_BASE
value|-5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Range of line offsets in a special line info. opcode.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_LINE_RANGE
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_LINE_RANGE
value|14
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_LINE_MIN_INSN_LENGTH
end_ifndef

begin_comment
comment|/* Define the architecture-dependent minimum instruction length (in      bytes).  This value should be rather too small than too big.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_LINE_MIN_INSN_LENGTH
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Flag that indicates the initial value of the is_stmt_start flag.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_LINE_DEFAULT_IS_STMT
value|1
end_define

begin_comment
comment|/* Given a special op, return the line skip amount.  */
end_comment

begin_define
define|#
directive|define
name|SPECIAL_LINE
parameter_list|(
name|op
parameter_list|)
define|\
value|(((op) - DWARF2_LINE_OPCODE_BASE)%DWARF2_LINE_RANGE + DWARF2_LINE_BASE)
end_define

begin_comment
comment|/* Given a special op, return the address skip amount (in units of    DWARF2_LINE_MIN_INSN_LENGTH.  */
end_comment

begin_define
define|#
directive|define
name|SPECIAL_ADDR
parameter_list|(
name|op
parameter_list|)
value|(((op) - DWARF2_LINE_OPCODE_BASE)/DWARF2_LINE_RANGE)
end_define

begin_comment
comment|/* The maximum address skip amount that can be encoded with a special op.  */
end_comment

begin_define
define|#
directive|define
name|MAX_SPECIAL_ADDR_DELTA
value|SPECIAL_ADDR(255)
end_define

begin_struct
struct|struct
name|line_entry
block|{
name|struct
name|line_entry
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
name|struct
name|dwarf2_line_info
name|loc
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|line_subseg
block|{
name|struct
name|line_subseg
modifier|*
name|next
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
name|struct
name|line_entry
modifier|*
name|head
decl_stmt|;
name|struct
name|line_entry
modifier|*
modifier|*
name|ptail
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|line_seg
block|{
name|struct
name|line_seg
modifier|*
name|next
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|struct
name|line_subseg
modifier|*
name|head
decl_stmt|;
name|symbolS
modifier|*
name|text_start
decl_stmt|;
name|symbolS
modifier|*
name|text_end
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Collects data for all line table entries during assembly.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|line_seg
modifier|*
name|all_segs
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|file_entry
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|dir
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Table of files used by .debug_line.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_entry
modifier|*
name|files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|files_in_use
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|files_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of directories used by .debug_line.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|dirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dirs_in_use
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dirs_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE when we've seen a .loc directive recently.  Used to avoid    doing work when there's nothing to do.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|loc_directive_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE when we're supposed to set the basic block mark whenever a    label is seen.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|dwarf2_loc_mark_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current location as indicated by the most recent .loc directive.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dwarf2_line_info
name|current
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|DWARF2_LINE_DEFAULT_IS_STMT
operator|?
name|DWARF2_FLAG_IS_STMT
operator|:
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of an address on the target.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|sizeof_address
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|struct
name|line_subseg
modifier|*
name|get_line_subseg
parameter_list|(
name|segT
parameter_list|,
name|subsegT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|get_filenum
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|frag
modifier|*
name|first_frag_for_seg
parameter_list|(
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|frag
modifier|*
name|last_frag_for_seg
parameter_list|(
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_byte
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_opcode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_two
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_four
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_abbrev
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_uleb128
parameter_list|(
name|addressT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_sleb128
parameter_list|(
name|addressT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|offsetT
name|get_frag_fix
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_set_addr
parameter_list|(
name|symbolS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|size_inc_line_addr
parameter_list|(
name|int
parameter_list|,
name|addressT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_inc_line_addr
parameter_list|(
name|int
parameter_list|,
name|addressT
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_inc_line_addr
parameter_list|(
name|int
parameter_list|,
name|addressT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_fixed_inc_line_addr
parameter_list|(
name|int
parameter_list|,
name|symbolS
modifier|*
parameter_list|,
name|symbolS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|relax_inc_line_addr
parameter_list|(
name|int
parameter_list|,
name|symbolS
modifier|*
parameter_list|,
name|symbolS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_entries
parameter_list|(
name|segT
parameter_list|,
name|struct
name|line_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_file_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_debug_line
parameter_list|(
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_debug_aranges
parameter_list|(
name|segT
parameter_list|,
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_debug_abbrev
parameter_list|(
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|TC_DWARF2_EMIT_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|TC_DWARF2_EMIT_OFFSET
value|generic_dwarf2_emit_offset
end_define

begin_comment
comment|/* Create an offset to .dwarf2_*.  */
end_comment

begin_function
specifier|static
name|void
name|generic_dwarf2_emit_offset
parameter_list|(
name|symbolS
modifier|*
name|symbol
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|expressionS
name|expr
decl_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|symbol
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Find or create an entry for SEG+SUBSEG in ALL_SEGS.  */
end_comment

begin_function
specifier|static
name|struct
name|line_subseg
modifier|*
name|get_line_subseg
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
specifier|static
name|segT
name|last_seg
decl_stmt|;
specifier|static
name|subsegT
name|last_subseg
decl_stmt|;
specifier|static
name|struct
name|line_subseg
modifier|*
name|last_line_subseg
decl_stmt|;
name|struct
name|line_seg
modifier|*
modifier|*
name|ps
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|struct
name|line_subseg
modifier|*
modifier|*
name|pss
decl_stmt|,
modifier|*
name|ss
decl_stmt|;
if|if
condition|(
name|seg
operator|==
name|last_seg
operator|&&
name|subseg
operator|==
name|last_subseg
condition|)
return|return
name|last_line_subseg
return|;
for|for
control|(
name|ps
operator|=
operator|&
name|all_segs
init|;
operator|(
name|s
operator|=
operator|*
name|ps
operator|)
operator|!=
name|NULL
condition|;
name|ps
operator|=
operator|&
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|seg
operator|==
name|seg
condition|)
goto|goto
name|found_seg
goto|;
name|s
operator|=
operator|(
expr|struct
name|line_seg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|seg
operator|=
name|seg
expr_stmt|;
name|s
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
operator|*
name|ps
operator|=
name|s
expr_stmt|;
name|found_seg
label|:
for|for
control|(
name|pss
operator|=
operator|&
name|s
operator|->
name|head
init|;
operator|(
name|ss
operator|=
operator|*
name|pss
operator|)
operator|!=
name|NULL
condition|;
name|pss
operator|=
operator|&
name|ss
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ss
operator|->
name|subseg
operator|==
name|subseg
condition|)
goto|goto
name|found_subseg
goto|;
if|if
condition|(
name|ss
operator|->
name|subseg
operator|>
name|subseg
condition|)
break|break;
block|}
name|ss
operator|=
operator|(
expr|struct
name|line_subseg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|next
operator|=
operator|*
name|pss
expr_stmt|;
name|ss
operator|->
name|subseg
operator|=
name|subseg
expr_stmt|;
name|ss
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|ss
operator|->
name|ptail
operator|=
operator|&
name|ss
operator|->
name|head
expr_stmt|;
operator|*
name|pss
operator|=
name|ss
expr_stmt|;
name|found_subseg
label|:
name|last_seg
operator|=
name|seg
expr_stmt|;
name|last_subseg
operator|=
name|subseg
expr_stmt|;
name|last_line_subseg
operator|=
name|ss
expr_stmt|;
return|return
name|ss
return|;
block|}
end_function

begin_comment
comment|/* Record an entry for LOC occurring at LABEL.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_gen_line_info_1
parameter_list|(
name|symbolS
modifier|*
name|label
parameter_list|,
name|struct
name|dwarf2_line_info
modifier|*
name|loc
parameter_list|)
block|{
name|struct
name|line_subseg
modifier|*
name|ss
decl_stmt|;
name|struct
name|line_entry
modifier|*
name|e
decl_stmt|;
name|e
operator|=
operator|(
expr|struct
name|line_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|e
operator|->
name|loc
operator|=
operator|*
name|loc
expr_stmt|;
name|ss
operator|=
name|get_line_subseg
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|)
expr_stmt|;
operator|*
name|ss
operator|->
name|ptail
operator|=
name|e
expr_stmt|;
name|ss
operator|->
name|ptail
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record an entry for LOC occurring at OFS within the current fragment.  */
end_comment

begin_function
name|void
name|dwarf2_gen_line_info
parameter_list|(
name|addressT
name|ofs
parameter_list|,
name|struct
name|dwarf2_line_info
modifier|*
name|loc
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
name|line
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|unsigned
name|int
name|filenum
init|=
operator|-
literal|1
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
comment|/* Early out for as-yet incomplete location information.  */
if|if
condition|(
name|loc
operator|->
name|filenum
operator|==
literal|0
operator|||
name|loc
operator|->
name|line
operator|==
literal|0
condition|)
return|return;
comment|/* Don't emit sequences of line symbols for the same line when the      symbols apply to assembler code.  It is necessary to emit      duplicate line symbols when a compiler asks for them, because GDB      uses them to determine the end of the prologue.  */
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_DWARF2
operator|&&
name|line
operator|==
name|loc
operator|->
name|line
operator|&&
name|filenum
operator|==
name|loc
operator|->
name|filenum
condition|)
return|return;
name|line
operator|=
name|loc
operator|->
name|line
expr_stmt|;
name|filenum
operator|=
name|loc
operator|->
name|filenum
expr_stmt|;
name|sym
operator|=
name|symbol_temp_new
argument_list|(
name|now_seg
argument_list|,
name|ofs
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|dwarf2_gen_line_info_1
argument_list|(
name|sym
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the current source information.  If .file directives have    been encountered, the info for the corresponding source file is    returned.  Otherwise, the info for the assembly source file is    returned.  */
end_comment

begin_function
name|void
name|dwarf2_where
parameter_list|(
name|struct
name|dwarf2_line_info
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_DWARF2
condition|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|filename
argument_list|,
operator|&
name|line
operator|->
name|line
argument_list|)
expr_stmt|;
name|line
operator|->
name|filenum
operator|=
name|get_filenum
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
operator|->
name|column
operator|=
literal|0
expr_stmt|;
name|line
operator|->
name|flags
operator|=
name|DWARF2_FLAG_IS_STMT
expr_stmt|;
name|line
operator|->
name|isa
operator|=
name|current
operator|.
name|isa
expr_stmt|;
block|}
else|else
operator|*
name|line
operator|=
name|current
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A hook to allow the target backend to inform the line number state     machine of isa changes when assembler debug info is enabled.  */
end_comment

begin_function
name|void
name|dwarf2_set_isa
parameter_list|(
name|unsigned
name|int
name|isa
parameter_list|)
block|{
name|current
operator|.
name|isa
operator|=
name|isa
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called for each machine instruction, or relatively atomic group of    machine instructions (ie built-in macro).  The instruction or group    is SIZE bytes in length.  If dwarf2 line number generation is called    for, emit a line statement appropriately.  */
end_comment

begin_function
name|void
name|dwarf2_emit_insn
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|struct
name|dwarf2_line_info
name|loc
decl_stmt|;
if|if
condition|(
name|loc_directive_seen
condition|)
block|{
comment|/* Use the last location established by a .loc directive, not 	 the value returned by dwarf2_where().  That calls as_where() 	 which will return either the logical input file name (foo.c) 	or the physical input file name (foo.s) and not the file name 	specified in the most recent .loc directive (eg foo.h).  */
name|loc
operator|=
name|current
expr_stmt|;
comment|/* Unless we generate DWARF2 debugging information for each 	 assembler line, we only emit one line symbol for one LOC.  */
if|if
condition|(
name|debug_type
operator|!=
name|DEBUG_DWARF2
condition|)
name|loc_directive_seen
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug_type
operator|!=
name|DEBUG_DWARF2
condition|)
return|return;
else|else
name|dwarf2_where
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
name|dwarf2_gen_line_info
argument_list|(
name|frag_now_fix
argument_list|()
operator|-
name|size
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|current
operator|.
name|flags
operator|&=
operator|~
operator|(
name|DWARF2_FLAG_BASIC_BLOCK
operator||
name|DWARF2_FLAG_PROLOGUE_END
operator||
name|DWARF2_FLAG_EPILOGUE_BEGIN
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called for each (preferably code) label.  If dwarf2_loc_mark_labels    is enabled, emit a basic block marker.  */
end_comment

begin_function
name|void
name|dwarf2_emit_label
parameter_list|(
name|symbolS
modifier|*
name|label
parameter_list|)
block|{
name|struct
name|dwarf2_line_info
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|dwarf2_loc_mark_labels
condition|)
return|return;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|label
argument_list|)
operator|!=
name|now_seg
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
condition|)
return|return;
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_DWARF2
condition|)
name|dwarf2_where
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
else|else
block|{
name|loc
operator|=
name|current
expr_stmt|;
name|loc_directive_seen
operator|=
name|FALSE
expr_stmt|;
block|}
name|loc
operator|.
name|flags
operator||=
name|DWARF2_FLAG_BASIC_BLOCK
expr_stmt|;
name|current
operator|.
name|flags
operator|&=
operator|~
operator|(
name|DWARF2_FLAG_BASIC_BLOCK
operator||
name|DWARF2_FLAG_PROLOGUE_END
operator||
name|DWARF2_FLAG_EPILOGUE_BEGIN
operator|)
expr_stmt|;
name|dwarf2_gen_line_info_1
argument_list|(
name|label
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a .debug_line file number for FILENAME.  If NUM is nonzero,    allocate it on that file table slot, otherwise return the first    empty one.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_filenum
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
name|last_used
decl_stmt|,
name|last_used_dir_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|size_t
name|dir_len
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|dir
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
operator|&&
name|last_used
condition|)
block|{
if|if
condition|(
operator|!
name|files
index|[
name|last_used
index|]
operator|.
name|dir
operator|&&
name|strcmp
argument_list|(
name|filename
argument_list|,
name|files
index|[
name|last_used
index|]
operator|.
name|filename
argument_list|)
operator|==
literal|0
condition|)
return|return
name|last_used
return|;
if|if
condition|(
name|files
index|[
name|last_used
index|]
operator|.
name|dir
operator|&&
name|strncmp
argument_list|(
name|filename
argument_list|,
name|dirs
index|[
name|files
index|[
name|last_used
index|]
operator|.
name|dir
index|]
argument_list|,
name|last_used_dir_len
argument_list|)
operator|==
literal|0
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|filename
index|[
name|last_used_dir_len
index|]
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|filename
operator|+
name|last_used_dir_len
operator|+
literal|1
argument_list|,
name|files
index|[
name|last_used
index|]
operator|.
name|filename
argument_list|)
operator|==
literal|0
condition|)
return|return
name|last_used
return|;
block|}
name|file
operator|=
name|lbasename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Don't make empty string from / or A: from A:/ .  */
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
if|if
condition|(
name|file
operator|<=
name|filename
operator|+
literal|3
condition|)
name|file
operator|=
name|filename
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|file
operator|==
name|filename
operator|+
literal|1
condition|)
name|file
operator|=
name|filename
expr_stmt|;
endif|#
directive|endif
name|dir_len
operator|=
name|file
operator|-
name|filename
expr_stmt|;
name|dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dir_len
condition|)
block|{
operator|--
name|dir_len
expr_stmt|;
for|for
control|(
name|dir
operator|=
literal|1
init|;
name|dir
operator|<
name|dirs_in_use
condition|;
operator|++
name|dir
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|filename
argument_list|,
name|dirs
index|[
name|dir
index|]
argument_list|,
name|dir_len
argument_list|)
operator|==
literal|0
operator|&&
name|dirs
index|[
name|dir
index|]
index|[
name|dir_len
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|dir
operator|>=
name|dirs_in_use
condition|)
block|{
if|if
condition|(
name|dir
operator|>=
name|dirs_allocated
condition|)
block|{
name|dirs_allocated
operator|=
name|dir
operator|+
literal|32
expr_stmt|;
name|dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|dirs
argument_list|,
operator|(
name|dir
operator|+
literal|32
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dirs
index|[
name|dir
index|]
operator|=
name|xmalloc
argument_list|(
name|dir_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dirs
index|[
name|dir
index|]
argument_list|,
name|filename
argument_list|,
name|dir_len
argument_list|)
expr_stmt|;
name|dirs
index|[
name|dir
index|]
index|[
name|dir_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dirs_in_use
operator|=
name|dir
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|files_in_use
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|dir
operator|==
name|dir
operator|&&
name|files
index|[
name|i
index|]
operator|.
name|filename
operator|&&
name|strcmp
argument_list|(
name|file
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|last_used
operator|=
name|i
expr_stmt|;
name|last_used_dir_len
operator|=
name|dir_len
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
else|else
name|i
operator|=
name|num
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|files_allocated
condition|)
block|{
name|unsigned
name|int
name|old
init|=
name|files_allocated
decl_stmt|;
name|files_allocated
operator|=
name|i
operator|+
literal|32
expr_stmt|;
name|files
operator|=
operator|(
expr|struct
name|file_entry
operator|*
operator|)
name|xrealloc
argument_list|(
name|files
argument_list|,
operator|(
name|i
operator|+
literal|32
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|files
operator|+
name|old
argument_list|,
literal|0
argument_list|,
operator|(
name|i
operator|+
literal|32
operator|-
name|old
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|files
index|[
name|i
index|]
operator|.
name|filename
operator|=
name|num
condition|?
name|file
else|:
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|files_in_use
operator|<
name|i
operator|+
literal|1
condition|)
name|files_in_use
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|last_used
operator|=
name|i
expr_stmt|;
name|last_used_dir_len
operator|=
name|dir_len
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Handle two forms of .file directive:    - Pass .file "source.c" to s_app_file    - Handle .file 1 "source.c" by adding an entry to the DWARF-2 file table     If an entry is added to the file table, return a pointer to the filename. */
end_comment

begin_function
name|char
modifier|*
name|dwarf2_directive_file
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|offsetT
name|num
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|filename_len
decl_stmt|;
comment|/* Continue to accept a bare string and pass it off.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|s_app_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|num
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|filename
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|filename_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"file number less than one"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|num
operator|<
operator|(
name|int
operator|)
name|files_in_use
operator|&&
name|files
index|[
name|num
index|]
operator|.
name|filename
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"file number %ld already allocated"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|num
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|get_filenum
argument_list|(
name|filename
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_function
name|void
name|dwarf2_directive_loc
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|offsetT
name|filenum
decl_stmt|,
name|line
decl_stmt|;
name|filenum
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|line
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|filenum
operator|<
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"file number less than one"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|filenum
operator|>=
operator|(
name|int
operator|)
name|files_in_use
operator|||
name|files
index|[
name|filenum
index|]
operator|.
name|filename
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unassigned file number %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|filenum
argument_list|)
expr_stmt|;
return|return;
block|}
name|current
operator|.
name|filenum
operator|=
name|filenum
expr_stmt|;
name|current
operator|.
name|line
operator|=
name|line
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|listing
condition|)
block|{
if|if
condition|(
name|files
index|[
name|filenum
index|]
operator|.
name|dir
condition|)
block|{
name|size_t
name|dir_len
init|=
name|strlen
argument_list|(
name|dirs
index|[
name|files
index|[
name|filenum
index|]
operator|.
name|dir
index|]
argument_list|)
decl_stmt|;
name|size_t
name|file_len
init|=
name|strlen
argument_list|(
name|files
index|[
name|filenum
index|]
operator|.
name|filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|dir_len
operator|+
literal|1
operator|+
name|file_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|dirs
index|[
name|files
index|[
name|filenum
index|]
operator|.
name|dir
index|]
argument_list|,
name|dir_len
argument_list|)
expr_stmt|;
name|INSERT_DIR_SEPARATOR
argument_list|(
name|cp
argument_list|,
name|dir_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
operator|+
name|dir_len
operator|+
literal|1
argument_list|,
name|files
index|[
name|filenum
index|]
operator|.
name|filename
argument_list|,
name|file_len
argument_list|)
expr_stmt|;
name|cp
index|[
name|dir_len
operator|+
name|file_len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|listing_source_file
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|listing_source_file
argument_list|(
name|files
index|[
name|filenum
index|]
operator|.
name|filename
argument_list|)
expr_stmt|;
name|listing_source_line
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|current
operator|.
name|column
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|ISALPHA
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|offsetT
name|value
decl_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"basic_block"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current
operator|.
name|flags
operator||=
name|DWARF2_FLAG_BASIC_BLOCK
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"prologue_end"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current
operator|.
name|flags
operator||=
name|DWARF2_FLAG_PROLOGUE_END
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"epilogue_begin"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current
operator|.
name|flags
operator||=
name|DWARF2_FLAG_EPILOGUE_BEGIN
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"is_stmt"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|value
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|current
operator|.
name|flags
operator|&=
operator|~
name|DWARF2_FLAG_IS_STMT
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
literal|1
condition|)
name|current
operator|.
name|flags
operator||=
name|DWARF2_FLAG_IS_STMT
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"is_stmt value not 0 or 1"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"isa"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|value
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
name|current
operator|.
name|isa
operator|=
name|value
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"isa number less than zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown .loc sub-directive `%s'"
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|loc_directive_seen
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarf2_directive_loc_mark_labels
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|offsetT
name|value
init|=
name|get_absolute_expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected 0 or 1"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dwarf2_loc_mark_labels
operator|=
name|value
operator|!=
literal|0
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|frag
modifier|*
name|first_frag_for_seg
parameter_list|(
name|segT
name|seg
parameter_list|)
block|{
return|return
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_root
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|frag
modifier|*
name|last_frag_for_seg
parameter_list|(
name|segT
name|seg
parameter_list|)
block|{
name|frchainS
modifier|*
name|f
init|=
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|frchainP
decl_stmt|;
while|while
condition|(
name|f
operator|->
name|frch_next
operator|!=
name|NULL
condition|)
name|f
operator|=
name|f
operator|->
name|frch_next
expr_stmt|;
return|return
name|f
operator|->
name|frch_last
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a single byte into the current segment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|out_byte
parameter_list|(
name|int
name|byte
parameter_list|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a statement program opcode into the current segment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|out_opcode
parameter_list|(
name|int
name|opc
parameter_list|)
block|{
name|out_byte
argument_list|(
name|opc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a two-byte word into the current segment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|out_two
parameter_list|(
name|int
name|data
parameter_list|)
block|{
name|md_number_to_chars
argument_list|(
name|frag_more
argument_list|(
literal|2
argument_list|)
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a four byte word into the current segment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|out_four
parameter_list|(
name|int
name|data
parameter_list|)
block|{
name|md_number_to_chars
argument_list|(
name|frag_more
argument_list|(
literal|4
argument_list|)
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an unsigned "little-endian base 128" number.  */
end_comment

begin_function
specifier|static
name|void
name|out_uleb128
parameter_list|(
name|addressT
name|value
parameter_list|)
block|{
name|output_leb128
argument_list|(
name|frag_more
argument_list|(
name|sizeof_leb128
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a signed "little-endian base 128" number.  */
end_comment

begin_function
specifier|static
name|void
name|out_sleb128
parameter_list|(
name|addressT
name|value
parameter_list|)
block|{
name|output_leb128
argument_list|(
name|frag_more
argument_list|(
name|sizeof_leb128
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a tuple for .debug_abbrev.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|out_abbrev
parameter_list|(
name|int
name|name
parameter_list|,
name|int
name|form
parameter_list|)
block|{
name|out_uleb128
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the size of a fragment.  */
end_comment

begin_function
specifier|static
name|offsetT
name|get_frag_fix
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|frchainS
modifier|*
name|fr
decl_stmt|;
if|if
condition|(
name|frag
operator|->
name|fr_next
condition|)
return|return
name|frag
operator|->
name|fr_fix
return|;
comment|/* If a fragment is the last in the chain, special measures must be      taken to find its size before relaxation, since it may be pending      on some subsegment chain.  */
for|for
control|(
name|fr
operator|=
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|frchainP
init|;
name|fr
condition|;
name|fr
operator|=
name|fr
operator|->
name|frch_next
control|)
if|if
condition|(
name|fr
operator|->
name|frch_last
operator|==
name|frag
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|fr
operator|->
name|frch_obstack
argument_list|)
operator|-
name|frag
operator|->
name|fr_literal
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set an absolute address (may result in a relocation entry).  */
end_comment

begin_function
specifier|static
name|void
name|out_set_addr
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
name|expressionS
name|expr
decl_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_extended_op
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|sizeof_address
operator|+
literal|1
argument_list|)
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNE_set_address
argument_list|)
expr_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|sizeof_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|DWARF2_LINE_MIN_INSN_LENGTH
operator|>
literal|1
end_if

begin_function_decl
specifier|static
name|void
name|scale_addr_delta
parameter_list|(
name|addressT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|scale_addr_delta
parameter_list|(
name|addressT
modifier|*
name|addr_delta
parameter_list|)
block|{
specifier|static
name|int
name|printed_this
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|addr_delta
operator|%
name|DWARF2_LINE_MIN_INSN_LENGTH
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|printed_this
condition|)
name|as_bad
argument_list|(
literal|"unaligned opcodes detected in executable segment"
argument_list|)
expr_stmt|;
name|printed_this
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|addr_delta
operator|/=
name|DWARF2_LINE_MIN_INSN_LENGTH
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|scale_addr_delta
parameter_list|(
name|A
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Encode a pair of line and address skips as efficiently as possible.    Note that the line skip is signed, whereas the address skip is unsigned.     The following two routines *must* be kept in sync.  This is    enforced by making emit_inc_line_addr abort if we do not emit    exactly the expected number of bytes.  */
end_comment

begin_function
specifier|static
name|int
name|size_inc_line_addr
parameter_list|(
name|int
name|line_delta
parameter_list|,
name|addressT
name|addr_delta
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|,
name|opcode
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
comment|/* Scale the address delta by the minimum instruction length.  */
name|scale_addr_delta
argument_list|(
operator|&
name|addr_delta
argument_list|)
expr_stmt|;
comment|/* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.      We cannot use special opcodes here, since we want the end_sequence      to emit the matrix entry.  */
if|if
condition|(
name|line_delta
operator|==
name|INT_MAX
condition|)
block|{
if|if
condition|(
name|addr_delta
operator|==
name|MAX_SPECIAL_ADDR_DELTA
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
name|len
operator|=
literal|1
operator|+
name|sizeof_leb128
argument_list|(
name|addr_delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|len
operator|+
literal|3
return|;
block|}
comment|/* Bias the line delta by the base.  */
name|tmp
operator|=
name|line_delta
operator|-
name|DWARF2_LINE_BASE
expr_stmt|;
comment|/* If the line increment is out of range of a special opcode, we      must encode it with DW_LNS_advance_line.  */
if|if
condition|(
name|tmp
operator|>=
name|DWARF2_LINE_RANGE
condition|)
block|{
name|len
operator|=
literal|1
operator|+
name|sizeof_leb128
argument_list|(
name|line_delta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|line_delta
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
literal|0
operator|-
name|DWARF2_LINE_BASE
expr_stmt|;
block|}
comment|/* Bias the opcode by the special opcode base.  */
name|tmp
operator|+=
name|DWARF2_LINE_OPCODE_BASE
expr_stmt|;
comment|/* Avoid overflow when addr_delta is large.  */
if|if
condition|(
name|addr_delta
operator|<
literal|256
operator|+
name|MAX_SPECIAL_ADDR_DELTA
condition|)
block|{
comment|/* Try using a special opcode.  */
name|opcode
operator|=
name|tmp
operator|+
name|addr_delta
operator|*
name|DWARF2_LINE_RANGE
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
literal|255
condition|)
return|return
name|len
operator|+
literal|1
return|;
comment|/* Try using DW_LNS_const_add_pc followed by special op.  */
name|opcode
operator|=
name|tmp
operator|+
operator|(
name|addr_delta
operator|-
name|MAX_SPECIAL_ADDR_DELTA
operator|)
operator|*
name|DWARF2_LINE_RANGE
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
literal|255
condition|)
return|return
name|len
operator|+
literal|2
return|;
block|}
comment|/* Otherwise use DW_LNS_advance_pc.  */
name|len
operator|+=
literal|1
operator|+
name|sizeof_leb128
argument_list|(
name|addr_delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW_LNS_copy or special opcode.  */
name|len
operator|+=
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_inc_line_addr
parameter_list|(
name|int
name|line_delta
parameter_list|,
name|addressT
name|addr_delta
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|,
name|opcode
decl_stmt|;
name|int
name|need_copy
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|len
decl_stmt|;
comment|/* Line number sequences cannot go backward in addresses.  This means      we've incorrectly ordered the statements in the sequence.  */
name|assert
argument_list|(
operator|(
name|offsetT
operator|)
name|addr_delta
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Scale the address delta by the minimum instruction length.  */
name|scale_addr_delta
argument_list|(
operator|&
name|addr_delta
argument_list|)
expr_stmt|;
comment|/* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.      We cannot use special opcodes here, since we want the end_sequence      to emit the matrix entry.  */
if|if
condition|(
name|line_delta
operator|==
name|INT_MAX
condition|)
block|{
if|if
condition|(
name|addr_delta
operator|==
name|MAX_SPECIAL_ADDR_DELTA
condition|)
operator|*
name|p
operator|++
operator|=
name|DW_LNS_const_add_pc
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|DW_LNS_advance_pc
expr_stmt|;
name|p
operator|+=
name|output_leb128
argument_list|(
name|p
argument_list|,
name|addr_delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|DW_LNS_extended_op
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|DW_LNE_end_sequence
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Bias the line delta by the base.  */
name|tmp
operator|=
name|line_delta
operator|-
name|DWARF2_LINE_BASE
expr_stmt|;
comment|/* If the line increment is out of range of a special opcode, we      must encode it with DW_LNS_advance_line.  */
if|if
condition|(
name|tmp
operator|>=
name|DWARF2_LINE_RANGE
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|DW_LNS_advance_line
expr_stmt|;
name|p
operator|+=
name|output_leb128
argument_list|(
name|p
argument_list|,
name|line_delta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|line_delta
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
literal|0
operator|-
name|DWARF2_LINE_BASE
expr_stmt|;
name|need_copy
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Prettier, I think, to use DW_LNS_copy instead of a "line +0, addr +0"      special opcode.  */
if|if
condition|(
name|line_delta
operator|==
literal|0
operator|&&
name|addr_delta
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|DW_LNS_copy
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Bias the opcode by the special opcode base.  */
name|tmp
operator|+=
name|DWARF2_LINE_OPCODE_BASE
expr_stmt|;
comment|/* Avoid overflow when addr_delta is large.  */
if|if
condition|(
name|addr_delta
operator|<
literal|256
operator|+
name|MAX_SPECIAL_ADDR_DELTA
condition|)
block|{
comment|/* Try using a special opcode.  */
name|opcode
operator|=
name|tmp
operator|+
name|addr_delta
operator|*
name|DWARF2_LINE_RANGE
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
literal|255
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|opcode
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Try using DW_LNS_const_add_pc followed by special op.  */
name|opcode
operator|=
name|tmp
operator|+
operator|(
name|addr_delta
operator|-
name|MAX_SPECIAL_ADDR_DELTA
operator|)
operator|*
name|DWARF2_LINE_RANGE
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
literal|255
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|DW_LNS_const_add_pc
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|opcode
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Otherwise use DW_LNS_advance_pc.  */
operator|*
name|p
operator|++
operator|=
name|DW_LNS_advance_pc
expr_stmt|;
name|p
operator|+=
name|output_leb128
argument_list|(
name|p
argument_list|,
name|addr_delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_copy
condition|)
operator|*
name|p
operator|++
operator|=
name|DW_LNS_copy
expr_stmt|;
else|else
operator|*
name|p
operator|++
operator|=
name|tmp
expr_stmt|;
name|done
label|:
name|assert
argument_list|(
name|p
operator|==
name|end
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handy routine to combine calls to the above two routines.  */
end_comment

begin_function
specifier|static
name|void
name|out_inc_line_addr
parameter_list|(
name|int
name|line_delta
parameter_list|,
name|addressT
name|addr_delta
parameter_list|)
block|{
name|int
name|len
init|=
name|size_inc_line_addr
argument_list|(
name|line_delta
argument_list|,
name|addr_delta
argument_list|)
decl_stmt|;
name|emit_inc_line_addr
argument_list|(
name|line_delta
argument_list|,
name|addr_delta
argument_list|,
name|frag_more
argument_list|(
name|len
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out an alternative form of line and address skips using    DW_LNS_fixed_advance_pc opcodes.  This uses more space than the default    line and address information, but it helps support linker relaxation that    changes the code offsets.  */
end_comment

begin_function
specifier|static
name|void
name|out_fixed_inc_line_addr
parameter_list|(
name|int
name|line_delta
parameter_list|,
name|symbolS
modifier|*
name|to_sym
parameter_list|,
name|symbolS
modifier|*
name|from_sym
parameter_list|)
block|{
name|expressionS
name|expr
decl_stmt|;
comment|/* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.  */
if|if
condition|(
name|line_delta
operator|==
name|INT_MAX
condition|)
block|{
name|out_opcode
argument_list|(
name|DW_LNS_fixed_advance_pc
argument_list|)
expr_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|to_sym
expr_stmt|;
name|expr
operator|.
name|X_op_symbol
operator|=
name|from_sym
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_extended_op
argument_list|)
expr_stmt|;
name|out_byte
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNE_end_sequence
argument_list|)
expr_stmt|;
return|return;
block|}
name|out_opcode
argument_list|(
name|DW_LNS_advance_line
argument_list|)
expr_stmt|;
name|out_sleb128
argument_list|(
name|line_delta
argument_list|)
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_fixed_advance_pc
argument_list|)
expr_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|to_sym
expr_stmt|;
name|expr
operator|.
name|X_op_symbol
operator|=
name|from_sym
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a variant frag that we can use to relax address/line    increments between fragments of the target segment.  */
end_comment

begin_function
specifier|static
name|void
name|relax_inc_line_addr
parameter_list|(
name|int
name|line_delta
parameter_list|,
name|symbolS
modifier|*
name|to_sym
parameter_list|,
name|symbolS
modifier|*
name|from_sym
parameter_list|)
block|{
name|expressionS
name|expr
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|to_sym
expr_stmt|;
name|expr
operator|.
name|X_op_symbol
operator|=
name|from_sym
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* The maximum size of the frag is the line delta with a maximum      sized address delta.  */
name|max_chars
operator|=
name|size_inc_line_addr
argument_list|(
name|line_delta
argument_list|,
operator|-
name|DWARF2_LINE_MIN_INSN_LENGTH
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_dwarf2dbg
argument_list|,
name|max_chars
argument_list|,
name|max_chars
argument_list|,
literal|1
argument_list|,
name|make_expr_symbol
argument_list|(
operator|&
name|expr
argument_list|)
argument_list|,
name|line_delta
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function estimates the size of a rs_dwarf2dbg variant frag    based on the current values of the symbols.  It is called before    the relaxation loop.  We set fr_subtype to the expected length.  */
end_comment

begin_function
name|int
name|dwarf2dbg_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
name|offsetT
name|addr_delta
decl_stmt|;
name|int
name|size
decl_stmt|;
name|addr_delta
operator|=
name|resolve_symbol_value
argument_list|(
name|frag
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_inc_line_addr
argument_list|(
name|frag
operator|->
name|fr_offset
argument_list|,
name|addr_delta
argument_list|)
expr_stmt|;
name|frag
operator|->
name|fr_subtype
operator|=
name|size
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* This function relaxes a rs_dwarf2dbg variant frag based on the    current values of the symbols.  fr_subtype is the current length    of the frag.  This returns the change in frag length.  */
end_comment

begin_function
name|int
name|dwarf2dbg_relax_frag
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
name|int
name|old_size
decl_stmt|,
name|new_size
decl_stmt|;
name|old_size
operator|=
name|frag
operator|->
name|fr_subtype
expr_stmt|;
name|new_size
operator|=
name|dwarf2dbg_estimate_size_before_relax
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
name|new_size
operator|-
name|old_size
return|;
block|}
end_function

begin_comment
comment|/* This function converts a rs_dwarf2dbg variant frag into a normal    fill frag.  This is called after all relaxation has been done.    fr_subtype will be the desired length of the frag.  */
end_comment

begin_function
name|void
name|dwarf2dbg_convert_frag
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
name|offsetT
name|addr_diff
decl_stmt|;
name|addr_diff
operator|=
name|resolve_symbol_value
argument_list|(
name|frag
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
comment|/* fr_var carries the max_chars that we created the fragment with.      fr_subtype carries the current expected length.  We must, of      course, have allocated enough memory earlier.  */
name|assert
argument_list|(
name|frag
operator|->
name|fr_var
operator|>=
operator|(
name|int
operator|)
name|frag
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|emit_inc_line_addr
argument_list|(
name|frag
operator|->
name|fr_offset
argument_list|,
name|addr_diff
argument_list|,
name|frag
operator|->
name|fr_literal
operator|+
name|frag
operator|->
name|fr_fix
argument_list|,
name|frag
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|frag
operator|->
name|fr_fix
operator|+=
name|frag
operator|->
name|fr_subtype
expr_stmt|;
name|frag
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|frag
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|fr_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate .debug_line content for the chain of line number entries    beginning at E, for segment SEG.  */
end_comment

begin_function
specifier|static
name|void
name|process_entries
parameter_list|(
name|segT
name|seg
parameter_list|,
name|struct
name|line_entry
modifier|*
name|e
parameter_list|)
block|{
name|unsigned
name|filenum
init|=
literal|1
decl_stmt|;
name|unsigned
name|line
init|=
literal|1
decl_stmt|;
name|unsigned
name|column
init|=
literal|0
decl_stmt|;
name|unsigned
name|isa
init|=
literal|0
decl_stmt|;
name|unsigned
name|flags
init|=
name|DWARF2_LINE_DEFAULT_IS_STMT
condition|?
name|DWARF2_FLAG_IS_STMT
else|:
literal|0
decl_stmt|;
name|fragS
modifier|*
name|last_frag
init|=
name|NULL
decl_stmt|,
modifier|*
name|frag
decl_stmt|;
name|addressT
name|last_frag_ofs
init|=
literal|0
decl_stmt|,
name|frag_ofs
decl_stmt|;
name|symbolS
modifier|*
name|last_lab
init|=
name|NULL
decl_stmt|,
modifier|*
name|lab
decl_stmt|;
name|struct
name|line_entry
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|int
name|line_delta
decl_stmt|;
if|if
condition|(
name|filenum
operator|!=
name|e
operator|->
name|loc
operator|.
name|filenum
condition|)
block|{
name|filenum
operator|=
name|e
operator|->
name|loc
operator|.
name|filenum
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_set_file
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|filenum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|!=
name|e
operator|->
name|loc
operator|.
name|column
condition|)
block|{
name|column
operator|=
name|e
operator|->
name|loc
operator|.
name|column
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_set_column
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isa
operator|!=
name|e
operator|->
name|loc
operator|.
name|isa
condition|)
block|{
name|isa
operator|=
name|e
operator|->
name|loc
operator|.
name|isa
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_set_isa
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|e
operator|->
name|loc
operator|.
name|flags
operator|^
name|flags
operator|)
operator|&
name|DWARF2_FLAG_IS_STMT
condition|)
block|{
name|flags
operator|=
name|e
operator|->
name|loc
operator|.
name|flags
expr_stmt|;
name|out_opcode
argument_list|(
name|DW_LNS_negate_stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|loc
operator|.
name|flags
operator|&
name|DWARF2_FLAG_BASIC_BLOCK
condition|)
name|out_opcode
argument_list|(
name|DW_LNS_set_basic_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|loc
operator|.
name|flags
operator|&
name|DWARF2_FLAG_PROLOGUE_END
condition|)
name|out_opcode
argument_list|(
name|DW_LNS_set_prologue_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|loc
operator|.
name|flags
operator|&
name|DWARF2_FLAG_EPILOGUE_BEGIN
condition|)
name|out_opcode
argument_list|(
name|DW_LNS_set_epilogue_begin
argument_list|)
expr_stmt|;
comment|/* Don't try to optimize away redundant entries; gdb wants two 	 entries for a function where the code starts on the same line as 	 the {, and there's no way to identify that case here.  Trust gcc 	 to optimize appropriately.  */
name|line_delta
operator|=
name|e
operator|->
name|loc
operator|.
name|line
operator|-
name|line
expr_stmt|;
name|lab
operator|=
name|e
operator|->
name|label
expr_stmt|;
name|frag
operator|=
name|symbol_get_frag
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|frag_ofs
operator|=
name|S_GET_VALUE
argument_list|(
name|lab
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_frag
operator|==
name|NULL
condition|)
block|{
name|out_set_addr
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|out_inc_line_addr
argument_list|(
name|line_delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DWARF2_USE_FIXED_ADVANCE_PC
condition|)
name|out_fixed_inc_line_addr
argument_list|(
name|line_delta
argument_list|,
name|lab
argument_list|,
name|last_lab
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frag
operator|==
name|last_frag
condition|)
name|out_inc_line_addr
argument_list|(
name|line_delta
argument_list|,
name|frag_ofs
operator|-
name|last_frag_ofs
argument_list|)
expr_stmt|;
else|else
name|relax_inc_line_addr
argument_list|(
name|line_delta
argument_list|,
name|lab
argument_list|,
name|last_lab
argument_list|)
expr_stmt|;
name|line
operator|=
name|e
operator|->
name|loc
operator|.
name|line
expr_stmt|;
name|last_lab
operator|=
name|lab
expr_stmt|;
name|last_frag
operator|=
name|frag
expr_stmt|;
name|last_frag_ofs
operator|=
name|frag_ofs
expr_stmt|;
name|next
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|e
condition|)
do|;
comment|/* Emit a DW_LNE_end_sequence for the end of the section.  */
name|frag
operator|=
name|last_frag_for_seg
argument_list|(
name|seg
argument_list|)
expr_stmt|;
name|frag_ofs
operator|=
name|get_frag_fix
argument_list|(
name|frag
argument_list|,
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|DWARF2_USE_FIXED_ADVANCE_PC
condition|)
block|{
name|lab
operator|=
name|symbol_temp_new
argument_list|(
name|seg
argument_list|,
name|frag_ofs
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|out_fixed_inc_line_addr
argument_list|(
name|INT_MAX
argument_list|,
name|lab
argument_list|,
name|last_lab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frag
operator|==
name|last_frag
condition|)
name|out_inc_line_addr
argument_list|(
name|INT_MAX
argument_list|,
name|frag_ofs
operator|-
name|last_frag_ofs
argument_list|)
expr_stmt|;
else|else
block|{
name|lab
operator|=
name|symbol_temp_new
argument_list|(
name|seg
argument_list|,
name|frag_ofs
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|relax_inc_line_addr
argument_list|(
name|INT_MAX
argument_list|,
name|lab
argument_list|,
name|last_lab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit the directory and file tables for .debug_line.  */
end_comment

begin_function
specifier|static
name|void
name|out_file_list
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Emit directory list.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|dirs_in_use
condition|;
operator|++
name|i
control|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|dirs
index|[
name|i
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate it.  */
name|out_byte
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|files_in_use
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|filename
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unassigned file number %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* Prevent a crash later, particularly for file 1.  */
name|files
index|[
name|i
index|]
operator|.
name|filename
operator|=
literal|""
expr_stmt|;
continue|continue;
block|}
name|size
operator|=
name|strlen
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|filename
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|dir
argument_list|)
expr_stmt|;
comment|/* directory number */
name|out_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* last modification timestamp */
name|out_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* filesize */
block|}
comment|/* Terminate filename list.  */
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the collected .debug_line data.  */
end_comment

begin_function
specifier|static
name|void
name|out_debug_line
parameter_list|(
name|segT
name|line_seg
parameter_list|)
block|{
name|expressionS
name|expr
decl_stmt|;
name|symbolS
modifier|*
name|line_start
decl_stmt|;
name|symbolS
modifier|*
name|prologue_end
decl_stmt|;
name|symbolS
modifier|*
name|line_end
decl_stmt|;
name|struct
name|line_seg
modifier|*
name|s
decl_stmt|;
name|enum
name|dwarf2_format
name|d2f
decl_stmt|;
name|int
name|sizeof_initial_length
decl_stmt|;
name|int
name|sizeof_offset
decl_stmt|;
name|subseg_set
argument_list|(
name|line_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line_start
operator|=
name|symbol_temp_new_now
argument_list|()
expr_stmt|;
name|prologue_end
operator|=
name|symbol_temp_make
argument_list|()
expr_stmt|;
name|line_end
operator|=
name|symbol_temp_make
argument_list|()
expr_stmt|;
comment|/* Total length of the information for this compilation unit.  */
name|expr
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|line_end
expr_stmt|;
name|expr
operator|.
name|X_op_symbol
operator|=
name|line_start
expr_stmt|;
name|d2f
operator|=
name|DWARF2_FORMAT
argument_list|()
expr_stmt|;
if|if
condition|(
name|d2f
operator|==
name|dwarf2_format_32bit
condition|)
block|{
name|sizeof_initial_length
operator|=
name|sizeof_offset
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d2f
operator|==
name|dwarf2_format_64bit
condition|)
block|{
name|sizeof_initial_length
operator|=
literal|12
expr_stmt|;
name|sizeof_offset
operator|=
literal|8
expr_stmt|;
name|out_four
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d2f
operator|==
name|dwarf2_format_64bit_irix
condition|)
block|{
name|sizeof_initial_length
operator|=
name|sizeof_offset
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: unknown dwarf2 format"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|.
name|X_add_number
operator|=
operator|-
name|sizeof_initial_length
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|sizeof_offset
argument_list|)
expr_stmt|;
comment|/* Version.  */
name|out_two
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Length of the prologue following this length.  */
name|expr
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|prologue_end
expr_stmt|;
name|expr
operator|.
name|X_op_symbol
operator|=
name|line_start
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
operator|-
operator|(
name|sizeof_initial_length
operator|+
literal|2
operator|+
name|sizeof_offset
operator|)
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|sizeof_offset
argument_list|)
expr_stmt|;
comment|/* Parameters of the state machine.  */
name|out_byte
argument_list|(
name|DWARF2_LINE_MIN_INSN_LENGTH
argument_list|)
expr_stmt|;
name|out_byte
argument_list|(
name|DWARF2_LINE_DEFAULT_IS_STMT
argument_list|)
expr_stmt|;
name|out_byte
argument_list|(
name|DWARF2_LINE_BASE
argument_list|)
expr_stmt|;
name|out_byte
argument_list|(
name|DWARF2_LINE_RANGE
argument_list|)
expr_stmt|;
name|out_byte
argument_list|(
name|DWARF2_LINE_OPCODE_BASE
argument_list|)
expr_stmt|;
comment|/* Standard opcode lengths.  */
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* DW_LNS_copy */
name|out_byte
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_advance_pc */
name|out_byte
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_advance_line */
name|out_byte
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_set_file */
name|out_byte
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_set_column */
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* DW_LNS_negate_stmt */
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* DW_LNS_set_basic_block */
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* DW_LNS_const_add_pc */
name|out_byte
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_fixed_advance_pc */
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* DW_LNS_set_prologue_end */
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* DW_LNS_set_epilogue_begin */
name|out_byte
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_LNS_set_isa */
name|out_file_list
argument_list|()
expr_stmt|;
name|symbol_set_value_now
argument_list|(
name|prologue_end
argument_list|)
expr_stmt|;
comment|/* For each section, emit a statement program.  */
for|for
control|(
name|s
operator|=
name|all_segs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|process_entries
argument_list|(
name|s
operator|->
name|seg
argument_list|,
name|s
operator|->
name|head
operator|->
name|head
argument_list|)
expr_stmt|;
name|symbol_set_value_now
argument_list|(
name|line_end
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|out_debug_ranges
parameter_list|(
name|segT
name|ranges_seg
parameter_list|)
block|{
name|unsigned
name|int
name|addr_size
init|=
name|sizeof_address
decl_stmt|;
name|struct
name|line_seg
modifier|*
name|s
decl_stmt|;
name|expressionS
name|expr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|subseg_set
argument_list|(
name|ranges_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Base Address Entry.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_size
condition|;
name|i
operator|++
control|)
name|out_byte
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_size
condition|;
name|i
operator|++
control|)
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Range List Entry.  */
for|for
control|(
name|s
operator|=
name|all_segs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|frag
operator|=
name|first_frag_for_seg
argument_list|(
name|s
operator|->
name|seg
argument_list|)
expr_stmt|;
name|beg
operator|=
name|symbol_temp_new
argument_list|(
name|s
operator|->
name|seg
argument_list|,
literal|0
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|s
operator|->
name|text_start
operator|=
name|beg
expr_stmt|;
name|frag
operator|=
name|last_frag_for_seg
argument_list|(
name|s
operator|->
name|seg
argument_list|)
expr_stmt|;
name|end
operator|=
name|symbol_temp_new
argument_list|(
name|s
operator|->
name|seg
argument_list|,
name|get_frag_fix
argument_list|(
name|frag
argument_list|,
name|s
operator|->
name|seg
argument_list|)
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|s
operator|->
name|text_end
operator|=
name|end
expr_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|beg
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|end
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
block|}
comment|/* End of Range Entry.   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_size
condition|;
name|i
operator|++
control|)
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_size
condition|;
name|i
operator|++
control|)
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit data for .debug_aranges.  */
end_comment

begin_function
specifier|static
name|void
name|out_debug_aranges
parameter_list|(
name|segT
name|aranges_seg
parameter_list|,
name|segT
name|info_seg
parameter_list|)
block|{
name|unsigned
name|int
name|addr_size
init|=
name|sizeof_address
decl_stmt|;
name|addressT
name|size
decl_stmt|,
name|skip
decl_stmt|;
name|struct
name|line_seg
modifier|*
name|s
decl_stmt|;
name|expressionS
name|expr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size
operator|=
literal|4
operator|+
literal|2
operator|+
literal|4
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|skip
operator|=
literal|2
operator|*
name|addr_size
operator|-
operator|(
name|size
operator|&
operator|(
literal|2
operator|*
name|addr_size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|skip
operator|==
literal|2
operator|*
name|addr_size
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
name|size
operator|+=
name|skip
expr_stmt|;
for|for
control|(
name|s
operator|=
name|all_segs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|size
operator|+=
literal|2
operator|*
name|addr_size
expr_stmt|;
name|size
operator|+=
literal|2
operator|*
name|addr_size
expr_stmt|;
name|subseg_set
argument_list|(
name|aranges_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Length of the compilation unit.  */
name|out_four
argument_list|(
name|size
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* Version.  */
name|out_two
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Offset to .debug_info.  */
comment|/* ??? sizeof_offset */
name|TC_DWARF2_EMIT_OFFSET
argument_list|(
name|section_symbol
argument_list|(
name|info_seg
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Size of an address (offset portion).  */
name|out_byte
argument_list|(
name|addr_size
argument_list|)
expr_stmt|;
comment|/* Size of a segment descriptor.  */
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Align the header.  */
if|if
condition|(
name|skip
condition|)
name|frag_align
argument_list|(
name|ffs
argument_list|(
literal|2
operator|*
name|addr_size
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|all_segs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|frag
operator|=
name|first_frag_for_seg
argument_list|(
name|s
operator|->
name|seg
argument_list|)
expr_stmt|;
name|beg
operator|=
name|symbol_temp_new
argument_list|(
name|s
operator|->
name|seg
argument_list|,
literal|0
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|s
operator|->
name|text_start
operator|=
name|beg
expr_stmt|;
name|frag
operator|=
name|last_frag_for_seg
argument_list|(
name|s
operator|->
name|seg
argument_list|)
expr_stmt|;
name|end
operator|=
name|symbol_temp_new
argument_list|(
name|s
operator|->
name|seg
argument_list|,
name|get_frag_fix
argument_list|(
name|frag
argument_list|,
name|s
operator|->
name|seg
argument_list|)
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|s
operator|->
name|text_end
operator|=
name|end
expr_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|beg
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|end
expr_stmt|;
name|expr
operator|.
name|X_op_symbol
operator|=
name|beg
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|addr_size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
name|addr_size
argument_list|,
literal|0
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit data for .debug_abbrev.  Note that this must be kept in    sync with out_debug_info below.  */
end_comment

begin_function
specifier|static
name|void
name|out_debug_abbrev
parameter_list|(
name|segT
name|abbrev_seg
parameter_list|)
block|{
name|subseg_set
argument_list|(
name|abbrev_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out_uleb128
argument_list|(
name|DW_TAG_compile_unit
argument_list|)
expr_stmt|;
name|out_byte
argument_list|(
name|DW_CHILDREN_no
argument_list|)
expr_stmt|;
name|out_abbrev
argument_list|(
name|DW_AT_stmt_list
argument_list|,
name|DW_FORM_data4
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_segs
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|out_abbrev
argument_list|(
name|DW_AT_low_pc
argument_list|,
name|DW_FORM_addr
argument_list|)
expr_stmt|;
name|out_abbrev
argument_list|(
name|DW_AT_high_pc
argument_list|,
name|DW_FORM_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DWARF2_FORMAT
argument_list|()
operator|==
name|dwarf2_format_32bit
condition|)
name|out_abbrev
argument_list|(
name|DW_AT_ranges
argument_list|,
name|DW_FORM_data4
argument_list|)
expr_stmt|;
else|else
name|out_abbrev
argument_list|(
name|DW_AT_ranges
argument_list|,
name|DW_FORM_data8
argument_list|)
expr_stmt|;
block|}
name|out_abbrev
argument_list|(
name|DW_AT_name
argument_list|,
name|DW_FORM_string
argument_list|)
expr_stmt|;
name|out_abbrev
argument_list|(
name|DW_AT_comp_dir
argument_list|,
name|DW_FORM_string
argument_list|)
expr_stmt|;
name|out_abbrev
argument_list|(
name|DW_AT_producer
argument_list|,
name|DW_FORM_string
argument_list|)
expr_stmt|;
name|out_abbrev
argument_list|(
name|DW_AT_language
argument_list|,
name|DW_FORM_data2
argument_list|)
expr_stmt|;
name|out_abbrev
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Terminate the abbreviations for this compilation unit.  */
name|out_byte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a description of this compilation unit for .debug_info.  */
end_comment

begin_function
specifier|static
name|void
name|out_debug_info
parameter_list|(
name|segT
name|info_seg
parameter_list|,
name|segT
name|abbrev_seg
parameter_list|,
name|segT
name|line_seg
parameter_list|,
name|segT
name|ranges_seg
parameter_list|)
block|{
name|char
name|producer
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|comp_dir
decl_stmt|;
name|expressionS
name|expr
decl_stmt|;
name|symbolS
modifier|*
name|info_start
decl_stmt|;
name|symbolS
modifier|*
name|info_end
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|dwarf2_format
name|d2f
decl_stmt|;
name|int
name|sizeof_offset
decl_stmt|;
name|subseg_set
argument_list|(
name|info_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info_start
operator|=
name|symbol_temp_new_now
argument_list|()
expr_stmt|;
name|info_end
operator|=
name|symbol_temp_make
argument_list|()
expr_stmt|;
comment|/* Compilation Unit length.  */
name|expr
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|info_end
expr_stmt|;
name|expr
operator|.
name|X_op_symbol
operator|=
name|info_start
expr_stmt|;
name|d2f
operator|=
name|DWARF2_FORMAT
argument_list|()
expr_stmt|;
if|if
condition|(
name|d2f
operator|==
name|dwarf2_format_32bit
condition|)
block|{
name|expr
operator|.
name|X_add_number
operator|=
operator|-
literal|4
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sizeof_offset
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d2f
operator|==
name|dwarf2_format_64bit
condition|)
block|{
name|expr
operator|.
name|X_add_number
operator|=
operator|-
literal|12
expr_stmt|;
name|out_four
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sizeof_offset
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d2f
operator|==
name|dwarf2_format_64bit_irix
condition|)
block|{
name|expr
operator|.
name|X_add_number
operator|=
operator|-
literal|8
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sizeof_offset
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: unknown dwarf2 format"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* DWARF version.  */
name|out_two
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* .debug_abbrev offset */
name|TC_DWARF2_EMIT_OFFSET
argument_list|(
name|section_symbol
argument_list|(
name|abbrev_seg
argument_list|)
argument_list|,
name|sizeof_offset
argument_list|)
expr_stmt|;
comment|/* Target address size.  */
name|out_byte
argument_list|(
name|sizeof_address
argument_list|)
expr_stmt|;
comment|/* DW_TAG_compile_unit DIE abbrev */
name|out_uleb128
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* DW_AT_stmt_list */
comment|/* ??? sizeof_offset */
name|TC_DWARF2_EMIT_OFFSET
argument_list|(
name|section_symbol
argument_list|(
name|line_seg
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* These two attributes are emitted if all of the code is contiguous.  */
if|if
condition|(
name|all_segs
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* DW_AT_low_pc */
name|expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|all_segs
operator|->
name|text_start
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|sizeof_address
argument_list|)
expr_stmt|;
comment|/* DW_AT_high_pc */
name|expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|all_segs
operator|->
name|text_end
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|sizeof_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This attribute is emitted if the code is disjoint.  */
comment|/* DW_AT_ranges.  */
name|TC_DWARF2_EMIT_OFFSET
argument_list|(
name|section_symbol
argument_list|(
name|ranges_seg
argument_list|)
argument_list|,
name|sizeof_offset
argument_list|)
expr_stmt|;
block|}
comment|/* DW_AT_name.  We don't have the actual file name that was present      on the command line, so assume files[1] is the main input file.      We're not supposed to get called unless at least one line number      entry was emitted, so this should always be defined.  */
if|if
condition|(
operator|!
name|files
operator|||
name|files_in_use
operator|<
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|files
index|[
literal|1
index|]
operator|.
name|dir
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|dirs
index|[
name|files
index|[
literal|1
index|]
operator|.
name|dir
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|dirs
index|[
name|files
index|[
literal|1
index|]
operator|.
name|dir
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|INSERT_DIR_SEPARATOR
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|files
index|[
literal|1
index|]
operator|.
name|filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* DW_AT_comp_dir */
name|comp_dir
operator|=
name|getpwd
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|comp_dir
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|comp_dir
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* DW_AT_producer */
name|sprintf
argument_list|(
name|producer
argument_list|,
literal|"GNU AS %s"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|producer
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|producer
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* DW_AT_language.  Yes, this is probably not really MIPS, but the      dwarf2 draft has no standard code for assembler.  */
name|out_two
argument_list|(
name|DW_LANG_Mips_Assembler
argument_list|)
expr_stmt|;
name|symbol_set_value_now
argument_list|(
name|info_end
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the dwarf2 debug sections.  We emit .debug.line if there    were any .file/.loc directives, or --gdwarf2 was given, or if the    file has a non-empty .debug_info section.  If we emit .debug_line,    and the .debug_info section is empty, we also emit .debug_info,    .debug_aranges and .debug_abbrev.  ALL_SEGS will be non-null if    there were any .file/.loc directives, or --gdwarf2 was given and    there were any located instructions emitted.  */
end_comment

begin_function
name|void
name|dwarf2_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|segT
name|line_seg
decl_stmt|;
name|struct
name|line_seg
modifier|*
name|s
decl_stmt|;
name|segT
name|info_seg
decl_stmt|;
name|int
name|emit_other_sections
init|=
literal|0
decl_stmt|;
name|info_seg
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
literal|".debug_info"
argument_list|)
expr_stmt|;
name|emit_other_sections
operator|=
name|info_seg
operator|==
name|NULL
operator|||
operator|!
name|seg_not_empty_p
argument_list|(
name|info_seg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_segs
operator|&&
name|emit_other_sections
condition|)
comment|/* There is no line information and no non-empty .debug_info        section.  */
return|return;
comment|/* Calculate the size of an address for the target machine.  */
name|sizeof_address
operator|=
name|DWARF2_ADDR_SIZE
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
comment|/* Create and switch to the line number section.  */
name|line_seg
operator|=
name|subseg_new
argument_list|(
literal|".debug_line"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|line_seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
comment|/* For each subsection, chain the debug entries together.  */
for|for
control|(
name|s
operator|=
name|all_segs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|line_subseg
modifier|*
name|ss
init|=
name|s
operator|->
name|head
decl_stmt|;
name|struct
name|line_entry
modifier|*
modifier|*
name|ptail
init|=
name|ss
operator|->
name|ptail
decl_stmt|;
while|while
condition|(
operator|(
name|ss
operator|=
name|ss
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptail
operator|=
name|ss
operator|->
name|head
expr_stmt|;
name|ptail
operator|=
name|ss
operator|->
name|ptail
expr_stmt|;
block|}
block|}
name|out_debug_line
argument_list|(
name|line_seg
argument_list|)
expr_stmt|;
comment|/* If this is assembler generated line info, and there is no      debug_info already, we need .debug_info and .debug_abbrev      sections as well.  */
if|if
condition|(
name|emit_other_sections
condition|)
block|{
name|segT
name|abbrev_seg
decl_stmt|;
name|segT
name|aranges_seg
decl_stmt|;
name|segT
name|ranges_seg
decl_stmt|;
name|assert
argument_list|(
name|all_segs
argument_list|)
expr_stmt|;
name|info_seg
operator|=
name|subseg_new
argument_list|(
literal|".debug_info"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abbrev_seg
operator|=
name|subseg_new
argument_list|(
literal|".debug_abbrev"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aranges_seg
operator|=
name|subseg_new
argument_list|(
literal|".debug_aranges"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|info_seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|abbrev_seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|aranges_seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|aranges_seg
argument_list|,
name|ffs
argument_list|(
literal|2
operator|*
name|sizeof_address
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_segs
operator|->
name|next
operator|==
name|NULL
condition|)
name|ranges_seg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|ranges_seg
operator|=
name|subseg_new
argument_list|(
literal|".debug_ranges"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|ranges_seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|ranges_seg
argument_list|,
name|ffs
argument_list|(
literal|2
operator|*
name|sizeof_address
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|out_debug_ranges
argument_list|(
name|ranges_seg
argument_list|)
expr_stmt|;
block|}
name|out_debug_aranges
argument_list|(
name|aranges_seg
argument_list|,
name|info_seg
argument_list|)
expr_stmt|;
name|out_debug_abbrev
argument_list|(
name|abbrev_seg
argument_list|)
expr_stmt|;
name|out_debug_info
argument_list|(
name|info_seg
argument_list|,
name|abbrev_seg
argument_list|,
name|line_seg
argument_list|,
name|ranges_seg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

