begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* read.c - read a source file -    Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 1997    Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|MASK_CHAR
value|(0xFF)
end_define

begin_comment
comment|/* If your chars aren't 8 bits, you will 				   change this a bit.  But then, GNU isn't 				   spozed to run on your machine anyway. 				   (RMS is so shortsighted sometimes.) 				   */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MASK_CHAR
value|((int)(unsigned char)-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the largest known floating point format (for now). It will    grow when we do 4361 style flonums. */
end_comment

begin_define
define|#
directive|define
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
value|(16)
end_define

begin_comment
comment|/* Routines that read assembler source text to build spagetti in memory.    Another group of these functions is in the expr.c module.  */
end_comment

begin_comment
comment|/* for isdigit() */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"listing.h"
end_include

begin_include
include|#
directive|include
file|"ecoff.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TC_START_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TC_START_LABEL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x==':')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The NOP_OPCODE is for the alignment fill value.  * fill it a nop instruction so that the disassembler does not choke  * on it  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOP_OPCODE
end_ifndef

begin_define
define|#
directive|define
name|NOP_OPCODE
value|0x00
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->next char of source file to parse. */
end_comment

begin_decl_stmt
name|int
name|generate_asm_lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag to generate line stab for .s file */
end_comment

begin_if
if|#
directive|if
name|BITS_PER_CHAR
operator|!=
literal|8
end_if

begin_comment
comment|/*  The following table is indexed by[(char)] and will break if     a char does not have exactly 256 states (hopefully 0:255!)!  */
end_comment

begin_decl_stmt
name|die
name|horribly
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_AT
end_ifndef

begin_comment
comment|/* The m88k unfortunately uses @ as a label beginner.  */
end_comment

begin_define
define|#
directive|define
name|LEX_AT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_BR
end_ifndef

begin_comment
comment|/* The RS/6000 assembler uses {,},[,] as parts of symbol names.  */
end_comment

begin_define
define|#
directive|define
name|LEX_BR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_PCT
end_ifndef

begin_comment
comment|/* The Delta 68k assembler permits % inside label names.  */
end_comment

begin_define
define|#
directive|define
name|LEX_PCT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_QM
end_ifndef

begin_comment
comment|/* The PowerPC Windows NT assemblers permits ? inside label names.  */
end_comment

begin_define
define|#
directive|define
name|LEX_QM
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_DOLLAR
end_ifndef

begin_comment
comment|/* The a29k assembler does not permits labels to start with $.  */
end_comment

begin_define
define|#
directive|define
name|LEX_DOLLAR
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_TILDE
end_ifndef

begin_comment
comment|/* The Delta 68k assembler permits ~ at start of label names.  */
end_comment

begin_define
define|#
directive|define
name|LEX_TILDE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* used by is_... macros. our ctype[] */
end_comment

begin_decl_stmt
name|char
name|lex_type
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* @ABCDEFGHIJKLMNO */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* PQRSTUVWXYZ[\]^_ */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LEX_DOLLAR
block|,
name|LEX_PCT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* _!"#$%&'()*+,-./ */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LEX_QM
block|,
comment|/* 0123456789:;<=>? */
name|LEX_AT
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* @ABCDEFGHIJKLMNO */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
name|LEX_BR
block|,
literal|0
block|,
name|LEX_BR
block|,
literal|0
block|,
literal|3
block|,
comment|/* PQRSTUVWXYZ[\]^_ */
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* `abcdefghijklmno */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
name|LEX_BR
block|,
literal|0
block|,
name|LEX_BR
block|,
name|LEX_TILDE
block|,
literal|0
block|,
comment|/* pqrstuvwxyz{|}~. */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * In: a character.  * Out: 1 if this character ends a line.  */
end_comment

begin_define
define|#
directive|define
name|_
value|(0)
end_define

begin_decl_stmt
name|char
name|is_end_of_line
index|[
literal|256
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|CR_EOL
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
comment|/* @abcdefghijklmno */
else|#
directive|else
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* @abcdefghijklmno */
endif|#
directive|endif
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
ifdef|#
directive|ifdef
name|TC_HPPA
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* _!"#$%&'()*+,-./ */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* 0123456789:;<=>? */
else|#
directive|else
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* 0123456789:;<=>? */
endif|#
directive|endif
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|_
end_undef

begin_comment
comment|/* Functions private to this file. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st char of each buffer of lines is here. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->1 + last char in buffer. */
end_comment

begin_comment
comment|/* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1 in the    tc-<CPU>.h file.  See the "Porting GAS" section of the internals manual. */
end_comment

begin_decl_stmt
name|int
name|target_big_endian
init|=
name|TARGET_BYTES_BIG_ENDIAN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JF a hack */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables for handling include file directory list. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|include_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of pointers to directories to 			   search for .include's */
end_comment

begin_decl_stmt
name|int
name|include_dir_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many are in the list */
end_comment

begin_decl_stmt
name|int
name|include_dir_maxlen
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of longest in list */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
name|struct
name|broken_word
modifier|*
name|broken_words
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|new_broken_words
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The current offset into the absolute section.  We don't try to    build frags in the absolute section, since no data can be stored    there.  We just keep track of the current offset.  */
end_comment

begin_decl_stmt
name|addressT
name|abs_section_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this line had an MRI style label, it is stored in this variable.    This is used by some of the MRI pseudo-ops.  */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|line_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This global variable is used to support MRI common sections.  We    translate such sections into a common symbol.  This variable is    non-NULL when we are in an MRI common section.  */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|mri_common_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In MRI mode, after a dc.b pseudo-op with an odd number of bytes, we    need to align to an even byte boundary unless the next pseudo-op is    dc.b, ds.b, or dcb.b.  This variable is set to 1 if an alignment    may be needed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mri_pending_align
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cons_worker
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scrub_from_string
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hex_float
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_org
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|expressionS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|demand_copy_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
name|lenP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|get_segmented_expression
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|get_known_segmented_expression
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pobegin
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_line_sb
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|read_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|pobegin
argument_list|()
expr_stmt|;
name|obj_read_begin_hook
argument_list|()
expr_stmt|;
comment|/* Something close -- but not too close -- to a multiple of 1024.      The debugging malloc I'm using has 24 bytes of overhead.  */
name|obstack_begin
argument_list|(
operator|&
name|notes
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|cond_obstack
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
comment|/* Use machine dependent syntax */
for|for
control|(
name|p
operator|=
name|line_separator_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Use more.  FIXME-SOMEDAY. */
if|if
condition|(
name|flag_mri
condition|)
name|lex_type
index|[
literal|'?'
index|]
operator|=
literal|3
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* set up pseudo-op tables */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|po_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|potable
index|[]
init|=
block|{
block|{
literal|"abort"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
block|{
literal|"ascii"
block|,
name|stringer
block|,
literal|0
block|}
block|,
block|{
literal|"asciz"
block|,
name|stringer
block|,
literal|1
block|}
block|,
block|{
literal|"balign"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
block|{
literal|"balignw"
block|,
name|s_align_bytes
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|"balignl"
block|,
name|s_align_bytes
block|,
operator|-
literal|4
block|}
block|,
comment|/* block */
block|{
literal|"byte"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"comm"
block|,
name|s_comm
block|,
literal|0
block|}
block|,
block|{
literal|"common"
block|,
name|s_mri_common
block|,
literal|0
block|}
block|,
block|{
literal|"common.s"
block|,
name|s_mri_common
block|,
literal|1
block|}
block|,
block|{
literal|"data"
block|,
name|s_data
block|,
literal|0
block|}
block|,
block|{
literal|"dc"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"dc.b"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"dc.d"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"dc.l"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"dc.s"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"dc.w"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"dc.x"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"dcb"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"dcb.b"
block|,
name|s_space
block|,
literal|1
block|}
block|,
block|{
literal|"dcb.d"
block|,
name|s_float_space
block|,
literal|'d'
block|}
block|,
block|{
literal|"dcb.l"
block|,
name|s_space
block|,
literal|4
block|}
block|,
block|{
literal|"dcb.s"
block|,
name|s_float_space
block|,
literal|'f'
block|}
block|,
block|{
literal|"dcb.w"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"dcb.x"
block|,
name|s_float_space
block|,
literal|'x'
block|}
block|,
block|{
literal|"ds"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"ds.b"
block|,
name|s_space
block|,
literal|1
block|}
block|,
block|{
literal|"ds.d"
block|,
name|s_space
block|,
literal|8
block|}
block|,
block|{
literal|"ds.l"
block|,
name|s_space
block|,
literal|4
block|}
block|,
block|{
literal|"ds.p"
block|,
name|s_space
block|,
literal|12
block|}
block|,
block|{
literal|"ds.s"
block|,
name|s_space
block|,
literal|4
block|}
block|,
block|{
literal|"ds.w"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"ds.x"
block|,
name|s_space
block|,
literal|12
block|}
block|,
block|{
literal|"debug"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|S_SET_DESC
block|{
literal|"desc"
block|,
name|s_desc
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* dim */
block|{
literal|"double"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
comment|/* dsect */
block|{
literal|"eject"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
comment|/* Formfeed listing */
block|{
literal|"else"
block|,
name|s_else
block|,
literal|0
block|}
block|,
block|{
literal|"elsec"
block|,
name|s_else
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|s_end
block|,
literal|0
block|}
block|,
block|{
literal|"endc"
block|,
name|s_endif
block|,
literal|0
block|}
block|,
block|{
literal|"endif"
block|,
name|s_endif
block|,
literal|0
block|}
block|,
comment|/* endef */
block|{
literal|"equ"
block|,
name|s_set
block|,
literal|0
block|}
block|,
block|{
literal|"equiv"
block|,
name|s_set
block|,
literal|1
block|}
block|,
block|{
literal|"err"
block|,
name|s_err
block|,
literal|0
block|}
block|,
block|{
literal|"exitm"
block|,
name|s_mexit
block|,
literal|0
block|}
block|,
comment|/* extend */
block|{
literal|"extern"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* We treat all undef as ext */
block|{
literal|"appfile"
block|,
name|s_app_file
block|,
literal|1
block|}
block|,
block|{
literal|"appline"
block|,
name|s_app_line
block|,
literal|0
block|}
block|,
block|{
literal|"fail"
block|,
name|s_fail
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|s_app_file
block|,
literal|0
block|}
block|,
block|{
literal|"fill"
block|,
name|s_fill
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"format"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"global"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"globl"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"hword"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"if"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_ne
block|}
block|,
block|{
literal|"ifc"
block|,
name|s_ifc
block|,
literal|0
block|}
block|,
block|{
literal|"ifdef"
block|,
name|s_ifdef
block|,
literal|0
block|}
block|,
block|{
literal|"ifeq"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_eq
block|}
block|,
block|{
literal|"ifeqs"
block|,
name|s_ifeqs
block|,
literal|0
block|}
block|,
block|{
literal|"ifge"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_ge
block|}
block|,
block|{
literal|"ifgt"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_gt
block|}
block|,
block|{
literal|"ifle"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_le
block|}
block|,
block|{
literal|"iflt"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_lt
block|}
block|,
block|{
literal|"ifnc"
block|,
name|s_ifc
block|,
literal|1
block|}
block|,
block|{
literal|"ifndef"
block|,
name|s_ifdef
block|,
literal|1
block|}
block|,
block|{
literal|"ifne"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_ne
block|}
block|,
block|{
literal|"ifnes"
block|,
name|s_ifeqs
block|,
literal|1
block|}
block|,
block|{
literal|"ifnotdef"
block|,
name|s_ifdef
block|,
literal|1
block|}
block|,
block|{
literal|"include"
block|,
name|s_include
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"irp"
block|,
name|s_irp
block|,
literal|0
block|}
block|,
block|{
literal|"irep"
block|,
name|s_irp
block|,
literal|0
block|}
block|,
block|{
literal|"irpc"
block|,
name|s_irp
block|,
literal|1
block|}
block|,
block|{
literal|"irepc"
block|,
name|s_irp
block|,
literal|1
block|}
block|,
block|{
literal|"lcomm"
block|,
name|s_lcomm
block|,
literal|0
block|}
block|,
block|{
literal|"lflags"
block|,
name|listing_flags
block|,
literal|0
block|}
block|,
comment|/* Listing flags */
block|{
literal|"linkonce"
block|,
name|s_linkonce
block|,
literal|0
block|}
block|,
block|{
literal|"list"
block|,
name|listing_list
block|,
literal|1
block|}
block|,
comment|/* Turn listing on */
block|{
literal|"llen"
block|,
name|listing_psize
block|,
literal|1
block|}
block|,
block|{
literal|"long"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"lsym"
block|,
name|s_lsym
block|,
literal|0
block|}
block|,
block|{
literal|"macro"
block|,
name|s_macro
block|,
literal|0
block|}
block|,
block|{
literal|"mexit"
block|,
name|s_mexit
block|,
literal|0
block|}
block|,
block|{
literal|"mri"
block|,
name|s_mri
block|,
literal|0
block|}
block|,
block|{
literal|".mri"
block|,
name|s_mri
block|,
literal|0
block|}
block|,
comment|/* Special case so .mri works in MRI mode.  */
block|{
literal|"name"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"noformat"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"nolist"
block|,
name|listing_list
block|,
literal|0
block|}
block|,
comment|/* Turn listing off */
block|{
literal|"nopage"
block|,
name|listing_nopage
block|,
literal|0
block|}
block|,
block|{
literal|"octa"
block|,
name|cons
block|,
literal|16
block|}
block|,
block|{
literal|"offset"
block|,
name|s_struct
block|,
literal|0
block|}
block|,
block|{
literal|"org"
block|,
name|s_org
block|,
literal|0
block|}
block|,
block|{
literal|"p2align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
block|{
literal|"p2alignw"
block|,
name|s_align_ptwo
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|"p2alignl"
block|,
name|s_align_ptwo
block|,
operator|-
literal|4
block|}
block|,
block|{
literal|"page"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
block|{
literal|"plen"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
block|{
literal|"print"
block|,
name|s_print
block|,
literal|0
block|}
block|,
block|{
literal|"psize"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
comment|/* set paper size */
block|{
literal|"purgem"
block|,
name|s_purgem
block|,
literal|0
block|}
block|,
block|{
literal|"quad"
block|,
name|cons
block|,
literal|8
block|}
block|,
block|{
literal|"rep"
block|,
name|s_rept
block|,
literal|0
block|}
block|,
block|{
literal|"rept"
block|,
name|s_rept
block|,
literal|0
block|}
block|,
block|{
literal|"rva"
block|,
name|s_rva
block|,
literal|4
block|}
block|,
block|{
literal|"sbttl"
block|,
name|listing_title
block|,
literal|1
block|}
block|,
comment|/* Subtitle of listing */
comment|/* scl */
comment|/* sect */
block|{
literal|"set"
block|,
name|s_set
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"single"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
comment|/* size */
block|{
literal|"space"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"skip"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"spc"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"stabd"
block|,
name|s_stab
block|,
literal|'d'
block|}
block|,
block|{
literal|"stabn"
block|,
name|s_stab
block|,
literal|'n'
block|}
block|,
block|{
literal|"stabs"
block|,
name|s_stab
block|,
literal|'s'
block|}
block|,
block|{
literal|"string"
block|,
name|stringer
block|,
literal|1
block|}
block|,
block|{
literal|"struct"
block|,
name|s_struct
block|,
literal|0
block|}
block|,
comment|/* tag */
block|{
literal|"text"
block|,
name|s_text
block|,
literal|0
block|}
block|,
comment|/* This is for gcc to use.  It's only just been added (2/94), so gcc      won't be able to use it for a while -- probably a year or more.      But once this has been released, check with gcc maintainers      before deleting it or even changing the spelling.  */
block|{
literal|"this_GCC_requires_the_GNU_assembler"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* If we're folding case -- done for some targets, not necessarily      all -- the above string in an input file will be converted to      this one.  Match it either way...  */
block|{
literal|"this_gcc_requires_the_gnu_assembler"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"title"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
comment|/* Listing title */
block|{
literal|"ttl"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
comment|/* type */
comment|/* use */
comment|/* val */
block|{
literal|"xcom"
block|,
name|s_comm
block|,
literal|0
block|}
block|,
block|{
literal|"xdef"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"xref"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"xstabs"
block|,
name|s_xstab
block|,
literal|'s'
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"zero"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|}
comment|/* end sentinel */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pop_override_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pop_table_name
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pop_insert
parameter_list|(
name|table
parameter_list|)
specifier|const
name|pseudo_typeS
modifier|*
name|table
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|errtxt
decl_stmt|;
specifier|const
name|pseudo_typeS
modifier|*
name|pop
decl_stmt|;
for|for
control|(
name|pop
operator|=
name|table
init|;
name|pop
operator|->
name|poc_name
condition|;
name|pop
operator|++
control|)
block|{
name|errtxt
operator|=
name|hash_insert
argument_list|(
name|po_hash
argument_list|,
name|pop
operator|->
name|poc_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pop
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtxt
operator|&&
operator|(
operator|!
name|pop_override_ok
operator|||
name|strcmp
argument_list|(
name|errtxt
argument_list|,
literal|"exists"
argument_list|)
operator|)
condition|)
name|as_fatal
argument_list|(
literal|"error constructing %s pseudo-op table: %s"
argument_list|,
name|pop_table_name
argument_list|,
name|errtxt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|md_pop_insert
end_ifndef

begin_define
define|#
directive|define
name|md_pop_insert
parameter_list|()
value|pop_insert(md_pseudo_table)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|obj_pop_insert
end_ifndef

begin_define
define|#
directive|define
name|obj_pop_insert
parameter_list|()
value|pop_insert(obj_pseudo_table)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|pobegin
parameter_list|()
block|{
name|po_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Do the target-specific pseudo ops. */
name|pop_table_name
operator|=
literal|"md"
expr_stmt|;
name|md_pop_insert
argument_list|()
expr_stmt|;
comment|/* Now object specific.  Skip any that were in the target table. */
name|pop_table_name
operator|=
literal|"obj"
expr_stmt|;
name|pop_override_ok
operator|=
literal|1
expr_stmt|;
name|obj_pop_insert
argument_list|()
expr_stmt|;
comment|/* Now portable ones.  Skip any that we've seen already. */
name|pop_table_name
operator|=
literal|"standard"
expr_stmt|;
name|pop_insert
argument_list|(
name|potable
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|HANDLE_CONDITIONAL_ASSEMBLY
parameter_list|()
define|\
value|if (ignore_input ())							\     {									\       while (! is_end_of_line[(unsigned char) *input_line_pointer++])	\ 	if (input_line_pointer == buffer_limit)				\ 	  break;							\       continue;								\     }
end_define

begin_comment
comment|/* This function is used when scrubbing the characters between #APP    and #NO_APP.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scrub_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scrub_string_end
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|scrub_from_string
parameter_list|(
name|from
parameter_list|)
name|char
modifier|*
modifier|*
name|from
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
operator|*
name|from
operator|=
name|scrub_string
expr_stmt|;
name|size
operator|=
name|scrub_string_end
operator|-
name|scrub_string
expr_stmt|;
name|scrub_string
operator|=
name|scrub_string_end
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/*	read_a_source_file()  *  * We read the file, putting things into a web that  * represents what we have been reading.  */
end_comment

begin_function
name|void
name|read_a_source_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* string of symbol, '\0' appended */
specifier|register
name|int
name|temp
decl_stmt|;
name|pseudo_typeS
modifier|*
name|pop
decl_stmt|;
name|buffer
operator|=
name|input_scrub_new_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|listing_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|listing_newline
argument_list|(
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We have another line to parse. */
name|know
argument_list|(
name|buffer_limit
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Must have a sentinel. */
name|contin
label|:
comment|/* JF this goto is my fault I admit it. 				   Someone brave please re-write the whole 				   input section here?  Pleeze???  */
while|while
condition|(
name|input_line_pointer
operator|<
name|buffer_limit
condition|)
block|{
comment|/* We have more of this buffer to parse. */
comment|/* 	   * We now have input_line_pointer->1st char of next line. 	   * If input_line_pointer [-1] == '\n' then we just 	   * scanned another line: so bump line counters. 	   */
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
operator|-
literal|1
index|]
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|md_start_line_hook
name|md_start_line_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bump_line_counters
argument_list|()
expr_stmt|;
name|line_label
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flag_m68k_mri
ifdef|#
directive|ifdef
name|LABELS_WITHOUT_COLONS
operator|||
literal|1
endif|#
directive|endif
condition|)
block|{
comment|/* Text at the start of a line must be a label, we 		     run down and stick a colon in.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
modifier|*
name|line_start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|mri_line_macro
decl_stmt|;
name|LISTING_NEWLINE
argument_list|()
expr_stmt|;
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* In MRI mode, the EQU and MACRO pseudoops must 			 be handled specially.  */
name|mri_line_macro
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|char
modifier|*
name|rest
init|=
name|input_line_pointer
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|rest
operator|==
literal|':'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|*
name|rest
operator|==
literal|' '
operator|||
operator|*
name|rest
operator|==
literal|'\t'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"EQU"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"SET"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rest
index|[
literal|3
index|]
operator|==
literal|' '
operator|||
name|rest
index|[
literal|3
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|input_line_pointer
operator|=
name|rest
operator|+
literal|3
expr_stmt|;
name|equals
argument_list|(
name|line_start
argument_list|,
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"SET"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"MACRO"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|rest
index|[
literal|5
index|]
operator|==
literal|' '
operator|||
name|rest
index|[
literal|5
index|]
operator|==
literal|'\t'
operator|||
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|rest
index|[
literal|5
index|]
index|]
operator|)
condition|)
name|mri_line_macro
operator|=
literal|1
expr_stmt|;
block|}
comment|/* In MRI mode, we need to handle the MACRO                          pseudo-op specially: we don't want to put the                          symbol in the symbol table.  */
if|if
condition|(
operator|!
name|mri_line_macro
condition|)
name|line_label
operator|=
name|colon
argument_list|(
name|line_start
argument_list|)
expr_stmt|;
else|else
name|line_label
operator|=
name|symbol_create
argument_list|(
name|line_start
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	   * We are at the begining of a line, or similar place. 	   * We expect a well-formed assembler statement. 	   * A "symbol-name:" is a statement. 	   * 	   * Depending on what compiler is used, the order of these tests 	   * may vary to catch most common case 1st. 	   * Each test is independent of all other tests at the (top) level. 	   * PLEASE make a compiler that doesn't use this assembler. 	   * It is crufty to waste a compiler's time encoding things for this 	   * assembler, which then wastes more time decoding it. 	   * (And communicating via (linear) files is silly! 	   * If you must pass stuff, please pass a tree!) 	   */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|)
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\f'
operator|||
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|know
argument_list|(
name|c
operator|!=
literal|' '
argument_list|)
expr_stmt|;
comment|/* No further leading whitespace. */
name|LISTING_NEWLINE
argument_list|()
expr_stmt|;
comment|/* 	   * C is the 1st significant character. 	   * Input_line_pointer points after that character. 	   */
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* want user-defined label or pseudo/opcode */
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
name|s
operator|=
operator|--
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* name's delimiter */
comment|/* 	       * C is character after symbol. 	       * That character's place in the input line is now '\0'. 	       * S points to the beginning of the symbol. 	       *   [In case of pseudo-op, s->'.'.] 	       * Input_line_pointer->'\0' where c was. 	       */
if|if
condition|(
name|TC_START_LABEL
argument_list|(
name|c
argument_list|,
name|input_line_pointer
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|char
modifier|*
name|rest
init|=
name|input_line_pointer
operator|+
literal|1
decl_stmt|;
comment|/* In MRI mode, \tsym: set 0 is permitted.  */
if|if
condition|(
operator|*
name|rest
operator|==
literal|':'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|*
name|rest
operator|==
literal|' '
operator|||
operator|*
name|rest
operator|==
literal|'\t'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"EQU"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"SET"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rest
index|[
literal|3
index|]
operator|==
literal|' '
operator|||
name|rest
index|[
literal|3
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|input_line_pointer
operator|=
name|rest
operator|+
literal|3
expr_stmt|;
name|equals
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|line_label
operator|=
name|colon
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* user-defined label */
operator|*
name|input_line_pointer
operator|++
operator|=
literal|':'
expr_stmt|;
comment|/* Put ':' back for error messages' sake. */
comment|/* Input_line_pointer->after ':'. */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
operator|||
operator|(
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'='
ifdef|#
directive|ifdef
name|TC_EQUAL_IN_INSN
operator|&&
operator|!
name|TC_EQUAL_IN_INSN
argument_list|(
name|c
argument_list|,
name|input_line_pointer
argument_list|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|equals
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* expect pseudo-op or machine instruction */
name|pop
operator|=
name|NULL
expr_stmt|;
define|#
directive|define
name|IGNORE_OPCODE_CASE
ifdef|#
directive|ifdef
name|IGNORE_OPCODE_CASE
block|{
name|char
modifier|*
name|s2
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s2
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
operator|*
name|s2
operator|=
name|tolower
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|flag_m68k_mri
ifdef|#
directive|ifdef
name|NO_PSEUDO_DOT
operator|||
literal|1
endif|#
directive|endif
condition|)
block|{
comment|/* The MRI assembler and the m88k use pseudo-ops                          without a period.  */
name|pop
operator|=
operator|(
name|pseudo_typeS
operator|*
operator|)
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop
operator|!=
name|NULL
operator|&&
name|pop
operator|->
name|poc_handler
operator|==
name|NULL
condition|)
name|pop
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pop
operator|!=
name|NULL
operator|||
operator|(
operator|!
name|flag_m68k_mri
operator|&&
operator|*
name|s
operator|==
literal|'.'
operator|)
condition|)
block|{
comment|/* 		       * PSEUDO - OP. 		       * 		       * WARNING: c has next char, which may be end-of-line. 		       * We lookup the pseudo-op table with s+1 because we 		       * already know that the pseudo-op begins with a '.'. 		       */
if|if
condition|(
name|pop
operator|==
name|NULL
condition|)
name|pop
operator|=
operator|(
name|pseudo_typeS
operator|*
operator|)
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* In MRI mode, we may need to insert an                          automatic alignment directive.  What a hack                          this is.  */
if|if
condition|(
name|mri_pending_align
operator|&&
operator|(
name|pop
operator|==
name|NULL
operator|||
operator|!
operator|(
operator|(
name|pop
operator|->
name|poc_handler
operator|==
name|cons
operator|&&
name|pop
operator|->
name|poc_val
operator|==
literal|1
operator|)
operator|||
operator|(
name|pop
operator|->
name|poc_handler
operator|==
name|s_space
operator|&&
name|pop
operator|->
name|poc_val
operator|==
literal|1
operator|)
ifdef|#
directive|ifdef
name|tc_conditional_pseudoop
operator|||
name|tc_conditional_pseudoop
argument_list|(
name|pop
argument_list|)
endif|#
directive|endif
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_if
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_ifdef
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_ifc
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_ifeqs
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_else
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_endif
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_globl
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_ignore
operator|)
operator|)
condition|)
block|{
name|do_align
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mri_pending_align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|line_label
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print the error msg now, while we still can */
if|if
condition|(
name|pop
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown pseudo-op:  `%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Put it back for error messages etc. */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* The following skip of whitespace is compulsory. 			 A well shaped space is sometimes all that separates 			 keyword from operands. */
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* 		       * Input_line is restored. 		       * Input_line_pointer->1st non-blank char 		       * after pseudo-operation. 		       */
call|(
modifier|*
name|pop
operator|->
name|poc_handler
call|)
argument_list|(
name|pop
operator|->
name|poc_val
argument_list|)
expr_stmt|;
comment|/* If that was .end, just get out now.  */
if|if
condition|(
name|pop
operator|->
name|poc_handler
operator|==
name|s_end
condition|)
goto|goto
name|quit
goto|;
block|}
else|else
block|{
name|int
name|inquote
init|=
literal|0
decl_stmt|;
comment|/* WARNING: c has char, which may be end-of-line. */
comment|/* Also: input_line_pointer->`\0` where c was. */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|||
name|inquote
ifdef|#
directive|ifdef
name|TC_EOL_IN_INSN
operator|||
name|TC_EOL_IN_INSN
argument_list|(
name|input_line_pointer
argument_list|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|flag_m68k_mri
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'\''
condition|)
name|inquote
operator|=
operator|!
name|inquote
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_GENERATE_ASM_LINENO
if|if
condition|(
name|generate_asm_lineno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ecoff_no_current_file
argument_list|()
condition|)
name|generate_asm_lineno
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|generate_asm_lineno
operator|==
literal|1
condition|)
block|{
name|unsigned
name|int
name|lineno
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
name|OBJ_GENERATE_ASM_LINENO
argument_list|(
name|s
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|macro_defined
condition|)
block|{
name|sb
name|out
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|check_macro
argument_list|(
name|s
argument_list|,
operator|&
name|out
argument_list|,
literal|'\0'
argument_list|,
operator|&
name|err
argument_list|)
condition|)
block|{
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
name|as_bad
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|++
operator|=
name|c
expr_stmt|;
name|input_scrub_include_sb
argument_list|(
operator|&
name|out
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|mri_pending_align
condition|)
block|{
name|do_align
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mri_pending_align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|line_label
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|md_assemble
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Assemble 1 instruction. */
operator|*
name|input_line_pointer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* We resume loop AFTER the end-of-line from 			 this instruction. */
block|}
comment|/* if (*s=='.') */
block|}
comment|/* if c==':' */
continue|continue;
block|}
comment|/* if (is_name_beginner(c) */
comment|/* Empty statement?  */
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|LOCAL_LABELS_DOLLAR
operator|||
name|LOCAL_LABELS_FB
operator|)
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* local label  ("4:") */
name|char
modifier|*
name|backup
init|=
name|input_line_pointer
decl_stmt|;
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
name|temp
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|temp
operator|=
operator|(
name|temp
operator|*
literal|10
operator|)
operator|+
operator|*
name|input_line_pointer
operator|-
literal|'0'
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
comment|/* read the whole number */
if|if
condition|(
name|LOCAL_LABELS_DOLLAR
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'$'
operator|&&
operator|*
operator|(
name|input_line_pointer
operator|+
literal|1
operator|)
operator|==
literal|':'
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|dollar_label_defined
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"label \"%d$\" redefined"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|define_dollar_label
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|dollar_label_name
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
operator|*
name|input_line_pointer
operator|++
operator|==
literal|':'
condition|)
block|{
name|fb_label_instance_inc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|fb_label_name
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|input_line_pointer
operator|=
name|backup
expr_stmt|;
block|}
comment|/* local label  ("4:") */
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|line_comment_chars
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|/* Its a comment.  Better say APP or NO_APP */
name|char
modifier|*
name|ends
decl_stmt|;
name|char
modifier|*
name|new_buf
decl_stmt|;
name|char
modifier|*
name|new_tmp
decl_stmt|;
name|unsigned
name|int
name|new_length
decl_stmt|;
name|char
modifier|*
name|tmp_buf
init|=
literal|0
decl_stmt|;
name|bump_line_counters
argument_list|()
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"APP\n"
argument_list|,
literal|4
argument_list|)
condition|)
continue|continue;
comment|/* We ignore it */
name|s
operator|+=
literal|4
expr_stmt|;
name|ends
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
literal|"#NO_APP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ends
condition|)
block|{
name|unsigned
name|int
name|tmp_len
decl_stmt|;
name|unsigned
name|int
name|num
decl_stmt|;
comment|/* The end of the #APP wasn't in this buffer.  We 		     keep reading in buffers until we find the #NO_APP 		     that goes with this #APP  There is one.  The specs 		     guarentee it. . . */
name|tmp_len
operator|=
name|buffer_limit
operator|-
name|s
expr_stmt|;
name|tmp_buf
operator|=
name|xmalloc
argument_list|(
name|tmp_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp_buf
argument_list|,
name|s
argument_list|,
name|tmp_len
argument_list|)
expr_stmt|;
do|do
block|{
name|new_tmp
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_tmp
condition|)
break|break;
else|else
name|buffer_limit
operator|=
name|new_tmp
expr_stmt|;
name|input_line_pointer
operator|=
name|buffer
expr_stmt|;
name|ends
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
literal|"#NO_APP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ends
condition|)
name|num
operator|=
name|ends
operator|-
name|buffer
expr_stmt|;
else|else
name|num
operator|=
name|buffer_limit
operator|-
name|buffer
expr_stmt|;
name|tmp_buf
operator|=
name|xrealloc
argument_list|(
name|tmp_buf
argument_list|,
name|tmp_len
operator|+
name|num
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp_buf
operator|+
name|tmp_len
argument_list|,
name|buffer
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|tmp_len
operator|+=
name|num
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ends
condition|)
do|;
name|input_line_pointer
operator|=
name|ends
condition|?
name|ends
operator|+
literal|8
else|:
name|NULL
expr_stmt|;
name|s
operator|=
name|tmp_buf
expr_stmt|;
name|ends
operator|=
name|s
operator|+
name|tmp_len
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|=
name|ends
operator|+
literal|8
expr_stmt|;
block|}
name|scrub_string
operator|=
name|s
expr_stmt|;
name|scrub_string_end
operator|=
name|ends
expr_stmt|;
name|new_length
operator|=
name|ends
operator|-
name|s
expr_stmt|;
name|new_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|new_length
argument_list|)
expr_stmt|;
name|new_tmp
operator|=
name|new_buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|space
decl_stmt|;
name|int
name|size
decl_stmt|;
name|space
operator|=
operator|(
name|new_buf
operator|+
name|new_length
operator|)
operator|-
name|new_tmp
expr_stmt|;
name|size
operator|=
name|do_scrub_chars
argument_list|(
name|scrub_from_string
argument_list|,
name|new_tmp
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|space
condition|)
block|{
name|new_tmp
operator|+=
name|size
expr_stmt|;
break|break;
block|}
name|new_buf
operator|=
name|xrealloc
argument_list|(
name|new_buf
argument_list|,
name|new_length
operator|+
literal|100
argument_list|)
expr_stmt|;
name|new_tmp
operator|=
name|new_buf
operator|+
name|new_length
expr_stmt|;
name|new_length
operator|+=
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|tmp_buf
condition|)
name|free
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
name|old_buffer
operator|=
name|buffer
expr_stmt|;
name|old_input
operator|=
name|input_line_pointer
expr_stmt|;
name|old_limit
operator|=
name|buffer_limit
expr_stmt|;
name|buffer
operator|=
name|new_buf
expr_stmt|;
name|input_line_pointer
operator|=
name|new_buf
expr_stmt|;
name|buffer_limit
operator|=
name|new_tmp
expr_stmt|;
continue|continue;
block|}
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_unrecognized_line
if|if
condition|(
name|tc_unrecognized_line
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* as_warn("Junk character %d.",c);  Now done by ignore_rest */
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Report unknown char as ignored. */
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* while (input_line_pointer<buffer_limit) */
ifdef|#
directive|ifdef
name|md_after_pass_hook
name|md_after_pass_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|old_buffer
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|bump_line_counters
argument_list|()
expr_stmt|;
if|if
condition|(
name|old_input
operator|!=
literal|0
condition|)
block|{
name|buffer
operator|=
name|old_buffer
expr_stmt|;
name|input_line_pointer
operator|=
name|old_input
expr_stmt|;
name|buffer_limit
operator|=
name|old_limit
expr_stmt|;
name|old_buffer
operator|=
literal|0
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
block|}
block|}
comment|/* while (more buffers to scan) */
name|quit
label|:
ifdef|#
directive|ifdef
name|md_cleanup
name|md_cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|input_scrub_close
argument_list|()
expr_stmt|;
comment|/* Close the input file */
block|}
end_function

begin_comment
comment|/* For most MRI pseudo-ops, the line actually ends at the first    nonquoted space.  This function looks for that point, stuffs a null    in, and sets *STOPCP to the character that used to be there, and    returns the location.     Until I hear otherwise, I am going to assume that this is only true    for the m68k MRI assembler.  */
end_comment

begin_function
name|char
modifier|*
name|mri_comment_field
parameter_list|(
name|stopcp
parameter_list|)
name|char
modifier|*
name|stopcp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TC_M68K
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|inquote
init|=
literal|0
decl_stmt|;
name|know
argument_list|(
name|flag_m68k_mri
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
operator|(
operator|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
operator|)
operator|||
name|inquote
operator|)
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
condition|)
name|inquote
operator|=
operator|!
name|inquote
expr_stmt|;
block|}
operator|*
name|stopcp
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
else|#
directive|else
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
condition|;
name|s
operator|++
control|)
empty_stmt|;
operator|*
name|stopcp
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Skip to the end of an MRI comment field.  */
end_comment

begin_function
name|void
name|mri_comment_end
parameter_list|(
name|stop
parameter_list|,
name|stopc
parameter_list|)
name|char
modifier|*
name|stop
decl_stmt|;
name|int
name|stopc
decl_stmt|;
block|{
name|know
argument_list|(
name|flag_mri
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|stop
expr_stmt|;
operator|*
name|stop
operator|=
name|stopc
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_abort
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|".abort detected.  Abandoning ship."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Guts of .align directive.  N is the power of two to which to align.    FILL may be NULL, or it may point to the bytes of the fill pattern.    LEN is the length of whatever FILL points to, if anything.  MAX is    the maximum number of characters to skip when doing the alignment,    or 0 if there is no maximum.  */
end_comment

begin_function
specifier|static
name|void
name|do_align
parameter_list|(
name|n
parameter_list|,
name|fill
parameter_list|,
name|len
parameter_list|,
name|max
parameter_list|)
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|fill
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
name|char
name|default_fill
decl_stmt|;
ifdef|#
directive|ifdef
name|md_do_align
name|md_do_align
argument_list|(
name|n
argument_list|,
name|fill
argument_list|,
name|len
argument_list|,
name|max
argument_list|,
name|just_record_alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fill
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: Fix this right for BFD!  */
if|if
condition|(
name|now_seg
operator|!=
name|data_section
operator|&&
name|now_seg
operator|!=
name|bss_section
condition|)
name|default_fill
operator|=
name|NOP_OPCODE
expr_stmt|;
else|else
name|default_fill
operator|=
literal|0
expr_stmt|;
name|fill
operator|=
operator|&
name|default_fill
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Only make a frag if we HAVE to. . . */
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
name|frag_align
argument_list|(
name|n
argument_list|,
operator|*
name|fill
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|frag_align_pattern
argument_list|(
name|n
argument_list|,
name|fill
argument_list|,
name|len
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|md_do_align
name|just_record_alignment
label|:
endif|#
directive|endif
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .align pseudo-op.  A positive ARG is a default alignment    (in bytes).  A negative ARG is the negative of the length of the    fill pattern.  BYTES_P is non-zero if the alignment value should be    interpreted as the byte boundary, rather than the power of 2.  */
end_comment

begin_function
specifier|static
name|void
name|s_align
parameter_list|(
name|arg
parameter_list|,
name|bytes_p
parameter_list|)
name|int
name|arg
decl_stmt|;
name|int
name|bytes_p
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|align
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
name|offsetT
name|fill
init|=
literal|0
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|fill_p
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
name|align
operator|=
literal|0
expr_stmt|;
else|else
name|align
operator|=
name|arg
expr_stmt|;
comment|/* Default value from pseudo-op table */
block|}
else|else
block|{
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bytes_p
condition|)
block|{
comment|/* Convert to a power of 2.  */
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|align
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|align
operator|>>=
literal|1
operator|,
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
literal|"Alignment not a power of 2"
argument_list|)
expr_stmt|;
name|align
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|align
operator|>
literal|15
condition|)
block|{
name|align
operator|=
literal|15
expr_stmt|;
name|as_bad
argument_list|(
literal|"Alignment too large: %u assumed"
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|fill_p
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|fill_p
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|fill_p
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|max
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|max
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fill_p
condition|)
block|{
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
literal|"expected fill pattern missing"
argument_list|)
expr_stmt|;
name|do_align
argument_list|(
name|align
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|fill_len
decl_stmt|;
if|if
condition|(
name|arg
operator|>=
literal|0
condition|)
name|fill_len
operator|=
literal|1
expr_stmt|;
else|else
name|fill_len
operator|=
operator|-
name|arg
expr_stmt|;
if|if
condition|(
name|fill_len
operator|<=
literal|1
condition|)
block|{
name|char
name|fill_char
decl_stmt|;
name|fill_char
operator|=
name|fill
expr_stmt|;
name|do_align
argument_list|(
name|align
argument_list|,
operator|&
name|fill_char
argument_list|,
name|fill_len
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|ab
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|fill_len
operator|>
sizeof|sizeof
name|ab
condition|)
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ab
argument_list|,
name|fill
argument_list|,
name|fill_len
argument_list|)
expr_stmt|;
name|do_align
argument_list|(
name|align
argument_list|,
name|ab
argument_list|,
name|fill_len
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .align pseudo-op on machines where ".align 4" means    align to a 4 byte boundary.  */
end_comment

begin_function
name|void
name|s_align_bytes
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|s_align
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .align pseud-op on machines where ".align 4" means align    to a 2**4 boundary.  */
end_comment

begin_function
name|void
name|s_align_ptwo
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|s_align
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_comm
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|offsetT
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after symbol-name: rest of line ignored."
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|".COMMon length (%ld.)<0! Ignored."
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Ignoring attempt to re-define symbol `%s'."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
operator|(
name|valueT
operator|)
name|temp
condition|)
name|as_bad
argument_list|(
literal|"Length of .comm \"%s\" is already %ld. Not changed to %ld."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_VMS
block|{
specifier|extern
name|int
name|flag_one
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|temp
operator|)
operator|||
operator|!
name|flag_one
condition|)
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|=
name|const_flag
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not OBJ_VMS */
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_comm() */
end_comment

begin_comment
comment|/* The MRI COMMON pseudo-op.  We handle this by creating a common    symbol with the appropriate name.  We make s_space do the right    thing by increasing the size.  */
end_comment

begin_function
name|void
name|s_mri_common
parameter_list|(
name|small
parameter_list|)
name|int
name|small
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|alc
init|=
name|NULL
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|align
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
operator|!
name|flag_mri
condition|)
block|{
name|s_comm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|name
argument_list|)
condition|)
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
else|else
block|{
do|do
block|{
operator|++
name|input_line_pointer
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
argument_list|)
condition|)
do|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|alc
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
operator|+
operator|(
name|input_line_pointer
operator|-
name|name
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|alc
argument_list|,
literal|"%s%s"
argument_list|,
name|name
argument_list|,
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|alc
expr_stmt|;
block|}
block|}
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|alc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|align
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"attempt to re-define symbol `%s'"
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_EXTERNAL
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|mri_common_symbol
operator|=
name|sym
expr_stmt|;
ifdef|#
directive|ifdef
name|S_SET_ALIGN
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
name|S_SET_ALIGN
argument_list|(
name|sym
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|line_label
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|line_label
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|line_label
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|line_label
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|line_label
argument_list|,
name|expr_section
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: We just ignore the small argument, which distinguishes      COMMON and COMMON.S.  I don't know what we can do about it.  */
comment|/* Ignore the type and hptype.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_data
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|segT
name|section
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_readonly_data_in_text
condition|)
block|{
name|section
operator|=
name|text_section
expr_stmt|;
name|temp
operator|+=
literal|1000
expr_stmt|;
block|}
else|else
name|section
operator|=
name|data_section
expr_stmt|;
name|subseg_set
argument_list|(
name|section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|const_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .appfile pseudo-op.  This is automatically generated by    do_scrub_chars when a preprocessor # line comment is seen with a    file name.  This default definition may be overridden by the object    or CPU specific pseudo-ops.  This function is also the default    definition for .file; the APPFILE argument is 1 for .appfile, 0 for    .file.  */
end_comment

begin_function
name|void
name|s_app_file
parameter_list|(
name|appfile
parameter_list|)
name|int
name|appfile
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Some assemblers tolerate immediately following '"' */
if|if
condition|(
operator|(
name|s
operator|=
name|demand_copy_string
argument_list|(
operator|&
name|length
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If this is a fake .appfile, a fake newline was inserted into 	 the buffer.  Passing -2 to new_logical_line tells it to 	 account for it.  */
name|new_logical_line
argument_list|(
name|s
argument_list|,
name|appfile
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* In MRI mode, the preprocessor may have inserted an extraneous          backquote.  */
if|if
condition|(
name|flag_m68k_mri
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'\''
operator|&&
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
literal|1
index|]
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|obj_app_file
name|obj_app_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Handle the .appline pseudo-op.  This is automatically generated by    do_scrub_chars when a preprocessor # line comment is seen.  This    default definition may be overridden by the object or CPU specific    pseudo-ops.  */
end_comment

begin_function
name|void
name|s_app_line
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|l
decl_stmt|;
comment|/* The given number is that of the next line.  */
name|l
operator|=
name|get_absolute_expression
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
comment|/* Some of the back ends can't deal with non-positive line numbers.        Besides, it's silly.  */
name|as_warn
argument_list|(
literal|"Line numbers must be positive; line number %d rejected."
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|l
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .end pseudo-op.  Actually, the real work is done in    read_a_source_file.  */
end_comment

begin_function
name|void
name|s_end
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|flag_mri
condition|)
block|{
comment|/* The MRI assembler permits the start symbol to follow .end,          but we don't support that.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'*'
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'!'
condition|)
name|as_warn
argument_list|(
literal|"start address not supported"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the .err pseudo-op.  */
end_comment

begin_function
name|void
name|s_err
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|as_bad
argument_list|(
literal|".err encountered"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI fail pseudo-op.  */
end_comment

begin_function
name|void
name|s_fail
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|offsetT
name|temp
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
literal|500
condition|)
name|as_warn
argument_list|(
literal|".fail %ld encountered"
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|".fail %ld encountered"
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_fill
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|long
name|temp_repeat
init|=
literal|0
decl_stmt|;
name|long
name|temp_size
init|=
literal|1
decl_stmt|;
specifier|register
name|long
name|temp_fill
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|temp_repeat
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* This is to be compatible with BSD 4.2 AS, not for any rational reason.  */
define|#
directive|define
name|BSD_FILL_SIZE_CROCK_8
value|(8)
if|if
condition|(
name|temp_size
operator|>
name|BSD_FILL_SIZE_CROCK_8
condition|)
block|{
name|as_warn
argument_list|(
literal|".fill size clamped to %d."
argument_list|,
name|BSD_FILL_SIZE_CROCK_8
argument_list|)
expr_stmt|;
name|temp_size
operator|=
name|BSD_FILL_SIZE_CROCK_8
expr_stmt|;
block|}
if|if
condition|(
name|temp_size
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Size negative: .fill ignored."
argument_list|)
expr_stmt|;
name|temp_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp_repeat
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|temp_repeat
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
literal|"Repeat< 0, .fill ignored"
argument_list|)
expr_stmt|;
name|temp_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|temp_size
operator|&&
operator|!
name|need_pass_2
condition|)
block|{
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
operator|(
name|int
operator|)
name|temp_size
argument_list|,
operator|(
name|int
operator|)
name|temp_size
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|offsetT
operator|)
name|temp_repeat
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|temp_size
argument_list|)
expr_stmt|;
comment|/* The magic number BSD_FILL_SIZE_CROCK_4 is from BSD 4.2 VAX        * flavoured AS.  The following bizzare behaviour is to be        * compatible with above.  I guess they tried to take up to 8        * bytes from a 4-byte expression and they forgot to sign        * extend. Un*x Sux. */
define|#
directive|define
name|BSD_FILL_SIZE_CROCK_4
value|(4)
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|temp_fill
argument_list|,
operator|(
name|temp_size
operator|>
name|BSD_FILL_SIZE_CROCK_4
condition|?
name|BSD_FILL_SIZE_CROCK_4
else|:
operator|(
name|int
operator|)
name|temp_size
operator|)
argument_list|)
expr_stmt|;
comment|/* Note: .fill (),0 emits no frag (since we are asked to .fill 0 bytes)        * but emits no error message because it seems a legal thing to do.        * It is a degenerate case of .fill but could be emitted by a compiler.        */
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_globl
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI IRP and IRPC pseudo-ops.  */
end_comment

begin_function
name|void
name|s_irp
parameter_list|(
name|irpc
parameter_list|)
name|int
name|irpc
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|sb
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|sb
name|out
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|sb_add_char
argument_list|(
operator|&
name|s
argument_list|,
operator|*
name|input_line_pointer
operator|++
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|err
operator|=
name|expand_irp
argument_list|(
name|irpc
argument_list|,
literal|0
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|out
argument_list|,
name|get_line_sb
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|input_scrub_include_sb
argument_list|(
operator|&
name|out
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .linkonce pseudo-op.  This tells the assembler to mark    the section to only be linked once.  However, this is not supported    by most object file formats.  This takes an optional argument,    which is what to do about duplicates.  */
end_comment

begin_function
name|void
name|s_linkonce
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|enum
name|linkonce_type
name|type
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|type
operator|=
name|LINKONCE_DISCARD
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
literal|"discard"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|LINKONCE_DISCARD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
literal|"one_only"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|LINKONCE_ONE_ONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
literal|"same_size"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|LINKONCE_SAME_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
literal|"same_contents"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|LINKONCE_SAME_CONTENTS
expr_stmt|;
else|else
name|as_warn
argument_list|(
literal|"unrecognized .linkonce type `%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|obj_handle_link_once
name|obj_handle_link_once
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! defined (obj_handle_link_once) */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
block|{
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
operator|&
name|SEC_LINK_ONCE
operator|)
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
literal|".linkonce is not supported for this object file format"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|flags
operator||=
name|SEC_LINK_ONCE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|LINKONCE_DISCARD
case|:
name|flags
operator||=
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
break|break;
case|case
name|LINKONCE_ONE_ONLY
case|:
name|flags
operator||=
name|SEC_LINK_DUPLICATES_ONE_ONLY
expr_stmt|;
break|break;
case|case
name|LINKONCE_SAME_SIZE
case|:
name|flags
operator||=
name|SEC_LINK_DUPLICATES_SAME_SIZE
expr_stmt|;
break|break;
case|case
name|LINKONCE_SAME_CONTENTS
case|:
name|flags
operator||=
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|,
name|flags
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"bfd_set_section_flags: %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! defined (BFD_ASSEMBLER) */
name|as_warn
argument_list|(
literal|".linkonce is not supported for this object file format"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! defined (BFD_ASSEMBLER) */
endif|#
directive|endif
comment|/* ! defined (obj_handle_link_once) */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_lcomm
parameter_list|(
name|needs_align
parameter_list|)
comment|/* 1 if this was a ".bss" directive, which may require a 3rd argument 	(alignment); 0 if it was an ".lcomm" (2 args only)  */
name|int
name|needs_align
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|segT
name|current_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|current_subseg
init|=
name|now_subseg
decl_stmt|;
specifier|const
name|int
name|max_alignment
init|=
literal|15
decl_stmt|;
name|int
name|align
init|=
literal|0
decl_stmt|;
name|segT
name|bss_seg
init|=
name|bss_section
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Accept an optional comma after the name.  The comma used to be      required, but Irix 5 cc does not generate it.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing size expression"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"BSS length (%d.)<0! Ignored."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TC_MIPS
argument_list|)
operator|||
name|defined
argument_list|(
name|TC_ALPHA
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_ecoff_flavour
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
comment|/* For MIPS and Alpha ECOFF or ELF, small objects are put in .sbss.  */
if|if
condition|(
name|temp
operator|<=
name|bfd_get_gp_size
argument_list|(
name|stdoutput
argument_list|)
condition|)
block|{
name|bss_seg
operator|=
name|subseg_new
argument_list|(
literal|".sbss"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|bss_seg
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|bss_seg
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"error setting flags for \".sbss\": %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|needs_align
condition|)
block|{
comment|/* FIXME. This needs to be machine independent. */
if|if
condition|(
name|temp
operator|>=
literal|8
condition|)
name|align
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|>=
literal|4
condition|)
name|align
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|>=
literal|2
condition|)
name|align
operator|=
literal|1
expr_stmt|;
else|else
name|align
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_EVAX
comment|/* FIXME: This needs to be done in a more general fashion.  */
name|align
operator|=
literal|3
expr_stmt|;
endif|#
directive|endif
name|record_alignment
argument_list|(
name|bss_seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needs_align
condition|)
block|{
name|align
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after size"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing alignment"
argument_list|)
expr_stmt|;
return|return;
block|}
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|max_alignment
condition|)
block|{
name|align
operator|=
name|max_alignment
expr_stmt|;
name|as_warn
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|<
literal|0
condition|)
block|{
name|align
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Alignment negative. 0 assumed."
argument_list|)
expr_stmt|;
block|}
name|record_alignment
argument_list|(
name|bss_seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
comment|/* if needs align */
else|else
block|{
comment|/* Assume some objects may require alignment on some systems.  */
if|#
directive|if
name|defined
argument_list|(
name|TC_ALPHA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|temp
operator|>
literal|1
condition|)
block|{
name|align
operator|=
name|ffs
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|%
operator|(
literal|1
operator|<<
name|align
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_seg
operator|||
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|pfrag
decl_stmt|;
name|subseg_set
argument_list|(
name|bss_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
condition|)
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* detach from old frag	*/
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_seg
condition|)
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_symbol
operator|=
name|NULL
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
operator|(
name|offsetT
operator|)
name|temp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_seg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* The symbol may already have been created with a preceding          ".globl" directive -- be careful not to step on storage class          in that case.  Otherwise, set it to static. */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|C_EXT
condition|)
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_COFF */
ifdef|#
directive|ifdef
name|S_SET_SIZE
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|as_bad
argument_list|(
literal|"Ignoring attempt to re-define symbol `%s'."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_lcomm() */
end_comment

begin_function
name|void
name|s_lsym
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* we permit ANY defined expression: BSD4.2 demands constants */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad expression"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* FIXME-SOON I pulled a (&& symbolP->sy_other == 0&&      symbolP->sy_desc == 0) out of this test because coff doesn't have      those fields, and I can't see when they'd ever be tripped.  I      don't think I understand why they were here so I may have      introduced a bug. As recently as 1.37 didn't have this test      anyway.  xoxorich. */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|undefined_section
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The name might be an undefined .global symbol; be sure to 	 keep the "external" bit. */
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
operator|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|?
name|absolute_section
else|:
name|reg_section
operator|)
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Symbol %s already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_lsym() */
end_comment

begin_comment
comment|/* Read a line into an sb.  */
end_comment

begin_function
specifier|static
name|int
name|get_line_sb
parameter_list|(
name|line
parameter_list|)
name|sb
modifier|*
name|line
decl_stmt|;
block|{
name|char
name|quote1
decl_stmt|,
name|quote2
decl_stmt|,
name|inquote
decl_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bump_line_counters
argument_list|()
expr_stmt|;
if|if
condition|(
name|input_line_pointer
operator|>=
name|buffer_limit
condition|)
block|{
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_limit
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* If app.c sets any other characters to LEX_IS_STRINGQUOTE, this      code needs to be changed.  */
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
name|quote1
operator|=
literal|'"'
expr_stmt|;
else|else
name|quote1
operator|=
literal|'\0'
expr_stmt|;
name|quote2
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flag_m68k_mri
condition|)
name|quote2
operator|=
literal|'\''
expr_stmt|;
ifdef|#
directive|ifdef
name|LEX_IS_STRINGQUOTE
name|quote2
operator|=
literal|'\''
expr_stmt|;
endif|#
directive|endif
name|inquote
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|||
operator|(
name|inquote
operator|!=
literal|'\0'
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|inquote
operator|==
operator|*
name|input_line_pointer
condition|)
name|inquote
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|inquote
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
name|quote1
condition|)
name|inquote
operator|=
name|quote1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
name|quote2
condition|)
name|inquote
operator|=
name|quote2
expr_stmt|;
block|}
name|sb_add_char
argument_list|(
name|line
argument_list|,
operator|*
name|input_line_pointer
operator|++
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|input_line_pointer
operator|<
name|buffer_limit
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bump_line_counters
argument_list|()
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Define a macro.  This is an interface to macro.c, which is shared    between gas and gasp.  */
end_comment

begin_function
name|void
name|s_macro
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|sb
name|s
decl_stmt|;
name|sb
name|label
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|sb_add_char
argument_list|(
operator|&
name|s
argument_list|,
operator|*
name|input_line_pointer
operator|++
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
name|sb_add_string
argument_list|(
operator|&
name|label
argument_list|,
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|define_macro
argument_list|(
literal|0
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|label
argument_list|,
name|get_line_sb
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|line_label
argument_list|,
name|undefined_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line_label
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|flag_m68k_mri
ifdef|#
directive|ifdef
name|NO_PSEUDO_DOT
operator|||
literal|1
endif|#
directive|endif
operator|)
operator|&&
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|!
name|flag_m68k_mri
operator|&&
operator|*
name|name
operator|==
literal|'.'
operator|&&
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|name
operator|+
literal|1
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|as_warn
argument_list|(
literal|"attempt to redefine pseudo-op `%s' ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .mexit pseudo-op, which immediately exits a macro    expansion.  */
end_comment

begin_function
name|void
name|s_mexit
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|cond_exit_macro
argument_list|(
name|macro_nest
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch in and out of MRI mode.  */
end_comment

begin_function
name|void
name|s_mri
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|on
decl_stmt|,
name|old_flag
decl_stmt|;
name|on
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|old_flag
operator|=
name|flag_mri
expr_stmt|;
if|if
condition|(
name|on
operator|!=
literal|0
condition|)
block|{
name|flag_mri
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
name|flag_m68k_mri
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|flag_mri
operator|=
literal|0
expr_stmt|;
name|flag_m68k_mri
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MRI_MODE_CHANGE
if|if
condition|(
name|on
operator|!=
name|old_flag
condition|)
name|MRI_MODE_CHANGE
argument_list|(
name|on
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle changing the location counter.  */
end_comment

begin_function
specifier|static
name|void
name|do_org
parameter_list|(
name|segment
parameter_list|,
name|exp
parameter_list|,
name|fill
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|int
name|fill
decl_stmt|;
block|{
if|if
condition|(
name|segment
operator|!=
name|now_seg
operator|&&
name|segment
operator|!=
name|absolute_section
condition|)
name|as_bad
argument_list|(
literal|"invalid segment \"%s\"; segment \"%s\" assumed"
argument_list|,
name|segment_name
argument_list|(
name|segment
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
if|if
condition|(
name|fill
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
literal|"ignoring fill value in absolute section"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"only constant offsets supported in absolute section"
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|abs_section_offset
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|fill
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|s_org
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
comment|/* The m68k MRI assembler has a different meaning for .org.  It      means to create an absolute section at a given address.  We can't      support that--use a linker script instead.  */
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|as_bad
argument_list|(
literal|"MRI style ORG pseudo-op not supported"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Don't believe the documentation of BSD 4.2 AS.  There is no such      thing as a sub-segment-relative origin.  Any absolute origin is      given a warning, then assumed to be segment-relative.  Any      segmented origin expression ("foo+42") had better be in the right      segment or the .org is ignored.       BSD 4.2 AS warns if you try to .org backwards. We cannot because      we never know sub-segment sizes when we are reading code.  BSD      will crash trying to emit negative numbers of filler bytes in      certain .orgs. We don't crash, but see as-write for that code.       Don't make frag if need_pass_2==1.  */
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|do_org
argument_list|(
name|segment
argument_list|,
operator|&
name|exp
argument_list|,
name|temp_fill
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_org() */
end_comment

begin_comment
comment|/* Handle parsing for the MRI SECT/SECTION pseudo-op.  This should be    called by the obj-format routine which handles section changing    when in MRI mode.  It will create a new section, and return it.  It    will set *TYPE to the section type: one of 'C' (code), 'D' (data),    'M' (mixed), or 'R' (romable).  If BFD_ASSEMBLER is defined, the    flags will be set in the section.  */
end_comment

begin_function
name|void
name|s_mri_sect
parameter_list|(
name|type
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TC_M68K
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|name
argument_list|)
condition|)
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
else|else
block|{
do|do
block|{
operator|++
name|input_line_pointer
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
argument_list|)
condition|)
do|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
block|}
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|seg
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|int
name|align
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|record_alignment
argument_list|(
name|seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
operator|*
name|type
operator|=
literal|'C'
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|toupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'C'
operator|||
name|c
operator|==
literal|'D'
operator|||
name|c
operator|==
literal|'M'
operator|||
name|c
operator|==
literal|'R'
condition|)
operator|*
name|type
operator|=
name|c
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"unrecognized section type"
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
literal|'C'
condition|)
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|type
operator|==
literal|'D'
operator|||
operator|*
name|type
operator|==
literal|'M'
condition|)
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|type
operator|==
literal|'R'
condition|)
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_READONLY
operator||
name|SEC_ROM
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|SEC_NO_FLAGS
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|flags
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"error setting flags for \"%s\": %s"
argument_list|,
name|bfd_section_name
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* Ignore the HP type.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* ! TC_M68K */
ifdef|#
directive|ifdef
name|TC_I960
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|seg
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
operator|*
name|type
operator|=
literal|'C'
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|sectype
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|sectype
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|sectype
operator|==
literal|'\0'
condition|)
operator|*
name|type
operator|=
literal|'C'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|sectype
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|type
operator|=
literal|'C'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|sectype
argument_list|,
literal|"data"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|type
operator|=
literal|'D'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|sectype
argument_list|,
literal|"romdata"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|type
operator|=
literal|'R'
expr_stmt|;
else|else
name|as_warn
argument_list|(
literal|"unrecognized section type `%s'"
argument_list|,
name|sectype
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|char
modifier|*
name|seccmd
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|seccmd
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|seccmd
argument_list|,
literal|"absolute"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"absolute sections are not supported"
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|seccmd
argument_list|,
literal|"align"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|align
decl_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|record_alignment
argument_list|(
name|seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"unrecognized section command `%s'"
argument_list|,
name|seccmd
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* ! TC_I960 */
comment|/* The MRI assembler seems to use different forms of .sect for      different targets.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ! TC_I960 */
endif|#
directive|endif
comment|/* ! TC_M68K */
block|}
end_function

begin_comment
comment|/* Handle the .print pseudo-op.  */
end_comment

begin_function
name|void
name|s_print
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|s
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .purgem pseudo-op.  */
end_comment

begin_function
name|void
name|s_purgem
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|delete_macro
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .rept pseudo-op.  */
end_comment

begin_function
name|void
name|s_rept
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|sb
name|one
decl_stmt|;
name|sb
name|many
decl_stmt|;
name|count
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_and_nest
argument_list|(
literal|"REPT"
argument_list|,
literal|"ENDR"
argument_list|,
operator|&
name|one
argument_list|,
name|get_line_sb
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"rept without endr"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sb_new
argument_list|(
operator|&
name|many
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|sb_add_sb
argument_list|(
operator|&
name|many
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|one
argument_list|)
expr_stmt|;
name|input_scrub_include_sb
argument_list|(
operator|&
name|many
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|many
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .equ, .equiv and .set directives.  If EQUIV is 1, then    this is .equiv, and it is an error if the symbol is already    defined.  */
end_comment

begin_function
name|void
name|s_set
parameter_list|(
name|equiv
parameter_list|)
name|int
name|equiv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|delim
decl_stmt|;
specifier|register
name|char
modifier|*
name|end_name
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/*    * Especial apologies for the random logic:    * this just grew, and could be parsed much more simply!    * Dean in haste.    */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Turn '. = mumble' into a .org mumble */
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|do_org
argument_list|(
name|segment
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* "set" symbols are local unless otherwise specified. */
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF */
block|}
comment|/* make a new symbol */
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
if|if
condition|(
name|equiv
operator|&&
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|reg_section
condition|)
name|as_bad
argument_list|(
literal|"symbol `%s' already defined"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_set() */
end_comment

begin_function
name|void
name|s_space
parameter_list|(
name|mult
parameter_list|)
name|int
name|mult
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|expressionS
name|val
decl_stmt|;
name|char
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
name|int
name|bytes
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
comment|/* In m68k MRI mode, we need to align to a word boundary, unless      this is ds.b.  */
if|if
condition|(
name|flag_m68k_mri
operator|&&
name|mult
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|abs_section_offset
operator|+=
name|abs_section_offset
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|abs_section_offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mri_common_symbol
operator|!=
name|NULL
condition|)
block|{
name|valueT
name|val
decl_stmt|;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|,
name|val
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|know
argument_list|(
name|line_label
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|line_label
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|==
name|mri_common_symbol
argument_list|)
expr_stmt|;
name|line_label
operator|->
name|sy_value
operator|.
name|X_add_number
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|do_align
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|line_label
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|bytes
operator|=
name|mult
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|val
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|val
operator|.
name|X_add_number
operator|<
operator|-
literal|0x80
operator|||
name|val
operator|.
name|X_add_number
operator|>
literal|0xff
operator|||
operator|(
name|mult
operator|!=
literal|0
operator|&&
name|mult
operator|!=
literal|1
operator|&&
name|val
operator|.
name|X_add_number
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"Unsupported variable size or fill value"
argument_list|)
expr_stmt|;
else|else
block|{
name|offsetT
name|i
decl_stmt|;
if|if
condition|(
name|mult
operator|==
literal|0
condition|)
name|mult
operator|=
literal|1
expr_stmt|;
name|bytes
operator|=
name|mult
operator|*
name|exp
operator|.
name|X_add_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exp
operator|.
name|X_add_number
condition|;
name|i
operator|++
control|)
name|emit_expr
argument_list|(
operator|&
name|val
argument_list|,
name|mult
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|long
name|repeat
decl_stmt|;
name|repeat
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|mult
condition|)
name|repeat
operator|*=
name|mult
expr_stmt|;
name|bytes
operator|=
name|repeat
expr_stmt|;
if|if
condition|(
name|repeat
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|flag_mri
operator|||
name|repeat
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
literal|".space repeat count is %s, ignored"
argument_list|,
name|repeat
condition|?
literal|"negative"
else|:
literal|"zero"
argument_list|)
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
comment|/* If we are in the absolute section, just bump the offset.  */
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|abs_section_offset
operator|+=
name|repeat
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
comment|/* If we are secretly in an MRI common section, then 	     creating space just increases the size of the common 	     symbol.  */
if|if
condition|(
name|mri_common_symbol
operator|!=
name|NULL
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|,
name|S_GET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|)
operator|+
name|repeat
argument_list|)
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|offsetT
operator|)
name|repeat
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|as_bad
argument_list|(
literal|"space allocation too complex in absolute section"
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mri_common_symbol
operator|!=
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"space allocation too complex in common section"
argument_list|)
expr_stmt|;
name|mri_common_symbol
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|p
operator|=
name|frag_var
argument_list|(
name|rs_space
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
name|val
operator|.
name|X_add_number
expr_stmt|;
block|}
name|getout
label|:
comment|/* In MRI mode, after an odd number of bytes, we must align to an      even word boundary, unless the next instruction is a dc.b, ds.b      or dcb.b.  */
if|if
condition|(
name|flag_mri
operator|&&
operator|(
name|bytes
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|mri_pending_align
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is like s_space, but the value is a floating point number with    the given precision.  This is for the MRI dcb.s pseudo-op and    friends.  */
end_comment

begin_function
name|void
name|s_float_space
parameter_list|(
name|float_type
parameter_list|)
name|int
name|float_type
decl_stmt|;
block|{
name|offsetT
name|count
decl_stmt|;
name|int
name|flen
decl_stmt|;
name|char
name|temp
index|[
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
index|]
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|count
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"missing value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Skip any 0{letter} that may be present.  Don't even check if the    * letter is legal.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|isalpha
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
comment|/* Accept :xxxx, where the x's are hex digits, for a floating point      with the exact digits specified.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|flen
operator|=
name|hex_float
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|md_atof
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|,
operator|&
name|flen
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|flen
operator|<=
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|flen
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|as_bad
argument_list|(
literal|"Bad floating literal: %s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|flen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|temp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|flen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .struct pseudo-op, as found in MIPS assemblers.  */
end_comment

begin_function
name|void
name|s_struct
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|abs_section_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|absolute_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_text
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|text_section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|const_flag
operator|&=
operator|~
name|IN_DEFAULT_SECTION
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* s_text() */
end_comment

begin_escape
end_escape

begin_function
name|void
name|demand_empty_rest_of_line
parameter_list|()
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* Return having already swallowed end-of-line. */
block|}
end_function

begin_comment
comment|/* Return pointing just after end-of-line. */
end_comment

begin_function
name|void
name|ignore_rest_of_line
parameter_list|()
comment|/* For suspect lines: gives warning. */
block|{
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"Rest of line ignored. First ignored character is `%c'."
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Rest of line ignored. First ignored character valued 0x%x."
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
while|while
condition|(
name|input_line_pointer
operator|<
name|buffer_limit
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Return pointing just after end-of-line. */
name|know
argument_list|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
operator|-
literal|1
index|]
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			pseudo_set()  *  * In:	Pointer to a symbol.  *	Input_line_pointer->expression.  *  * Out:	Input_line_pointer->just after any whitespace after expression.  *	Tried to set symbol to value of expression.  *	Will change symbols type, value, and frag;  */
end_comment

begin_function
name|void
name|pseudo_set
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
name|int
name|ext
decl_stmt|;
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* NULL pointer is logic error. */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
name|ext
operator|=
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
operator|(
name|void
operator|)
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
name|as_bad
argument_list|(
literal|"illegal expression; zero assumed"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
literal|"missing expression; zero assumed"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_big
condition|)
name|as_bad
argument_list|(
literal|"%s number invalid; zero assumed"
argument_list|,
name|exp
operator|.
name|X_add_number
operator|>
literal|0
condition|?
literal|"bignum"
else|:
literal|"floating point"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_subtract
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_op_symbol
argument_list|)
operator|)
operator|&&
name|SEG_NORMAL
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
operator|&&
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_frag
operator|==
name|exp
operator|.
name|X_op_symbol
operator|->
name|sy_frag
condition|)
block|{
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|exp
operator|.
name|X_op_symbol
argument_list|)
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
case|case
name|O_absent
case|:
case|case
name|O_big
case|:
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_constant
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
if|if
condition|(
name|ext
condition|)
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
else|else
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
case|case
name|O_register
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|reg_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|undefined_section
operator|||
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
name|symbolP
operator|->
name|sy_value
operator|=
name|exp
expr_stmt|;
else|else
block|{
name|symbolS
modifier|*
name|s
init|=
name|exp
operator|.
name|X_add_symbol
decl_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
if|if
condition|(
name|ext
condition|)
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
else|else
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|exp
operator|.
name|X_add_number
operator|+
name|S_GET_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|s
operator|->
name|sy_frag
expr_stmt|;
name|copy_symbol_attributes
argument_list|(
name|symbolP
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* The value is some complex expression. 	 FIXME: Should we set the segment to anything?  */
name|symbolP
operator|->
name|sy_value
operator|=
name|exp
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			cons()  *  * CONStruct more frag of .bytes, or .words etc.  * Should need_pass_2 be 1 then emit no frag(s).  * This understands EXPRESSIONS.  *  * Bug (?)  *  * This has a split personality. We use expression() to read the  * value. We can detect if the value won't fit in a byte or word.  * But we can't detect if expression() discarded significant digits  * in the case of a long. Not worth the crocks required to fix it.  */
end_comment

begin_comment
comment|/* Select a parser for cons expressions.  */
end_comment

begin_comment
comment|/* Some targets need to parse the expression in various fancy ways.    You can define TC_PARSE_CONS_EXPRESSION to do whatever you like    (for example, the HPPA does this).  Otherwise, you can define    BITFIELD_CONS_EXPRESSIONS to permit bitfields to be specified, or    REPEAT_CONS_EXPRESSIONS to permit repeat counts.  If none of these    are defined, which is the normal case, then only simple expressions    are permitted.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|parse_mri_cons
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|exp
operator|,
name|unsigned
name|int
name|nbytes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TC_PARSE_CONS_EXPRESSION
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|BITFIELD_CONS_EXPRESSIONS
end_ifdef

begin_define
define|#
directive|define
name|TC_PARSE_CONS_EXPRESSION
parameter_list|(
name|EXP
parameter_list|,
name|NBYTES
parameter_list|)
value|parse_bitfield_cons (EXP, NBYTES)
end_define

begin_decl_stmt
specifier|static
name|void
name|parse_bitfield_cons
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|exp
operator|,
name|unsigned
name|int
name|nbytes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|REPEAT_CONS_EXPRESSIONS
end_ifdef

begin_define
define|#
directive|define
name|TC_PARSE_CONS_EXPRESSION
parameter_list|(
name|EXP
parameter_list|,
name|NBYTES
parameter_list|)
value|parse_repeat_cons (EXP, NBYTES)
end_define

begin_decl_stmt
specifier|static
name|void
name|parse_repeat_cons
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|exp
operator|,
name|unsigned
name|int
name|nbytes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we haven't gotten one yet, just call expression.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TC_PARSE_CONS_EXPRESSION
end_ifndef

begin_define
define|#
directive|define
name|TC_PARSE_CONS_EXPRESSION
parameter_list|(
name|EXP
parameter_list|,
name|NBYTES
parameter_list|)
value|expression (EXP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* worker to do .byte etc statements */
end_comment

begin_comment
comment|/* clobbers input_line_pointer, checks */
end_comment

begin_comment
comment|/* end-of-line. */
end_comment

begin_function
specifier|static
name|void
name|cons_worker
parameter_list|(
name|nbytes
parameter_list|,
name|rva
parameter_list|)
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* 1=.byte, 2=.word, 4=.long */
name|int
name|rva
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|flag_m68k_mri
condition|)
name|parse_mri_cons
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
else|else
name|TC_PARSE_CONS_EXPRESSION
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rva
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
name|exp
operator|.
name|X_op
operator|=
name|O_symbol_rva
expr_stmt|;
else|else
name|as_fatal
argument_list|(
literal|"rva without symbol"
argument_list|)
expr_stmt|;
block|}
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* In MRI mode, after an odd number of bytes, we must align to an      even word boundary, unless the next instruction is a dc.b, ds.b      or dcb.b.  */
if|if
condition|(
name|flag_mri
operator|&&
name|nbytes
operator|==
literal|1
operator|&&
operator|(
name|c
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|mri_pending_align
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream. */
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cons
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|cons_worker
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_rva
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|cons_worker
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put the contents of expression EXP into the object file using    NBYTES bytes.  If need_pass_2 is 1, this does nothing.  */
end_comment

begin_function
name|void
name|emit_expr
parameter_list|(
name|exp
parameter_list|,
name|nbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
name|operatorT
name|op
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|valueT
name|extra_digit
init|=
literal|0
decl_stmt|;
comment|/* Don't do anything if we are going to make another pass.  */
if|if
condition|(
name|need_pass_2
condition|)
return|return;
name|op
operator|=
name|exp
operator|->
name|X_op
expr_stmt|;
comment|/* Allow `.word 0' in the absolute section.  */
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
if|if
condition|(
name|op
operator|!=
name|O_constant
operator|||
name|exp
operator|->
name|X_add_number
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
literal|"attempt to store value in absolute section"
argument_list|)
expr_stmt|;
name|abs_section_offset
operator|+=
name|nbytes
expr_stmt|;
return|return;
block|}
comment|/* Handle a negative bignum.  */
if|if
condition|(
name|op
operator|==
name|O_uminus
operator|&&
name|exp
operator|->
name|X_add_number
operator|==
literal|0
operator|&&
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_big
operator|&&
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_value
operator|.
name|X_add_number
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|carry
decl_stmt|;
name|exp
operator|=
operator|&
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_value
expr_stmt|;
comment|/* Negate the bignum: one's complement each digit and add 1.  */
name|carry
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exp
operator|->
name|X_add_number
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|next
decl_stmt|;
name|next
operator|=
operator|(
operator|(
operator|(
operator|~
operator|(
name|generic_bignum
index|[
name|i
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|)
operator|&
name|LITTLENUM_MASK
operator|)
operator|+
name|carry
operator|)
expr_stmt|;
name|generic_bignum
index|[
name|i
index|]
operator|=
name|next
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|carry
operator|=
name|next
operator|>>
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
comment|/* We can ignore any carry out, because it will be handled by 	 extra_digit if it is needed.  */
name|extra_digit
operator|=
operator|(
name|valueT
operator|)
operator|-
literal|1
expr_stmt|;
name|op
operator|=
name|O_big
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|O_absent
operator|||
name|op
operator|==
name|O_illegal
condition|)
block|{
name|as_warn
argument_list|(
literal|"zero assumed for missing expression"
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_constant
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_big
operator|&&
name|exp
operator|->
name|X_add_number
operator|<=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"floating point number invalid; zero assumed"
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_constant
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_register
condition|)
block|{
name|as_warn
argument_list|(
literal|"register value used as expression"
argument_list|)
expr_stmt|;
name|op
operator|=
name|O_constant
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* If we have the difference of two symbols in a word, save it on      the broken_words list.  See the code in write.c.  */
if|if
condition|(
name|op
operator|==
name|O_subtract
operator|&&
name|nbytes
operator|==
literal|2
condition|)
block|{
name|struct
name|broken_word
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|broken_word
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|next_broken_word
operator|=
name|broken_words
expr_stmt|;
name|broken_words
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|x
operator|->
name|word_goes_here
operator|=
name|p
expr_stmt|;
name|x
operator|->
name|dispfrag
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|add
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
name|x
operator|->
name|sub
operator|=
name|exp
operator|->
name|X_op_symbol
expr_stmt|;
name|x
operator|->
name|addnum
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|x
operator|->
name|added
operator|=
literal|0
expr_stmt|;
name|new_broken_words
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If we have an integer, but the number of bytes is too large to      pass to md_number_to_chars, handle it as a bignum.  */
if|if
condition|(
name|op
operator|==
name|O_constant
operator|&&
name|nbytes
operator|>
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
block|{
name|valueT
name|val
decl_stmt|;
name|int
name|gencnt
decl_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|X_unsigned
operator|&&
name|exp
operator|->
name|X_add_number
operator|<
literal|0
condition|)
name|extra_digit
operator|=
operator|(
name|valueT
operator|)
operator|-
literal|1
expr_stmt|;
name|val
operator|=
operator|(
name|valueT
operator|)
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|gencnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|generic_bignum
index|[
name|gencnt
index|]
operator|=
name|val
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|val
operator|>>=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
operator|++
name|gencnt
expr_stmt|;
block|}
do|while
condition|(
name|val
operator|!=
literal|0
condition|)
do|;
name|op
operator|=
name|exp
operator|->
name|X_op
operator|=
name|O_big
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
name|gencnt
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|O_constant
condition|)
block|{
specifier|register
name|valueT
name|get
decl_stmt|;
specifier|register
name|valueT
name|use
decl_stmt|;
specifier|register
name|valueT
name|mask
decl_stmt|;
name|valueT
name|hibit
decl_stmt|;
specifier|register
name|valueT
name|unmask
decl_stmt|;
comment|/* JF<< of>= number of bits in the object is undefined.  In 	 particular SPARC (Sun 4) has problems */
if|if
condition|(
name|nbytes
operator|>=
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
block|{
name|mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
name|hibit
operator|=
literal|0
expr_stmt|;
else|else
name|hibit
operator|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
operator|(
name|nbytes
operator|*
name|BITS_PER_CHAR
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't store these bits. */
name|mask
operator|=
operator|~
operator|(
name|valueT
operator|)
literal|0
operator|<<
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
expr_stmt|;
name|hibit
operator|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
operator|(
name|nbytes
operator|*
name|BITS_PER_CHAR
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|unmask
operator|=
operator|~
name|mask
expr_stmt|;
comment|/* Do store these bits. */
ifdef|#
directive|ifdef
name|NEVER
literal|"Do this mod if you want every overflow check to assume SIGNED 2's complement data."
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|unmask
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* Includes sign bit now. */
endif|#
directive|endif
name|get
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|use
operator|=
name|get
operator|&
name|unmask
expr_stmt|;
if|if
condition|(
operator|(
name|get
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|get
operator|&
name|mask
operator|)
operator|!=
name|mask
operator|||
operator|(
name|get
operator|&
name|hibit
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Leading bits contain both 0s& 1s. */
name|as_warn
argument_list|(
literal|"Value 0x%lx truncated to 0x%lx."
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|get
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|use
argument_list|)
expr_stmt|;
block|}
comment|/* put bytes in right order. */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|use
argument_list|,
operator|(
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_big
condition|)
block|{
name|int
name|size
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|nums
decl_stmt|;
name|know
argument_list|(
name|nbytes
operator|%
name|CHARS_PER_LITTLENUM
operator|==
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|exp
operator|->
name|X_add_number
operator|*
name|CHARS_PER_LITTLENUM
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
name|size
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bignum truncated to %d bytes"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|size
operator|=
name|nbytes
expr_stmt|;
block|}
if|if
condition|(
name|target_big_endian
condition|)
block|{
while|while
condition|(
name|nbytes
operator|>
name|size
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|extra_digit
argument_list|,
name|CHARS_PER_LITTLENUM
argument_list|)
expr_stmt|;
name|nbytes
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|p
operator|+=
name|CHARS_PER_LITTLENUM
expr_stmt|;
block|}
name|nums
operator|=
name|generic_bignum
operator|+
name|size
operator|/
name|CHARS_PER_LITTLENUM
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
operator|--
name|nums
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
operator|*
name|nums
argument_list|,
name|CHARS_PER_LITTLENUM
argument_list|)
expr_stmt|;
name|size
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|p
operator|+=
name|CHARS_PER_LITTLENUM
expr_stmt|;
block|}
block|}
else|else
block|{
name|nums
operator|=
name|generic_bignum
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
operator|*
name|nums
argument_list|,
name|CHARS_PER_LITTLENUM
argument_list|)
expr_stmt|;
operator|++
name|nums
expr_stmt|;
name|size
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|p
operator|+=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|nbytes
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
block|}
while|while
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|extra_digit
argument_list|,
name|CHARS_PER_LITTLENUM
argument_list|)
expr_stmt|;
name|nbytes
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|p
operator|+=
name|CHARS_PER_LITTLENUM
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* Now we need to generate a fixS to record the symbol value. 	 This is easy for BFD.  For other targets it can be more 	 complex.  For very complex cases (currently, the HPPA and 	 NS32K), you can define TC_CONS_FIX_NEW to do whatever you 	 want.  For simpler cases, you can define TC_CONS_RELOC to be 	 the name of the reloc code that should be stored in the fixS. 	 If neither is defined, the code uses NO_RELOC if it is 	 defined, and otherwise uses 0.  */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
ifdef|#
directive|ifdef
name|TC_CONS_FIX_NEW
name|TC_CONS_FIX_NEW
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|r
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|r
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|r
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|r
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"unsupported BFD relocation size %u"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|r
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
operator|(
name|int
operator|)
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|TC_CONS_FIX_NEW
name|TC_CONS_FIX_NEW
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Figure out which reloc number to use.  Use TC_CONS_RELOC if 	 it is defined, otherwise use NO_RELOC if it is defined, 	 otherwise use 0.  */
ifndef|#
directive|ifndef
name|TC_CONS_RELOC
ifdef|#
directive|ifdef
name|NO_RELOC
define|#
directive|define
name|TC_CONS_RELOC
value|NO_RELOC
else|#
directive|else
define|#
directive|define
name|TC_CONS_RELOC
value|0
endif|#
directive|endif
endif|#
directive|endif
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
operator|(
name|int
operator|)
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|TC_CONS_RELOC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_CONS_FIX_NEW */
endif|#
directive|endif
comment|/* BFD_ASSEMBLER */
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BITFIELD_CONS_EXPRESSIONS
end_ifdef

begin_comment
comment|/* i960 assemblers, (eg, asm960), allow bitfields after ".byte" as    w:x,y:z, where w and y are bitwidths and x and y are values.  They    then pack them all together. We do a little better in that we allow    them in words, longs, etc. and we'll pack them in target byte order    for you.     The rules are: pack least significat bit first, if a field doesn't    entirely fit, put it in the next unit.  Overflowing the bitfield is    explicitly *not* even a warning.  The bitwidth should be considered    a "mask".     To use this function the tc-XXX.h file should define    BITFIELD_CONS_EXPRESSIONS.  */
end_comment

begin_function
specifier|static
name|void
name|parse_bitfield_cons
parameter_list|(
name|exp
parameter_list|,
name|nbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
name|unsigned
name|int
name|bits_available
init|=
name|BITS_PER_CHAR
operator|*
name|nbytes
decl_stmt|;
name|char
modifier|*
name|hold
init|=
name|input_line_pointer
decl_stmt|;
operator|(
name|void
operator|)
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|':'
condition|)
block|{
comment|/* bitfields */
name|long
name|value
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|long
name|width
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|':'
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
break|break;
block|}
comment|/* next piece is not a bitfield */
comment|/* In the general case, we can't allow 	     full expressions with symbol 	     differences and such.  The relocation 	     entries for symbols not defined in this 	     assembly would require arbitrary field 	     widths, positions, and masks which most 	     of our current object formats don't 	     support.  	     In the specific case where a symbol 	     *is* defined in this assembly, we 	     *could* build fixups and track it, but 	     this could lead to confusion for the 	     backends.  I'm lazy. I'll take any 	     SEG_ABSOLUTE. I think that means that 	     you can use a previous .set or 	     .equ type symbol.  xoxorich. */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_warn
argument_list|(
literal|"using a bit field width of zero"
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
comment|/* implied zero width bitfield */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
literal|"field width \"%s\" too complex for a bitfield"
argument_list|,
name|hold
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|':'
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* too complex */
if|if
condition|(
operator|(
name|width
operator|=
name|exp
operator|->
name|X_add_number
operator|)
operator|>
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"field width %lu too big to fit in %d bytes: truncated to %d bits"
argument_list|,
name|width
argument_list|,
name|nbytes
argument_list|,
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
argument_list|)
expr_stmt|;
name|width
operator|=
name|BITS_PER_CHAR
operator|*
name|nbytes
expr_stmt|;
block|}
comment|/* too big */
if|if
condition|(
name|width
operator|>
name|bits_available
condition|)
block|{
comment|/* FIXME-SOMEDAY: backing up and reparsing is wasteful.  */
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
name|value
expr_stmt|;
break|break;
block|}
comment|/* won't fit */
name|hold
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* skip ':' */
operator|(
name|void
operator|)
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|char
name|cache
init|=
operator|*
name|input_line_pointer
decl_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
literal|"field value \"%s\" too complex for a bitfield"
argument_list|,
name|hold
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|cache
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* too complex */
name|value
operator||=
operator|(
operator|(
operator|~
operator|(
operator|-
literal|1
operator|<<
name|width
operator|)
operator|&
name|exp
operator|->
name|X_add_number
operator|)
operator|<<
operator|(
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
operator|-
name|bits_available
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bits_available
operator|-=
name|width
operator|)
operator|==
literal|0
operator|||
name|is_it_end_of_statement
argument_list|()
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
break|break;
block|}
comment|/* all the bitfields we're gonna get */
name|hold
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
operator|(
name|void
operator|)
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* forever loop */
name|exp
operator|->
name|X_add_number
operator|=
name|value
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_unsigned
operator|=
literal|1
expr_stmt|;
block|}
comment|/* if looks like a bitfield */
block|}
end_function

begin_comment
comment|/* parse_bitfield_cons() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BITFIELD_CONS_EXPRESSIONS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Handle an MRI style string expression.  */
end_comment

begin_function
specifier|static
name|void
name|parse_mri_cons
parameter_list|(
name|exp
parameter_list|,
name|nbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\''
operator|&&
operator|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'\''
operator|||
operator|(
operator|*
name|input_line_pointer
operator|!=
literal|'A'
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'E'
operator|)
operator|)
condition|)
name|TC_PARSE_CONS_EXPRESSION
argument_list|(
name|exp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|scan
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* An MRI style string.  Cut into as many bytes as will fit into 	 a nbyte chunk, left justify if necessary, and separate with 	 commas so we can try again later.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'A'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'E'
condition|)
block|{
name|as_bad
argument_list|(
literal|"EBCDIC constants are not supported"
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
for|for
control|(
name|scan
operator|=
literal|0
init|;
name|scan
operator|<
name|nbytes
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'\''
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
name|result
operator|=
operator|(
name|result
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|input_line_pointer
operator|++
operator|)
expr_stmt|;
block|}
comment|/* Left justify */
while|while
condition|(
name|scan
operator|<
name|nbytes
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
comment|/* Create correct expression */
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
name|result
expr_stmt|;
comment|/* Fake it so that we can read the next char too */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
literal|'\''
operator|||
operator|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'\''
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
name|input_line_pointer
operator|-=
literal|2
expr_stmt|;
name|input_line_pointer
index|[
literal|0
index|]
operator|=
literal|','
expr_stmt|;
name|input_line_pointer
index|[
literal|1
index|]
operator|=
literal|'\''
expr_stmt|;
block|}
else|else
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REPEAT_CONS_EXPRESSIONS
end_ifdef

begin_comment
comment|/* Parse a repeat expression for cons.  This is used by the MIPS    assembler.  The format is NUMBER:COUNT; NUMBER appears in the    object file COUNT times.     To use this for a target, define REPEAT_CONS_EXPRESSIONS.  */
end_comment

begin_function
specifier|static
name|void
name|parse_repeat_cons
parameter_list|(
name|exp
parameter_list|,
name|nbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
name|expressionS
name|count
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|':'
condition|)
block|{
comment|/* No repeat count.  */
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|count
operator|.
name|X_add_number
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Unresolvable or nonpositive repeat count; using 1"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The cons function is going to output this expression once.  So we      output it count - 1 times.  */
for|for
control|(
name|i
operator|=
name|count
operator|.
name|X_add_number
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|emit_expr
argument_list|(
name|exp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REPEAT_CONS_EXPRESSIONS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Parse a floating point number represented as a hex constant.  This    permits users to specify the exact bits they want in the floating    point number.  */
end_comment

begin_function
specifier|static
name|int
name|hex_float
parameter_list|(
name|float_type
parameter_list|,
name|bytes
parameter_list|)
name|int
name|float_type
decl_stmt|;
name|char
modifier|*
name|bytes
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|float_type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|length
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|length
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|length
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|length
operator|=
literal|12
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Unknown floating type type '%c'"
argument_list|,
name|float_type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* It would be nice if we could go through expression to parse the      hex constant, but if we get a bignum it's a pain to sort it into      the buffer correctly.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|hex_p
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'_'
condition|)
block|{
name|int
name|d
decl_stmt|;
comment|/* The MRI assembler accepts arbitrary underscores strewn about 	 through the hex constant, so we ignore them as well. */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'_'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|>=
name|length
condition|)
block|{
name|as_warn
argument_list|(
literal|"Floating point constant too large"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|d
operator|=
name|hex_value
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|<<
literal|4
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'_'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|hex_p
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|d
operator|+=
name|hex_value
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|target_big_endian
condition|)
name|bytes
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
else|else
name|bytes
index|[
name|length
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|d
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|length
condition|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|memset
argument_list|(
name|bytes
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|length
operator|-
name|i
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/*  *			float_cons()  *  * CONStruct some more frag chars of .floats .ffloats etc.  * Makes 0 or more new frags.  * If need_pass_2 == 1, no frags are emitted.  * This understands only floating literals, not expressions. Sorry.  *  * A floating constant is defined by atof_generic(), except it is preceded  * by 0d 0f 0g or 0h. After observing the STRANGE way my BSD AS does its  * reading, I decided to be incompatible. This always tries to give you  * rounded bits to the precision of the pseudo-op. Former AS did premature  * truncatation, restored noisy bits instead of trailing 0s AND gave you  * a choice of 2 flavours of noise according to which of 2 floating-point  * scanners you directed AS to use.  *  * In:	input_line_pointer->whitespace before, or '0' of flonum.  *  */
end_comment

begin_function
name|void
name|float_cons
parameter_list|(
name|float_type
parameter_list|)
comment|/* Clobbers input_line-pointer, checks end-of-line. */
specifier|register
name|int
name|float_type
decl_stmt|;
comment|/* 'f':.ffloat ... 'F':.float ... */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Number of chars in an object. */
specifier|register
name|char
modifier|*
name|err
decl_stmt|;
comment|/* Error from scanning floating literal. */
name|char
name|temp
index|[
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
index|]
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
do|do
block|{
comment|/* input_line_pointer->1st char of a flonum (we hope!). */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Skip any 0{letter} that may be present. Don't even check if the        * letter is legal. Someone may invent a "z" format and this routine        * has no use for such information. Lusers beware: you get        * diagnostics if your input is ill-conditioned.        */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|isalpha
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
comment|/* Accept :xxxx, where the x's are hex digits, for a floating          point with the exact digits specified.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|length
operator|=
name|hex_float
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|err
operator|=
name|md_atof
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|length
operator|<=
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|as_bad
argument_list|(
literal|"Bad floating literal: %s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|REPEAT_CONS_EXPRESSIONS
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|':'
condition|)
block|{
name|expressionS
name|count_exp
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|count_exp
operator|.
name|X_add_number
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"unresolvable or nonpositive repeat count; using 1"
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|=
name|count_exp
operator|.
name|X_add_number
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|temp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
block|}
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
operator|--
name|input_line_pointer
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* float_cons() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			stringer()  *  * We read 0 or more ',' seperated, double-quoted strings.  *  * Caller should have checked need_pass_2 is FALSE because we don't check it.  */
end_comment

begin_function
name|void
name|stringer
parameter_list|(
name|append_zero
parameter_list|)
comment|/* Worker to do .ascii etc statements. */
comment|/* Checks end-of-line. */
specifier|register
name|int
name|append_zero
decl_stmt|;
comment|/* 0: don't append '\0', else 1 */
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*    * The following awkward logic is to parse ZERO or more strings,    * comma seperated. Recall a string expression includes spaces    * before the opening '\"' and spaces after the closing '\"'.    * We fake a leading ',' if there is (supposed to be)    * a 1st, expression. We keep demanding expressions for each    * ','.    */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop. */
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Compensate for end of loop. */
block|}
else|else
block|{
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop. */
block|}
while|while
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'\"'
case|:
operator|++
name|input_line_pointer
expr_stmt|;
comment|/*->1st char of string. */
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|append_zero
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|know
argument_list|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
name|c
operator|=
name|get_single_number
argument_list|()
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'>'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected<nn>"
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stringer() */
end_comment

begin_escape
end_escape

begin_comment
comment|/* FIXME-SOMEDAY: I had trouble here on characters with the     high bits set.  We'll probably also have trouble with     multibyte chars, wide chars, etc.  Also be careful about     returning values bigger than 1 byte.  xoxorich. */
end_comment

begin_function
name|unsigned
name|int
name|next_char_of_string
parameter_list|()
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|&
name|CHAR_MASK
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\"'
case|:
name|c
operator|=
name|NOT_A_CHAR
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|as_warn
argument_list|(
literal|"Unterminated string: Newline inserted."
argument_list|)
expr_stmt|;
name|bump_line_counters
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_STRING_ESCAPES
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
condition|)
block|{
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|c
operator|=
literal|'\013'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
break|break;
comment|/* As itself. */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|long
name|number
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|number
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
operator|&&
name|i
operator|<
literal|3
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|number
operator|=
name|number
operator|*
literal|8
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
name|c
operator|=
name|number
operator|&
literal|0xff
expr_stmt|;
block|}
operator|--
name|input_line_pointer
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
block|{
name|long
name|number
decl_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|number
operator|=
name|number
operator|*
literal|16
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|number
operator|=
name|number
operator|*
literal|16
operator|+
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
name|number
operator|=
name|number
operator|*
literal|16
operator|+
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|c
operator|=
name|number
operator|&
literal|0xff
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
comment|/* To be compatible with BSD 4.2 as: give the luser a linefeed!! */
name|as_warn
argument_list|(
literal|"Unterminated string: Newline inserted."
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
name|bump_line_counters
argument_list|()
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|ONLY_STANDARD_ESCAPES
name|as_bad
argument_list|(
literal|"Bad escaped character in string, '?' assumed"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
endif|#
directive|endif
comment|/* ONLY_STANDARD_ESCAPES */
break|break;
block|}
comment|/* switch on escaped char */
break|break;
endif|#
directive|endif
comment|/* ! defined (NO_STRING_ESCAPES) */
default|default:
break|break;
block|}
comment|/* switch on char */
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* next_char_of_string() */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|segT
name|get_segmented_expression
parameter_list|(
name|expP
parameter_list|)
specifier|register
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
specifier|register
name|segT
name|retval
decl_stmt|;
name|retval
operator|=
name|expression
argument_list|(
name|expP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expP
operator|->
name|X_op
operator|==
name|O_illegal
operator|||
name|expP
operator|->
name|X_op
operator|==
name|O_absent
operator|||
name|expP
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected address expression; zero assumed"
argument_list|)
expr_stmt|;
name|expP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|absolute_section
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|segT
name|get_known_segmented_expression
parameter_list|(
name|expP
parameter_list|)
specifier|register
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
specifier|register
name|segT
name|retval
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|get_segmented_expression
argument_list|(
name|expP
argument_list|)
operator|)
operator|==
name|undefined_section
condition|)
block|{
comment|/* There is no easy way to extract the undefined symbol from the 	 expression.  */
if|if
condition|(
name|expP
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|expP
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|expr_section
condition|)
name|as_warn
argument_list|(
literal|"symbol \"%s\" undefined; zero assumed"
argument_list|,
name|S_GET_NAME
argument_list|(
name|expP
operator|->
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
literal|"some symbol undefined; zero assumed"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|absolute_section
expr_stmt|;
name|expP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|know
argument_list|(
name|retval
operator|==
name|absolute_section
operator|||
name|SEG_NORMAL
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_known_segmented_expression() */
end_comment

begin_function
name|offsetT
name|get_absolute_expression
parameter_list|()
block|{
name|expressionS
name|exp
decl_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_absent
condition|)
name|as_bad
argument_list|(
literal|"bad or irreducible absolute expression; zero assumed"
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|exp
operator|.
name|X_add_number
return|;
block|}
end_function

begin_function
name|char
comment|/* return terminator */
name|get_absolute_expression_and_terminator
parameter_list|(
name|val_pointer
parameter_list|)
name|long
modifier|*
name|val_pointer
decl_stmt|;
comment|/* return value of expression */
block|{
comment|/* FIXME: val_pointer should probably be offsetT *.  */
operator|*
name|val_pointer
operator|=
operator|(
name|long
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
return|return
operator|(
operator|*
name|input_line_pointer
operator|++
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			demand_copy_C_string()  *  * Like demand_copy_string, but return NULL if the string contains any '\0's.  * Give a warning if that happens.  */
end_comment

begin_function
name|char
modifier|*
name|demand_copy_C_string
parameter_list|(
name|len_pointer
parameter_list|)
name|int
modifier|*
name|len_pointer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|demand_copy_string
argument_list|(
name|len_pointer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
operator|*
name|len_pointer
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
operator|*
name|len_pointer
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
literal|"This string may not contain \'\\0\'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|s
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			demand_copy_string()  *  * Demand string, but return a safe (=private) copy of the string.  * Return NULL if we can't read a string here.  */
end_comment

begin_function
name|char
modifier|*
name|demand_copy_string
parameter_list|(
name|lenP
parameter_list|)
name|int
modifier|*
name|lenP
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip opening quote. */
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
comment|/* JF this next line is so demand_copy_C_string will return a 	 null terminated string. */
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|retval
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Missing string"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
operator|*
name|lenP
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* demand_copy_string() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *		is_it_end_of_statement()  *  * In:	Input_line_pointer->next character.  *  * Do:	Skip input_line_pointer over all whitespace.  *  * Out:	1 if input_line_pointer->end-of-line. */
end_comment

begin_function
name|int
name|is_it_end_of_statement
parameter_list|()
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
return|return
operator|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* is_it_end_of_statement() */
end_comment

begin_function
name|void
name|equals
parameter_list|(
name|sym_name
parameter_list|,
name|reassign
parameter_list|)
name|char
modifier|*
name|sym_name
decl_stmt|;
name|int
name|reassign
decl_stmt|;
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* symbol we are working with */
name|char
modifier|*
name|stop
decl_stmt|;
name|char
name|stopc
decl_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'='
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|' '
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'\t'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|sym_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Turn '. = mumble' into a .org mumble */
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|do_org
argument_list|(
name|segment
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
comment|/* Permit register names to be redefined.  */
if|if
condition|(
operator|!
name|reassign
operator|&&
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|reg_section
condition|)
name|as_bad
argument_list|(
literal|"symbol `%s' already defined"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* equals() */
end_comment

begin_comment
comment|/* .include -- include a file at this point. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|s_include
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|newbuf
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|try
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
name|filename
operator|=
name|demand_copy_string
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|' '
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'\t'
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|filename
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|i
operator|+
name|include_dir_maxlen
operator|+
literal|5
comment|/* slop */
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|include_dir_count
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|include_dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|try
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|try
argument_list|)
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|filename
expr_stmt|;
name|gotit
label|:
comment|/* malloc Storage leak when file is found on path.  FIXME-SOMEDAY. */
name|newbuf
operator|=
name|input_scrub_include_file
argument_list|(
name|path
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_include() */
end_comment

begin_function
name|void
name|add_include_dir
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|include_dir_count
operator|==
literal|0
condition|)
block|{
name|include_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|include_dirs
argument_list|)
argument_list|)
expr_stmt|;
name|include_dirs
index|[
literal|0
index|]
operator|=
literal|"."
expr_stmt|;
comment|/* Current dir */
name|include_dir_count
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|include_dir_count
operator|++
expr_stmt|;
name|include_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|include_dirs
argument_list|,
name|include_dir_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|include_dirs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|include_dirs
index|[
name|include_dir_count
operator|-
literal|1
index|]
operator|=
name|path
expr_stmt|;
comment|/* New one */
name|i
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|include_dir_maxlen
condition|)
name|include_dir_maxlen
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add_include_dir() */
end_comment

begin_function
name|void
name|s_ignore
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_print_statistics
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"pseudo-op table"
argument_list|,
name|po_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of read.c */
end_comment

end_unit

