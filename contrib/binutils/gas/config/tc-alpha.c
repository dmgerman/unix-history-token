begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-alpha.c - Processor-specific code for the DEC Alpha AXP CPU.    Copyright (C) 1989, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Contributed by Carnegie Mellon University, 1993.    Written by Alessandro Forin, based on earlier gas-1.38 target CPU files.    Modified by Ken Raeburn for gas-2.x and ECOFF support.    Modified by Richard Henderson for ELF support.    Modified by Klaus K"ampf for EVAX (openVMS/Alpha) support.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1993 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/alpha.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/alpha.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Local types */
end_comment

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|2
end_define

begin_define
define|#
directive|define
name|MAX_INSN_ARGS
value|5
end_define

begin_struct
struct|struct
name|alpha_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|alpha_insn
block|{
name|unsigned
name|insn
decl_stmt|;
name|int
name|nfixups
decl_stmt|;
name|struct
name|alpha_fixup
name|fixups
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|alpha_macro_arg
block|{
name|MACRO_EOA
init|=
literal|1
block|,
name|MACRO_IR
block|,
name|MACRO_PIR
block|,
name|MACRO_CPIR
block|,
name|MACRO_FPR
block|,
name|MACRO_EXP
block|}
enum|;
end_enum

begin_struct
struct|struct
name|alpha_macro
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|void
argument_list|(
argument|*emit
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
expr_stmt|;
specifier|const
name|PTR
name|arg
decl_stmt|;
name|enum
name|alpha_macro_arg
name|argsets
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Two extra symbols we want to see in our input.  This is a blatent    misuse of the expressionS.X_op field.  */
end_comment

begin_define
define|#
directive|define
name|O_pregister
value|(O_max+1)
end_define

begin_comment
comment|/* O_register, but in parentheses */
end_comment

begin_define
define|#
directive|define
name|O_cpregister
value|(O_pregister+1)
end_define

begin_comment
comment|/* + a leading comma */
end_comment

begin_comment
comment|/* Macros for extracting the type and number of encoded register tokens */
end_comment

begin_define
define|#
directive|define
name|is_ir_num
parameter_list|(
name|x
parameter_list|)
value|(((x)& 32) == 0)
end_define

begin_define
define|#
directive|define
name|is_fpr_num
parameter_list|(
name|x
parameter_list|)
value|(((x)& 32) != 0)
end_define

begin_define
define|#
directive|define
name|regno
parameter_list|(
name|x
parameter_list|)
value|((x)& 31)
end_define

begin_comment
comment|/* Something odd inherited from the old assembler */
end_comment

begin_define
define|#
directive|define
name|note_gpreg
parameter_list|(
name|R
parameter_list|)
value|(alpha_gprmask |= (1<< (R)))
end_define

begin_define
define|#
directive|define
name|note_fpreg
parameter_list|(
name|R
parameter_list|)
value|(alpha_fprmask |= (1<< (R)))
end_define

begin_comment
comment|/* Predicates for 16- and 32-bit ranges */
end_comment

begin_define
define|#
directive|define
name|range_signed_16
parameter_list|(
name|x
parameter_list|)
value|((offsetT)(x)>= -(offsetT)0x8000&&	\ 				 (offsetT)(x)<=  (offsetT)0x7FFF)
end_define

begin_define
define|#
directive|define
name|range_signed_32
parameter_list|(
name|x
parameter_list|)
value|((offsetT)(x)>= -(offsetT)0x80000000&& \ 				 (offsetT)(x)<=  (offsetT)0x7FFFFFFF)
end_define

begin_comment
comment|/* Macros for sign extending from 16- and 32-bits.  */
end_comment

begin_comment
comment|/* XXX: The cast macros will work on all the systems that I care about,    but really a predicate should be found to use the non-cast forms.  */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|sign_extend_16
parameter_list|(
name|x
parameter_list|)
value|((short)(x))
end_define

begin_define
define|#
directive|define
name|sign_extend_32
parameter_list|(
name|x
parameter_list|)
value|((int)(x))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sign_extend_16
parameter_list|(
name|x
parameter_list|)
value|((offsetT)(((x)& 0xFFFF) ^ 0x8000) - 0x8000)
end_define

begin_define
define|#
directive|define
name|sign_extend_32
parameter_list|(
name|x
parameter_list|)
value|((offsetT)(((x)& 0xFFFFFFFF) \ 					   ^ 0x80000000) - 0x80000000)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros to build tokens */
end_comment

begin_define
define|#
directive|define
name|set_tok_reg
parameter_list|(
name|t
parameter_list|,
name|r
parameter_list|)
value|(memset(&(t), 0, sizeof(t)),		\ 				 (t).X_op = O_register,			\ 				 (t).X_add_number = (r))
end_define

begin_define
define|#
directive|define
name|set_tok_preg
parameter_list|(
name|t
parameter_list|,
name|r
parameter_list|)
value|(memset(&(t), 0, sizeof(t)),		\ 				 (t).X_op = O_pregister,		\ 				 (t).X_add_number = (r))
end_define

begin_define
define|#
directive|define
name|set_tok_cpreg
parameter_list|(
name|t
parameter_list|,
name|r
parameter_list|)
value|(memset(&(t), 0, sizeof(t)),		\ 				 (t).X_op = O_cpregister,		\ 				 (t).X_add_number = (r))
end_define

begin_define
define|#
directive|define
name|set_tok_freg
parameter_list|(
name|t
parameter_list|,
name|r
parameter_list|)
value|(memset(&(t), 0, sizeof(t)),		\ 				 (t).X_op = O_register,			\ 				 (t).X_add_number = (r)+32)
end_define

begin_define
define|#
directive|define
name|set_tok_sym
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|a
parameter_list|)
value|(memset(&(t), 0, sizeof(t)),		\ 				 (t).X_op = O_symbol,			\ 				 (t).X_add_symbol = (s),		\ 				 (t).X_add_number = (a))
end_define

begin_define
define|#
directive|define
name|set_tok_const
parameter_list|(
name|t
parameter_list|,
name|n
parameter_list|)
value|(memset(&(t), 0, sizeof(t)),		\ 				 (t).X_op = O_constant,			\ 				 (t).X_add_number = (n))
end_define

begin_escape
end_escape

begin_comment
comment|/* Prototypes for all local functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tokenize_arguments
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|expressionS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|alpha_opcode
modifier|*
name|find_opcode_match
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|alpha_opcode
operator|*
operator|,
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|alpha_macro
modifier|*
name|find_macro_match
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|alpha_macro
operator|*
operator|,
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|insert_operand
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
specifier|const
expr|struct
name|alpha_operand
operator|*
operator|,
name|offsetT
operator|,
name|char
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assemble_insn
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|alpha_opcode
operator|*
operator|,
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
expr|struct
name|alpha_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assemble_tokens_to_insn
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
expr|struct
name|alpha_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assemble_tokens
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|load_expression
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_ldgp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_division
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_lda
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_ldah
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_ir_load
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_loadstore
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_jsrjmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_ldX
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_ldXu
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_uldX
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_uldXu
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_ldil
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_stX
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_ustX
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_sextX
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_retjcr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|int
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_alpha_text
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_alpha_data
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_ELF
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|s_alpha_comm
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ECOFF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_EVAX
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|s_alpha_rdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|s_alpha_sdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|s_alpha_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_EVAX
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|s_alpha_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|s_alpha_gprel32
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_alpha_float_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_alpha_proc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_alpha_set
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_alpha_base
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_alpha_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_alpha_stringer
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_alpha_space
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_literal_section
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|segT
operator|*
operator|,
name|symbolS
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_ELF
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|select_gp_value
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|alpha_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Generic assembler global variables which must be defined by all    targets.  */
end_comment

begin_comment
comment|/* These are exported to relaxing code, even though we don't do any    relaxing on this processor currently.  */
end_comment

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a    single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0d1.0.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|const char FLT_CHARS[] = "dD";
else|#
directive|else
end_else

begin_comment
comment|/* XXX: Do all of these really get used on the alpha??  */
end_comment

begin_decl_stmt
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_EVAX
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"Fm:g+1h:H"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"Fm:g"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_32ADDR
value|(OPTION_MD_BASE)
block|{
literal|"32addr"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_32ADDR
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_EVAX
end_ifdef

begin_define
define|#
directive|define
name|AXP_REG_R0
value|0
end_define

begin_define
define|#
directive|define
name|AXP_REG_R16
value|16
end_define

begin_define
define|#
directive|define
name|AXP_REG_R17
value|17
end_define

begin_undef
undef|#
directive|undef
name|AXP_REG_T9
end_undef

begin_define
define|#
directive|define
name|AXP_REG_T9
value|22
end_define

begin_undef
undef|#
directive|undef
name|AXP_REG_T10
end_undef

begin_define
define|#
directive|define
name|AXP_REG_T10
value|23
end_define

begin_undef
undef|#
directive|undef
name|AXP_REG_T11
end_undef

begin_define
define|#
directive|define
name|AXP_REG_T11
value|24
end_define

begin_undef
undef|#
directive|undef
name|AXP_REG_T12
end_undef

begin_define
define|#
directive|define
name|AXP_REG_T12
value|25
end_define

begin_define
define|#
directive|define
name|AXP_REG_AI
value|25
end_define

begin_undef
undef|#
directive|undef
name|AXP_REG_FP
end_undef

begin_define
define|#
directive|define
name|AXP_REG_FP
value|29
end_define

begin_undef
undef|#
directive|undef
name|AXP_REG_GP
end_undef

begin_define
define|#
directive|define
name|AXP_REG_GP
value|AXP_REG_PV
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_EVAX  */
end_comment

begin_comment
comment|/* The cpu for which we are generating code */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|alpha_target
init|=
name|AXP_OPCODE_BASE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|alpha_target_name
init|=
literal|"<all>"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The hash table of instruction opcodes */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|alpha_opcode_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The hash table of macro opcodes */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|alpha_macro_hash
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_comment
comment|/* The $gp relocation symbol */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|alpha_gp_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX: what is this, and why is it exported? */
end_comment

begin_decl_stmt
name|valueT
name|alpha_gp_value
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The current $gp register */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_gp_register
init|=
name|AXP_REG_GP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A table of the register symbols */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|alpha_register_table
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constant sections, or sections of constants */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_decl_stmt
specifier|static
name|segT
name|alpha_lita_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|alpha_lit4_section
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_EVAX
end_ifdef

begin_decl_stmt
specifier|static
name|segT
name|alpha_link_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|alpha_ctors_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|alpha_dtors_section
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|segT
name|alpha_lit8_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbols referring to said sections. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|alpha_lita_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|alpha_lit4_symbol
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_EVAX
end_ifdef

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|alpha_link_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|alpha_ctors_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|alpha_dtors_symbol
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|alpha_lit8_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Literal for .litX+0x8000 within .lita */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_decl_stmt
specifier|static
name|offsetT
name|alpha_lit4_literal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|offsetT
name|alpha_lit8_literal
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Is the assembler not allowed to use $at? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_noat_on
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are macros enabled? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_macros_on
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are floats disabled? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_nofloats_on
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are addresses 32 bit? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_addr32_on
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbol labelling the current insn.  When the Alpha gas sees      foo:        .quad 0    and the section happens to not be on an eight byte boundary, it    will align both the symbol and the .quad to an eight byte boundary.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|alpha_insn_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we should automatically align data generation pseudo-ops.    .align 0 will turn this off.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_auto_align_on
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The known current alignment of the current section.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_current_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are exported to ECOFF code.  */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|alpha_gprmask
decl_stmt|,
name|alpha_fprmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the debugging option was seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_debug
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_EVAX
end_ifdef

begin_comment
comment|/* Collect information about current procedure here.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|symbolS
modifier|*
name|symbol
decl_stmt|;
comment|/* proc pdesc symbol */
name|int
name|pdsckind
decl_stmt|;
name|int
name|framereg
decl_stmt|;
comment|/* register for frame pointer */
name|int
name|framesize
decl_stmt|;
comment|/* size of frame */
name|int
name|rsa_offset
decl_stmt|;
name|int
name|ra_save
decl_stmt|;
name|int
name|fp_save
decl_stmt|;
name|long
name|imask
decl_stmt|;
name|long
name|fmask
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|prologue
decl_stmt|;
block|}
name|alpha_evax_proc
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|alpha_flag_hash_long_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -+ */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_flag_show_after_trunc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -H */
end_comment

begin_comment
comment|/* If the -+ switch is given, then a hash is appended to any name that is  * longer than 64 characters, else longer symbol names are truncated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_basereg_clobbered
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The macro table */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|alpha_macro
name|alpha_macros
index|[]
init|=
block|{
comment|/* Load/Store macros */
block|{
literal|"lda"
block|,
name|emit_lda
block|,
name|NULL
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldah"
block|,
name|emit_ldah
block|,
name|NULL
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldl"
block|,
name|emit_ir_load
block|,
literal|"ldl"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldl_l"
block|,
name|emit_ir_load
block|,
literal|"ldl_l"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldq"
block|,
name|emit_ir_load
block|,
literal|"ldq"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldq_l"
block|,
name|emit_ir_load
block|,
literal|"ldq_l"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldq_u"
block|,
name|emit_ir_load
block|,
literal|"ldq_u"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldf"
block|,
name|emit_loadstore
block|,
literal|"ldf"
block|,
block|{
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldg"
block|,
name|emit_loadstore
block|,
literal|"ldg"
block|,
block|{
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"lds"
block|,
name|emit_loadstore
block|,
literal|"lds"
block|,
block|{
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldt"
block|,
name|emit_loadstore
block|,
literal|"ldt"
block|,
block|{
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldb"
block|,
name|emit_ldX
block|,
operator|(
name|PTR
operator|)
literal|0
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldbu"
block|,
name|emit_ldXu
block|,
operator|(
name|PTR
operator|)
literal|0
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldw"
block|,
name|emit_ldX
block|,
operator|(
name|PTR
operator|)
literal|1
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldwu"
block|,
name|emit_ldXu
block|,
operator|(
name|PTR
operator|)
literal|1
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"uldw"
block|,
name|emit_uldX
block|,
operator|(
name|PTR
operator|)
literal|1
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"uldwu"
block|,
name|emit_uldXu
block|,
operator|(
name|PTR
operator|)
literal|1
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"uldl"
block|,
name|emit_uldX
block|,
operator|(
name|PTR
operator|)
literal|2
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"uldlu"
block|,
name|emit_uldXu
block|,
operator|(
name|PTR
operator|)
literal|2
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"uldq"
block|,
name|emit_uldXu
block|,
operator|(
name|PTR
operator|)
literal|3
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldgp"
block|,
name|emit_ldgp
block|,
name|NULL
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldi"
block|,
name|emit_lda
block|,
name|NULL
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldil"
block|,
name|emit_ldil
block|,
name|NULL
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ldiq"
block|,
name|emit_lda
block|,
name|NULL
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
if|#
directive|if
literal|0
block|{ "ldif"	emit_ldiq, NULL,     { MACRO_FPR, MACRO_EXP, MACRO_EOA } },   { "ldid"	emit_ldiq, NULL,     { MACRO_FPR, MACRO_EXP, MACRO_EOA } },   { "ldig"	emit_ldiq, NULL,     { MACRO_FPR, MACRO_EXP, MACRO_EOA } },   { "ldis"	emit_ldiq, NULL,     { MACRO_FPR, MACRO_EXP, MACRO_EOA } },   { "ldit"	emit_ldiq, NULL,     { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
endif|#
directive|endif
block|{
literal|"stl"
block|,
name|emit_loadstore
block|,
literal|"stl"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"stl_c"
block|,
name|emit_loadstore
block|,
literal|"stl_c"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"stq"
block|,
name|emit_loadstore
block|,
literal|"stq"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"stq_c"
block|,
name|emit_loadstore
block|,
literal|"stq_c"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"stq_u"
block|,
name|emit_loadstore
block|,
literal|"stq_u"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"stf"
block|,
name|emit_loadstore
block|,
literal|"stf"
block|,
block|{
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"stg"
block|,
name|emit_loadstore
block|,
literal|"stg"
block|,
block|{
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"sts"
block|,
name|emit_loadstore
block|,
literal|"sts"
block|,
block|{
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"stt"
block|,
name|emit_loadstore
block|,
literal|"stt"
block|,
block|{
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_FPR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"stb"
block|,
name|emit_stX
block|,
operator|(
name|PTR
operator|)
literal|0
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"stw"
block|,
name|emit_stX
block|,
operator|(
name|PTR
operator|)
literal|1
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ustw"
block|,
name|emit_ustX
block|,
operator|(
name|PTR
operator|)
literal|1
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ustl"
block|,
name|emit_ustX
block|,
operator|(
name|PTR
operator|)
literal|2
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ustq"
block|,
name|emit_ustX
block|,
operator|(
name|PTR
operator|)
literal|3
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
comment|/* Arithmetic macros */
if|#
directive|if
literal|0
block|{ "absl"	emit_absl, 1, { IR } },   { "absl"	emit_absl, 2, { IR, IR } },   { "absl"	emit_absl, 2, { EXP, IR } },   { "absq"	emit_absq, 1, { IR } },   { "absq"	emit_absq, 2, { IR, IR } },   { "absq"	emit_absq, 2, { EXP, IR } },
endif|#
directive|endif
block|{
literal|"sextb"
block|,
name|emit_sextX
block|,
operator|(
name|PTR
operator|)
literal|0
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_EXP, MACRO_IR, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"sextw"
block|,
name|emit_sextX
block|,
operator|(
name|PTR
operator|)
literal|1
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_EXP, MACRO_IR, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"divl"
block|,
name|emit_division
block|,
literal|"__divl"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,       MACRO_IR, MACRO_EXP, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"divlu"
block|,
name|emit_division
block|,
literal|"__divlu"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,       MACRO_IR, MACRO_EXP, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"divq"
block|,
name|emit_division
block|,
literal|"__divq"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,       MACRO_IR, MACRO_EXP, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"divqu"
block|,
name|emit_division
block|,
literal|"__divqu"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,       MACRO_IR, MACRO_EXP, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"reml"
block|,
name|emit_division
block|,
literal|"__reml"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,       MACRO_IR, MACRO_EXP, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"remlu"
block|,
name|emit_division
block|,
literal|"__remlu"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,       MACRO_IR, MACRO_EXP, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"remq"
block|,
name|emit_division
block|,
literal|"__remq"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,       MACRO_IR, MACRO_EXP, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"remqu"
block|,
name|emit_division
block|,
literal|"__remqu"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
comment|/* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,       MACRO_IR, MACRO_EXP, MACRO_EOA */
block|}
block|}
block|,
block|{
literal|"jsr"
block|,
name|emit_jsrjmp
block|,
literal|"jsr"
block|,
block|{
name|MACRO_PIR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"jmp"
block|,
name|emit_jsrjmp
block|,
literal|"jmp"
block|,
block|{
name|MACRO_PIR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"ret"
block|,
name|emit_retjcr
block|,
literal|"ret"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_PIR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"jcr"
block|,
name|emit_retjcr
block|,
literal|"jcr"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_PIR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_EOA
block|}
block|}
block|,
block|{
literal|"jsr_coroutine"
block|,
name|emit_retjcr
block|,
literal|"jcr"
block|,
block|{
name|MACRO_IR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_IR
block|,
name|MACRO_EOA
block|,
name|MACRO_PIR
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_PIR
block|,
name|MACRO_EOA
block|,
name|MACRO_EXP
block|,
name|MACRO_EOA
block|,
name|MACRO_EOA
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|alpha_num_macros
init|=
sizeof|sizeof
argument_list|(
name|alpha_macros
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|alpha_macros
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Public interface functions */
end_comment

begin_comment
comment|/* This function is called once, at assembler startup time.  It sets    up all the tables, etc. that the MD part of the assembler will    need, that can be determined before arguments are parsed.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Create the opcode hash table */
name|alpha_opcode_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha_num_opcodes
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
name|name
operator|=
name|alpha_opcodes
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|alpha_opcode_hash
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|alpha_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|as_fatal
argument_list|(
literal|"internal error: can't hash opcode `%s': %s"
argument_list|,
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|alpha_num_opcodes
operator|&&
operator|(
name|alpha_opcodes
index|[
name|i
index|]
operator|.
name|name
operator|==
name|name
operator|||
operator|!
name|strcmp
argument_list|(
name|alpha_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|)
condition|)
continue|continue;
block|}
comment|/* Some opcodes include modifiers of various sorts with a "/mod" syntax,      like the architecture manual suggests.  However, for use with gcc at      least, we also need access to those same opcodes without the "/".  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha_num_opcodes
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|slash
decl_stmt|;
name|name
operator|=
name|alpha_opcodes
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|(
name|slash
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|slash
operator|-
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|+
operator|(
name|slash
operator|-
name|name
operator|)
argument_list|,
name|slash
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hash_insert
argument_list|(
name|alpha_opcode_hash
argument_list|,
name|p
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|alpha_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Ignore failures -- the opcode table does duplicate some 	     variants in different forms, like "hw_stq" and "hw_st/q".  */
block|}
while|while
condition|(
operator|++
name|i
operator|<
name|alpha_num_opcodes
operator|&&
operator|(
name|alpha_opcodes
index|[
name|i
index|]
operator|.
name|name
operator|==
name|name
operator|||
operator|!
name|strcmp
argument_list|(
name|alpha_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|)
condition|)
continue|continue;
block|}
comment|/* Create the macro hash table */
name|alpha_macro_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha_num_macros
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
name|name
operator|=
name|alpha_macros
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|alpha_macro_hash
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|alpha_macros
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|as_fatal
argument_list|(
literal|"internal error: can't hash macro `%s': %s"
argument_list|,
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|alpha_num_macros
operator|&&
operator|(
name|alpha_macros
index|[
name|i
index|]
operator|.
name|name
operator|==
name|name
operator|||
operator|!
name|strcmp
argument_list|(
name|alpha_macros
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|)
condition|)
continue|continue;
block|}
comment|/* Construct symbols for each of the registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|char
name|name
index|[
literal|4
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"$%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|alpha_register_table
index|[
name|i
index|]
operator|=
name|symbol_create
argument_list|(
name|name
argument_list|,
name|reg_section
argument_list|,
name|i
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
literal|64
condition|;
operator|++
name|i
control|)
block|{
name|char
name|name
index|[
literal|5
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"$f%d"
argument_list|,
name|i
operator|-
literal|32
argument_list|)
expr_stmt|;
name|alpha_register_table
index|[
name|i
index|]
operator|=
name|symbol_create
argument_list|(
name|name
argument_list|,
name|reg_section
argument_list|,
name|i
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
comment|/* Create the special symbols and sections we'll be using */
comment|/* So .sbss will get used for tiny objects.  */
name|bfd_set_gp_size
argument_list|(
name|stdoutput
argument_list|,
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
name|create_literal_section
argument_list|(
literal|".lita"
argument_list|,
operator|&
name|alpha_lita_section
argument_list|,
operator|&
name|alpha_lita_symbol
argument_list|)
expr_stmt|;
comment|/* For handling the GP, create a symbol that won't be output in the      symbol table.  We'll edit it out of relocs later.  */
name|alpha_gp_symbol
operator|=
name|symbol_create
argument_list|(
literal|"<GP value>"
argument_list|,
name|alpha_lita_section
argument_list|,
literal|0x8000
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_EVAX
name|create_literal_section
argument_list|(
literal|".link"
argument_list|,
operator|&
name|alpha_link_section
argument_list|,
operator|&
name|alpha_link_symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
block|{
name|segT
name|sec
decl_stmt|;
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".mdebug"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
literal|3
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ERIC_neverdef
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".reginfo"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* The ABI says this section should be loaded so that the running 	 program can access it.  */
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
argument_list|)
expr_stmt|;
name|bfd_set_section_alignement
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* OBJ_ELF */
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The public interface to the instruction assembler.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|opname
index|[
literal|32
index|]
decl_stmt|;
comment|/* current maximum is 13 */
name|expressionS
name|tok
index|[
name|MAX_INSN_ARGS
index|]
decl_stmt|;
name|int
name|ntok
decl_stmt|,
name|opnamelen
decl_stmt|,
name|trunclen
decl_stmt|;
comment|/* split off the opcode */
name|opnamelen
operator|=
name|strspn
argument_list|(
name|str
argument_list|,
literal|"abcdefghijklmnopqrstuvwxyz_/48"
argument_list|)
expr_stmt|;
name|trunclen
operator|=
operator|(
name|opnamelen
operator|<
sizeof|sizeof
argument_list|(
name|opname
argument_list|)
operator|-
literal|1
condition|?
name|opnamelen
else|:
sizeof|sizeof
argument_list|(
name|opname
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|opname
argument_list|,
name|str
argument_list|,
name|trunclen
argument_list|)
expr_stmt|;
name|opname
index|[
name|trunclen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* tokenize the rest of the line */
if|if
condition|(
operator|(
name|ntok
operator|=
name|tokenize_arguments
argument_list|(
name|str
operator|+
name|opnamelen
argument_list|,
name|tok
argument_list|,
name|MAX_INSN_ARGS
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* finish it off */
name|assemble_tokens
argument_list|(
name|opname
argument_list|,
name|tok
argument_list|,
name|ntok
argument_list|,
name|alpha_macros_on
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Round up a section's size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|size
parameter_list|)
name|segT
name|seg
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
name|valueT
name|mask
init|=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|size
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type type, and store the appropriate bytes in *litP.  The number    of LITTLENUMS emitted is stored in *sizeP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|vax_md_atof
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* VAX floats */
case|case
literal|'G'
case|:
comment|/* VAX md_atof doesn't like "G" for some reason.  */
name|type
operator|=
literal|'g'
expr_stmt|;
case|case
literal|'F'
case|:
case|case
literal|'D'
case|:
return|return
name|vax_md_atof
argument_list|(
name|type
argument_list|,
name|litP
argument_list|,
name|sizeP
argument_list|)
return|;
comment|/* IEEE floats */
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to MD_ATOF()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Take care of the target-specific command-line options.  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'F'
case|:
name|alpha_nofloats_on
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_32ADDR
case|:
name|alpha_addr32_on
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|alpha_debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
block|{
specifier|static
specifier|const
struct|struct
name|machine
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
block|}
modifier|*
name|p
struct|,
name|m
index|[]
init|=
block|{
block|{
literal|"21064"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV4
block|}
block|,
block|{
literal|"21064a"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV4
block|}
block|,
block|{
literal|"21066"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV4
block|}
block|,
block|{
literal|"21068"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV4
block|}
block|,
block|{
literal|"21164"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV5
block|}
block|,
comment|/* Do we have CIX extension here? */
block|{
literal|"21164a"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV5
operator||
name|AXP_OPCODE_BWX
block|}
block|,
comment|/* Still same PALcodes? */
block|{
literal|"21164pc"
block|,
operator|(
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV5
operator||
name|AXP_OPCODE_BWX
operator||
name|AXP_OPCODE_CIX
operator||
name|AXP_OPCODE_MAX
operator|)
block|}
block|,
comment|/* All new PALcodes?  Extras? */
block|{
literal|"21264"
block|,
operator|(
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_BWX
operator||
name|AXP_OPCODE_CIX
operator||
name|AXP_OPCODE_MAX
operator|)
block|}
block|,
block|{
literal|"ev4"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV4
block|}
block|,
block|{
literal|"ev45"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV4
block|}
block|,
block|{
literal|"lca45"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV4
block|}
block|,
block|{
literal|"ev5"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV5
block|}
block|,
block|{
literal|"ev56"
block|,
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV5
operator||
name|AXP_OPCODE_BWX
block|}
block|,
block|{
literal|"pca56"
block|,
operator|(
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_EV5
operator||
name|AXP_OPCODE_BWX
operator||
name|AXP_OPCODE_CIX
operator||
name|AXP_OPCODE_MAX
operator|)
block|}
block|,
block|{
literal|"ev6"
block|,
operator|(
name|AXP_OPCODE_BASE
operator||
name|AXP_OPCODE_BWX
operator||
name|AXP_OPCODE_CIX
operator||
name|AXP_OPCODE_MAX
operator|)
block|}
block|,
block|{
literal|"all"
block|,
name|AXP_OPCODE_BASE
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
for|for
control|(
name|p
operator|=
name|m
init|;
name|p
operator|->
name|name
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alpha_target_name
operator|=
name|p
operator|->
name|name
operator|,
name|alpha_target
operator|=
name|p
operator|->
name|flags
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|as_warn
argument_list|(
literal|"Unknown CPU identifier `%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|OBJ_EVAX
case|case
literal|'+'
case|:
comment|/* For g++.  Hash any name> 63 chars long. */
name|alpha_flag_hash_long_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Show new symbol after hash truncation */
name|alpha_flag_show_after_trunc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* for gnu-c/vax compatibility.  */
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a description of the command-line options that we accept.  */
end_comment

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs
argument_list|(
literal|"\ Alpha options:\n\ -32addr			treat addresses as 32-bit values\n\ -F			lack floating point instructions support\n\ -m21064 | -m21066 | -m21164 | -m21164a\n\ -mev4 | -mev45 | -mev5 | -mev56 | -mall\n\ 			specify variant of Alpha architecture\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_EVAX
name|fputs
argument_list|(
literal|"\ VMS options:\n\ -+			hash encode (don't truncate) names longer than 64 characters\n\ -H			show new symbol after hash truncation\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Decide from what point a pc-relative relocation is relative to,    relative to the pc-relative fixup.  Er, relatively speaking.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|valueT
name|addr
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_ALPHA_GPDISP
case|:
case|case
name|BFD_RELOC_ALPHA_GPDISP_HI16
case|:
case|case
name|BFD_RELOC_ALPHA_GPDISP_LO16
case|:
return|return
name|addr
return|;
default|default:
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|addr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to simplify or even eliminate a fixup.  The return value is    ignored; perhaps it was once meaningful, but now it is historical.    To indicate that a fixup has been eliminated, set fixP->fx_done.     For ELF, here it is that we transform the GPDISP_HI16 reloc we used    internally into the GPDISP reloc used externally.  We had to do    this so that we'd have the GPDISP_LO16 reloc as a tag to compute    the distance to the "lda" instruction for setting the addend to    GPDISP.  */
end_comment

begin_function
name|int
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|valueP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valueP
decl_stmt|;
block|{
name|char
modifier|*
specifier|const
name|fixpos
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valueP
decl_stmt|;
name|unsigned
name|image
decl_stmt|,
name|size
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
comment|/* The GPDISP relocations are processed internally with a symbol 	 referring to the current function; we need to drop in a value 	 which, when added to the address of the start of the function, 	 gives the desired GP.  */
case|case
name|BFD_RELOC_ALPHA_GPDISP_HI16
case|:
block|{
name|fixS
modifier|*
name|next
init|=
name|fixP
operator|->
name|fx_next
decl_stmt|;
name|assert
argument_list|(
name|next
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ALPHA_GPDISP_LO16
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
operator|(
name|next
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|next
operator|->
name|fx_where
operator|-
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|-
name|fixP
operator|->
name|fx_where
operator|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|-
name|sign_extend_16
argument_list|(
name|value
argument_list|)
operator|)
operator|>>
literal|16
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_ALPHA_GPDISP
expr_stmt|;
endif|#
directive|endif
goto|goto
name|do_reloc_gp
goto|;
case|case
name|BFD_RELOC_ALPHA_GPDISP_LO16
case|:
name|value
operator|=
name|sign_extend_16
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|do_reloc_gp
label|:
name|fixP
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|size
operator|=
literal|2
expr_stmt|;
goto|goto
name|do_reloc_xx
goto|;
case|case
name|BFD_RELOC_32
case|:
name|size
operator|=
literal|4
expr_stmt|;
goto|goto
name|do_reloc_xx
goto|;
case|case
name|BFD_RELOC_64
case|:
name|size
operator|=
literal|8
expr_stmt|;
name|do_reloc_xx
label|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
case|case
name|BFD_RELOC_GPREL32
case|:
name|assert
argument_list|(
name|fixP
operator|->
name|fx_subsy
operator|==
name|alpha_gp_symbol
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: inherited this obliviousness of `value' -- why? */
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
operator|-
name|alpha_gp_value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_GPREL32
case|:
return|return
literal|1
return|;
endif|#
directive|endif
case|case
name|BFD_RELOC_23_PCREL_S2
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
block|{
name|image
operator|=
name|bfd_getl32
argument_list|(
name|fixpos
argument_list|)
expr_stmt|;
name|image
operator|=
operator|(
name|image
operator|&
operator|~
literal|0x1FFFFF
operator|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|2
operator|)
operator|&
literal|0x1FFFFF
operator|)
expr_stmt|;
goto|goto
name|write_done
goto|;
block|}
return|return
literal|1
return|;
case|case
name|BFD_RELOC_ALPHA_HINT
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
block|{
name|image
operator|=
name|bfd_getl32
argument_list|(
name|fixpos
argument_list|)
expr_stmt|;
name|image
operator|=
operator|(
name|image
operator|&
operator|~
literal|0x3FFF
operator|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|2
operator|)
operator|&
literal|0x3FFF
operator|)
expr_stmt|;
goto|goto
name|write_done
goto|;
block|}
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
case|case
name|BFD_RELOC_ALPHA_LITERAL
case|:
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BFD_RELOC_ALPHA_LITUSE
case|:
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ALPHA_ELF_LITERAL
case|:
case|case
name|BFD_RELOC_ALPHA_LITUSE
case|:
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_EVAX
case|case
name|BFD_RELOC_ALPHA_LINKAGE
case|:
case|case
name|BFD_RELOC_ALPHA_CODEADDR
case|:
return|return
literal|1
return|;
endif|#
directive|endif
default|default:
block|{
specifier|const
name|struct
name|alpha_operand
modifier|*
name|operand
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
literal|0
condition|)
name|as_fatal
argument_list|(
literal|"unhandled relocation type %s"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|-
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|<
name|alpha_num_operands
argument_list|)
expr_stmt|;
name|operand
operator|=
operator|&
name|alpha_operands
index|[
operator|-
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
index|]
expr_stmt|;
comment|/* The rest of these fixups only exist internally during symbol 	   resolution and have no representation in the object file. 	   Therefore they must be completely resolved as constants.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
literal|0
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|->
name|bsym
operator|->
name|section
operator|!=
name|absolute_section
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"non-absolute expression in constant field"
argument_list|)
expr_stmt|;
name|image
operator|=
name|bfd_getl32
argument_list|(
name|fixpos
argument_list|)
expr_stmt|;
name|image
operator|=
name|insert_operand
argument_list|(
name|image
argument_list|,
name|operand
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
block|}
goto|goto
name|write_done
goto|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
literal|0
operator|||
name|fixP
operator|->
name|fx_pcrel
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
block|{
name|as_warn_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"type %d reloc done?\n"
argument_list|,
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|write_done
label|:
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|image
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|done
label|:
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Look for a register name in the given symbol.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'$'
condition|)
block|{
name|int
name|is_float
init|=
literal|0
decl_stmt|,
name|num
decl_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|name
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
return|return
name|alpha_register_table
index|[
name|AXP_REG_FP
index|]
return|;
name|is_float
operator|=
literal|32
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|++
name|name
argument_list|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|num
operator|=
name|name
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'0'
operator|&&
name|isdigit
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|num
operator|=
operator|(
name|name
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|name
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|num
operator|>=
literal|32
condition|)
break|break;
block|}
else|else
break|break;
if|if
condition|(
operator|!
name|alpha_noat_on
operator|&&
name|num
operator|==
name|AXP_REG_AT
condition|)
name|as_warn
argument_list|(
literal|"Used $at without \".set noat\""
argument_list|)
expr_stmt|;
return|return
name|alpha_register_table
index|[
name|num
operator|+
name|is_float
index|]
return|;
case|case
literal|'a'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|alpha_noat_on
condition|)
name|as_warn
argument_list|(
literal|"Used $at without \".set noat\""
argument_list|)
expr_stmt|;
return|return
name|alpha_register_table
index|[
name|AXP_REG_AT
index|]
return|;
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
return|return
name|alpha_register_table
index|[
name|alpha_gp_register
index|]
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
return|return
name|alpha_register_table
index|[
name|AXP_REG_SP
index|]
return|;
break|break;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_comment
comment|/* @@@ Magic ECOFF bits.  */
end_comment

begin_function
name|void
name|alpha_frob_ecoff_data
parameter_list|()
block|{
name|select_gp_value
argument_list|()
expr_stmt|;
comment|/* $zero and $f31 are read-only */
name|alpha_gprmask
operator|&=
operator|~
literal|1
expr_stmt|;
name|alpha_fprmask
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hook to remember a recently defined label so that the auto-align    code can adjust the symbol after we know what alignment will be    required.  */
end_comment

begin_function
name|void
name|alpha_define_label
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|alpha_insn_label
operator|=
name|sym
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if we must always emit a reloc for a type and false if    there is some hope of resolving it a assembly time.  */
end_comment

begin_function
name|int
name|alpha_force_relocation
parameter_list|(
name|f
parameter_list|)
name|fixS
modifier|*
name|f
decl_stmt|;
block|{
switch|switch
condition|(
name|f
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_ALPHA_GPDISP_HI16
case|:
case|case
name|BFD_RELOC_ALPHA_GPDISP_LO16
case|:
case|case
name|BFD_RELOC_ALPHA_GPDISP
case|:
ifdef|#
directive|ifdef
name|OBJ_ECOFF
case|case
name|BFD_RELOC_ALPHA_LITERAL
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ALPHA_ELF_LITERAL
case|:
endif|#
directive|endif
case|case
name|BFD_RELOC_ALPHA_LITUSE
case|:
case|case
name|BFD_RELOC_GPREL32
case|:
ifdef|#
directive|ifdef
name|OBJ_EVAX
case|case
name|BFD_RELOC_ALPHA_LINKAGE
case|:
case|case
name|BFD_RELOC_ALPHA_CODEADDR
case|:
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|BFD_RELOC_23_PCREL_S2
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_ALPHA_HINT
case|:
return|return
literal|0
return|;
default|default:
name|assert
argument_list|(
operator|(
name|int
operator|)
name|f
operator|->
name|fx_r_type
operator|<
literal|0
operator|&&
operator|-
operator|(
name|int
operator|)
name|f
operator|->
name|fx_r_type
operator|<
name|alpha_num_operands
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if we can partially resolve a relocation now.  */
end_comment

begin_function
name|int
name|alpha_fix_adjustable
parameter_list|(
name|f
parameter_list|)
name|fixS
modifier|*
name|f
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Prevent all adjustments to global symbols */
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|f
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Are there any relocation types for which we must generate a reloc      but we can adjust the values contained within it?  */
switch|switch
condition|(
name|f
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_ALPHA_GPDISP_HI16
case|:
case|case
name|BFD_RELOC_ALPHA_GPDISP_LO16
case|:
case|case
name|BFD_RELOC_ALPHA_GPDISP
case|:
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
case|case
name|BFD_RELOC_ALPHA_LITERAL
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ALPHA_ELF_LITERAL
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_EVAX
case|case
name|BFD_RELOC_ALPHA_LINKAGE
case|:
case|case
name|BFD_RELOC_ALPHA_CODEADDR
case|:
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|BFD_RELOC_ALPHA_LITUSE
case|:
return|return
literal|0
return|;
case|case
name|BFD_RELOC_GPREL32
case|:
case|case
name|BFD_RELOC_23_PCREL_S2
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_ALPHA_HINT
case|:
return|return
literal|1
return|;
default|default:
name|assert
argument_list|(
operator|(
name|int
operator|)
name|f
operator|->
name|fx_r_type
operator|<
literal|0
operator|&&
operator|-
operator|(
name|int
operator|)
name|f
operator|->
name|fx_r_type
operator|<
name|alpha_num_operands
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Generate the BFD reloc to be stuck in the object file from the    fixup used internally in the assembler.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|sec
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|fixp
operator|->
name|fx_addsy
operator|->
name|bsym
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
comment|/* Make sure none of our internal relocations make it this far.      They'd better have been fully resolved by this point.  */
name|assert
argument_list|(
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
operator|>
literal|0
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"cannot represent `%s' relocation in object file"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_pcrel
operator|!=
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|as_fatal
argument_list|(
literal|"internal error? cannot generate `%s' relocation"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|fixp
operator|->
name|fx_pcrel
operator|==
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ALPHA_LITERAL
condition|)
block|{
comment|/* fake out bfd_perform_relocation. sigh */
name|reloc
operator|->
name|addend
operator|=
operator|-
name|alpha_gp_value
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/*        * Ohhh, this is ugly.  The problem is that if this is a local global        * symbol, the relocation will entirely be performed at link time, not        * at assembly time.  bfd_perform_reloc doesn't know about this sort        * of thing, and as a result we need to fake it out here.        */
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
name|reloc
operator|->
name|addend
operator|-=
name|fixp
operator|->
name|fx_addsy
operator|->
name|bsym
operator|->
name|value
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Parse a register name off of the input_line and return a register    number.  Gets md_undefined_symbol above to do the register name    matching for us.     Only called as a part of processing the ECOFF .frame directive.  */
end_comment

begin_function
name|int
name|tc_get_register
parameter_list|(
name|frame
parameter_list|)
name|int
name|frame
decl_stmt|;
block|{
name|int
name|framereg
init|=
name|AXP_REG_SP
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'$'
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
name|md_undefined_symbol
argument_list|(
name|s
argument_list|)
decl_stmt|;
operator|*
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\0'
argument_list|)
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
operator|(
name|framereg
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|)
operator|<=
literal|31
condition|)
goto|goto
name|found
goto|;
block|}
name|as_warn
argument_list|(
literal|"frame reg expected, using $%d."
argument_list|,
name|framereg
argument_list|)
expr_stmt|;
name|found
label|:
name|note_gpreg
argument_list|(
name|framereg
argument_list|)
expr_stmt|;
return|return
name|framereg
return|;
block|}
end_function

begin_comment
comment|/* This is called before the symbol table is processed.  In order to    work with gcc when using mips-tfile, we must keep all local labels.    However, in other cases, we want to discard them.  If we were    called with -g, but we didn't see any debugging information, it may    mean that gcc is smuggling debugging information through to    mips-tfile, in which case we must generate all local labels.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_function
name|void
name|alpha_frob_file_before_adjust
parameter_list|()
block|{
if|if
condition|(
name|alpha_debug
operator|!=
literal|0
operator|&&
operator|!
name|ecoff_debugging_seen
condition|)
name|flag_keep_locals
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ECOFF */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Parse the arguments to an opcode.  */
end_comment

begin_function
specifier|static
name|int
name|tokenize_arguments
parameter_list|(
name|str
parameter_list|,
name|tok
parameter_list|,
name|ntok
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|expressionS
name|tok
index|[]
decl_stmt|;
name|int
name|ntok
decl_stmt|;
block|{
name|expressionS
modifier|*
name|end_tok
init|=
name|tok
operator|+
name|ntok
decl_stmt|;
name|char
modifier|*
name|old_input_line_pointer
decl_stmt|;
name|int
name|saw_comma
init|=
literal|0
decl_stmt|,
name|saw_arg
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|tok
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tok
argument_list|)
operator|*
name|ntok
argument_list|)
expr_stmt|;
comment|/* Save and restore input_line_pointer around this function */
name|old_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|tok
operator|<
name|end_tok
operator|&&
operator|*
name|input_line_pointer
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|fini
goto|;
case|case
literal|','
case|:
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|saw_comma
operator|||
operator|!
name|saw_arg
condition|)
goto|goto
name|err
goto|;
name|saw_comma
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'('
case|:
block|{
name|char
modifier|*
name|hold
init|=
name|input_line_pointer
operator|++
decl_stmt|;
comment|/* First try for parenthesized register ... */
name|expression
argument_list|(
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|')'
operator|&&
name|tok
operator|->
name|X_op
operator|==
name|O_register
condition|)
block|{
name|tok
operator|->
name|X_op
operator|=
operator|(
name|saw_comma
condition|?
name|O_cpregister
else|:
name|O_pregister
operator|)
expr_stmt|;
name|saw_comma
operator|=
literal|0
expr_stmt|;
name|saw_arg
operator|=
literal|1
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
operator|++
name|tok
expr_stmt|;
break|break;
block|}
comment|/* ... then fall through to plain expression */
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
block|}
default|default:
if|if
condition|(
name|saw_arg
operator|&&
operator|!
name|saw_comma
condition|)
goto|goto
name|err
goto|;
name|expression
argument_list|(
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|X_op
operator|==
name|O_illegal
operator|||
name|tok
operator|->
name|X_op
operator|==
name|O_absent
condition|)
goto|goto
name|err
goto|;
name|saw_comma
operator|=
literal|0
expr_stmt|;
name|saw_arg
operator|=
literal|1
expr_stmt|;
operator|++
name|tok
expr_stmt|;
break|break;
block|}
block|}
name|fini
label|:
if|if
condition|(
name|saw_comma
condition|)
goto|goto
name|err
goto|;
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
return|return
name|ntok
operator|-
operator|(
name|end_tok
operator|-
name|tok
operator|)
return|;
name|err
label|:
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Search forward through all variants of an opcode looking for a    syntax match.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|alpha_opcode
modifier|*
name|find_opcode_match
parameter_list|(
name|first_opcode
parameter_list|,
name|tok
parameter_list|,
name|pntok
parameter_list|,
name|pcpumatch
parameter_list|)
specifier|const
name|struct
name|alpha_opcode
modifier|*
name|first_opcode
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
modifier|*
name|pntok
decl_stmt|;
name|int
modifier|*
name|pcpumatch
decl_stmt|;
block|{
specifier|const
name|struct
name|alpha_opcode
modifier|*
name|opcode
init|=
name|first_opcode
decl_stmt|;
name|int
name|ntok
init|=
operator|*
name|pntok
decl_stmt|;
name|int
name|got_cpu_match
init|=
literal|0
decl_stmt|;
do|do
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|opidx
decl_stmt|;
name|int
name|tokidx
init|=
literal|0
decl_stmt|;
comment|/* Don't match opcodes that don't exist on this architecture */
if|if
condition|(
operator|!
operator|(
name|opcode
operator|->
name|flags
operator|&
name|alpha_target
operator|)
condition|)
goto|goto
name|match_failed
goto|;
name|got_cpu_match
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|opidx
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opidx
condition|;
operator|++
name|opidx
control|)
block|{
specifier|const
name|struct
name|alpha_operand
modifier|*
name|operand
init|=
operator|&
name|alpha_operands
index|[
operator|*
name|opidx
index|]
decl_stmt|;
comment|/* only take input from real operands */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_FAKE
condition|)
continue|continue;
comment|/* when we expect input, make sure we have it */
if|if
condition|(
name|tokidx
operator|>=
name|ntok
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_OPTIONAL_MASK
operator|)
operator|==
literal|0
condition|)
goto|goto
name|match_failed
goto|;
continue|continue;
block|}
comment|/* match operand type with expression type */
switch|switch
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_TYPECHECK_MASK
condition|)
block|{
case|case
name|AXP_OPERAND_IR
case|:
if|if
condition|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|||
operator|!
name|is_ir_num
argument_list|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
goto|goto
name|match_failed
goto|;
break|break;
case|case
name|AXP_OPERAND_FPR
case|:
if|if
condition|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|||
operator|!
name|is_fpr_num
argument_list|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
goto|goto
name|match_failed
goto|;
break|break;
case|case
name|AXP_OPERAND_IR
operator||
name|AXP_OPERAND_PARENS
case|:
if|if
condition|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|!=
name|O_pregister
operator|||
operator|!
name|is_ir_num
argument_list|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
goto|goto
name|match_failed
goto|;
break|break;
case|case
name|AXP_OPERAND_IR
operator||
name|AXP_OPERAND_PARENS
operator||
name|AXP_OPERAND_COMMA
case|:
if|if
condition|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|!=
name|O_cpregister
operator|||
operator|!
name|is_ir_num
argument_list|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
goto|goto
name|match_failed
goto|;
break|break;
case|case
name|AXP_OPERAND_RELATIVE
case|:
case|case
name|AXP_OPERAND_SIGNED
case|:
case|case
name|AXP_OPERAND_UNSIGNED
case|:
switch|switch
condition|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
case|case
name|O_absent
case|:
case|case
name|O_register
case|:
case|case
name|O_pregister
case|:
case|case
name|O_cpregister
case|:
goto|goto
name|match_failed
goto|;
block|}
break|break;
default|default:
comment|/* everything else should have been fake */
name|abort
argument_list|()
expr_stmt|;
block|}
operator|++
name|tokidx
expr_stmt|;
block|}
comment|/* possible match -- did we use all of our input? */
if|if
condition|(
name|tokidx
operator|==
name|ntok
condition|)
block|{
operator|*
name|pntok
operator|=
name|ntok
expr_stmt|;
return|return
name|opcode
return|;
block|}
name|match_failed
label|:
empty_stmt|;
block|}
do|while
condition|(
operator|++
name|opcode
operator|-
name|alpha_opcodes
operator|<
name|alpha_num_opcodes
operator|&&
operator|!
name|strcmp
argument_list|(
name|opcode
operator|->
name|name
argument_list|,
name|first_opcode
operator|->
name|name
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|pcpumatch
condition|)
operator|*
name|pcpumatch
operator|=
name|got_cpu_match
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Search forward through all variants of a macro looking for a syntax    match.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|alpha_macro
modifier|*
name|find_macro_match
parameter_list|(
name|first_macro
parameter_list|,
name|tok
parameter_list|,
name|pntok
parameter_list|)
specifier|const
name|struct
name|alpha_macro
modifier|*
name|first_macro
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
modifier|*
name|pntok
decl_stmt|;
block|{
specifier|const
name|struct
name|alpha_macro
modifier|*
name|macro
init|=
name|first_macro
decl_stmt|;
name|int
name|ntok
init|=
operator|*
name|pntok
decl_stmt|;
do|do
block|{
specifier|const
name|enum
name|alpha_macro_arg
modifier|*
name|arg
init|=
name|macro
operator|->
name|argsets
decl_stmt|;
name|int
name|tokidx
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
block|{
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
name|MACRO_EOA
case|:
if|if
condition|(
name|tokidx
operator|==
name|ntok
condition|)
return|return
name|macro
return|;
else|else
name|tokidx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MACRO_IR
case|:
if|if
condition|(
name|tokidx
operator|>=
name|ntok
operator|||
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|||
operator|!
name|is_ir_num
argument_list|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
goto|goto
name|match_failed
goto|;
operator|++
name|tokidx
expr_stmt|;
break|break;
case|case
name|MACRO_PIR
case|:
if|if
condition|(
name|tokidx
operator|>=
name|ntok
operator|||
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|!=
name|O_pregister
operator|||
operator|!
name|is_ir_num
argument_list|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
goto|goto
name|match_failed
goto|;
operator|++
name|tokidx
expr_stmt|;
break|break;
case|case
name|MACRO_CPIR
case|:
if|if
condition|(
name|tokidx
operator|>=
name|ntok
operator|||
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|!=
name|O_cpregister
operator|||
operator|!
name|is_ir_num
argument_list|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
goto|goto
name|match_failed
goto|;
operator|++
name|tokidx
expr_stmt|;
break|break;
case|case
name|MACRO_FPR
case|:
if|if
condition|(
name|tokidx
operator|>=
name|ntok
operator|||
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|||
operator|!
name|is_fpr_num
argument_list|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
goto|goto
name|match_failed
goto|;
operator|++
name|tokidx
expr_stmt|;
break|break;
case|case
name|MACRO_EXP
case|:
if|if
condition|(
name|tokidx
operator|>=
name|ntok
condition|)
goto|goto
name|match_failed
goto|;
switch|switch
condition|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
case|case
name|O_absent
case|:
case|case
name|O_register
case|:
case|case
name|O_pregister
case|:
case|case
name|O_cpregister
case|:
goto|goto
name|match_failed
goto|;
block|}
operator|++
name|tokidx
expr_stmt|;
break|break;
name|match_failed
label|:
while|while
condition|(
operator|*
name|arg
operator|!=
name|MACRO_EOA
condition|)
operator|++
name|arg
expr_stmt|;
name|tokidx
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|++
name|arg
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|macro
operator|-
name|alpha_macros
operator|<
name|alpha_num_macros
operator|&&
operator|!
name|strcmp
argument_list|(
name|macro
operator|->
name|name
argument_list|,
name|first_macro
operator|->
name|name
argument_list|)
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert an operand value into an instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|insert_operand
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|val
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|unsigned
name|insn
decl_stmt|;
specifier|const
name|struct
name|alpha_operand
modifier|*
name|operand
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
block|{
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|32
operator|&&
operator|!
operator|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_NOOVERFLOW
operator|)
condition|)
block|{
name|offsetT
name|min
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_SIGNED
condition|)
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
name|min
operator|||
name|val
operator|>
name|max
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
init|=
literal|"operand out of range (%s not between %d and %d)"
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|*
literal|3
operator|+
literal|2
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|val
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
condition|)
name|as_warn
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
name|insn
operator||=
operator|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/*  * Turn an opcode description and a set of arguments into  * an instruction and a fixup.  */
end_comment

begin_function
specifier|static
name|void
name|assemble_insn
parameter_list|(
name|opcode
parameter_list|,
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|insn
parameter_list|)
specifier|const
name|struct
name|alpha_opcode
modifier|*
name|opcode
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
name|struct
name|alpha_insn
modifier|*
name|insn
decl_stmt|;
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|argidx
decl_stmt|;
name|unsigned
name|image
decl_stmt|;
name|int
name|tokidx
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
for|for
control|(
name|argidx
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|argidx
condition|;
operator|++
name|argidx
control|)
block|{
specifier|const
name|struct
name|alpha_operand
modifier|*
name|operand
init|=
operator|&
name|alpha_operands
index|[
operator|*
name|argidx
index|]
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_FAKE
condition|)
block|{
comment|/* fake operands take no value and generate no fixup */
name|image
operator|=
name|insert_operand
argument_list|(
name|image
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tokidx
operator|>=
name|ntok
condition|)
block|{
switch|switch
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_OPTIONAL_MASK
condition|)
block|{
case|case
name|AXP_OPERAND_DEFAULT_FIRST
case|:
name|t
operator|=
operator|&
name|tok
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|AXP_OPERAND_DEFAULT_SECOND
case|:
name|t
operator|=
operator|&
name|tok
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|AXP_OPERAND_DEFAULT_ZERO
case|:
block|{
specifier|static
specifier|const
name|expressionS
name|zero_exp
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|O_constant
block|,
literal|1
block|}
decl_stmt|;
name|t
operator|=
operator|&
name|zero_exp
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|t
operator|=
operator|&
name|tok
index|[
name|tokidx
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_pregister
case|:
case|case
name|O_cpregister
case|:
name|image
operator|=
name|insert_operand
argument_list|(
name|image
argument_list|,
name|operand
argument_list|,
name|regno
argument_list|(
name|t
operator|->
name|X_add_number
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
name|image
operator|=
name|insert_operand
argument_list|(
name|image
argument_list|,
name|operand
argument_list|,
name|t
operator|->
name|X_add_number
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|struct
name|alpha_fixup
modifier|*
name|fixup
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|nfixups
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
literal|"too many fixups"
argument_list|)
expr_stmt|;
name|fixup
operator|=
operator|&
name|insn
operator|->
name|fixups
index|[
name|insn
operator|->
name|nfixups
operator|++
index|]
expr_stmt|;
name|fixup
operator|->
name|exp
operator|=
operator|*
name|t
expr_stmt|;
name|fixup
operator|->
name|reloc
operator|=
name|operand
operator|->
name|default_reloc
expr_stmt|;
block|}
break|break;
block|}
block|}
name|insn
operator|->
name|insn
operator|=
name|image
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Actually output an instruction with its fixup.  */
end_comment

begin_function
specifier|static
name|void
name|emit_insn
parameter_list|(
name|insn
parameter_list|)
name|struct
name|alpha_insn
modifier|*
name|insn
decl_stmt|;
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Take care of alignment duties */
if|if
condition|(
name|alpha_auto_align_on
operator|&&
name|alpha_current_align
operator|<
literal|2
condition|)
name|alpha_align
argument_list|(
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|alpha_insn_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_current_align
operator|>
literal|2
condition|)
name|alpha_current_align
operator|=
literal|2
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
comment|/* Write out the instruction.  */
name|f
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
operator|->
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Apply the fixups in order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|nfixups
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|alpha_fixup
modifier|*
name|fixup
init|=
operator|&
name|insn
operator|->
name|fixups
index|[
name|i
index|]
decl_stmt|;
name|int
name|size
decl_stmt|,
name|pcrel
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Some fixups are only used internally and so have no howto */
if|if
condition|(
operator|(
name|int
operator|)
name|fixup
operator|->
name|reloc
operator|<
literal|0
condition|)
name|size
operator|=
literal|4
operator|,
name|pcrel
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* These relocation types are only used internally. */
elseif|else
if|if
condition|(
name|fixup
operator|->
name|reloc
operator|==
name|BFD_RELOC_ALPHA_GPDISP_HI16
operator|||
name|fixup
operator|->
name|reloc
operator|==
name|BFD_RELOC_ALPHA_GPDISP_LO16
condition|)
block|{
name|size
operator|=
literal|2
operator|,
name|pcrel
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixup
operator|->
name|reloc
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
name|pcrel
operator|=
name|reloc_howto
operator|->
name|pc_relative
expr_stmt|;
block|}
name|assert
argument_list|(
name|size
operator|>=
literal|1
operator|&&
name|size
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
operator|&
name|fixup
operator|->
name|exp
argument_list|,
name|pcrel
argument_list|,
name|fixup
operator|->
name|reloc
argument_list|)
expr_stmt|;
comment|/* Turn off complaints that the addend is too large for some fixups */
switch|switch
condition|(
name|fixup
operator|->
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_ALPHA_GPDISP_LO16
case|:
ifdef|#
directive|ifdef
name|OBJ_ECOFF
case|case
name|BFD_RELOC_ALPHA_LITERAL
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ALPHA_ELF_LITERAL
case|:
endif|#
directive|endif
case|case
name|BFD_RELOC_GPREL32
case|:
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given an opcode name and a pre-tokenized set of arguments, assemble    the insn, but do not emit it.     Note that this implies no macros allowed, since we can't store more    than one insn in an insn structure.  */
end_comment

begin_function
specifier|static
name|void
name|assemble_tokens_to_insn
parameter_list|(
name|opname
parameter_list|,
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|insn
parameter_list|)
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
name|struct
name|alpha_insn
modifier|*
name|insn
decl_stmt|;
block|{
specifier|const
name|struct
name|alpha_opcode
modifier|*
name|opcode
decl_stmt|;
comment|/* search opcodes */
name|opcode
operator|=
operator|(
specifier|const
expr|struct
name|alpha_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|alpha_opcode_hash
argument_list|,
name|opname
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
name|int
name|cpumatch
decl_stmt|;
name|opcode
operator|=
name|find_opcode_match
argument_list|(
name|opcode
argument_list|,
name|tok
argument_list|,
operator|&
name|ntok
argument_list|,
operator|&
name|cpumatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
name|assemble_insn
argument_list|(
name|opcode
argument_list|,
name|tok
argument_list|,
name|ntok
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cpumatch
condition|)
name|as_bad
argument_list|(
literal|"inappropriate arguments for opcode `%s'"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"opcode `%s' not supported for target %s"
argument_list|,
name|opname
argument_list|,
name|alpha_target_name
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"unknown opcode `%s'"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an opcode name and a pre-tokenized set of arguments, take the    opcode all the way through emission.  */
end_comment

begin_function
specifier|static
name|void
name|assemble_tokens
parameter_list|(
name|opname
parameter_list|,
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|local_macros_on
parameter_list|)
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
name|int
name|local_macros_on
decl_stmt|;
block|{
name|int
name|found_something
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|alpha_opcode
modifier|*
name|opcode
decl_stmt|;
specifier|const
name|struct
name|alpha_macro
modifier|*
name|macro
decl_stmt|;
name|int
name|cpumatch
init|=
literal|1
decl_stmt|;
comment|/* search macros */
if|if
condition|(
name|local_macros_on
condition|)
block|{
name|macro
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|alpha_macro
operator|*
operator|)
name|hash_find
argument_list|(
name|alpha_macro_hash
argument_list|,
name|opname
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|macro
condition|)
block|{
name|found_something
operator|=
literal|1
expr_stmt|;
name|macro
operator|=
name|find_macro_match
argument_list|(
name|macro
argument_list|,
name|tok
argument_list|,
operator|&
name|ntok
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro
condition|)
block|{
call|(
modifier|*
name|macro
operator|->
name|emit
call|)
argument_list|(
name|tok
argument_list|,
name|ntok
argument_list|,
name|macro
operator|->
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* search opcodes */
name|opcode
operator|=
operator|(
specifier|const
expr|struct
name|alpha_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|alpha_opcode_hash
argument_list|,
name|opname
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
name|found_something
operator|=
literal|1
expr_stmt|;
name|opcode
operator|=
name|find_opcode_match
argument_list|(
name|opcode
argument_list|,
name|tok
argument_list|,
operator|&
name|ntok
argument_list|,
operator|&
name|cpumatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
name|struct
name|alpha_insn
name|insn
decl_stmt|;
name|assemble_insn
argument_list|(
name|opcode
argument_list|,
name|tok
argument_list|,
name|ntok
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|found_something
condition|)
if|if
condition|(
name|cpumatch
condition|)
name|as_bad
argument_list|(
literal|"inappropriate arguments for opcode `%s'"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"opcode `%s' not supported for target %s"
argument_list|,
name|opname
argument_list|,
name|alpha_target_name
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"unknown opcode `%s'"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Some instruction sets indexed by lg(size) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|sextX_op
index|[]
init|=
block|{
literal|"sextb"
block|,
literal|"sextw"
block|,
literal|"sextl"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|insXl_op
index|[]
init|=
block|{
literal|"insbl"
block|,
literal|"inswl"
block|,
literal|"insll"
block|,
literal|"insql"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|insXh_op
index|[]
init|=
block|{
name|NULL
block|,
literal|"inswh"
block|,
literal|"inslh"
block|,
literal|"insqh"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|extXl_op
index|[]
init|=
block|{
literal|"extbl"
block|,
literal|"extwl"
block|,
literal|"extll"
block|,
literal|"extql"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|extXh_op
index|[]
init|=
block|{
name|NULL
block|,
literal|"extwh"
block|,
literal|"extlh"
block|,
literal|"extqh"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mskXl_op
index|[]
init|=
block|{
literal|"mskbl"
block|,
literal|"mskwl"
block|,
literal|"mskll"
block|,
literal|"mskql"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mskXh_op
index|[]
init|=
block|{
name|NULL
block|,
literal|"mskwh"
block|,
literal|"msklh"
block|,
literal|"mskqh"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|stX_op
index|[]
init|=
block|{
literal|"stb"
block|,
literal|"stw"
block|,
literal|"stl"
block|,
literal|"stq"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ldX_op
index|[]
init|=
block|{
literal|"ldb"
block|,
literal|"ldw"
block|,
literal|"ldll"
block|,
literal|"ldq"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ldXu_op
index|[]
init|=
block|{
literal|"ldbu"
block|,
literal|"ldwu"
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implement the ldgp macro.  */
end_comment

begin_function
specifier|static
name|void
name|emit_ldgp
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|unused
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|unused
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_AOUT
name|FIXME
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ECOFF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
comment|/* from "ldgp r1,n(r2)", generate "ldah r1,X(R2); lda r1,Y(r1)"      with appropriate constants and relocations.  */
name|struct
name|alpha_insn
name|insn
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
name|expressionS
name|addend
decl_stmt|;
comment|/* We're going to need this symbol in md_apply_fix().  */
operator|(
name|void
operator|)
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
if|if
condition|(
name|regno
argument_list|(
name|tok
index|[
literal|2
index|]
operator|.
name|X_add_number
argument_list|)
operator|==
name|AXP_REG_PV
condition|)
name|ecoff_set_gp_prolog_size
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|newtok
index|[
literal|0
index|]
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|2
index|]
operator|=
name|tok
index|[
literal|2
index|]
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
literal|"ldah"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
name|addend
operator|=
name|tok
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
name|assert
argument_list|(
name|addend
operator|.
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
name|addend
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|addend
operator|.
name|X_add_symbol
operator|=
name|alpha_gp_symbol
expr_stmt|;
endif|#
directive|endif
name|insn
operator|.
name|nfixups
operator|=
literal|1
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|=
name|addend
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_GPDISP_HI16
expr_stmt|;
name|emit_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|tok
index|[
literal|0
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
name|addend
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
name|insn
operator|.
name|nfixups
operator|=
literal|1
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|=
name|addend
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_GPDISP_LO16
expr_stmt|;
name|emit_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_ECOFF || OBJ_ELF */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_EVAX
end_ifdef

begin_comment
comment|/* Add symbol+addend to link pool.    Return offset from basesym to entry in link pool.     Add new fixup only if offset isn't 16bit.  */
end_comment

begin_function
name|valueT
name|add_to_link_pool
parameter_list|(
name|basesym
parameter_list|,
name|sym
parameter_list|,
name|addend
parameter_list|)
name|symbolS
modifier|*
name|basesym
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|addend
decl_stmt|;
block|{
name|segT
name|current_section
init|=
name|now_seg
decl_stmt|;
name|int
name|current_subsec
init|=
name|now_subseg
decl_stmt|;
name|valueT
name|offset
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|alpha_link_section
argument_list|)
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|offset
operator|=
operator|-
name|basesym
operator|->
name|sy_obj
expr_stmt|;
comment|/* @@ This assumes all entries in a given section will be of the same      size...  Probably correct, but unwise to rely on.  */
comment|/* This must always be called with the same subsegment.  */
if|if
condition|(
name|seginfo
operator|->
name|frchainP
condition|)
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|fix_root
init|;
name|fixp
operator|!=
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
operator|,
name|offset
operator|+=
literal|8
control|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|==
name|sym
operator|&&
name|fixp
operator|->
name|fx_offset
operator|==
name|addend
condition|)
block|{
if|if
condition|(
name|range_signed_16
argument_list|(
name|offset
argument_list|)
condition|)
block|{
return|return
name|offset
return|;
block|}
block|}
block|}
comment|/* Not found in 16bit signed range.  */
name|subseg_set
argument_list|(
name|alpha_link_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
name|sym
argument_list|,
name|addend
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_64
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_section
argument_list|,
name|current_subsec
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|literal_pool_size
operator|+=
literal|8
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_EVAX */
end_comment

begin_comment
comment|/* Load a (partial) expression into a target register.     If poffset is not null, after the call it will either contain    O_constant 0, or a 16-bit offset appropriate for any MEM format    instruction.  In addition, pbasereg will be modified to point to    the base register to use in that MEM format instruction.     In any case, *pbasereg should contain a base register to add to the    expression.  This will normally be either AXP_REG_ZERO or    alpha_gp_register.  Symbol addresses will always be loaded via $gp,    so "foo($0)" is interpreted as adding the address of foo to $0;    i.e. "ldq $targ, LIT($gp); addq $targ, $0, $targ".  Odd, perhaps,    but this is what OSF/1 does.     Finally, the return value is true if the calling macro may emit a    LITUSE reloc if otherwise appropriate.  */
end_comment

begin_function
specifier|static
name|int
name|load_expression
parameter_list|(
name|targreg
parameter_list|,
name|exp
parameter_list|,
name|pbasereg
parameter_list|,
name|poffset
parameter_list|)
name|int
name|targreg
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|int
modifier|*
name|pbasereg
decl_stmt|;
name|expressionS
modifier|*
name|poffset
decl_stmt|;
block|{
name|int
name|emit_lituse
init|=
literal|0
decl_stmt|;
name|offsetT
name|addend
init|=
name|exp
operator|->
name|X_add_number
decl_stmt|;
name|int
name|basereg
init|=
operator|*
name|pbasereg
decl_stmt|;
name|struct
name|alpha_insn
name|insn
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_symbol
case|:
block|{
ifdef|#
directive|ifdef
name|OBJ_ECOFF
name|offsetT
name|lit
decl_stmt|;
comment|/* attempt to reduce .lit load by splitting the offset from 	   its symbol when possible, but don't create a situation in 	   which we'd fail.  */
if|if
condition|(
operator|!
name|range_signed_32
argument_list|(
name|addend
argument_list|)
operator|&&
operator|(
name|alpha_noat_on
operator|||
name|targreg
operator|==
name|AXP_REG_AT
operator|)
condition|)
block|{
name|lit
operator|=
name|add_to_literal_pool
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|,
name|addend
argument_list|,
name|alpha_lita_section
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lit
operator|=
name|add_to_literal_pool
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|,
literal|0
argument_list|,
name|alpha_lita_section
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lit
operator|>=
literal|0x8000
condition|)
name|as_fatal
argument_list|(
literal|"overflow in literal (.lita) table"
argument_list|)
expr_stmt|;
comment|/* emit "ldq r, lit(gp)" */
if|if
condition|(
name|basereg
operator|!=
name|alpha_gp_register
operator|&&
name|targreg
operator|==
name|basereg
condition|)
block|{
if|if
condition|(
name|alpha_noat_on
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at register while noat in effect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targreg
operator|==
name|AXP_REG_AT
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at while $at in use"
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
block|}
else|else
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|set_tok_sym
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|alpha_lita_symbol
argument_list|,
name|lit
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|alpha_gp_register
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
literal|"ldq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|.
name|nfixups
operator|==
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_LITERAL
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_ECOFF */
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* emit "ldq r, gotoff(gp)" */
if|if
condition|(
name|basereg
operator|!=
name|alpha_gp_register
operator|&&
name|targreg
operator|==
name|basereg
condition|)
block|{
if|if
condition|(
name|alpha_noat_on
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at register while noat in effect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targreg
operator|==
name|AXP_REG_AT
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at while $at in use"
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
block|}
else|else
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|range_signed_32
argument_list|(
name|addend
argument_list|)
operator|&&
operator|(
name|alpha_noat_on
operator|||
name|targreg
operator|==
name|AXP_REG_AT
operator|)
condition|)
block|{
name|newtok
index|[
literal|1
index|]
operator|=
operator|*
name|exp
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|set_tok_sym
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|alpha_gp_register
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
literal|"ldq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|.
name|nfixups
operator|==
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_ELF_LITERAL
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_ELF */
ifdef|#
directive|ifdef
name|OBJ_EVAX
name|offsetT
name|link
decl_stmt|;
if|if
condition|(
name|alpha_basereg_clobbered
condition|)
block|{
comment|/* no basereg, reload basreg from 0(FP).  */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_FP
argument_list|)
expr_stmt|;
name|basereg
operator|=
name|targreg
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Find symbol or symbol pointer in link section.  */
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|==
name|alpha_evax_proc
operator|.
name|symbol
condition|)
block|{
if|if
condition|(
name|range_signed_16
argument_list|(
name|addend
argument_list|)
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|range_signed_32
argument_list|(
name|addend
argument_list|)
condition|)
block|{
name|link
operator|=
name|add_to_link_pool
argument_list|(
name|alpha_evax_proc
operator|.
name|symbol
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|link
operator|=
name|add_to_link_pool
argument_list|(
name|alpha_evax_proc
operator|.
name|symbol
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
literal|"ldq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_EVAX */
name|emit_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_EVAX
name|emit_lituse
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|basereg
operator|!=
name|alpha_gp_register
operator|&&
name|basereg
operator|!=
name|AXP_REG_ZERO
condition|)
block|{
comment|/* emit "addq r, base, r" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"addq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|basereg
operator|=
name|targreg
expr_stmt|;
block|}
break|break;
case|case
name|O_constant
case|:
break|break;
case|case
name|O_subtract
case|:
comment|/* Assume that this difference expression will be resolved to an 	 absolute value and that that value will fit in 16 bits. */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|1
index|]
operator|=
operator|*
name|exp
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|poffset
condition|)
name|set_tok_const
argument_list|(
operator|*
name|poffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|range_signed_32
argument_list|(
name|addend
argument_list|)
condition|)
block|{
name|offsetT
name|lit
decl_stmt|;
comment|/* for 64-bit addends, just put it in the literal pool */
ifdef|#
directive|ifdef
name|OBJ_EVAX
comment|/* emit "ldq targreg, lit(basereg)"  */
name|lit
operator|=
name|add_to_link_pool
argument_list|(
name|alpha_evax_proc
operator|.
name|symbol
argument_list|,
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|lit
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|alpha_gp_register
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|alpha_lit8_section
operator|==
name|NULL
condition|)
block|{
name|create_literal_section
argument_list|(
literal|".lit8"
argument_list|,
operator|&
name|alpha_lit8_section
argument_list|,
operator|&
name|alpha_lit8_symbol
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
name|alpha_lit8_literal
operator|=
name|add_to_literal_pool
argument_list|(
name|alpha_lit8_symbol
argument_list|,
literal|0x8000
argument_list|,
name|alpha_lita_section
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_lit8_literal
operator|>=
literal|0x8000
condition|)
name|as_fatal
argument_list|(
literal|"overflow in literal (.lita) table"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|lit
operator|=
name|add_to_literal_pool
argument_list|(
name|NULL
argument_list|,
name|addend
argument_list|,
name|alpha_lit8_section
argument_list|,
literal|8
argument_list|)
operator|-
literal|0x8000
expr_stmt|;
if|if
condition|(
name|lit
operator|>=
literal|0x8000
condition|)
name|as_fatal
argument_list|(
literal|"overflow in literal (.lit8) table"
argument_list|)
expr_stmt|;
comment|/* emit "lda litreg, .lit8+0x8000" */
if|if
condition|(
name|targreg
operator|==
name|basereg
condition|)
block|{
if|if
condition|(
name|alpha_noat_on
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at register while noat in effect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targreg
operator|==
name|AXP_REG_AT
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at while $at in use"
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
block|}
else|else
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
name|set_tok_sym
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|alpha_lita_symbol
argument_list|,
name|alpha_lit8_literal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
name|set_tok_sym
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|alpha_lit8_symbol
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|alpha_gp_register
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
literal|"ldq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|.
name|nfixups
operator|==
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ECOFF
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_LITERAL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_ELF_LITERAL
expr_stmt|;
endif|#
directive|endif
name|emit_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
comment|/* emit "ldq litreg, lit(litreg)" */
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|lit
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|newtok
index|[
literal|0
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
literal|"ldq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|.
name|nfixups
operator|<
name|MAX_INSN_FIXUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|nfixups
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|insn
operator|.
name|fixups
index|[
literal|1
index|]
argument_list|,
operator|&
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_fixup
argument_list|)
operator|*
name|insn
operator|.
name|nfixups
argument_list|)
expr_stmt|;
block|}
name|insn
operator|.
name|nfixups
operator|++
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_LITUSE
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
name|emit_lituse
operator|=
literal|0
expr_stmt|;
name|emit_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
comment|/* emit "addq litreg, base, target" */
if|if
condition|(
name|basereg
operator|!=
name|AXP_REG_ZERO
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"addq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !OBJ_EVAX */
if|if
condition|(
name|poffset
condition|)
name|set_tok_const
argument_list|(
operator|*
name|poffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pbasereg
operator|=
name|targreg
expr_stmt|;
block|}
else|else
block|{
name|offsetT
name|low
decl_stmt|,
name|high
decl_stmt|,
name|extra
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* for 32-bit operands, break up the addend */
name|low
operator|=
name|sign_extend_16
argument_list|(
name|addend
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|addend
operator|-
name|low
expr_stmt|;
name|high
operator|=
name|sign_extend_16
argument_list|(
name|tmp
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|-
operator|(
name|high
operator|<<
literal|16
operator|)
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
name|sign_extend_16
argument_list|(
name|tmp
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
name|extra
operator|=
literal|0
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|targreg
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
condition|)
block|{
comment|/* emit "ldah r, extra(r) */
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldah"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|basereg
operator|=
name|targreg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|high
condition|)
block|{
comment|/* emit "ldah r, high(r) */
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldah"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|basereg
operator|=
name|targreg
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|low
operator|&&
operator|!
name|poffset
operator|)
operator|||
operator|(
operator|!
name|poffset
operator|&&
name|basereg
operator|!=
name|targreg
operator|)
condition|)
block|{
comment|/* emit "lda r, low(base)" */
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|basereg
operator|=
name|targreg
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|poffset
condition|)
name|set_tok_const
argument_list|(
operator|*
name|poffset
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|*
name|pbasereg
operator|=
name|basereg
expr_stmt|;
block|}
return|return
name|emit_lituse
return|;
block|}
end_function

begin_comment
comment|/* The lda macro differs from the lda instruction in that it handles    most simple expressions, particualrly symbol address loads and    large constants.  */
end_comment

begin_function
specifier|static
name|void
name|emit_lda
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|unused
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|unused
decl_stmt|;
block|{
name|int
name|basereg
decl_stmt|;
if|if
condition|(
name|ntok
operator|==
literal|2
condition|)
name|basereg
operator|=
operator|(
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|?
name|AXP_REG_ZERO
else|:
name|alpha_gp_register
operator|)
expr_stmt|;
else|else
name|basereg
operator|=
name|tok
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
operator|(
name|void
operator|)
name|load_expression
argument_list|(
name|tok
index|[
literal|0
index|]
operator|.
name|X_add_number
argument_list|,
operator|&
name|tok
index|[
literal|1
index|]
argument_list|,
operator|&
name|basereg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The ldah macro differs from the ldah instruction in that it has $31    as an implied base register.  */
end_comment

begin_function
specifier|static
name|void
name|emit_ldah
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|unused
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|unused
decl_stmt|;
block|{
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
name|newtok
index|[
literal|0
index|]
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|newtok
index|[
literal|1
index|]
operator|=
name|tok
index|[
literal|1
index|]
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_ZERO
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldah"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle all "simple" integer register loads -- ldq, ldq_l, ldq_u,    etc.  They differ from the real instructions in that they do simple    expressions like the lda macro.  */
end_comment

begin_function
specifier|static
name|void
name|emit_ir_load
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|opname
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|opname
decl_stmt|;
block|{
name|int
name|basereg
decl_stmt|,
name|lituse
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|alpha_insn
name|insn
decl_stmt|;
if|if
condition|(
name|ntok
operator|==
literal|2
condition|)
name|basereg
operator|=
operator|(
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|?
name|AXP_REG_ZERO
else|:
name|alpha_gp_register
operator|)
expr_stmt|;
else|else
name|basereg
operator|=
name|tok
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
name|lituse
operator|=
name|load_expression
argument_list|(
name|tok
index|[
literal|0
index|]
operator|.
name|X_add_number
argument_list|,
operator|&
name|tok
index|[
literal|1
index|]
argument_list|,
operator|&
name|basereg
argument_list|,
operator|&
name|newtok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|0
index|]
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|opname
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|lituse
condition|)
block|{
name|assert
argument_list|(
name|insn
operator|.
name|nfixups
operator|<
name|MAX_INSN_FIXUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|nfixups
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|insn
operator|.
name|fixups
index|[
literal|1
index|]
argument_list|,
operator|&
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_fixup
argument_list|)
operator|*
name|insn
operator|.
name|nfixups
argument_list|)
expr_stmt|;
block|}
name|insn
operator|.
name|nfixups
operator|++
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_LITUSE
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
block|}
name|emit_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_EVAX
comment|/* special hack. If the basereg is clobbered for a call        all lda's before the call don't have a basereg.  */
if|if
condition|(
operator|(
name|tok
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|tok
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|alpha_gp_register
operator|)
condition|)
block|{
name|alpha_basereg_clobbered
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Handle fp register loads, and both integer and fp register stores.    Again, we handle simple expressions.  */
end_comment

begin_function
specifier|static
name|void
name|emit_loadstore
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|opname
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|opname
decl_stmt|;
block|{
name|int
name|basereg
decl_stmt|,
name|lituse
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|alpha_insn
name|insn
decl_stmt|;
if|if
condition|(
name|ntok
operator|==
literal|2
condition|)
name|basereg
operator|=
operator|(
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|?
name|AXP_REG_ZERO
else|:
name|alpha_gp_register
operator|)
expr_stmt|;
else|else
name|basereg
operator|=
name|tok
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|!
name|range_signed_16
argument_list|(
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
block|{
if|if
condition|(
name|alpha_noat_on
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at register while noat in effect"
argument_list|)
expr_stmt|;
name|lituse
operator|=
name|load_expression
argument_list|(
name|AXP_REG_AT
argument_list|,
operator|&
name|tok
index|[
literal|1
index|]
argument_list|,
operator|&
name|basereg
argument_list|,
operator|&
name|newtok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newtok
index|[
literal|1
index|]
operator|=
name|tok
index|[
literal|1
index|]
expr_stmt|;
name|lituse
operator|=
literal|0
expr_stmt|;
block|}
name|newtok
index|[
literal|0
index|]
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|opname
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|lituse
condition|)
block|{
name|assert
argument_list|(
name|insn
operator|.
name|nfixups
operator|<
name|MAX_INSN_FIXUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|nfixups
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|insn
operator|.
name|fixups
index|[
literal|1
index|]
argument_list|,
operator|&
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_fixup
argument_list|)
operator|*
name|insn
operator|.
name|nfixups
argument_list|)
expr_stmt|;
block|}
name|insn
operator|.
name|nfixups
operator|++
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_LITUSE
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
block|}
name|emit_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load a half-word or byte as an unsigned value.  */
end_comment

begin_function
specifier|static
name|void
name|emit_ldXu
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|vlgsize
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|vlgsize
decl_stmt|;
block|{
if|if
condition|(
name|alpha_target
operator|&
name|AXP_OPCODE_BWX
condition|)
name|emit_ir_load
argument_list|(
name|tok
argument_list|,
name|ntok
argument_list|,
name|ldXu_op
index|[
operator|(
name|long
operator|)
name|vlgsize
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|alpha_noat_on
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at register while noat in effect"
argument_list|)
expr_stmt|;
comment|/* emit "lda $at, exp" */
name|memcpy
argument_list|(
name|newtok
argument_list|,
name|tok
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
operator|*
name|ntok
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|=
name|AXP_REG_AT
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
name|ntok
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "ldq_u targ, 0($at)" */
name|newtok
index|[
literal|0
index|]
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldq_u"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "extXl targ, $at, targ" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|2
index|]
operator|=
name|newtok
index|[
literal|0
index|]
expr_stmt|;
name|assemble_tokens
argument_list|(
name|extXl_op
index|[
operator|(
name|long
operator|)
name|vlgsize
index|]
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Load a half-word or byte as a signed value.  */
end_comment

begin_function
specifier|static
name|void
name|emit_ldX
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|vlgsize
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|vlgsize
decl_stmt|;
block|{
name|emit_ldXu
argument_list|(
name|tok
argument_list|,
name|ntok
argument_list|,
name|vlgsize
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
name|sextX_op
index|[
operator|(
name|long
operator|)
name|vlgsize
index|]
argument_list|,
name|tok
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load an integral value from an unaligned address as an unsigned    value.  */
end_comment

begin_function
specifier|static
name|void
name|emit_uldXu
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|vlgsize
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|vlgsize
decl_stmt|;
block|{
name|long
name|lgsize
init|=
operator|(
name|long
operator|)
name|vlgsize
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|alpha_noat_on
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at register while noat in effect"
argument_list|)
expr_stmt|;
comment|/* emit "lda $at, exp" */
name|memcpy
argument_list|(
name|newtok
argument_list|,
name|tok
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
operator|*
name|ntok
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|=
name|AXP_REG_AT
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
name|ntok
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "ldq_u $t9, 0($at)" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldq_u"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "ldq_u $t10, size-1($at)" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
operator|(
literal|1
operator|<<
name|lgsize
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldq_u"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "extXl $t9, $at, $t9" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
name|extXl_op
index|[
name|lgsize
index|]
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "extXh $t10, $at, $t10" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
name|extXh_op
index|[
name|lgsize
index|]
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "or $t9, $t10, targ" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|2
index|]
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"or"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load an integral value from an unaligned address as a signed value.    Note that quads should get funneled to the unsigned load since we    don't have to do the sign extension.  */
end_comment

begin_function
specifier|static
name|void
name|emit_uldX
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|vlgsize
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|vlgsize
decl_stmt|;
block|{
name|emit_uldXu
argument_list|(
name|tok
argument_list|,
name|ntok
argument_list|,
name|vlgsize
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
name|sextX_op
index|[
operator|(
name|long
operator|)
name|vlgsize
index|]
argument_list|,
name|tok
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement the ldil macro.  */
end_comment

begin_function
specifier|static
name|void
name|emit_ldil
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|unused
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|unused
decl_stmt|;
block|{
name|expressionS
name|newtok
index|[
literal|2
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|newtok
argument_list|,
name|tok
argument_list|,
sizeof|sizeof
argument_list|(
name|newtok
argument_list|)
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|=
name|sign_extend_32
argument_list|(
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
name|ntok
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store a half-word or byte.  */
end_comment

begin_function
specifier|static
name|void
name|emit_stX
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|vlgsize
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|vlgsize
decl_stmt|;
block|{
name|int
name|lgsize
init|=
operator|(
name|int
operator|)
operator|(
name|long
operator|)
name|vlgsize
decl_stmt|;
if|if
condition|(
name|alpha_target
operator|&
name|AXP_OPCODE_BWX
condition|)
name|emit_loadstore
argument_list|(
name|tok
argument_list|,
name|ntok
argument_list|,
name|stX_op
index|[
name|lgsize
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|alpha_noat_on
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at register while noat in effect"
argument_list|)
expr_stmt|;
comment|/* emit "lda $at, exp" */
name|memcpy
argument_list|(
name|newtok
argument_list|,
name|tok
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
operator|*
name|ntok
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|=
name|AXP_REG_AT
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
name|ntok
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "ldq_u $t9, 0($at)" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldq_u"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "insXl src, $at, $t10" */
name|newtok
index|[
literal|0
index|]
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
name|insXl_op
index|[
name|lgsize
index|]
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "mskXl $t9, $at, $t9" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|2
index|]
operator|=
name|newtok
index|[
literal|0
index|]
expr_stmt|;
name|assemble_tokens
argument_list|(
name|mskXl_op
index|[
name|lgsize
index|]
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "or $t9, $t10, $t9" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"or"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "stq_u $t9, 0($at) */
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"stq_u"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store an integer to an unaligned address.  */
end_comment

begin_function
specifier|static
name|void
name|emit_ustX
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|vlgsize
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|vlgsize
decl_stmt|;
block|{
name|int
name|lgsize
init|=
operator|(
name|int
operator|)
operator|(
name|long
operator|)
name|vlgsize
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
comment|/* emit "lda $at, exp" */
name|memcpy
argument_list|(
name|newtok
argument_list|,
name|tok
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
operator|*
name|ntok
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|=
name|AXP_REG_AT
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
name|ntok
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "ldq_u $9, 0($at)" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldq_u"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "ldq_u $10, size-1($at)" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
operator|(
literal|1
operator|<<
name|lgsize
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldq_u"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "insXl src, $at, $t11" */
name|newtok
index|[
literal|0
index|]
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_T11
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
name|insXl_op
index|[
name|lgsize
index|]
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "insXh src, $at, $t12" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_T12
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
name|insXh_op
index|[
name|lgsize
index|]
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "mskXl $t9, $at, $t9" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|2
index|]
operator|=
name|newtok
index|[
literal|0
index|]
expr_stmt|;
name|assemble_tokens
argument_list|(
name|mskXl_op
index|[
name|lgsize
index|]
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "mskXh $t10, $at, $t10" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|2
index|]
operator|=
name|newtok
index|[
literal|0
index|]
expr_stmt|;
name|assemble_tokens
argument_list|(
name|mskXh_op
index|[
name|lgsize
index|]
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "or $t9, $t11, $t9" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_T11
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|2
index|]
operator|=
name|newtok
index|[
literal|0
index|]
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"or"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "or $t10, $t12, $t10" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_T12
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|2
index|]
operator|=
name|newtok
index|[
literal|0
index|]
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"or"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "stq_u $t9, 0($at)" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"stq_u"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "stq_u $t10, size-1($at)" */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
operator|(
literal|1
operator|<<
name|lgsize
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"stq_u"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sign extend a half-word or byte.  The 32-bit sign extend is    implemented as "addl $31, $r, $t" in the opcode table.  */
end_comment

begin_function
specifier|static
name|void
name|emit_sextX
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|vlgsize
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|vlgsize
decl_stmt|;
block|{
name|long
name|lgsize
init|=
operator|(
name|long
operator|)
name|vlgsize
decl_stmt|;
if|if
condition|(
name|alpha_target
operator|&
name|AXP_OPCODE_BWX
condition|)
name|assemble_tokens
argument_list|(
name|sextX_op
index|[
name|lgsize
index|]
argument_list|,
name|tok
argument_list|,
name|ntok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|bitshift
init|=
literal|64
operator|-
literal|8
operator|*
operator|(
literal|1
operator|<<
name|lgsize
operator|)
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
comment|/* emit "sll src,bits,dst" */
name|newtok
index|[
literal|0
index|]
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|bitshift
argument_list|)
expr_stmt|;
name|newtok
index|[
literal|2
index|]
operator|=
name|tok
index|[
name|ntok
operator|-
literal|1
index|]
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"sll"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emit "sra dst,bits,dst" */
name|newtok
index|[
literal|0
index|]
operator|=
name|newtok
index|[
literal|2
index|]
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"sra"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement the division and modulus macros.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_EVAX
end_ifdef

begin_comment
comment|/* Make register usage like in normal procedure call.    Don't clobber PV and RA.  */
end_comment

begin_function
specifier|static
name|void
name|emit_division
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|symname
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|symname
decl_stmt|;
block|{
comment|/* DIVISION and MODULUS. Yech.    *    * Convert    *    OP x,y,result    * to    *    mov x,R16	# if x != R16    *    mov y,R17	# if y != R17    *    lda AT,__OP    *    jsr AT,(AT),0    *    mov R0,result    *    * with appropriate optimizations if R0,R16,R17 are the registers    * specified by the compiler.    */
name|int
name|xr
decl_stmt|,
name|yr
decl_stmt|,
name|rr
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
name|xr
operator|=
name|regno
argument_list|(
name|tok
index|[
literal|0
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|yr
operator|=
name|regno
argument_list|(
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|<
literal|3
condition|)
name|rr
operator|=
name|xr
expr_stmt|;
else|else
name|rr
operator|=
name|regno
argument_list|(
name|tok
index|[
literal|2
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
comment|/* Move the operands into the right place */
if|if
condition|(
name|yr
operator|==
name|AXP_REG_R16
operator|&&
name|xr
operator|==
name|AXP_REG_R17
condition|)
block|{
comment|/* They are in exactly the wrong order -- swap through AT */
if|if
condition|(
name|alpha_noat_on
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at register while noat in effect"
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_R16
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_R17
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_R16
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_R17
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|yr
operator|==
name|AXP_REG_R16
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_R16
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_R17
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xr
operator|!=
name|AXP_REG_R16
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|xr
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_R16
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yr
operator|!=
name|AXP_REG_R16
operator|&&
name|yr
operator|!=
name|AXP_REG_R17
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|yr
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_R17
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|symname
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|set_tok_sym
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"lda"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Call the division routine */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|set_tok_cpreg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"jsr"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Move the result to the right place */
if|if
condition|(
name|rr
operator|!=
name|AXP_REG_R0
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_R0
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !OBJ_EVAX */
end_comment

begin_function
specifier|static
name|void
name|emit_division
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|symname
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|symname
decl_stmt|;
block|{
comment|/* DIVISION and MODULUS. Yech.    * Convert    *    OP x,y,result    * to    *    lda pv,__OP    *    mov x,t10    *    mov y,t11    *    jsr t9,(pv),__OP    *    mov t12,result    *    * with appropriate optimizations if t10,t11,t12 are the registers    * specified by the compiler.    */
name|int
name|xr
decl_stmt|,
name|yr
decl_stmt|,
name|rr
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
name|xr
operator|=
name|regno
argument_list|(
name|tok
index|[
literal|0
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|yr
operator|=
name|regno
argument_list|(
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|<
literal|3
condition|)
name|rr
operator|=
name|xr
expr_stmt|;
else|else
name|rr
operator|=
name|regno
argument_list|(
name|tok
index|[
literal|2
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|symname
argument_list|)
expr_stmt|;
comment|/* Move the operands into the right place */
if|if
condition|(
name|yr
operator|==
name|AXP_REG_T10
operator|&&
name|xr
operator|==
name|AXP_REG_T11
condition|)
block|{
comment|/* They are in exactly the wrong order -- swap through AT */
if|if
condition|(
name|alpha_noat_on
condition|)
name|as_bad
argument_list|(
literal|"macro requires $at register while noat in effect"
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T11
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_AT
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_T11
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|yr
operator|==
name|AXP_REG_T10
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_T11
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xr
operator|!=
name|AXP_REG_T10
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|xr
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_T10
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yr
operator|!=
name|AXP_REG_T10
operator|&&
name|yr
operator|!=
name|AXP_REG_T11
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|yr
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|AXP_REG_T11
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Call the division routine */
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|set_tok_sym
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"jsr"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Reload the GP register */
ifdef|#
directive|ifdef
name|OBJ_AOUT
name|FIXME
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ECOFF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|alpha_gp_register
argument_list|)
decl_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_T9
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldgp"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Move the result to the right place */
if|if
condition|(
name|rr
operator|!=
name|AXP_REG_T12
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_T12
argument_list|)
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"mov"
argument_list|,
name|newtok
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OBJ_EVAX */
end_comment

begin_comment
comment|/* The jsr and jmp macros differ from their instruction counterparts    in that they can load the target address and default most    everything.  */
end_comment

begin_function
specifier|static
name|void
name|emit_jsrjmp
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|vopname
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|vopname
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opname
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|vopname
decl_stmt|;
name|struct
name|alpha_insn
name|insn
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
name|int
name|r
decl_stmt|,
name|tokidx
init|=
literal|0
decl_stmt|,
name|lituse
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tokidx
operator|<
name|ntok
operator|&&
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|r
operator|=
name|regno
argument_list|(
name|tok
index|[
name|tokidx
operator|++
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"jmp"
argument_list|)
operator|==
literal|0
condition|?
name|AXP_REG_ZERO
else|:
name|AXP_REG_RA
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokidx
operator|<
name|ntok
operator|&&
operator|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|==
name|O_pregister
operator|||
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|==
name|O_cpregister
operator|)
condition|)
name|r
operator|=
name|regno
argument_list|(
name|tok
index|[
name|tokidx
operator|++
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_EVAX
comment|/* keep register if jsr $n.<sym>  */
else|#
directive|else
else|else
block|{
name|int
name|basereg
init|=
name|alpha_gp_register
decl_stmt|;
name|lituse
operator|=
name|load_expression
argument_list|(
name|r
operator|=
name|AXP_REG_PV
argument_list|,
operator|&
name|tok
index|[
name|tokidx
index|]
argument_list|,
operator|&
name|basereg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|set_tok_cpreg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|r
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_EVAX
comment|/* FIXME: Add hint relocs to BFD for evax.  */
else|#
directive|else
if|if
condition|(
name|tokidx
operator|<
name|ntok
condition|)
name|newtok
index|[
literal|2
index|]
operator|=
name|tok
index|[
name|tokidx
index|]
expr_stmt|;
else|else
endif|#
directive|endif
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_tokens_to_insn
argument_list|(
name|opname
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
comment|/* add the LITUSE fixup */
if|if
condition|(
name|lituse
condition|)
block|{
name|assert
argument_list|(
name|insn
operator|.
name|nfixups
operator|<
name|MAX_INSN_FIXUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|nfixups
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|insn
operator|.
name|fixups
index|[
literal|1
index|]
argument_list|,
operator|&
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_fixup
argument_list|)
operator|*
name|insn
operator|.
name|nfixups
argument_list|)
expr_stmt|;
block|}
name|insn
operator|.
name|nfixups
operator|++
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_ALPHA_LITUSE
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|insn
operator|.
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|3
expr_stmt|;
block|}
name|emit_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_EVAX
name|alpha_basereg_clobbered
operator|=
literal|0
expr_stmt|;
comment|/* reload PV from 0(FP) if it is our current base register.  */
if|if
condition|(
name|alpha_gp_register
operator|==
name|AXP_REG_PV
condition|)
block|{
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|AXP_REG_PV
argument_list|)
expr_stmt|;
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_tok_preg
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|AXP_REG_FP
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
literal|"ldq"
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The ret and jcr instructions differ from their instruction    counterparts in that everything can be defaulted.  */
end_comment

begin_function
specifier|static
name|void
name|emit_retjcr
parameter_list|(
name|tok
parameter_list|,
name|ntok
parameter_list|,
name|vopname
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|const
name|PTR
name|vopname
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opname
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|vopname
decl_stmt|;
name|expressionS
name|newtok
index|[
literal|3
index|]
decl_stmt|;
name|int
name|r
decl_stmt|,
name|tokidx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tokidx
operator|<
name|ntok
operator|&&
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|r
operator|=
name|regno
argument_list|(
name|tok
index|[
name|tokidx
operator|++
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|AXP_REG_ZERO
expr_stmt|;
name|set_tok_reg
argument_list|(
name|newtok
index|[
literal|0
index|]
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokidx
operator|<
name|ntok
operator|&&
operator|(
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|==
name|O_pregister
operator|||
name|tok
index|[
name|tokidx
index|]
operator|.
name|X_op
operator|==
name|O_cpregister
operator|)
condition|)
name|r
operator|=
name|regno
argument_list|(
name|tok
index|[
name|tokidx
operator|++
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|AXP_REG_RA
expr_stmt|;
name|set_tok_cpreg
argument_list|(
name|newtok
index|[
literal|1
index|]
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokidx
operator|<
name|ntok
condition|)
name|newtok
index|[
literal|2
index|]
operator|=
name|tok
index|[
name|tokidx
index|]
expr_stmt|;
else|else
name|set_tok_const
argument_list|(
name|newtok
index|[
literal|2
index|]
argument_list|,
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"ret"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assemble_tokens
argument_list|(
name|opname
argument_list|,
name|newtok
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assembler directives */
end_comment

begin_comment
comment|/* Handle the .text pseudo-op.  This is like the usual one, but it    clears alpha_insn_label and restores auto alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_text
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|s_text
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|alpha_auto_align_on
operator|=
literal|1
expr_stmt|;
name|alpha_current_align
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .data pseudo-op.  This is like the usual one, but it    clears alpha_insn_label and restores auto alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_data
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|s_data
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|alpha_auto_align_on
operator|=
literal|1
expr_stmt|;
name|alpha_current_align
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_comment
comment|/* Handle the OSF/1 .comm pseudo quirks.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_comm
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|offsetT
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Alpha OSF/1 compiler doesn't provide the comma, gcc does.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|".COMMon length (%ld.)<0! Ignored."
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Ignoring attempt to re-define symbol"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
operator|(
name|valueT
operator|)
name|temp
condition|)
name|as_bad
argument_list|(
literal|"Length of .comm \"%s\" is already %ld. Not changed to %ld."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! OBJ_ELF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_comment
comment|/* Handle the .rdata pseudo-op.  This is like the usual one, but it    clears alpha_insn_label and restores auto alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_rdata
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
literal|".rdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|alpha_auto_align_on
operator|=
literal|1
expr_stmt|;
name|alpha_current_align
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_comment
comment|/* Handle the .sdata pseudo-op.  This is like the usual one, but it    clears alpha_insn_label and restores auto alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_sdata
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
literal|".sdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|alpha_auto_align_on
operator|=
literal|1
expr_stmt|;
name|alpha_current_align
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Handle the .section pseudo-op.  This is like the usual one, but it    clears alpha_insn_label and restores auto alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_section
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|obj_elf_section
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|alpha_auto_align_on
operator|=
literal|1
expr_stmt|;
name|alpha_current_align
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_EVAX
end_ifdef

begin_comment
comment|/* Handle the section specific pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_section
parameter_list|(
name|secid
parameter_list|)
name|int
name|secid
decl_stmt|;
block|{
name|int
name|temp
decl_stmt|;
define|#
directive|define
name|EVAX_SECTION_COUNT
value|6
specifier|static
name|char
modifier|*
name|section_name
index|[
name|EVAX_SECTION_COUNT
operator|+
literal|1
index|]
init|=
block|{
literal|"NULL"
block|,
literal|".rdata"
block|,
literal|".comm"
block|,
literal|".link"
block|,
literal|".ctors"
block|,
literal|".dtors"
block|,
literal|".lcomm"
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|secid
operator|<=
literal|0
operator|)
operator|||
operator|(
name|secid
operator|>
name|EVAX_SECTION_COUNT
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Unknown section directive"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
name|section_name
index|[
name|secid
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|alpha_auto_align_on
operator|=
literal|1
expr_stmt|;
name|alpha_current_align
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .prologue */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_prologue
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|alpha_basereg_clobbered
operator|=
literal|0
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse .ent directives.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_ent
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|expressionS
name|symexpr
decl_stmt|;
name|alpha_evax_proc
operator|.
name|pdsckind
operator|=
literal|0
expr_stmt|;
name|alpha_evax_proc
operator|.
name|framereg
operator|=
operator|-
literal|1
expr_stmt|;
name|alpha_evax_proc
operator|.
name|framesize
operator|=
literal|0
expr_stmt|;
name|alpha_evax_proc
operator|.
name|rsa_offset
operator|=
literal|0
expr_stmt|;
name|alpha_evax_proc
operator|.
name|ra_save
operator|=
name|AXP_REG_RA
expr_stmt|;
name|alpha_evax_proc
operator|.
name|fp_save
operator|=
operator|-
literal|1
expr_stmt|;
name|alpha_evax_proc
operator|.
name|imask
operator|=
literal|0
expr_stmt|;
name|alpha_evax_proc
operator|.
name|fmask
operator|=
literal|0
expr_stmt|;
name|alpha_evax_proc
operator|.
name|prologue
operator|=
literal|0
expr_stmt|;
name|alpha_evax_proc
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|expression
argument_list|(
operator|&
name|symexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|symexpr
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_fatal
argument_list|(
literal|".ent directive has no symbol"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|symexpr
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|alpha_evax_proc
operator|.
name|symbol
operator|=
name|symbol
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse .frame<framreg>,<framesize>,RA,<rsa_offset> directives.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_frame
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|long
name|val
decl_stmt|;
name|alpha_evax_proc
operator|.
name|framereg
operator|=
name|tc_get_register
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
operator|||
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|val
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bad .frame directive 1./2. param"
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|alpha_evax_proc
operator|.
name|framesize
operator|=
name|val
expr_stmt|;
operator|(
name|void
operator|)
name|tc_get_register
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bad .frame directive 3./4. param"
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|alpha_evax_proc
operator|.
name|rsa_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|s_alpha_pdesc
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
name|long
name|val
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|symbolS
modifier|*
name|entry_sym
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|alpha_link_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|now_seg
operator|!=
name|alpha_link_section
condition|)
block|{
name|as_bad
argument_list|(
literal|".pdesc directive not in link (.link) section"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|alpha_evax_proc
operator|.
name|symbol
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|alpha_evax_proc
operator|.
name|symbol
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|".pdesc has no matching .ent"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|alpha_evax_proc
operator|.
name|symbol
operator|->
name|sy_obj
operator|=
operator|(
name|valueT
operator|)
name|seginfo
operator|->
name|literal_pool_size
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_warn
argument_list|(
literal|".pdesc directive has no entry symbol"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|entry_sym
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
comment|/* Save bfd symbol of proc desc in function symbol.  */
name|alpha_evax_proc
operator|.
name|symbol
operator|->
name|bsym
operator|->
name|udata
operator|.
name|p
operator|=
operator|(
name|PTR
operator|)
name|entry_sym
operator|->
name|bsym
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"No comma after .pdesc<entryname>"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"stack"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alpha_evax_proc
operator|.
name|pdsckind
operator|=
name|PDSC_S_K_KIND_FP_STACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"reg"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alpha_evax_proc
operator|.
name|pdsckind
operator|=
name|PDSC_S_K_KIND_FP_REGISTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"null"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alpha_evax_proc
operator|.
name|pdsckind
operator|=
name|PDSC_S_K_KIND_NULL
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
literal|"unknown procedure kind"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|frag_align
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|fixp
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|seginfo
operator|->
name|literal_pool_size
operator|+=
literal|16
expr_stmt|;
operator|*
name|p
operator|=
name|alpha_evax_proc
operator|.
name|pdsckind
operator||
operator|(
operator|(
name|alpha_evax_proc
operator|.
name|framereg
operator|==
literal|29
operator|)
condition|?
name|PDSC_S_M_BASE_REG_IS_FP
else|:
literal|0
operator|)
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
name|PDSC_S_M_NATIVE
operator||
name|PDSC_S_M_NO_JACKET
expr_stmt|;
switch|switch
condition|(
name|alpha_evax_proc
operator|.
name|pdsckind
condition|)
block|{
case|case
name|PDSC_S_K_KIND_NULL
case|:
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PDSC_S_K_KIND_FP_REGISTER
case|:
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
operator|=
name|alpha_evax_proc
operator|.
name|fp_save
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
operator|=
name|alpha_evax_proc
operator|.
name|ra_save
expr_stmt|;
break|break;
case|case
name|PDSC_S_K_KIND_FP_STACK
case|:
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|2
argument_list|,
operator|(
name|valueT
operator|)
name|alpha_evax_proc
operator|.
name|rsa_offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* impossible */
break|break;
block|}
operator|*
operator|(
name|p
operator|+
literal|4
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|5
operator|)
operator|=
name|alpha_evax_proc
operator|.
name|type
operator|&
literal|0x0f
expr_stmt|;
comment|/* Signature offset.  */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|6
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
literal|8
argument_list|,
literal|8
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_64
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_evax_proc
operator|.
name|pdsckind
operator|==
name|PDSC_S_K_KIND_NULL
condition|)
return|return;
comment|/* Add dummy fix to make add_to_link_pool work.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|fixp
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|seginfo
operator|->
name|literal_pool_size
operator|+=
literal|8
expr_stmt|;
comment|/* pdesc+16: Size.  */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|alpha_evax_proc
operator|.
name|framesize
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|4
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Entry length.  */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|6
argument_list|,
name|alpha_evax_proc
operator|.
name|prologue
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_evax_proc
operator|.
name|pdsckind
operator|==
name|PDSC_S_K_KIND_FP_REGISTER
condition|)
return|return;
comment|/* Add dummy fix to make add_to_link_pool work.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|fixp
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|seginfo
operator|->
name|literal_pool_size
operator|+=
literal|8
expr_stmt|;
comment|/* pdesc+24: register masks.  */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|alpha_evax_proc
operator|.
name|imask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|4
argument_list|,
name|alpha_evax_proc
operator|.
name|fmask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Support for crash debug on vms.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_name
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|alpha_link_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|now_seg
operator|!=
name|alpha_link_section
condition|)
block|{
name|as_bad
argument_list|(
literal|".name directive not in link (.link) section"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_warn
argument_list|(
literal|".name directive has no symbol"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|frag_align
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|literal_pool_size
operator|+=
literal|8
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_64
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|s_alpha_linkage
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_fatal
argument_list|(
literal|"No symbol after .linkage"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|LKP_S_K_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|LKP_S_K_SIZE
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|LKP_S_K_SIZE
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,\
name|BFD_RELOC_ALPHA_LINKAGE
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|s_alpha_code_address
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_fatal
argument_list|(
literal|"No symbol after .code_address"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,\
name|BFD_RELOC_ALPHA_CODEADDR
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|s_alpha_fp_save
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|alpha_evax_proc
operator|.
name|fp_save
operator|=
name|tc_get_register
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|s_alpha_mask
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|long
name|val
decl_stmt|;
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|val
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bad .mask directive"
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|alpha_evax_proc
operator|.
name|imask
operator|=
name|val
expr_stmt|;
operator|(
name|void
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|s_alpha_fmask
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|long
name|val
decl_stmt|;
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|val
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bad .fmask directive"
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|alpha_evax_proc
operator|.
name|fmask
operator|=
name|val
expr_stmt|;
operator|(
name|void
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|s_alpha_end
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|alpha_evax_proc
operator|.
name|symbol
operator|=
literal|0
expr_stmt|;
name|alpha_basereg_clobbered
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|s_alpha_file
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|symbolS
modifier|*
name|s
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|static
name|char
name|case_hack
index|[
literal|32
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|demand_copy_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
name|lenP
operator|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|case_hack
argument_list|,
literal|"<CASE:%01d%01d>"
argument_list|,
name|alpha_flag_hash_long_names
argument_list|,
name|alpha_flag_show_after_trunc
argument_list|)
expr_stmt|;
name|s
operator|=
name|symbol_find_or_make
argument_list|(
name|case_hack
argument_list|)
expr_stmt|;
name|s
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_FILE
expr_stmt|;
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|s
operator|=
name|symbol_find_or_make
argument_list|(
name|demand_copy_string
argument_list|(
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_FILE
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_EVAX  */
end_comment

begin_comment
comment|/* Handle the .gprel32 pseudo op.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_gprel32
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|expression
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
switch|switch
condition|(
name|e
operator|.
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
name|e
operator|.
name|X_add_symbol
operator|=
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|O_symbol
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|OBJ_ECOFF
switch|switch
condition|(
name|e
operator|.
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
name|e
operator|.
name|X_add_symbol
operator|=
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|O_symbol
case|:
name|e
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|e
operator|.
name|X_op_symbol
operator|=
name|alpha_gp_symbol
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|alpha_auto_align_on
operator|&&
name|alpha_current_align
operator|<
literal|2
condition|)
name|alpha_align
argument_list|(
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|alpha_insn_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_current_align
operator|>
literal|2
condition|)
name|alpha_current_align
operator|=
literal|2
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|e
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_GPREL32
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle floating point allocation pseudo-ops.  This is like the    generic vresion, but it makes sure the current label, if any, is    correctly aligned.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_float_cons
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|int
name|log_size
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|log_size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'G'
case|:
name|log_size
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|log_size
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|alpha_auto_align_on
operator|&&
name|alpha_current_align
operator|<
name|log_size
condition|)
name|alpha_align
argument_list|(
name|log_size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|alpha_insn_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_current_align
operator|>
name|log_size
condition|)
name|alpha_current_align
operator|=
name|log_size
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|float_cons
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .proc pseudo op.  We don't really do much with it except    parse it.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_proc
parameter_list|(
name|is_static
parameter_list|)
name|int
name|is_static
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|temp
decl_stmt|;
comment|/* Takes ".proc name,nargs"  */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
comment|/*  symbolP->sy_other = (signed char) temp; */
name|as_warn
argument_list|(
literal|"unhandled: .proc %s,%d"
argument_list|,
name|name
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .set pseudo op.  This is used to turn on and off most of    the assembler features.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_set
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|,
name|ch
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|yesno
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|ch
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|yesno
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"reorder"
argument_list|,
name|s
argument_list|)
condition|)
comment|/* ignore */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"at"
argument_list|,
name|s
argument_list|)
condition|)
name|alpha_noat_on
operator|=
operator|!
name|yesno
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"macro"
argument_list|,
name|s
argument_list|)
condition|)
name|alpha_macros_on
operator|=
name|yesno
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"move"
argument_list|,
name|s
argument_list|)
condition|)
comment|/* ignore */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"volatile"
argument_list|,
name|s
argument_list|)
condition|)
comment|/* ignore */
empty_stmt|;
else|else
name|as_warn
argument_list|(
literal|"Tried to .set unrecognized mode `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .base pseudo op.  This changes the assembler's notion of    the $gp register.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_base
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|if (first_32bit_quadrant)     {
comment|/* not fatal, but it might not work in the end */
block|as_warn ("File overrides no-base-register option.");       first_32bit_quadrant = 0;     }
endif|#
directive|endif
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'$'
condition|)
block|{
comment|/* $rNN form */
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'r'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|alpha_gp_register
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|alpha_gp_register
operator|<
literal|0
operator|||
name|alpha_gp_register
operator|>
literal|31
condition|)
block|{
name|alpha_gp_register
operator|=
name|AXP_REG_GP
expr_stmt|;
name|as_warn
argument_list|(
literal|"Bad base register, using $%d."
argument_list|,
name|alpha_gp_register
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .align pseudo-op.  This aligns to a power of two.  It    also adjusts any current instruction label.  We treat this the same    way the MIPS port does: .align 0 turns off auto alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_align
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
name|char
name|fill
decl_stmt|,
modifier|*
name|pfill
decl_stmt|;
name|long
name|max_alignment
init|=
literal|15
decl_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|max_alignment
condition|)
block|{
name|align
operator|=
name|max_alignment
expr_stmt|;
name|as_bad
argument_list|(
literal|"Alignment too large: %d. assumed"
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Alignment negative: 0 assumed"
argument_list|)
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|pfill
operator|=
operator|&
name|fill
expr_stmt|;
block|}
else|else
name|pfill
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
block|{
name|alpha_auto_align_on
operator|=
literal|1
expr_stmt|;
name|alpha_align
argument_list|(
name|align
argument_list|,
name|pfill
argument_list|,
name|alpha_insn_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alpha_auto_align_on
operator|=
literal|0
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hook the normal string processor to reset known alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_stringer
parameter_list|(
name|terminate
parameter_list|)
name|int
name|terminate
decl_stmt|;
block|{
name|alpha_current_align
operator|=
literal|0
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|stringer
argument_list|(
name|terminate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hook the normal space processing to reset known alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_alpha_space
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|alpha_current_align
operator|=
literal|0
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
name|s_space
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hook into cons for auto-alignment.  */
end_comment

begin_function
name|void
name|alpha_cons_align
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|log_size
decl_stmt|;
name|log_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|size
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|++
name|log_size
expr_stmt|;
if|if
condition|(
name|alpha_auto_align_on
operator|&&
name|alpha_current_align
operator|<
name|log_size
condition|)
name|alpha_align
argument_list|(
name|log_size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|alpha_insn_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_current_align
operator|>
name|log_size
condition|)
name|alpha_current_align
operator|=
name|log_size
expr_stmt|;
name|alpha_insn_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG1
end_ifdef

begin_comment
comment|/* print token expression with alpha specific extension.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_print_token
parameter_list|(
name|f
parameter_list|,
name|exp
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_cpregister
case|:
name|putc
argument_list|(
literal|','
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|O_pregister
case|:
name|putc
argument_list|(
literal|'('
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|{
name|expressionS
name|nexp
init|=
operator|*
name|exp
decl_stmt|;
name|nexp
operator|.
name|X_op
operator|=
name|O_register
expr_stmt|;
name|print_expr
argument_list|(
name|f
argument_list|,
operator|&
name|nexp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|')'
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_expr
argument_list|(
name|f
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"common"
block|,
name|s_comm
block|,
literal|0
block|}
block|,
comment|/* is this used? */
ifdef|#
directive|ifdef
name|OBJ_ECOFF
block|{
literal|"comm"
block|,
name|s_alpha_comm
block|,
literal|0
block|}
block|,
comment|/* osf1 compiler does this */
block|{
literal|"rdata"
block|,
name|s_alpha_rdata
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"text"
block|,
name|s_alpha_text
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|s_alpha_data
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ECOFF
block|{
literal|"sdata"
block|,
name|s_alpha_sdata
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"section"
block|,
name|s_alpha_section
block|,
literal|0
block|}
block|,
block|{
literal|"section.s"
block|,
name|s_alpha_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|s_alpha_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect.s"
block|,
name|s_alpha_section
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_EVAX
block|{
literal|"pdesc"
block|,
name|s_alpha_pdesc
block|,
literal|0
block|}
block|,
block|{
literal|"name"
block|,
name|s_alpha_name
block|,
literal|0
block|}
block|,
block|{
literal|"linkage"
block|,
name|s_alpha_linkage
block|,
literal|0
block|}
block|,
block|{
literal|"code_address"
block|,
name|s_alpha_code_address
block|,
literal|0
block|}
block|,
block|{
literal|"ent"
block|,
name|s_alpha_ent
block|,
literal|0
block|}
block|,
block|{
literal|"frame"
block|,
name|s_alpha_frame
block|,
literal|0
block|}
block|,
block|{
literal|"fp_save"
block|,
name|s_alpha_fp_save
block|,
literal|0
block|}
block|,
block|{
literal|"mask"
block|,
name|s_alpha_mask
block|,
literal|0
block|}
block|,
block|{
literal|"fmask"
block|,
name|s_alpha_fmask
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|s_alpha_end
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|s_alpha_file
block|,
literal|0
block|}
block|,
block|{
literal|"rdata"
block|,
name|s_alpha_section
block|,
literal|1
block|}
block|,
block|{
literal|"comm"
block|,
name|s_alpha_section
block|,
literal|2
block|}
block|,
block|{
literal|"link"
block|,
name|s_alpha_section
block|,
literal|3
block|}
block|,
block|{
literal|"ctors"
block|,
name|s_alpha_section
block|,
literal|4
block|}
block|,
block|{
literal|"dtors"
block|,
name|s_alpha_section
block|,
literal|5
block|}
block|,
block|{
literal|"lcomm"
block|,
name|s_alpha_section
block|,
literal|6
block|}
block|,
endif|#
directive|endif
block|{
literal|"gprel32"
block|,
name|s_alpha_gprel32
block|,
literal|0
block|}
block|,
block|{
literal|"t_floating"
block|,
name|s_alpha_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"s_floating"
block|,
name|s_alpha_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"f_floating"
block|,
name|s_alpha_float_cons
block|,
literal|'F'
block|}
block|,
block|{
literal|"g_floating"
block|,
name|s_alpha_float_cons
block|,
literal|'G'
block|}
block|,
block|{
literal|"d_floating"
block|,
name|s_alpha_float_cons
block|,
literal|'D'
block|}
block|,
block|{
literal|"proc"
block|,
name|s_alpha_proc
block|,
literal|0
block|}
block|,
block|{
literal|"aproc"
block|,
name|s_alpha_proc
block|,
literal|1
block|}
block|,
block|{
literal|"set"
block|,
name|s_alpha_set
block|,
literal|0
block|}
block|,
block|{
literal|"reguse"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"livereg"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"base"
block|,
name|s_alpha_base
block|,
literal|0
block|}
block|,
comment|/*??*/
block|{
literal|"option"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"prologue"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"aent"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ugen"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"eflag"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"align"
block|,
name|s_alpha_align
block|,
literal|0
block|}
block|,
block|{
literal|"double"
block|,
name|s_alpha_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"float"
block|,
name|s_alpha_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"single"
block|,
name|s_alpha_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"ascii"
block|,
name|s_alpha_stringer
block|,
literal|0
block|}
block|,
block|{
literal|"asciz"
block|,
name|s_alpha_stringer
block|,
literal|1
block|}
block|,
block|{
literal|"string"
block|,
name|s_alpha_stringer
block|,
literal|1
block|}
block|,
block|{
literal|"space"
block|,
name|s_alpha_space
block|,
literal|0
block|}
block|,
block|{
literal|"skip"
block|,
name|s_alpha_space
block|,
literal|0
block|}
block|,
block|{
literal|"zero"
block|,
name|s_alpha_space
block|,
literal|0
block|}
block|,
comment|/* We don't do any optimizing, so we can safely ignore these.  */
block|{
literal|"noalias"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"alias"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Build a BFD section with its flags set appropriately for the .lita,    .lit8, or .lit4 sections.  */
end_comment

begin_function
specifier|static
name|void
name|create_literal_section
parameter_list|(
name|name
parameter_list|,
name|secp
parameter_list|,
name|symp
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|segT
modifier|*
name|secp
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|symp
decl_stmt|;
block|{
name|segT
name|current_section
init|=
name|now_seg
decl_stmt|;
name|int
name|current_subsec
init|=
name|now_subseg
decl_stmt|;
name|segT
name|new_sec
decl_stmt|;
operator|*
name|secp
operator|=
name|new_sec
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_section
argument_list|,
name|current_subsec
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|new_sec
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|new_sec
argument_list|,
name|SEC_RELOC
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
operator|*
name|symp
operator|=
name|section_symbol
argument_list|(
name|new_sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ECOFF
end_ifdef

begin_comment
comment|/* @@@ GP selection voodoo.  All of this seems overly complicated and    unnecessary; which is the primary reason it's for ECOFF only.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|maybe_set_gp
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|bfd_vma
name|vma
decl_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
return|return;
name|vma
operator|=
name|bfd_get_section_vma
argument_list|(
name|foo
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|vma
operator|&&
name|vma
operator|<
name|alpha_gp_value
condition|)
name|alpha_gp_value
operator|=
name|vma
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|select_gp_value
parameter_list|()
block|{
name|assert
argument_list|(
name|alpha_gp_value
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Get minus-one in whatever width...  */
name|alpha_gp_value
operator|=
literal|0
expr_stmt|;
name|alpha_gp_value
operator|--
expr_stmt|;
comment|/* Select the smallest VMA of these existing sections.  */
name|maybe_set_gp
argument_list|(
name|alpha_lita_section
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* These were disabled before -- should we use them?  */
block|maybe_set_gp (sdata);   maybe_set_gp (lit8_sec);   maybe_set_gp (lit4_sec);
endif|#
directive|endif
comment|/* @@ Will a simple 0x8000 work here?  If not, why not?  */
define|#
directive|define
name|GP_ADJUSTMENT
value|(0x8000 - 0x10)
name|alpha_gp_value
operator|+=
name|GP_ADJUSTMENT
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|alpha_gp_symbol
argument_list|,
name|alpha_gp_value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG1
name|printf
argument_list|(
literal|"Chose GP value of %lx\n"
argument_list|,
name|alpha_gp_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ECOFF */
end_comment

begin_comment
comment|/* Called internally to handle all alignment needs.  This takes care    of eliding calls to frag_align if'n the cached current alignment    says we've already got it, as well as taking care of the auto-align    feature wrt labels.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_align
parameter_list|(
name|n
parameter_list|,
name|pfill
parameter_list|,
name|label
parameter_list|)
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|pfill
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
block|{
if|if
condition|(
name|alpha_current_align
operator|>=
name|n
condition|)
return|return;
if|if
condition|(
name|pfill
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|2
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|static
name|char
specifier|const
name|nop
index|[
literal|4
index|]
init|=
block|{
literal|0x1f
block|,
literal|0x04
block|,
literal|0xff
block|,
literal|0x47
block|}
decl_stmt|;
comment|/* First, make sure we're on a four-byte boundary, in case 	     someone has been putting .byte values into the text 	     section.  The DEC assembler silently fills with unaligned 	     no-op instructions.  This will zero-fill, then nop-fill 	     with proper alignment.  */
if|if
condition|(
name|alpha_current_align
operator|<
literal|2
condition|)
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|frag_align_pattern
argument_list|(
name|n
argument_list|,
name|nop
argument_list|,
sizeof|sizeof
name|nop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|frag_align
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|frag_align
argument_list|(
name|n
argument_list|,
operator|*
name|pfill
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alpha_current_align
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|label
argument_list|)
operator|==
name|now_seg
argument_list|)
expr_stmt|;
name|label
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The Alpha has support for some VAX floating point types, as well as for    IEEE floating point.  We consider IEEE to be the primary floating point    format, and sneak in the VAX floating point support here.  */
end_comment

begin_define
define|#
directive|define
name|md_atof
value|vax_md_atof
end_define

begin_include
include|#
directive|include
file|"config/atof-vax.c"
end_include

end_unit

