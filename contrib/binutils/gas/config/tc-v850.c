begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-v850.c -- Assembler code for the NEC V850    Copyright (C) 1996, 1997, 1998 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/v850.h"
end_include

begin_define
define|#
directive|define
name|AREA_ZDA
value|0
end_define

begin_define
define|#
directive|define
name|AREA_SDA
value|1
end_define

begin_define
define|#
directive|define
name|AREA_TDA
value|2
end_define

begin_comment
comment|/* sign-extend a 16-bit number */
end_comment

begin_define
define|#
directive|define
name|SEXT16
parameter_list|(
name|x
parameter_list|)
value|((((x)& 0xffff) ^ (~ 0x7fff)) + 0x8000)
end_define

begin_comment
comment|/* Temporarily holds the reloc in a cons expression.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|hold_cons_reloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to TRUE if we want to be pedantic about signed overflows.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|warn_signed_overflows
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|warn_unsigned_overflows
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates the target BFD machine number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|machine
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates the target processor(s) for the assemble.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|processor_mask
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Structure to hold information about predefined registers.  */
end_comment

begin_struct
struct|struct
name|reg_name
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Generic assembler global variables which must be defined by all targets. */
end_comment

begin_comment
comment|/* Characters which always start a comment. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|";#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a     single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating     point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,     as in 0d1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* Conditional branches.  */
block|{
literal|0xff
block|,
operator|-
literal|0x100
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|0x1fffff
block|,
operator|-
literal|0x200000
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* Unconditional branches.  */
block|{
literal|0xff
block|,
operator|-
literal|0x100
block|,
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|0x1fffff
block|,
operator|-
literal|0x200000
block|,
literal|4
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|sdata_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|tdata_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|zdata_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|sbss_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|tbss_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|zbss_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|rosdata_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|rozdata_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|scommon_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|tcommon_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|zcommon_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fixups */
end_comment

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|(5)
end_define

begin_struct
struct|struct
name|v850_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|v850_fixup
name|fixups
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fc
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|v850_sdata
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|sdata_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|v850_tdata
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|tdata_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|v850_zdata
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|zdata_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|v850_sbss
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|sbss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|v850_tbss
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|tbss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|v850_zbss
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|zbss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|v850_rosdata
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|rosdata_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|v850_rozdata
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|rozdata_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|v850_bss
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
specifier|register
name|int
name|temp
init|=
name|get_absolute_expression
argument_list|()
decl_stmt|;
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|v850_offset
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|int
name|temp
init|=
name|get_absolute_expression
argument_list|()
decl_stmt|;
name|temp
operator|-=
name|frag_now_fix
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|frag_more
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copied from obj_elf_common() in gas/config/obj-elf.c */
end_comment

begin_function
specifier|static
name|void
name|v850_comm
parameter_list|(
name|area
parameter_list|)
name|int
name|area
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|have_align
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after symbol-name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|".COMMon length (%d.)<0! Ignored."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|temp
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Ignoring attempt to re-define symbol"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|size
condition|)
block|{
name|as_warn
argument_list|(
literal|"Length of .comm \"%s\" is already %ld. Not changed to %d."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|have_align
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|have_align
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_align
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|!
name|have_align
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Common alignment negative; 0 assumed"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbolP
operator|->
name|local
condition|)
block|{
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|char
modifier|*
name|pfrag
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* allocate_bss: */
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* convert to a power of 2 alignment */
for|for
control|(
name|align
operator|=
literal|0
init|;
operator|(
name|temp
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|temp
operator|>>=
literal|1
operator|,
operator|++
name|align
control|)
empty_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"Common alignment not a power of 2"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
name|align
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|AREA_SDA
case|:
name|record_alignment
argument_list|(
name|sbss_section
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|sbss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|AREA_ZDA
case|:
name|record_alignment
argument_list|(
name|zbss_section
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|zbss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|AREA_TDA
case|:
name|record_alignment
argument_list|(
name|tbss_section
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|tbss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|align
condition|)
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|AREA_SDA
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|sbss_section
condition|)
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AREA_ZDA
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|zbss_section
condition|)
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AREA_TDA
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|tbss_section
condition|)
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
operator|(
name|offsetT
operator|)
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|AREA_SDA
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|sbss_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|AREA_ZDA
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|zbss_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|AREA_TDA
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|tbss_section
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_common
label|:
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|size
argument_list|)
expr_stmt|;
name|S_SET_ALIGN
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|AREA_SDA
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|scommon_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|AREA_ZDA
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|zcommon_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|AREA_TDA
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|tcommon_section
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* @@ Some use the dot, some don't.  Can we get some consistency??  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'.'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* @@ Some say data, some say bss.  */
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"bss\""
argument_list|,
literal|4
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"data\""
argument_list|,
literal|5
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
operator|--
name|input_line_pointer
operator|!=
literal|'"'
condition|)
empty_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
goto|goto
name|bad_common_segment
goto|;
block|}
while|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|'"'
condition|)
empty_stmt|;
goto|goto
name|allocate_common
goto|;
block|}
name|symbolP
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|{
name|bad_common_segment
label|:
name|p
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
literal|"bad .common segment %s"
argument_list|,
name|input_line_pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|void
name|set_machine
parameter_list|(
name|int
name|number
parameter_list|)
block|{
name|machine
operator|=
name|number
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|machine
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
literal|0
case|:
name|processor_mask
operator|=
name|PROCESSOR_V850
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"sdata"
block|,
name|v850_sdata
block|,
literal|0
block|}
block|,
block|{
literal|"tdata"
block|,
name|v850_tdata
block|,
literal|0
block|}
block|,
block|{
literal|"zdata"
block|,
name|v850_zdata
block|,
literal|0
block|}
block|,
block|{
literal|"sbss"
block|,
name|v850_sbss
block|,
literal|0
block|}
block|,
block|{
literal|"tbss"
block|,
name|v850_tbss
block|,
literal|0
block|}
block|,
block|{
literal|"zbss"
block|,
name|v850_zbss
block|,
literal|0
block|}
block|,
block|{
literal|"rosdata"
block|,
name|v850_rosdata
block|,
literal|0
block|}
block|,
block|{
literal|"rozdata"
block|,
name|v850_rozdata
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|v850_bss
block|,
literal|0
block|}
block|,
block|{
literal|"offset"
block|,
name|v850_offset
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"zcomm"
block|,
name|v850_comm
block|,
name|AREA_ZDA
block|}
block|,
block|{
literal|"scomm"
block|,
name|v850_comm
block|,
name|AREA_SDA
block|}
block|,
block|{
literal|"tcomm"
block|,
name|v850_comm
block|,
name|AREA_TDA
block|}
block|,
block|{
literal|"v850"
block|,
name|set_machine
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|v850_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is sorted. Suitable for searching by a binary search. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|pre_defined_registers
index|[]
init|=
block|{
block|{
literal|"ep"
block|,
literal|30
block|}
block|,
comment|/* ep - element ptr */
block|{
literal|"gp"
block|,
literal|4
block|}
block|,
comment|/* gp - global ptr */
block|{
literal|"hp"
block|,
literal|2
block|}
block|,
comment|/* hp - handler stack ptr */
block|{
literal|"lp"
block|,
literal|31
block|}
block|,
comment|/* lp - link ptr */
block|{
literal|"r0"
block|,
literal|0
block|}
block|,
block|{
literal|"r1"
block|,
literal|1
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|}
block|,
block|{
literal|"r16"
block|,
literal|16
block|}
block|,
block|{
literal|"r17"
block|,
literal|17
block|}
block|,
block|{
literal|"r18"
block|,
literal|18
block|}
block|,
block|{
literal|"r19"
block|,
literal|19
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|}
block|,
block|{
literal|"r20"
block|,
literal|20
block|}
block|,
block|{
literal|"r21"
block|,
literal|21
block|}
block|,
block|{
literal|"r22"
block|,
literal|22
block|}
block|,
block|{
literal|"r23"
block|,
literal|23
block|}
block|,
block|{
literal|"r24"
block|,
literal|24
block|}
block|,
block|{
literal|"r25"
block|,
literal|25
block|}
block|,
block|{
literal|"r26"
block|,
literal|26
block|}
block|,
block|{
literal|"r27"
block|,
literal|27
block|}
block|,
block|{
literal|"r28"
block|,
literal|28
block|}
block|,
block|{
literal|"r29"
block|,
literal|29
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r30"
block|,
literal|30
block|}
block|,
block|{
literal|"r31"
block|,
literal|31
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"sp"
block|,
literal|3
block|}
block|,
comment|/* sp - stack ptr */
block|{
literal|"tp"
block|,
literal|5
block|}
block|,
comment|/* tp - text ptr */
block|{
literal|"zero"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG_NAME_CNT
value|(sizeof (pre_defined_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|system_registers
index|[]
init|=
block|{
block|{
literal|"ecr"
block|,
literal|4
block|}
block|,
block|{
literal|"eipc"
block|,
literal|0
block|}
block|,
block|{
literal|"eipsw"
block|,
literal|1
block|}
block|,
block|{
literal|"fepc"
block|,
literal|2
block|}
block|,
block|{
literal|"fepsw"
block|,
literal|3
block|}
block|,
block|{
literal|"psw"
block|,
literal|5
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SYSREG_NAME_CNT
value|(sizeof (system_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|cc_names
index|[]
init|=
block|{
block|{
literal|"c"
block|,
literal|0x1
block|}
block|,
block|{
literal|"e"
block|,
literal|0x2
block|}
block|,
block|{
literal|"ge"
block|,
literal|0xe
block|}
block|,
block|{
literal|"gt"
block|,
literal|0xf
block|}
block|,
block|{
literal|"h"
block|,
literal|0xb
block|}
block|,
block|{
literal|"l"
block|,
literal|0x1
block|}
block|,
block|{
literal|"le"
block|,
literal|0x7
block|}
block|,
block|{
literal|"lt"
block|,
literal|0x6
block|}
block|,
block|{
literal|"n"
block|,
literal|0x4
block|}
block|,
block|{
literal|"nc"
block|,
literal|0x9
block|}
block|,
block|{
literal|"ne"
block|,
literal|0xa
block|}
block|,
block|{
literal|"nh"
block|,
literal|0x3
block|}
block|,
block|{
literal|"nl"
block|,
literal|0x9
block|}
block|,
block|{
literal|"ns"
block|,
literal|0xc
block|}
block|,
block|{
literal|"nv"
block|,
literal|0x8
block|}
block|,
block|{
literal|"nz"
block|,
literal|0xa
block|}
block|,
block|{
literal|"p"
block|,
literal|0xc
block|}
block|,
block|{
literal|"s"
block|,
literal|0x4
block|}
block|,
block|{
literal|"sa"
block|,
literal|0xd
block|}
block|,
block|{
literal|"t"
block|,
literal|0x5
block|}
block|,
block|{
literal|"v"
block|,
literal|0x0
block|}
block|,
block|{
literal|"z"
block|,
literal|0x2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CC_NAME_CNT
value|(sizeof (cc_names) / sizeof (struct reg_name))
end_define

begin_comment
comment|/* reg_name_search does a binary search of the given register table    to see if "name" is a valid regiter name.  Returns the register    number from the array on success, or -1 on failure. */
end_comment

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
name|regs
parameter_list|,
name|regcount
parameter_list|,
name|name
parameter_list|,
name|accept_numbers
parameter_list|)
specifier|const
name|struct
name|reg_name
modifier|*
name|regs
decl_stmt|;
name|int
name|regcount
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|accept_numbers
decl_stmt|;
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* If the register name is a symbol, then evaluate it.  */
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* If the symbol is an alias for another name then use that. 	 If the symbol is an alias for a number, then return the number.  */
if|if
condition|(
name|symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|accept_numbers
condition|)
block|{
name|int
name|reg
init|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<=
literal|31
condition|)
return|return
name|reg
return|;
block|}
block|}
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|regcount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|regs
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|regs
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().  *  * in: Input_line_pointer points to 1st char of operand.  *  * out: A expressionS.  *	The operand may have been a register: in this case, X_op == O_register,  *	X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in  *	its original state.  */
end_comment

begin_function
specifier|static
name|boolean
name|register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|pre_defined_registers
argument_list|,
name|REG_NAME_CNT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* put back the delimiting char */
comment|/* look to see if it's in the register table */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* make the rest nice */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* reset the line as if we had not done anything */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Summary of system_register_name().  *  * in:  Input_line_pointer points to 1st char of operand.  *      expressionP points to an expression structure to be filled in.  *      accept_numbers is true iff numerical register names may be used.  *  * out: A expressionS structure in expressionP.  *	The operand may have been a register: in this case, X_op == O_register,  *	X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in  *	its original state.  */
end_comment

begin_function
specifier|static
name|boolean
name|system_register_name
parameter_list|(
name|expressionP
parameter_list|,
name|accept_numbers
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
name|boolean
name|accept_numbers
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|system_registers
argument_list|,
name|SYSREG_NAME_CNT
argument_list|,
name|name
argument_list|,
name|accept_numbers
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* put back the delimiting char */
if|if
condition|(
name|reg_number
operator|<
literal|0
operator|&&
name|accept_numbers
condition|)
block|{
name|input_line_pointer
operator|=
name|start
expr_stmt|;
comment|/* reset input_line pointer */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|reg_number
operator|=
name|strtol
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|input_line_pointer
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Make sure that the register number is allowable. */
if|if
condition|(
name|reg_number
operator|<
literal|0
operator|||
name|reg_number
operator|>
literal|5
condition|)
block|{
name|reg_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* look to see if it's in the register table */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* make the rest nice */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* reset the line as if we had not done anything */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Summary of cc_name().  *  * in: Input_line_pointer points to 1st char of operand.  *  * out: A expressionS.  *	The operand may have been a register: in this case, X_op == O_register,  *	X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in  *	its original state.  */
end_comment

begin_function
specifier|static
name|boolean
name|cc_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|cc_names
argument_list|,
name|CC_NAME_CNT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* put back the delimiting char */
comment|/* look to see if it's in the register table */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* make the rest nice */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* reset the line as if we had not done anything */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|skip_white_space
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|' '
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'\t'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
name|md_longopts
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"V850 options:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-mwarn-signed-overflow    Warn if signed immediate values overflow\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-mwarn-unsigned-overflow  Warn if unsigned immediate values overflow\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-mv850                    The code is targeted at the v850\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|!=
literal|'m'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown command line option: -%c%s\n"
argument_list|,
name|c
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"warn-signed-overflow"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warn_signed_overflows
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"warn-unsigned-overflow"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warn_unsigned_overflows
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"v850"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|machine
operator|=
literal|0
expr_stmt|;
name|processor_mask
operator|=
name|PROCESSOR_V850
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown command line option: -%c%s\n"
argument_list|,
name|c
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litp
parameter_list|,
name|sizep
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litp
decl_stmt|;
name|int
modifier|*
name|sizep
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
literal|"bad call to md_atof"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizep
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litp
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Very gross.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In range conditional or unconditional branch.  */
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|0
operator|||
name|fragP
operator|->
name|fr_subtype
operator|==
literal|2
condition|)
block|{
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_UNUSED
operator|+
operator|(
name|int
operator|)
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Out of range conditional branch.  Emit a branch around a jump.  */
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
operator|)
decl_stmt|;
comment|/* Reverse the condition of the first branch.  */
name|buffer
index|[
literal|0
index|]
operator|^=
literal|0x08
expr_stmt|;
comment|/* Mask off all the displacement bits.  */
name|buffer
index|[
literal|0
index|]
operator|&=
literal|0x8f
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|&=
literal|0x07
expr_stmt|;
comment|/* Now set the displacement bits so that we branch 	 around the unconditional branch.  */
name|buffer
index|[
literal|0
index|]
operator||=
literal|0x30
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the final 	 target.  */
name|md_number_to_chars
argument_list|(
name|buffer
operator|+
literal|2
argument_list|,
literal|0x00000780
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_UNUSED
operator|+
operator|(
name|int
operator|)
name|fragP
operator|->
name|fr_opcode
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
block|}
comment|/* Out of range unconditional branch.  Emit a jump.  */
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|3
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|0x00000780
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_UNUSED
operator|+
operator|(
name|int
operator|)
name|fragP
operator|->
name|fr_opcode
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|addr
parameter_list|)
name|asection
modifier|*
name|seg
decl_stmt|;
name|valueT
name|addr
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
specifier|register
specifier|const
name|struct
name|v850_opcode
modifier|*
name|op
decl_stmt|;
name|flagword
name|applicable
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|TARGET_CPU
argument_list|,
literal|"v850"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|machine
operator|==
operator|-
literal|1
condition|)
name|machine
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|processor_mask
operator|==
operator|-
literal|1
condition|)
name|processor_mask
operator|=
name|PROCESSOR_V850
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Unable to determine default target processor from string: %s"
argument_list|,
name|TARGET_CPU
argument_list|)
expr_stmt|;
name|v850_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert unique names into hash table.  The V850 instruction set      has many identical opcode names that have different opcodes based      on the operands.  This hash table then provides a quick index to      the first opcode with a particular name in the opcode table.  */
name|op
operator|=
name|v850_opcodes
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|op
operator|->
name|name
argument_list|)
condition|)
block|{
name|prev_name
operator|=
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|name
expr_stmt|;
name|hash_insert
argument_list|(
name|v850_hash
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
name|op
operator|++
expr_stmt|;
block|}
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|machine
argument_list|)
expr_stmt|;
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|sdata_section
operator|=
name|subseg_new
argument_list|(
literal|".sdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sdata_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator|)
argument_list|)
expr_stmt|;
name|tdata_section
operator|=
name|subseg_new
argument_list|(
literal|".tdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|tdata_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator|)
argument_list|)
expr_stmt|;
name|zdata_section
operator|=
name|subseg_new
argument_list|(
literal|".zdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|zdata_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator|)
argument_list|)
expr_stmt|;
name|sbss_section
operator|=
name|subseg_new
argument_list|(
literal|".sbss"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sbss_section
argument_list|,
name|applicable
operator|&
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|sbss_section
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
name|tbss_section
operator|=
name|subseg_new
argument_list|(
literal|".tbss"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|tbss_section
argument_list|,
name|applicable
operator|&
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|tbss_section
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
name|zbss_section
operator|=
name|subseg_new
argument_list|(
literal|".zbss"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|zbss_section
argument_list|,
name|applicable
operator|&
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|zbss_section
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
name|rosdata_section
operator|=
name|subseg_new
argument_list|(
literal|".rosdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|rosdata_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
name|rozdata_section
operator|=
name|subseg_new
argument_list|(
literal|".rozdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|rozdata_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
name|scommon_section
operator|=
name|subseg_new
argument_list|(
literal|".scommon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|scommon_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IS_COMMON
operator|)
argument_list|)
expr_stmt|;
name|zcommon_section
operator|=
name|subseg_new
argument_list|(
literal|".zcommon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|zcommon_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IS_COMMON
operator|)
argument_list|)
expr_stmt|;
name|tcommon_section
operator|=
name|subseg_new
argument_list|(
literal|".tcommon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|tcommon_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IS_COMMON
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|handle_sdaoff
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|==
name|NULL
condition|)
return|return
name|BFD_RELOC_V850_SDA_16_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|15
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|17
condition|)
return|return
name|BFD_RELOC_V850_SDA_15_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|16
operator|||
name|operand
operator|->
name|shift
operator|!=
literal|16
condition|)
block|{
name|as_bad
argument_list|(
literal|"sdaoff() relocation used on an instruction which does not support it"
argument_list|)
expr_stmt|;
return|return
name|BFD_RELOC_64
return|;
comment|/* Used to indicate an error condition.  */
block|}
return|return
name|BFD_RELOC_V850_SDA_16_16_OFFSET
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|handle_zdaoff
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|==
name|NULL
condition|)
return|return
name|BFD_RELOC_V850_ZDA_16_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|15
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|17
condition|)
return|return
name|BFD_RELOC_V850_ZDA_15_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|16
operator|||
name|operand
operator|->
name|shift
operator|!=
literal|16
condition|)
block|{
name|as_bad
argument_list|(
literal|"zdaoff() relocation used on an instruction which does not support it"
argument_list|)
expr_stmt|;
return|return
name|BFD_RELOC_64
return|;
comment|/* Used to indicate an error condition.  */
block|}
return|return
name|BFD_RELOC_V850_ZDA_16_16_OFFSET
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|handle_tdaoff
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|==
name|NULL
condition|)
return|return
name|BFD_RELOC_V850_TDA_7_7_OFFSET
return|;
comment|/* data item, not an instruction.  */
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|6
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|1
condition|)
return|return
name|BFD_RELOC_V850_TDA_6_8_OFFSET
return|;
comment|/* sld.w/sst.w, operand: D8_6  */
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|16
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|16
condition|)
return|return
name|BFD_RELOC_V850_TDA_16_16_OFFSET
return|;
comment|/* set1& chums, operands: D16 */
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|7
condition|)
block|{
name|as_bad
argument_list|(
literal|"tdaoff() relocation used on an instruction which does not support it"
argument_list|)
expr_stmt|;
return|return
name|BFD_RELOC_64
return|;
comment|/* Used to indicate an error condition.  */
block|}
return|return
name|operand
operator|->
name|insert
operator|!=
name|NULL
condition|?
name|BFD_RELOC_V850_TDA_7_8_OFFSET
comment|/* sld.h/sst.h, operand: D8_7 */
else|:
name|BFD_RELOC_V850_TDA_7_7_OFFSET
return|;
comment|/* sld.b/sst.b, opreand: D7   */
block|}
end_function

begin_comment
comment|/* Warning: The code in this function relies upon the definitions    in the v850_operands[] array (defined in opcodes/v850-opc.c)    matching the hard coded values contained herein.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|v850_reloc_prefix
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
name|boolean
name|paren_skipped
init|=
name|false
decl_stmt|;
comment|/* Skip leading opening parenthesis.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'('
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|paren_skipped
operator|=
name|true
expr_stmt|;
block|}
define|#
directive|define
name|CHECK_
parameter_list|(
name|name
parameter_list|,
name|reloc
parameter_list|)
define|\
value|if (strncmp (input_line_pointer, name##"(", strlen (name) + 1) == 0)	\     {									\       input_line_pointer += strlen (name);				\       return reloc;							\     }
name|CHECK_
argument_list|(
literal|"hi0"
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"hi"
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"lo"
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"sdaoff"
argument_list|,
name|handle_sdaoff
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"zdaoff"
argument_list|,
name|handle_zdaoff
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"tdaoff"
argument_list|,
name|handle_tdaoff
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore skipped parenthesis.  */
if|if
condition|(
name|paren_skipped
condition|)
operator|--
name|input_line_pointer
expr_stmt|;
return|return
name|BFD_RELOC_UNUSED
return|;
block|}
end_function

begin_comment
comment|/* Insert an operand value into an instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|v850_insert_operand
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|val
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|str
parameter_list|)
name|unsigned
name|long
name|insn
decl_stmt|;
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
specifier|const
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|insn
operator|=
name|operand
operator|->
name|insert
argument_list|(
name|insn
argument_list|,
name|val
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|&&
operator|!
name|warn_signed_overflows
operator|&&
name|strstr
argument_list|(
name|message
argument_list|,
literal|"out of range"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* skip warning... */
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|==
literal|0
operator|&&
operator|!
name|warn_unsigned_overflows
operator|&&
name|strstr
argument_list|(
name|message
argument_list|,
literal|"out of range"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* skip warning... */
block|}
elseif|else
if|if
condition|(
name|str
condition|)
block|{
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
literal|"%s: %s"
argument_list|,
name|str
argument_list|,
name|message
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s: %s"
argument_list|,
name|str
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|32
condition|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|offsetT
name|test
decl_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|warn_signed_overflows
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|warn_unsigned_overflows
condition|)
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|min
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
operator|(
name|offsetT
operator|)
name|min
operator|||
name|val
operator|>
operator|(
name|offsetT
operator|)
name|max
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
init|=
literal|"operand out of range (%s not between %ld and %ld)"
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Restore min and mix to expected values for decimal ranges.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|&&
operator|!
name|warn_signed_overflows
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|&&
operator|!
name|warn_unsigned_overflows
condition|)
name|min
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: "
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|sprint_value
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
name|copy_of_instruction
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|start_of_operands
decl_stmt|;
name|struct
name|v850_opcode
modifier|*
name|opcode
decl_stmt|;
name|struct
name|v850_opcode
modifier|*
name|next_opcode
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex_ptr
decl_stmt|;
name|int
name|next_opindex
decl_stmt|;
name|int
name|relaxable
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|insn_size
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|match
decl_stmt|;
name|boolean
name|extra_data_after_insn
init|=
name|false
decl_stmt|;
name|unsigned
name|extra_data_len
decl_stmt|;
name|unsigned
name|long
name|extra_data
decl_stmt|;
name|char
modifier|*
name|saved_input_line_pointer
decl_stmt|;
name|strncpy
argument_list|(
name|copy_of_instruction
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|copy_of_instruction
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Get the opcode.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* find the first opcode with the proper name */
name|opcode
operator|=
operator|(
expr|struct
name|v850_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|v850_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unrecognized opcode: `%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|str
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
name|start_of_operands
operator|=
name|str
expr_stmt|;
name|saved_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|->
name|processors
operator|&
name|processor_mask
operator|)
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
literal|"Target processor does not support this instruction."
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|relaxable
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
name|extra_data_after_insn
operator|=
name|false
expr_stmt|;
name|input_line_pointer
operator|=
name|str
operator|=
name|start_of_operands
expr_stmt|;
for|for
control|(
name|opindex_ptr
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
control|)
block|{
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
if|if
condition|(
name|next_opindex
operator|==
literal|0
condition|)
block|{
name|operand
operator|=
operator|&
name|v850_operands
index|[
operator|*
name|opindex_ptr
index|]
expr_stmt|;
block|}
else|else
block|{
name|operand
operator|=
operator|&
name|v850_operands
index|[
name|next_opindex
index|]
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
block|}
name|errmsg
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
operator|||
operator|*
name|str
operator|==
literal|'['
operator|||
operator|*
name|str
operator|==
literal|']'
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_RELAX
condition|)
name|relaxable
operator|=
literal|1
expr_stmt|;
comment|/* Gather the operand. */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
comment|/* lo(), hi(), hi0(), etc... */
if|if
condition|(
operator|(
name|reloc
operator|=
name|v850_reloc_prefix
argument_list|(
name|operand
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
comment|/* This is a fake reloc, used to indicate an error condition.  */
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_64
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_V850_ZDA_16_16_OFFSET
case|:
comment|/* To cope with "not1 7, zdaoff(0xfffff006)[r0]" 			 and the like.  */
comment|/* Fall through.  */
case|case
name|BFD_RELOC_LO16
case|:
block|{
comment|/* Truncate, then sign extend the value.  */
name|ex
operator|.
name|X_add_number
operator|=
name|SEXT16
argument_list|(
name|ex
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_HI16
case|:
block|{
comment|/* Truncate, then sign extend the value.  */
name|ex
operator|.
name|X_add_number
operator|=
name|SEXT16
argument_list|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_HI16_S
case|:
block|{
comment|/* Truncate, then sign extend the value.  */
name|int
name|temp
init|=
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
decl_stmt|;
name|temp
operator|+=
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|15
operator|)
operator|&
literal|1
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
name|SEXT16
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reloc: %d\n"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
literal|"AAARG -> unhandled constant reloc"
argument_list|)
expr_stmt|;
break|break;
block|}
name|insn
operator|=
name|v850_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|copy_of_instruction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fc
operator|>
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
literal|"too many fixups"
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|reloc
expr_stmt|;
name|fc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|errmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_REG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|errmsg
operator|=
literal|"invalid register name"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_NOT_R0
operator|)
operator|&&
name|ex
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
literal|"register r0 cannot be used here"
expr_stmt|;
comment|/* Force an error message to be generated by 			 skipping over any following potential matches 			 for this opcode.  */
name|opcode
operator|+=
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SRG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|system_register_name
argument_list|(
operator|&
name|ex
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|errmsg
operator|=
literal|"invalid system register name"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_EP
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|start
argument_list|,
literal|"ep"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|start
argument_list|,
literal|"r30"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Put things back the way we found them.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|start
expr_stmt|;
name|errmsg
operator|=
literal|"expected EP register"
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
operator|||
operator|*
name|str
operator|==
literal|'['
operator|||
operator|*
name|str
operator|==
literal|']'
condition|)
operator|++
name|str
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_CC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|cc_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|errmsg
operator|=
literal|"invalid condition code name"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|register_name
argument_list|(
operator|&
name|ex
argument_list|)
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_REG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* It is possible that an alias has been defined that 		     matches a register name.  For example the code may 		     include a ".set ZERO, 0" directive, which matches 		     the register name "zero".  Attempt to reparse the 		     field as an expression, and only complain if we 		     cannot generate a constant.  */
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* If this register is actually occuring too early on 			 the parsing of the instruction, (because another 			 field is missing) then report this.  */
if|if
condition|(
name|opindex_ptr
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
operator|(
name|v850_operands
index|[
name|opindex_ptr
index|[
literal|1
index|]
index|]
operator|.
name|flags
operator|&
name|V850_OPERAND_REG
operator|)
condition|)
name|errmsg
operator|=
literal|"syntax error: value is missing before the register name"
expr_stmt|;
else|else
name|errmsg
operator|=
literal|"syntax error: register not expected"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|system_register_name
argument_list|(
operator|&
name|ex
argument_list|,
name|false
argument_list|)
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SRG
operator|)
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
literal|"syntax error: system register not expected"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc_name
argument_list|(
operator|&
name|ex
argument_list|)
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_CC
operator|)
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
literal|"syntax error: condition code not expected"
expr_stmt|;
block|}
else|else
block|{
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errmsg
condition|)
goto|goto
name|error
goto|;
comment|/* fprintf (stderr, " insn: %x, operand %d, op: %d, add_number: %d\n", insn, opindex_ptr - opcode->operands, ex.X_op, ex.X_add_number); */
switch|switch
condition|(
name|ex
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|errmsg
operator|=
literal|"illegal operand"
expr_stmt|;
goto|goto
name|error
goto|;
case|case
name|O_absent
case|:
name|errmsg
operator|=
literal|"missing operand"
expr_stmt|;
goto|goto
name|error
goto|;
case|case
name|O_register
case|:
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|V850_OPERAND_REG
operator||
name|V850_OPERAND_SRG
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
literal|"invalid operand"
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|insn
operator|=
name|v850_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|copy_of_instruction
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
name|insn
operator|=
name|v850_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|copy_of_instruction
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
literal|"too many fixups"
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
operator|++
name|fc
expr_stmt|;
break|break;
block|}
block|}
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
operator|||
operator|*
name|str
operator|==
literal|'['
operator|||
operator|*
name|str
operator|==
literal|']'
operator|||
operator|*
name|str
operator|==
literal|')'
condition|)
operator|++
name|str
expr_stmt|;
block|}
name|match
operator|=
literal|1
expr_stmt|;
name|error
label|:
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
name|next_opcode
operator|=
name|opcode
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|next_opcode
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|next_opcode
operator|->
name|name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator|=
name|next_opcode
expr_stmt|;
comment|/* Skip versions that are not supported by the target 		 processor.  */
if|if
condition|(
operator|(
name|opcode
operator|->
name|processors
operator|&
name|processor_mask
operator|)
operator|==
literal|0
condition|)
goto|goto
name|error
goto|;
continue|continue;
block|}
name|as_bad
argument_list|(
literal|"%s: %s"
argument_list|,
name|copy_of_instruction
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|']'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
return|return;
block|}
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
literal|"junk at end of line: `%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
comment|/* Write out the instruction. */
if|if
condition|(
name|relaxable
operator|&&
name|fc
operator|>
literal|0
condition|)
block|{
name|insn_size
operator|=
literal|2
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|opcode
operator|->
name|name
argument_list|,
literal|"br"
argument_list|)
condition|)
block|{
name|f
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fixups
index|[
literal|0
index|]
operator|.
name|opindex
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|insn_size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|6
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fixups
index|[
literal|0
index|]
operator|.
name|opindex
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|insn_size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Four byte insns have an opcode with the two high bits on.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x0600
operator|)
operator|==
literal|0x0600
condition|)
name|insn_size
operator|=
literal|4
expr_stmt|;
else|else
name|insn_size
operator|=
literal|2
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
name|insn_size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|insn_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_data_after_insn
condition|)
block|{
name|f
operator|=
name|frag_more
argument_list|(
name|extra_data_len
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|extra_data
argument_list|,
name|extra_data_len
argument_list|)
expr_stmt|;
name|extra_data_after_insn
operator|=
name|false
expr_stmt|;
block|}
block|}
comment|/* Create any fixups.  At this point we do not use a      bfd_reloc_code_real_type, but instead just use the      BFD_RELOC_UNUSED plus the operand index.  This lets us easily      handle fixups for any operand type, although that is admittedly      not a very exciting feature.  We pick a BFD reloc type in      md_apply_fix.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|operand
operator|=
operator|&
name|v850_operands
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
expr_stmt|;
name|reloc
operator|=
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
expr_stmt|;
if|if
condition|(
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|address
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
if|if
condition|(
operator|!
name|reloc_howto
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
comment|/* XXX This will abort on an R_V850_8 reloc - 	     is this reloc actually used ? */
if|if
condition|(
name|size
operator|!=
literal|2
operator|&&
name|size
operator|!=
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|address
operator|=
operator|(
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|+
name|insn_size
operator|-
name|size
expr_stmt|;
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_32
condition|)
block|{
name|address
operator|+=
literal|2
expr_stmt|;
block|}
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|address
argument_list|,
name|size
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_HI16
case|:
case|case
name|BFD_RELOC_HI16_S
case|:
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
literal|1
comment|/* FIXME: V850_OPERAND_RELATIVE ??? */
argument_list|,
call|(
name|bfd_reloc_code_real_type
call|)
argument_list|(
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
operator|+
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created */
end_comment

begin_comment
comment|/* then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|seg
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|seg
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|fixp
operator|->
name|fx_addsy
operator|->
name|bsym
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"reloc %d not supported by object file format"
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Assume everything will fit in two bytes, then expand as necessary.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragp
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|fragp
decl_stmt|;
name|asection
modifier|*
name|seg
decl_stmt|;
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
literal|0
condition|)
name|fragp
operator|->
name|fr_var
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
literal|2
condition|)
name|fragp
operator|->
name|fr_var
operator|=
literal|2
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixp
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
comment|/* If the symbol is undefined, or in a section other than our own,      then let the linker figure it out.  */
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* The symbol is undefined.  Let the linker figure it out.  */
return|return
literal|0
return|;
block|}
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_function
name|int
name|md_apply_fix3
parameter_list|(
name|fixp
parameter_list|,
name|valuep
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|valueT
modifier|*
name|valuep
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|valueT
name|value
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|value
operator|=
operator|*
name|valuep
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|value
operator|=
operator|*
name|valuep
expr_stmt|;
else|else
block|{
name|value
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|==
name|absolute_section
condition|)
name|value
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We don't actually support subtracting a symbol.  */
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"expression too complex"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|int
name|opindex
decl_stmt|;
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|opindex
operator|=
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
name|operand
operator|=
operator|&
name|v850_operands
index|[
name|opindex
index|]
expr_stmt|;
comment|/* Fetch the instruction, insert the fully resolved operand          value, and stuff the instruction back again.  	 Note the instruction has been stored in little endian 	 format!  */
name|where
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|insn
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|insn
operator|=
name|v850_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|,
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
block|{
comment|/* Nothing else to do here. */
return|return
literal|1
return|;
block|}
comment|/* Determine a BFD reloc value based on the operand information.   	 We are only prepared to turn a few of the operands into relocs. */
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|22
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_V850_22_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|9
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_V850_9_PCREL
expr_stmt|;
else|else
block|{
comment|/* fprintf (stderr, "bits: %d, insn: %x\n", operand->bits, insn); */
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"unresolved expression that must be resolved"
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
block|{
comment|/* We still have to insert the value into memory!  */
name|where
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_size
operator|==
literal|1
condition|)
operator|*
name|where
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_size
operator|==
literal|2
condition|)
name|bfd_putl16
argument_list|(
name|value
operator|&
literal|0xffff
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_size
operator|==
literal|4
condition|)
name|bfd_putl32
argument_list|(
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
block|}
name|fixp
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a cons expression.  We have to handle hi(), lo(), etc    on the v850.  */
end_comment

begin_function
name|void
name|parse_cons_expression_v850
parameter_list|(
name|exp
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
comment|/* See if there's a reloc prefix like hi() we have to handle.  */
name|hold_cons_reloc
operator|=
name|v850_reloc_prefix
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Do normal expression parsing.  */
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a fixup for a cons expression.  If parse_cons_expression_v850    found a reloc prefix, then we use that reloc, else we choose an    appropriate one based on the size of the expression.  */
end_comment

begin_function
name|void
name|cons_fix_new_v850
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|size
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|hold_cons_reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|hold_cons_reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|2
condition|)
name|hold_cons_reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|hold_cons_reloc
operator|=
name|BFD_RELOC_8
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|!=
name|NULL
condition|)
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|hold_cons_reloc
argument_list|)
expr_stmt|;
else|else
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hold_cons_reloc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

