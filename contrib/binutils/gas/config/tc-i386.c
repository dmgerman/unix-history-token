begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i386.c -- Assemble code for the Intel 80386    Copyright (C) 1989, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000    Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/*   Intel 80386 machine specific gas.   Written by Eliot Dresselhaus (eliot@mgm.mit.edu).   Bugs& suggestions are completely welcome.  This is free software.   Please help us make it better.   */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/i386.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_WARNINGS
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_WARNINGS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INFER_ADDR_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|INFER_ADDR_PREFIX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SCALE1_WHEN_NO_INDEX
end_ifndef

begin_comment
comment|/* Specifying a scale factor besides 1 when there is no index is    futile.  eg. `mov (%ebx,2),%al' does exactly the same as    `mov (%ebx),%al'.  To slavishly follow what the programmer    specified, set SCALE1_WHEN_NO_INDEX to 0.  */
end_comment

begin_define
define|#
directive|define
name|SCALE1_WHEN_NO_INDEX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mode_from_disp_size
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_signed_byte
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_unsigned_byte
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_unsigned_word
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_signed_word
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|smallest_imm_type
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_prefix
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_16bit_code_flag
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_16bit_gcc_code_flag
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_intel_syntax
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|reloc
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 'md_assemble ()' gathers together information and puts it into a    i386_insn. */
end_comment

begin_union
union|union
name|i386_op
block|{
name|expressionS
modifier|*
name|disps
decl_stmt|;
name|expressionS
modifier|*
name|imms
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|regs
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|_i386_insn
block|{
comment|/* TM holds the template for the insn were currently assembling. */
name|template
name|tm
decl_stmt|;
comment|/* SUFFIX holds the instruction mnemonic suffix if given.        (e.g. 'l' for 'movl')  */
name|char
name|suffix
decl_stmt|;
comment|/* OPERANDS gives the number of given operands. */
name|unsigned
name|int
name|operands
decl_stmt|;
comment|/* REG_OPERANDS, DISP_OPERANDS, MEM_OPERANDS, IMM_OPERANDS give the number        of given register, displacement, memory operands and immediate        operands. */
name|unsigned
name|int
name|reg_operands
decl_stmt|,
name|disp_operands
decl_stmt|,
name|mem_operands
decl_stmt|,
name|imm_operands
decl_stmt|;
comment|/* TYPES [i] is the type (see above #defines) which tells us how to        use OP[i] for the corresponding operand.  */
name|unsigned
name|int
name|types
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Displacement expression, immediate expression, or register for each        operand.  */
name|union
name|i386_op
name|op
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Relocation type for operand */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|enum
name|bfd_reloc_code_real
name|disp_reloc
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
else|#
directive|else
name|int
name|disp_reloc
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* BASE_REG, INDEX_REG, and LOG2_SCALE_FACTOR are used to encode        the base index byte below.  */
specifier|const
name|reg_entry
modifier|*
name|base_reg
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|index_reg
decl_stmt|;
name|unsigned
name|int
name|log2_scale_factor
decl_stmt|;
comment|/* SEG gives the seg_entries of this insn.  They are zero unless        explicit segment overrides are given. */
specifier|const
name|seg_entry
modifier|*
name|seg
index|[
literal|2
index|]
decl_stmt|;
comment|/* segments for memory operands (if given) */
comment|/* PREFIX holds all the given prefix opcodes (usually null).        PREFIXES is the number of prefix opcodes.  */
name|unsigned
name|int
name|prefixes
decl_stmt|;
name|unsigned
name|char
name|prefix
index|[
name|MAX_PREFIXES
index|]
decl_stmt|;
comment|/* RM and SIB are the modrm byte and the sib byte where the        addressing modes of this insn are encoded.  */
name|modrm_byte
name|rm
decl_stmt|;
name|sib_byte
name|sib
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|_i386_insn
name|i386_insn
typedef|;
end_typedef

begin_comment
comment|/* List of chars besides those in app.c:symbol_chars that can start an    operand.  Used to prevent the scrubber eating vital white-space.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LEX_AT
end_ifdef

begin_decl_stmt
specifier|const
name|char
name|extra_symbol_chars
index|[]
init|=
literal|"*%-(@"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|extra_symbol_chars
index|[]
init|=
literal|"*%-("
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TE_I386AIX
argument_list|)
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|)
end_if

begin_comment
comment|/* Putting '/' here makes it impossible to use the divide operator.    However, we need it for compatibility with SVR4 systems.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PREFIX_SEPARATOR
value|'\\'
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PREFIX_SEPARATOR
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output. */
end_comment

begin_comment
comment|/* Also note that comments started like this one will always work if    '/' isn't otherwise defined.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TE_I386AIX
argument_list|)
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"/"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDxX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tables for lexical analysis */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mnemonic_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|operand_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|identifier_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|digit_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lexical macros */
end_comment

begin_define
define|#
directive|define
name|is_mnemonic_char
parameter_list|(
name|x
parameter_list|)
value|(mnemonic_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_operand_char
parameter_list|(
name|x
parameter_list|)
value|(operand_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_register_char
parameter_list|(
name|x
parameter_list|)
value|(register_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_space_char
parameter_list|(
name|x
parameter_list|)
value|((x) == ' ')
end_define

begin_define
define|#
directive|define
name|is_identifier_char
parameter_list|(
name|x
parameter_list|)
value|(identifier_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_digit_char
parameter_list|(
name|x
parameter_list|)
value|(digit_chars[(unsigned char) x])
end_define

begin_comment
comment|/* put here all non-digit non-letter charcters that may occur in an operand */
end_comment

begin_decl_stmt
specifier|static
name|char
name|operand_special_chars
index|[]
init|=
literal|"%$-+(,)*._~/<>|&^!:[@]"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* md_assemble() always leaves the strings it's passed unaltered.  To    effect this we maintain a stack of saved characters that we've smashed    with '\0's (indicating end of strings for various sub-fields of the    assembler instruction). */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_stack
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_stack_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack pointer */
end_comment

begin_define
define|#
directive|define
name|END_STRING_AND_SAVE
parameter_list|(
name|s
parameter_list|)
define|\
value|do { *save_stack_p++ = *(s); *(s) = '\0'; } while (0)
end_define

begin_define
define|#
directive|define
name|RESTORE_END_STRING
parameter_list|(
name|s
parameter_list|)
define|\
value|do { *(s) = *--save_stack_p; } while (0)
end_define

begin_comment
comment|/* The instruction we're assembling. */
end_comment

begin_decl_stmt
specifier|static
name|i386_insn
name|i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Possible templates for current insn.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|templates
modifier|*
name|current_templates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per instruction expressionS buffers: 2 displacements& 2 immediate max. */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|disp_expressions
index|[
literal|2
index|]
decl_stmt|,
name|im_expressions
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|this_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current operand we are working on */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_do_long_jump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME what does this do? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_16bit_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if we're writing 16-bit code, 0 if 32-bit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|intel_syntax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 for intel syntax, 0 if att syntax */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allow_naked_reg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if register prefix % not required */
end_comment

begin_decl_stmt
specifier|static
name|char
name|stackop_size
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in 16 bit gcc mode to add an l 				     suffix to call, ret, enter, leave, push, 				     and pop instructions so that gcc has the 				     same stack frame as in 32 bit mode.  */
end_comment

begin_comment
comment|/* Interface to relax_segment.    There are 2 relax states for 386 jump insns: one for conditional&    one for unconditional jumps.  This is because these two types of    jumps add different sizes to frags when we're figuring out what    sort of jump to choose to reach a given label.  */
end_comment

begin_comment
comment|/* types */
end_comment

begin_define
define|#
directive|define
name|COND_JUMP
value|1
end_define

begin_comment
comment|/* conditional jump */
end_comment

begin_define
define|#
directive|define
name|UNCOND_JUMP
value|2
end_define

begin_comment
comment|/* unconditional jump */
end_comment

begin_comment
comment|/* sizes */
end_comment

begin_define
define|#
directive|define
name|CODE16
value|1
end_define

begin_define
define|#
directive|define
name|SMALL
value|0
end_define

begin_define
define|#
directive|define
name|SMALL16
value|(SMALL|CODE16)
end_define

begin_define
define|#
directive|define
name|BIG
value|2
end_define

begin_define
define|#
directive|define
name|BIG16
value|(BIG|CODE16)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|INLINE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|INLINE
value|__inline__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ENCODE_RELAX_STATE
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|)
define|\
value|((relax_substateT)((type<<2) | (size)))
end_define

begin_define
define|#
directive|define
name|SIZE_FROM_RELAX_STATE
parameter_list|(
name|s
parameter_list|)
define|\
value|( (((s)& 0x3) == BIG ? 4 : (((s)& 0x3) == BIG16 ? 2 : 1)) )
end_define

begin_comment
comment|/* This table is used by relax_frag to promote short jumps to long    ones where necessary.  SMALL (short) jumps may be promoted to BIG    (32 bit long) ones, and SMALL16 jumps to BIG16 (16 bit long).  We    don't allow a short jump in a 32 bit code segment to be promoted to    a 16 bit offset jump because it's slower (requires data size    prefix), and doesn't work, unless the destination is in the bottom    64k of the code segment (The top 16 bits of eip are zeroed).  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The fields are:      1) most positive reach of this state,      2) most negative reach of this state,      3) how many bytes this mode will add to the size of the current frag      4) which index into the table to try if we can't fit into this one.   */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|BIG
argument_list|)
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|BIG16
argument_list|)
block|}
block|,
comment|/* dword conditionals adds 4 bytes to frag:      1 extra opcode byte, 3 extra displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* word conditionals add 2 bytes to frag:      1 extra opcode byte, 1 extra displacement byte.  */
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|BIG
argument_list|)
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|BIG16
argument_list|)
block|}
block|,
comment|/* dword jmp adds 3 bytes to frag:      0 extra opcode bytes, 3 extra displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
comment|/* word jmp adds 1 byte to frag:      0 extra opcode bytes, 1 extra displacement byte.  */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|i386_align_code
parameter_list|(
name|fragP
parameter_list|,
name|count
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
comment|/* Various efficient no-op patterns for aligning code labels.  */
comment|/* Note: Don't try to assemble the instructions in the comments. */
comment|/*       0L and 0w are not legal */
specifier|static
specifier|const
name|char
name|f32_1
index|[]
init|=
block|{
literal|0x90
block|}
decl_stmt|;
comment|/* nop			*/
specifier|static
specifier|const
name|char
name|f32_2
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|}
decl_stmt|;
comment|/* movl %esi,%esi	*/
specifier|static
specifier|const
name|char
name|f32_3
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x76
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f32_4
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi,1),%esi	*/
specifier|static
specifier|const
name|char
name|f32_5
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi,1),%esi	*/
specifier|static
specifier|const
name|char
name|f32_6
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f32_7
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi,1),%esi */
specifier|static
specifier|const
name|char
name|f32_8
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi,1),%esi */
specifier|static
specifier|const
name|char
name|f32_9
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|,
comment|/* movl %esi,%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_10
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x76
block|,
literal|0x00
block|,
comment|/* leal 0(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_11
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|,
comment|/* leal 0(%esi,1),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_12
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbf
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi),%edi	*/
specifier|static
specifier|const
name|char
name|f32_13
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_14
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi,1),%esi */
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_15
index|[]
init|=
block|{
literal|0xeb
block|,
literal|0x0d
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
comment|/* jmp .+15; lotsa nops	*/
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
name|f16_3
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f16_4
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%si),%si	*/
specifier|static
specifier|const
name|char
name|f16_5
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%si),%si	*/
specifier|static
specifier|const
name|char
name|f16_6
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|,
comment|/* mov %si,%si		*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
name|f16_7
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x00
block|,
comment|/* lea 0(%si),%si	*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
name|f16_8
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* lea 0w(%si),%si	*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|f32_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|f32_3
block|,
name|f32_4
block|,
name|f32_5
block|,
name|f32_6
block|,
name|f32_7
block|,
name|f32_8
block|,
name|f32_9
block|,
name|f32_10
block|,
name|f32_11
block|,
name|f32_12
block|,
name|f32_13
block|,
name|f32_14
block|,
name|f32_15
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|f16_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|f16_3
block|,
name|f16_4
block|,
name|f16_5
block|,
name|f16_6
block|,
name|f16_7
block|,
name|f16_8
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|}
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|count
operator|<=
literal|15
condition|)
block|{
if|if
condition|(
name|flag_16bit_code
condition|)
block|{
name|memcpy
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|f16_patt
index|[
name|count
operator|-
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|8
condition|)
comment|/* adjust jump offset */
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
index|]
operator|=
name|count
operator|-
literal|2
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|f32_patt
index|[
name|count
operator|-
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|count
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_invalid
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|i386_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|operand_string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|i386_intel_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|operand_string
operator|,
name|int
name|got_a_float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|reg_entry
modifier|*
name|parse_register
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|reg_string
operator|,
name|char
operator|*
operator|*
name|end_op
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|I386COFF
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|s_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|mode_from_disp_size
parameter_list|(
name|t
parameter_list|)
name|unsigned
name|int
name|t
decl_stmt|;
block|{
return|return
operator|(
name|t
operator|&
name|Disp8
operator|)
condition|?
literal|1
else|:
operator|(
name|t
operator|&
operator|(
name|Disp16
operator||
name|Disp32
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_byte
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
name|num
operator|>=
operator|-
literal|128
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|127
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fits_in_signed_byte() */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_byte
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
name|num
operator|&
literal|0xff
operator|)
operator|==
name|num
return|;
block|}
end_function

begin_comment
comment|/* fits_in_unsigned_byte() */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_word
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
name|num
operator|&
literal|0xffff
operator|)
operator|==
name|num
return|;
block|}
end_function

begin_comment
comment|/* fits_in_unsigned_word() */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_word
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
operator|-
literal|32768
operator|<=
name|num
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|32767
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fits_in_signed_word() */
end_comment

begin_function
specifier|static
name|int
name|smallest_imm_type
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* This code is disabled because all the Imm1 forms in the opcode table      are slower on the i486, and they're the versions with the implicitly      specified single-position displacement, which has another syntax if      you really want to use that form.  If you really prefer to have the      one-byte-shorter Imm1 form despite these problems, re-enable this      code.  */
block|if (num == 1)     return Imm1 | Imm8 | Imm8S | Imm16 | Imm32;
endif|#
directive|endif
return|return
operator|(
name|fits_in_signed_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8S
operator||
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator|)
else|:
name|fits_in_unsigned_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator|)
else|:
operator|(
name|fits_in_signed_word
argument_list|(
name|num
argument_list|)
operator|||
name|fits_in_unsigned_word
argument_list|(
name|num
argument_list|)
operator|)
condition|?
operator|(
name|Imm16
operator||
name|Imm32
operator|)
else|:
operator|(
name|Imm32
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* smallest_imm_type() */
end_comment

begin_comment
comment|/* Returns 0 if attempting to add a prefix where one from the same    class already exists, 1 if non rep/repne added, 2 if rep/repne    added.  */
end_comment

begin_function
specifier|static
name|int
name|add_prefix
parameter_list|(
name|prefix
parameter_list|)
name|unsigned
name|int
name|prefix
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|int
name|q
decl_stmt|;
switch|switch
condition|(
name|prefix
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|CS_PREFIX_OPCODE
case|:
case|case
name|DS_PREFIX_OPCODE
case|:
case|case
name|ES_PREFIX_OPCODE
case|:
case|case
name|FS_PREFIX_OPCODE
case|:
case|case
name|GS_PREFIX_OPCODE
case|:
case|case
name|SS_PREFIX_OPCODE
case|:
name|q
operator|=
name|SEG_PREFIX
expr_stmt|;
break|break;
case|case
name|REPNE_PREFIX_OPCODE
case|:
case|case
name|REPE_PREFIX_OPCODE
case|:
name|ret
operator|=
literal|2
expr_stmt|;
comment|/* fall thru */
case|case
name|LOCK_PREFIX_OPCODE
case|:
name|q
operator|=
name|LOCKREP_PREFIX
expr_stmt|;
break|break;
case|case
name|FWAIT_OPCODE
case|:
name|q
operator|=
name|WAIT_PREFIX
expr_stmt|;
break|break;
case|case
name|ADDR_PREFIX_OPCODE
case|:
name|q
operator|=
name|ADDR_PREFIX
expr_stmt|;
break|break;
case|case
name|DATA_PREFIX_OPCODE
case|:
name|q
operator|=
name|DATA_PREFIX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|q
index|]
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"same type of prefix used twice"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|prefixes
operator|+=
literal|1
expr_stmt|;
name|i
operator|.
name|prefix
index|[
name|q
index|]
operator|=
name|prefix
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_16bit_code_flag
parameter_list|(
name|new_16bit_code_flag
parameter_list|)
name|int
name|new_16bit_code_flag
decl_stmt|;
block|{
name|flag_16bit_code
operator|=
name|new_16bit_code_flag
expr_stmt|;
name|stackop_size
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_16bit_gcc_code_flag
parameter_list|(
name|new_16bit_code_flag
parameter_list|)
name|int
name|new_16bit_code_flag
decl_stmt|;
block|{
name|flag_16bit_code
operator|=
name|new_16bit_code_flag
expr_stmt|;
name|stackop_size
operator|=
name|new_16bit_code_flag
condition|?
literal|'l'
else|:
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_intel_syntax
parameter_list|(
name|syntax_flag
parameter_list|)
name|int
name|syntax_flag
decl_stmt|;
block|{
comment|/* Find out if register prefixing is specified.  */
name|int
name|ask_naked_reg
init|=
literal|0
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|char
modifier|*
name|string
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|e
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"prefix"
argument_list|)
operator|==
literal|0
condition|)
name|ask_naked_reg
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"noprefix"
argument_list|)
operator|==
literal|0
condition|)
name|ask_naked_reg
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad argument to syntax directive."
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|e
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|intel_syntax
operator|=
name|syntax_flag
expr_stmt|;
if|if
condition|(
name|ask_naked_reg
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|allow_naked_reg
operator|=
operator|(
name|intel_syntax
operator|&&
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|stdoutput
argument_list|)
operator|!=
literal|'\0'
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|allow_naked_reg
operator|=
literal|0
expr_stmt|;
comment|/* conservative default */
endif|#
directive|endif
block|}
else|else
name|allow_naked_reg
operator|=
operator|(
name|ask_naked_reg
operator|<
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|I386COFF
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_ALIGN_PTWO
argument_list|)
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"tfloat"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"value"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"noopt"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"code16gcc"
block|,
name|set_16bit_gcc_code_flag
block|,
literal|1
block|}
block|,
block|{
literal|"code16"
block|,
name|set_16bit_code_flag
block|,
literal|1
block|}
block|,
block|{
literal|"code32"
block|,
name|set_16bit_code_flag
block|,
literal|0
block|}
block|,
block|{
literal|"intel_syntax"
block|,
name|set_intel_syntax
block|,
literal|1
block|}
block|,
block|{
literal|"att_syntax"
block|,
name|set_intel_syntax
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for interface with expression () */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for instruction mnemonic lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for register lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|hash_err
decl_stmt|;
comment|/* initialize op_hash hash table */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
specifier|const
name|template
modifier|*
name|optab
decl_stmt|;
specifier|register
name|templates
modifier|*
name|core_optab
decl_stmt|;
name|optab
operator|=
name|i386_optab
expr_stmt|;
comment|/* setup for loop */
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
name|optab
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|++
name|optab
expr_stmt|;
if|if
condition|(
name|optab
operator|->
name|name
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|optab
operator|->
name|name
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* different name --> ship out current template list; 	       add to hash table;& begin anew */
name|core_optab
operator|->
name|end
operator|=
name|optab
expr_stmt|;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|core_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
block|{
name|hash_error
label|:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optab
operator|->
name|name
operator|==
name|NULL
condition|)
break|break;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
name|optab
expr_stmt|;
block|}
block|}
block|}
comment|/* initialize reg_hash hash table */
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
specifier|const
name|reg_entry
modifier|*
name|regtab
decl_stmt|;
for|for
control|(
name|regtab
operator|=
name|i386_regtab
init|;
name|regtab
operator|<
name|i386_regtab
operator|+
sizeof|sizeof
argument_list|(
name|i386_regtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|i386_regtab
index|[
literal|0
index|]
argument_list|)
condition|;
name|regtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|regtab
operator|->
name|reg_name
argument_list|,
operator|(
name|PTR
operator|)
name|regtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
goto|goto
name|hash_error
goto|;
block|}
block|}
comment|/* fill in lexical tables:  mnemonic_chars, operand_chars.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|digit_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|mnemonic_chars
index|[
name|c
index|]
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|128
condition|)
block|{
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LEX_AT
name|identifier_chars
index|[
literal|'@'
index|]
operator|=
literal|'@'
expr_stmt|;
endif|#
directive|endif
name|digit_chars
index|[
literal|'-'
index|]
operator|=
literal|'-'
expr_stmt|;
name|identifier_chars
index|[
literal|'_'
index|]
operator|=
literal|'_'
expr_stmt|;
name|identifier_chars
index|[
literal|'.'
index|]
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|operand_special_chars
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
name|operand_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|record_alignment
argument_list|(
name|text_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|data_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|i386_print_statistics
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"i386 opcode"
argument_list|,
name|op_hash
argument_list|)
expr_stmt|;
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"i386 register"
argument_list|,
name|reg_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG386
end_ifdef

begin_comment
comment|/* debugging routines for md_assemble */
end_comment

begin_decl_stmt
specifier|static
name|void
name|pi
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|i386_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pte
name|PARAMS
argument_list|(
operator|(
name|template
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pt
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pe
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ps
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pi
parameter_list|(
name|line
parameter_list|,
name|x
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|i386_insn
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|template
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: template "
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|pte
argument_list|(
operator|&
name|x
operator|->
name|tm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  modrm:  mode %x  reg %x  reg/mem %x"
argument_list|,
name|x
operator|->
name|rm
operator|.
name|mode
argument_list|,
name|x
operator|->
name|rm
operator|.
name|reg
argument_list|,
name|x
operator|->
name|rm
operator|.
name|regmem
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" base %x  index %x  scale %x\n"
argument_list|,
name|x
operator|->
name|bi
operator|.
name|base
argument_list|,
name|x
operator|->
name|bi
operator|.
name|index
argument_list|,
name|x
operator|->
name|bi
operator|.
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d:  "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|x
operator|->
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|RegMMX
operator||
name|RegXMM
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|x
operator|->
name|op
index|[
name|i
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Imm
condition|)
name|pe
argument_list|(
name|x
operator|->
name|op
index|[
name|i
index|]
operator|.
name|imms
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Disp
condition|)
name|pe
argument_list|(
name|x
operator|->
name|op
index|[
name|i
index|]
operator|.
name|disps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pte
parameter_list|(
name|t
parameter_list|)
name|template
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" %d operands "
argument_list|,
name|t
operator|->
name|operands
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"opcode %x "
argument_list|,
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"ext %x "
argument_list|,
name|t
operator|->
name|extension_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|D
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"W"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d type "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|t
operator|->
name|operand_types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pe
parameter_list|(
name|e
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    operation     %d\n"
argument_list|,
name|e
operator|->
name|X_op
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_number    %ld (%lx)\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|X_add_number
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_add_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|X_op_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    op_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ps
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s type %s%s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|,
name|S_IS_EXTERNAL
argument_list|(
name|s
argument_list|)
condition|?
literal|"EXTERNAL "
else|:
literal|""
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|type_name
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
block|}
name|type_names
index|[]
init|=
block|{
block|{
name|Reg8
block|,
literal|"r8"
block|}
block|,
block|{
name|Reg16
block|,
literal|"r16"
block|}
block|,
block|{
name|Reg32
block|,
literal|"r32"
block|}
block|,
block|{
name|Imm8
block|,
literal|"i8"
block|}
block|,
block|{
name|Imm8S
block|,
literal|"i8s"
block|}
block|,
block|{
name|Imm16
block|,
literal|"i16"
block|}
block|,
block|{
name|Imm32
block|,
literal|"i32"
block|}
block|,
block|{
name|Imm1
block|,
literal|"i1"
block|}
block|,
block|{
name|BaseIndex
block|,
literal|"BaseIndex"
block|}
block|,
block|{
name|Disp8
block|,
literal|"d8"
block|}
block|,
block|{
name|Disp16
block|,
literal|"d16"
block|}
block|,
block|{
name|Disp32
block|,
literal|"d32"
block|}
block|,
block|{
name|InOutPortReg
block|,
literal|"InOutPortReg"
block|}
block|,
block|{
name|ShiftCount
block|,
literal|"ShiftCount"
block|}
block|,
block|{
name|Control
block|,
literal|"control reg"
block|}
block|,
block|{
name|Test
block|,
literal|"test reg"
block|}
block|,
block|{
name|Debug
block|,
literal|"debug reg"
block|}
block|,
block|{
name|FloatReg
block|,
literal|"FReg"
block|}
block|,
block|{
name|FloatAcc
block|,
literal|"FAcc"
block|}
block|,
block|{
name|SReg2
block|,
literal|"SReg2"
block|}
block|,
block|{
name|SReg3
block|,
literal|"SReg3"
block|}
block|,
block|{
name|Acc
block|,
literal|"Acc"
block|}
block|,
block|{
name|JumpAbsolute
block|,
literal|"Jump Absolute"
block|}
block|,
block|{
name|RegMMX
block|,
literal|"rMMX"
block|}
block|,
block|{
name|RegXMM
block|,
literal|"rXMM"
block|}
block|,
block|{
name|EsSeg
block|,
literal|"es"
block|}
block|,
block|{
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pt
parameter_list|(
name|t
parameter_list|)
name|unsigned
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|type_name
modifier|*
name|ty
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|Unknown
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Unknown"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ty
operator|=
name|type_names
init|;
name|ty
operator|->
name|mask
condition|;
name|ty
operator|++
control|)
if|if
condition|(
name|t
operator|&
name|ty
operator|->
name|mask
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s, "
argument_list|,
name|ty
operator|->
name|tname
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG386 */
end_comment

begin_escape
end_escape

begin_function
name|int
name|tc_i386_force_relocation
parameter_list|(
name|fixp
parameter_list|)
name|struct
name|fix
modifier|*
name|fixp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
else|#
directive|else
comment|/* For COFF */
return|return
name|fixp
operator|->
name|fx_r_type
operator|==
literal|7
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|reloc
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|reloc
parameter_list|(
name|size
parameter_list|,
name|pcrel
parameter_list|,
name|other
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|bfd_reloc_code_real_type
name|other
decl_stmt|;
block|{
if|if
condition|(
name|other
operator|!=
name|NO_RELOC
condition|)
return|return
name|other
return|;
if|if
condition|(
name|pcrel
condition|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8_PCREL
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16_PCREL
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32_PCREL
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can not do %d byte pc-relative relocation"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can not do %d byte relocation"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * Here we decide which fixups can be adjusted to make them relative to  * the beginning of the section instead of the symbol.  Basically we need  * to make sure that the dynamic relocations are done correctly, so in  * some cases we force the original symbol to be used.  */
end_comment

begin_function
name|int
name|tc_i386_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_PE
argument_list|)
comment|/* Prevent all adjustments to global symbols, or else dynamic      linking will not work correctly.  */
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* adjust_reloc_syms doesn't know about the GOT */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_GOTOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_PLT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_GOT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_RVA
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|reloc
parameter_list|(
name|SIZE
parameter_list|,
name|PCREL
parameter_list|,
name|OTHER
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_16
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_16_PCREL
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_32_PCREL
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_386_PLT32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_386_GOT32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_386_GOTOFF
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|intel_float_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|mnemonic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|intel_float_operand
parameter_list|(
name|mnemonic
parameter_list|)
name|char
modifier|*
name|mnemonic
decl_stmt|;
block|{
if|if
condition|(
name|mnemonic
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|mnemonic
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|mnemonic
index|[
literal|0
index|]
operator|==
literal|'f'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  LINE points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
comment|/* Points to template once we've found it. */
specifier|const
name|template
modifier|*
name|t
decl_stmt|;
comment|/* Count the size of the instruction generated.  */
name|int
name|insn_size
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
name|mnemonic
index|[
name|MAX_MNEM_SIZE
index|]
decl_stmt|;
comment|/* Initialize globals. */
name|memset
argument_list|(
operator|&
name|i
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_OPERANDS
condition|;
name|j
operator|++
control|)
name|i
operator|.
name|disp_reloc
index|[
name|j
index|]
operator|=
name|NO_RELOC
expr_stmt|;
name|memset
argument_list|(
name|disp_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|disp_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|im_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|im_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|save_stack_p
operator|=
name|save_stack
expr_stmt|;
comment|/* reset stack pointer */
comment|/* First parse an instruction mnemonic& call i386_operand for the operands.      We assume that the scrubber has arranged it so that line[0] is the valid      start of a (possibly prefixed) mnemonic. */
block|{
name|char
modifier|*
name|l
init|=
name|line
decl_stmt|;
name|char
modifier|*
name|token_start
init|=
name|l
decl_stmt|;
name|char
modifier|*
name|mnem_p
decl_stmt|;
comment|/* Non-zero if we found a prefix only acceptable with string insns. */
specifier|const
name|char
modifier|*
name|expecting_string_instruction
init|=
name|NULL
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|mnem_p
operator|=
name|mnemonic
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|mnem_p
operator|=
name|mnemonic_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|l
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|mnem_p
operator|++
expr_stmt|;
if|if
condition|(
name|mnem_p
operator|>=
name|mnemonic
operator|+
sizeof|sizeof
argument_list|(
name|mnemonic
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such 386 instruction: `%s'"
argument_list|)
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
operator|&&
operator|*
name|l
operator|!=
name|PREFIX_SEPARATOR
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s in mnemonic"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|token_start
operator|==
name|l
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
name|PREFIX_SEPARATOR
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting prefix; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting mnemonic; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Look up instruction (or prefix) via hash table.  */
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
operator|&&
operator|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|||
name|l
index|[
literal|1
index|]
operator|!=
name|END_OF_INSN
operator|)
operator|&&
name|current_templates
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsPrefix
operator|)
condition|)
block|{
comment|/* If we are in 16-bit mode, do not allow addr16 or data16. 	       Similarly, in 32-bit mode, do not allow addr32 or data32.  */
if|if
condition|(
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Size16
operator||
name|Size32
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|Size32
operator|)
operator|!=
literal|0
operator|)
operator|^
name|flag_16bit_code
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"redundant %s prefix"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add prefix, checking for repeated prefixes.  */
switch|switch
condition|(
name|add_prefix
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return;
case|case
literal|2
case|:
name|expecting_string_instruction
operator|=
name|current_templates
operator|->
name|start
operator|->
name|name
expr_stmt|;
break|break;
block|}
comment|/* Skip past PREFIX_SEPARATOR and reset token_start.  */
name|token_start
operator|=
operator|++
name|l
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
comment|/* See if we can get a match by trimming off a suffix.  */
switch|switch
condition|(
name|mnem_p
index|[
operator|-
literal|1
index|]
condition|)
block|{
case|case
name|WORD_MNEM_SUFFIX
case|:
case|case
name|BYTE_MNEM_SUFFIX
case|:
case|case
name|SHORT_MNEM_SUFFIX
case|:
case|case
name|LONG_MNEM_SUFFIX
case|:
name|i
operator|.
name|suffix
operator|=
name|mnem_p
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|mnem_p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
break|break;
comment|/* Intel Syntax */
case|case
name|DWORD_MNEM_SUFFIX
case|:
if|if
condition|(
name|intel_syntax
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|mnem_p
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|mnem_p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such 386 instruction: `%s'"
argument_list|)
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* check for rep/repne without a string instruction */
if|if
condition|(
name|expecting_string_instruction
operator|&&
operator|!
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsString
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting string instruction after `%s'"
argument_list|)
argument_list|,
name|expecting_string_instruction
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* There may be operands to parse. */
if|if
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
comment|/* parse operands */
comment|/* 1 if operand is pending after ','. */
name|unsigned
name|int
name|expecting_operand
init|=
literal|0
decl_stmt|;
comment|/* Non-zero if operand parens not balanced. */
name|unsigned
name|int
name|paren_not_balanced
decl_stmt|;
do|do
block|{
comment|/* skip optional white space before operand */
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
operator|++
name|l
expr_stmt|;
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s before operand %d"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|token_start
operator|=
name|l
expr_stmt|;
comment|/* after white space */
name|paren_not_balanced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|paren_not_balanced
operator|||
operator|*
name|l
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
name|paren_not_balanced
condition|)
block|{
if|if
condition|(
operator|!
name|intel_syntax
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unbalanced parenthesis in operand %d."
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unbalanced brackets in operand %d."
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
comment|/* we are done */
block|}
elseif|else
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s in operand %d"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|intel_syntax
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
literal|'('
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|')'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|l
operator|==
literal|'['
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|']'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
block|}
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
name|token_start
condition|)
block|{
comment|/* yes, we've read in another operand */
name|unsigned
name|int
name|operand_ok
decl_stmt|;
name|this_operand
operator|=
name|i
operator|.
name|operands
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|>
name|MAX_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"spurious operands; (%d operands/instruction max)"
argument_list|)
argument_list|,
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* now parse operand adding info to 'i' as we go along */
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_syntax
condition|)
name|operand_ok
operator|=
name|i386_intel_operand
argument_list|(
name|token_start
argument_list|,
name|intel_float_operand
argument_list|(
name|mnemonic
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|operand_ok
operator|=
name|i386_operand
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* restore old contents */
if|if
condition|(
operator|!
name|operand_ok
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
condition|)
block|{
name|expecting_operand_after_comma
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting operand after ','; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting operand before ','; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* now *l must be either ',' or END_OF_INSN */
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
comment|/* just skip it, if it's \n complain */
goto|goto
name|expecting_operand_after_comma
goto|;
block|}
name|expecting_operand
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
do|;
comment|/* until we get end of insn */
block|}
block|}
comment|/* Now we've parsed the mnemonic into a set of templates, and have the      operands at hand.       Next, we find a template that matches the given insn,      making sure the overlap of the given operands types is consistent      with the template operand types. */
define|#
directive|define
name|MATCH
parameter_list|(
name|overlap
parameter_list|,
name|given
parameter_list|,
name|template
parameter_list|)
define|\
value|((overlap& ~JumpAbsolute) \&& ((given)& (BaseIndex|JumpAbsolute)) == ((overlap)& (BaseIndex|JumpAbsolute)))
comment|/* If given types r0 and r1 are registers they must be of the same type      unless the expected operand type register overlap is null.      Note that Acc in a template matches every size of reg.  */
define|#
directive|define
name|CONSISTENT_REGISTER_MATCH
parameter_list|(
name|m0
parameter_list|,
name|g0
parameter_list|,
name|t0
parameter_list|,
name|m1
parameter_list|,
name|g1
parameter_list|,
name|t1
parameter_list|)
define|\
value|( ((g0)& Reg) == 0 || ((g1)& Reg) == 0 || \     ((g0)& Reg) == ((g1)& Reg) || \     ((((m0)& Acc) ? Reg : (t0))& (((m1)& Acc) ? Reg : (t1))& Reg) == 0 )
block|{
specifier|register
name|unsigned
name|int
name|overlap0
decl_stmt|,
name|overlap1
decl_stmt|;
name|unsigned
name|int
name|overlap2
decl_stmt|;
name|unsigned
name|int
name|found_reverse_match
decl_stmt|;
name|int
name|suffix_check
decl_stmt|;
comment|/* All intel opcodes have reversed operands except for "bound" and        "enter".  We also don't reverse intersegment "jmp" and "call"        instructions with 2 immediate operands so that the immediate segment        precedes the offset, as it does when in AT&T mode.  "enter" and the        intersegment "jmp" and "call" instructions are the only ones that        have two immediate operands.  */
if|if
condition|(
name|intel_syntax
operator|&&
name|i
operator|.
name|operands
operator|>
literal|1
operator|&&
operator|(
name|strcmp
argument_list|(
name|mnemonic
argument_list|,
literal|"bound"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Imm
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Imm
operator|)
operator|)
condition|)
block|{
name|union
name|i386_op
name|temp_op
decl_stmt|;
name|unsigned
name|int
name|temp_type
decl_stmt|;
name|int
name|xchg1
init|=
literal|0
decl_stmt|;
name|int
name|xchg2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|2
condition|)
block|{
name|xchg1
operator|=
literal|0
expr_stmt|;
name|xchg2
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|3
condition|)
block|{
name|xchg1
operator|=
literal|0
expr_stmt|;
name|xchg2
operator|=
literal|2
expr_stmt|;
block|}
name|temp_type
operator|=
name|i
operator|.
name|types
index|[
name|xchg2
index|]
expr_stmt|;
name|i
operator|.
name|types
index|[
name|xchg2
index|]
operator|=
name|i
operator|.
name|types
index|[
name|xchg1
index|]
expr_stmt|;
name|i
operator|.
name|types
index|[
name|xchg1
index|]
operator|=
name|temp_type
expr_stmt|;
name|temp_op
operator|=
name|i
operator|.
name|op
index|[
name|xchg2
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|xchg2
index|]
operator|=
name|i
operator|.
name|op
index|[
name|xchg1
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|xchg1
index|]
operator|=
name|temp_op
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
specifier|const
name|seg_entry
modifier|*
name|temp_seg
decl_stmt|;
name|temp_seg
operator|=
name|i
operator|.
name|seg
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|seg
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|seg
index|[
literal|1
index|]
operator|=
name|temp_seg
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|imm_operands
condition|)
block|{
comment|/* Try to ensure constant immediates are represented in the smallest 	   opcode possible.  */
name|char
name|guess_suffix
init|=
literal|0
decl_stmt|;
name|int
name|op
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
name|guess_suffix
operator|=
name|i
operator|.
name|suffix
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
comment|/* Figure out a suffix from the last register operand specified. 	       We can't do this properly yet, ie. excluding InOutPortReg, 	       but the following works for instructions with immediates. 	       In any case, we can't set i.suffix yet.  */
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
condition|)
name|guess_suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
condition|)
name|guess_suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|flag_16bit_code
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
name|guess_suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Imm
operator|)
operator|&&
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* If a suffix is given, this operand may be shortened.  */
switch|switch
condition|(
name|guess_suffix
condition|)
block|{
case|case
name|WORD_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Imm16
expr_stmt|;
break|break;
case|case
name|BYTE_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Imm16
operator||
name|Imm8
operator||
name|Imm8S
expr_stmt|;
break|break;
block|}
comment|/* If this operand is at most 16 bits, convert it to a 		 signed 16 bit number before trying to see whether it will 		 fit in an even smaller size.  This allows a 16-bit operand 		 such as $0xffe0 to be recognised as within Imm8S range.  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Imm16
operator|)
operator|&&
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|&
operator|~
operator|(
name|offsetT
operator|)
literal|0xffff
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
expr_stmt|;
block|}
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|smallest_imm_type
argument_list|(
operator|(
name|long
operator|)
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
block|}
block|}
name|overlap0
operator|=
literal|0
expr_stmt|;
name|overlap1
operator|=
literal|0
expr_stmt|;
name|overlap2
operator|=
literal|0
expr_stmt|;
name|found_reverse_match
operator|=
literal|0
expr_stmt|;
name|suffix_check
operator|=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|?
name|No_bSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|?
name|No_wSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|SHORT_MNEM_SUFFIX
condition|?
name|No_sSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
condition|?
name|No_lSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|DWORD_MNEM_SUFFIX
condition|?
name|No_dSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|LONG_DOUBLE_MNEM_SUFFIX
condition|?
name|No_xSuf
else|:
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
name|t
operator|++
control|)
block|{
comment|/* Must have right number of operands. */
if|if
condition|(
name|i
operator|.
name|operands
operator|!=
name|t
operator|->
name|operands
condition|)
continue|continue;
comment|/* Check the suffix, except for some instructions in intel mode.  */
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|suffix_check
operator|)
operator|&&
operator|!
operator|(
name|intel_syntax
operator|&&
name|t
operator|->
name|base_opcode
operator|==
literal|0xd9
operator|&&
operator|(
name|t
operator|->
name|extension_opcode
operator|==
literal|5
comment|/* 0xd9,5 "fldcw"  */
operator|||
name|t
operator|->
name|extension_opcode
operator|==
literal|7
operator|)
operator|)
condition|)
comment|/* 0xd9,7 "f{n}stcw"  */
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|t
operator|->
name|operands
condition|)
break|break;
comment|/* 0 operands always matches */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|operands
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* check if other direction is valid ... */
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|D
operator||
name|FloatD
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* try reversing direction of operands */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* does not match either direction */
continue|continue;
block|}
comment|/* found_reverse_match holds which of D or FloatDR 		   we've found.  */
name|found_reverse_match
operator|=
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|D
operator||
name|FloatDR
operator|)
expr_stmt|;
break|break;
block|}
comment|/* found a forward 2 operand match here */
if|if
condition|(
name|t
operator|->
name|operands
operator|==
literal|3
condition|)
block|{
comment|/* Here we make use of the fact that there are no 		   reverse match 3 operand instructions, and all 3 		   operand instructions only need to be checked for 		   register consistency between operands 2 and 3.  */
name|overlap2
operator|=
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
condition|)
continue|continue;
block|}
comment|/* found either forward/reverse 2 or 3 operand match here: 	       slip through to break */
block|}
break|break;
comment|/* we've found a match; break out of loop */
block|}
comment|/* for (t = ... */
if|if
condition|(
name|t
operator|==
name|current_templates
operator|->
name|end
condition|)
block|{
comment|/* we found no match */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"suffix or operands invalid for `%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|JumpAbsolute
operator|)
operator|!=
operator|(
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
operator|&
name|JumpAbsolute
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"indirect %s without `*'"
argument_list|)
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|IsPrefix
operator||
name|IgnoreSize
operator|)
operator|)
operator|==
operator|(
name|IsPrefix
operator||
name|IgnoreSize
operator|)
condition|)
block|{
comment|/* Warn them that a data or address size prefix doesn't affect 	   assembly of the next line of code.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"stand-alone `%s' prefix"
argument_list|)
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the template we found.  */
name|i
operator|.
name|tm
operator|=
operator|*
name|t
expr_stmt|;
if|if
condition|(
name|found_reverse_match
condition|)
block|{
comment|/* If we found a reverse match we must alter the opcode 	   direction bit.  found_reverse_match holds bits to change 	   (different for int& float insns).  */
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|^=
name|found_reverse_match
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|1
index|]
operator|=
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
if|if
condition|(
name|SYSV386_COMPAT
operator|&&
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xfffffde0
operator|)
operator|==
literal|0xdce0
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|^=
name|FloatR
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|FWait
condition|)
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|FWAIT_OPCODE
argument_list|)
condition|)
return|return;
comment|/* Check string instruction segment overrides */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|!=
literal|0
operator|&&
name|i
operator|.
name|mem_operands
operator|!=
literal|0
condition|)
block|{
name|int
name|mem_op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|AnyMem
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|mem_op
index|]
operator|&
name|EsSeg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|!=
operator|&
name|es
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' operand %d must use `%%es' segment"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|mem_op
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* There's only ever one segment override allowed per instruction. 	       This instruction possibly has a legal segment override on the 	       second operand, so copy the segment to where non-string 	       instructions store it, allowing common code.  */
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|seg
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|mem_op
operator|+
literal|1
index|]
operator|&
name|EsSeg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|seg
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|i
operator|.
name|seg
index|[
literal|1
index|]
operator|!=
operator|&
name|es
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' operand %d must use `%%es' segment"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|mem_op
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If matched instruction specifies an explicit instruction mnemonic        suffix, use it.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|Size16
operator||
name|Size32
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Size16
condition|)
name|i
operator|.
name|suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
comment|/* If there's no instruction mnemonic suffix we try to invent one 	   based on register operands. */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
comment|/* We take i.suffix from the last register operand specified, 	       Destination register type is more significant than source 	       register type.  */
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg
operator|)
operator|&&
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
name|InOutPortReg
operator|)
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
condition|?
name|BYTE_MNEM_SUFFIX
else|:
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
operator|)
condition|?
name|WORD_MNEM_SUFFIX
else|:
name|LONG_MNEM_SUFFIX
operator|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* If this is an eight bit register, it's OK.  If it's 		   the 16 or 32 bit version of an eight bit register, 		   we will just use the low portion, and that's OK too. */
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
condition|)
continue|continue;
comment|/* movzx and movsx should not generate this warning. */
if|if
condition|(
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfb7
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfb6
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfbe
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfbf
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|WordReg
operator|)
operator|&&
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|<
literal|4
if|#
directive|if
literal|0
comment|/* Check that the template allows eight bit regs 		       This kills insns such as `orb $1,%edx', which 		       maybe should be allowed.  */
condition|&& (i.tm.operand_types[op]& (Reg8|InOutPortReg))
endif|#
directive|endif
condition|)
block|{
if|#
directive|if
name|REGISTER_WARNINGS
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
name|InOutPortReg
operator|)
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using `%%%s' instead of `%%%s' due to `%c' suffix"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|-
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
condition|?
literal|8
else|:
literal|16
operator|)
operator|)
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* Any other register is bad */
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|FloatReg
operator||
name|FloatAcc
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%%%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
condition|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
comment|/* Reject eight bit registers, except where the template 		 requires them. (eg. movzb)  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%%%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|REGISTER_WARNINGS
comment|/* Warn if the e prefix on a general reg is missing.  */
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using `%%%s' instead of `%%%s' due to `%c' suffix"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|+
literal|8
operator|)
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
comment|/* Reject eight bit registers, except where the template 		 requires them. (eg. movzb)  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%%%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|REGISTER_WARNINGS
comment|/* Warn if the e prefix on a general reg is present.  */
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg32
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using `%%%s' instead of `%%%s' due to `%c' suffix"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|-
literal|8
operator|)
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|DefaultSize
operator|)
operator|&&
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|stackop_size
expr_stmt|;
block|}
comment|/* Make still unresolved immediate matches conform to size of immediate        given in i.suffix.  Note: overlap2 cannot be an immediate!  */
if|if
condition|(
operator|(
name|overlap0
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator|)
operator|)
operator|&&
name|overlap0
operator|!=
name|Imm8
operator|&&
name|overlap0
operator|!=
name|Imm8S
operator|&&
name|overlap0
operator|!=
name|Imm16
operator|&&
name|overlap0
operator|!=
name|Imm32
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
name|overlap0
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|?
name|Imm16
else|:
name|Imm32
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overlap0
operator|==
operator|(
name|Imm16
operator||
name|Imm32
operator|)
condition|)
block|{
name|overlap0
operator|=
operator|(
name|flag_16bit_code
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
operator|)
condition|?
name|Imm16
else|:
name|Imm32
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no instruction mnemonic suffix given; can't determine immediate size"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|overlap1
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator|)
operator|)
operator|&&
name|overlap1
operator|!=
name|Imm8
operator|&&
name|overlap1
operator|!=
name|Imm8S
operator|&&
name|overlap1
operator|!=
name|Imm16
operator|&&
name|overlap1
operator|!=
name|Imm32
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
name|overlap1
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|?
name|Imm16
else|:
name|Imm32
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overlap1
operator|==
operator|(
name|Imm16
operator||
name|Imm32
operator|)
condition|)
block|{
name|overlap1
operator|=
operator|(
name|flag_16bit_code
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
operator|)
condition|?
name|Imm16
else|:
name|Imm32
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no instruction mnemonic suffix given; can't determine immediate size"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|assert
argument_list|(
operator|(
name|overlap2
operator|&
name|Imm
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|=
name|overlap0
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|Imm1
condition|)
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
comment|/* kludge for shift insns */
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|=
name|overlap1
expr_stmt|;
if|if
condition|(
name|overlap1
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|=
name|overlap2
expr_stmt|;
if|if
condition|(
name|overlap2
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
comment|/* Finalize opcode.  First, we change the opcode based on the operand        size given by i.suffix:  We need not change things for byte insns.  */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|W
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no instruction mnemonic suffix given and no register operands; can't size instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For movzx and movsx, need to check the register type */
if|if
condition|(
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfb6
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfbe
operator|)
condition|)
if|if
condition|(
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|)
block|{
name|unsigned
name|int
name|prefix
init|=
name|DATA_PREFIX_OPCODE
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|regs
operator|->
name|reg_type
operator|&
name|Reg16
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|prefix
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|suffix
operator|!=
name|BYTE_MNEM_SUFFIX
condition|)
block|{
comment|/* It's not a byte, select word/dword operation.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|W
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ShortForm
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
literal|8
expr_stmt|;
else|else
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
literal|1
expr_stmt|;
block|}
comment|/* Now select between word& dword operations via the operand 	   size prefix, except for instructions that will ignore this 	   prefix anyway.  */
if|if
condition|(
operator|(
operator|(
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|suffix
operator|==
name|DWORD_MNEM_SUFFIX
operator|)
operator|)
operator|||
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
operator|)
operator|==
name|flag_16bit_code
operator|&&
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IgnoreSize
operator|)
condition|)
block|{
name|unsigned
name|int
name|prefix
init|=
name|DATA_PREFIX_OPCODE
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpByte
condition|)
comment|/* jcxz, loop */
name|prefix
operator|=
name|ADDR_PREFIX_OPCODE
expr_stmt|;
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|prefix
argument_list|)
condition|)
return|return;
block|}
comment|/* Size floating point instruction.  */
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
operator|||
operator|(
name|intel_syntax
operator|&&
name|i
operator|.
name|suffix
operator|==
name|DWORD_MNEM_SUFFIX
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|FloatMF
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|^=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ImmExt
condition|)
block|{
comment|/* These AMD 3DNow! and Intel Katmai New Instructions have an 	   opcode suffix which is coded in the same place as an 8-bit 	   immediate field would be.  Here we fake an 8-bit immediate 	   operand from the opcode suffix stored in tm.extension_opcode.  */
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|assert
argument_list|(
name|i
operator|.
name|imm_operands
operator|==
literal|0
operator|&&
name|i
operator|.
name|operands
operator|<=
literal|2
operator|&&
literal|2
operator|<
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|&
name|im_expressions
index|[
name|i
operator|.
name|imm_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|i
operator|.
name|operands
index|]
operator|.
name|imms
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|i
operator|.
name|operands
operator|++
index|]
operator|=
name|Imm8
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
name|i
operator|.
name|tm
operator|.
name|extension_opcode
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|=
name|None
expr_stmt|;
block|}
comment|/* For insns with operands there are more diddles to do to the opcode. */
if|if
condition|(
name|i
operator|.
name|operands
condition|)
block|{
comment|/* Default segment register this instruction will use 	   for memory accesses.  0 means unknown. 	   This is only for optimizing out unnecessary segment overrides.  */
specifier|const
name|seg_entry
modifier|*
name|default_seg
init|=
literal|0
decl_stmt|;
comment|/* The imul $imm, %reg instruction is converted into 	   imul $imm, %reg, %reg, and the clr %reg instruction 	   is converted into xor %reg, %reg.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|regKludge
condition|)
block|{
name|unsigned
name|int
name|first_reg_op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Pretend we saw the extra register operand. */
name|assert
argument_list|(
name|i
operator|.
name|op
index|[
name|first_reg_op
operator|+
literal|1
index|]
operator|.
name|regs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|i
operator|.
name|op
index|[
name|first_reg_op
operator|+
literal|1
index|]
operator|.
name|regs
operator|=
name|i
operator|.
name|op
index|[
name|first_reg_op
index|]
operator|.
name|regs
expr_stmt|;
name|i
operator|.
name|types
index|[
name|first_reg_op
operator|+
literal|1
index|]
operator|=
name|i
operator|.
name|types
index|[
name|first_reg_op
index|]
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ShortForm
condition|)
block|{
comment|/* The register or float register operand is in operand 0 or 1. */
name|unsigned
name|int
name|op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|FloatReg
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Register goes in low 3 bits of opcode. */
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Ugh
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Warn about some common errors, but press on regardless. 		   The first case can be generated by gcc (<= 2.8.1).  */
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|2
condition|)
block|{
comment|/* reversed arguments on faddp, fsubp, etc. */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating to `%s %%%s,%%%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* extraneous `l' suffix on fp insn */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating to `%s %%%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
comment|/* The opcode is completed (modulo i.tm.extension_opcode which 	       must be put into the modrm byte). 	       Now, we make the modrm& index base bytes based on all the 	       info we've collected. */
comment|/* i.reg_operands MUST be the number of real register operands; 	       implicit registers do not count. */
if|if
condition|(
name|i
operator|.
name|reg_operands
operator|==
literal|2
condition|)
block|{
name|unsigned
name|int
name|source
decl_stmt|,
name|dest
decl_stmt|;
name|source
operator|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|dest
operator|=
name|source
operator|+
literal|1
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
comment|/* One of the register operands will be encoded in the 		   i.tm.reg field, the other in the combined i.tm.mode 		   and i.tm.regmem fields.  If no form of this 		   instruction supports a memory destination operand, 		   then we assume the source operand may sometimes be 		   a memory operand and so we need to store the 		   destination in the i.rm.reg field.  */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|dest
index|]
operator|&
name|AnyMem
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if it's not 2 reg operands... */
if|if
condition|(
name|i
operator|.
name|mem_operands
condition|)
block|{
name|unsigned
name|int
name|fake_zero_displacement
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|op
init|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|AnyMem
operator|)
condition|?
literal|0
else|:
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|AnyMem
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
decl_stmt|;
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|base_reg
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|disp_operands
condition|)
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/* Operand is just<disp> */
if|if
condition|(
name|flag_16bit_code
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|NO_BASE_REGISTER_16
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp16
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32
expr_stmt|;
block|}
block|}
else|else
comment|/* ! i.base_reg&& i.index_reg */
block|{
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|base
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32
expr_stmt|;
comment|/* Must be 32 bit */
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg16
condition|)
block|{
switch|switch
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_num
condition|)
block|{
case|case
literal|3
case|:
comment|/* (%bx) */
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
literal|7
expr_stmt|;
else|else
comment|/* (%bx,%si) -> 0, or (%bx,%di) -> 1 */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|-
literal|6
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* (%bp) */
name|default_seg
operator|=
operator|&
name|ss
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
literal|6
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* fake (%bp) into 0(%bp) */
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* (%bp,%si) -> 2, or (%bp,%di) -> 3 */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|-
literal|6
operator|+
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* (%si) -> 4 or (%di) -> 5 */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|-
literal|6
operator|+
literal|4
expr_stmt|;
block|}
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* i.base_reg and 32 bit mode */
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|base
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|==
name|EBP_REG_NUM
condition|)
block|{
name|default_seg
operator|=
operator|&
name|ss
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|==
literal|0
condition|)
block|{
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|==
name|ESP_REG_NUM
condition|)
block|{
name|default_seg
operator|=
operator|&
name|ss
expr_stmt|;
block|}
name|i
operator|.
name|sib
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/*<disp>(%esp) becomes two byte modrm 			       with no index register.  We've already 			       stored the code for esp in i.rm.regmem 			       ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.  Any 			       base register besides %esp will not use 			       the extra modrm byte.  */
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
if|#
directive|if
operator|!
name|SCALE1_WHEN_NO_INDEX
comment|/* Another case where we force the second 			       modrm byte.  */
if|if
condition|(
name|i
operator|.
name|log2_scale_factor
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
block|}
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fake_zero_displacement
condition|)
block|{
comment|/* Fakes a zero displacement assuming that i.types[op] 			   holds the correct displacement size. */
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|assert
argument_list|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|==
literal|0
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|=
name|exp
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* Fill in i.rm.reg or i.rm.regmem field with register 		   operand (if any) based on i.tm.extension_opcode. 		   Again, we must be careful to make sure that 		   segment/control/debug/test/MMX registers are coded 		   into the i.rm.reg field. */
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
name|unsigned
name|int
name|op
init|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
operator|)
decl_stmt|;
comment|/* If there is an extension opcode to put here, the 		       register number must be put into the regmem field. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
else|else
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
comment|/* Now, if no memory operand has set i.rm.mode = 0, 1, 2 		       we must set it to 3 to indicate this is a register 		       operand in the regmem field.  */
if|if
condition|(
operator|!
name|i
operator|.
name|mem_operands
condition|)
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Fill in i.rm.reg field with extension opcode (if any). */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|tm
operator|.
name|extension_opcode
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|Seg2ShortForm
operator||
name|Seg3ShortForm
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
name|POP_SEG_SHORT
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|==
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"you can't `pop %%cs'"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
operator|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
operator|~
operator|(
name|D
operator||
name|W
operator|)
operator|)
operator|==
name|MOV_AX_DISP32
condition|)
block|{
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* For the string instructions that allow a segment override 	       on one of their operands, the default segment is ds.  */
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
block|}
comment|/* If a segment was explicitly specified, 	   and the specified segment is not the default, 	   use an opcode prefix to select it. 	   If we never figured out what the default segment is, 	   then default_seg will be zero at this point, 	   and the specified segment prefix will always be used.  */
if|if
condition|(
operator|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|!=
name|default_seg
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|->
name|seg_prefix
argument_list|)
condition|)
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Ugh
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating to `%sp'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle conversion of 'int $3' --> special int3 insn. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
name|INT_OPCODE
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|==
literal|3
condition|)
block|{
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|=
name|INT3_OPCODE
expr_stmt|;
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpByte
operator||
name|JumpDword
operator|)
operator|)
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Convert "jmp constant" (and "call constant") to a jump (call) to 	 the absolute address given by the constant.  Since ix86 jumps and 	 calls are pc relative, we need to generate a reloc.  */
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_add_symbol
operator|=
operator|&
name|abs_symbol
expr_stmt|;
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
comment|/* We are ready to output the insn. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Output jumps. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Jump
condition|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|code16
decl_stmt|;
name|int
name|prefix
decl_stmt|;
name|code16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_16bit_code
condition|)
name|code16
operator|=
name|CODE16
expr_stmt|;
name|prefix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
condition|)
block|{
name|prefix
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
name|code16
operator|^=
name|CODE16
expr_stmt|;
block|}
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|code16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefixes
operator|!=
literal|0
operator|&&
operator|!
name|intel_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping prefixes on this instruction"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It's always a symbol;  End frag& setup for relax. 	   Make sure there is enough room in this frag for the largest 	   instruction we may generate in md_convert_frag.  This is 2 	   bytes for the opcode and room for the prefix and largest 	   displacement.  */
name|frag_grow
argument_list|(
name|prefix
operator|+
literal|2
operator|+
name|size
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
name|prefix
operator|+
literal|1
expr_stmt|;
comment|/* Prefix and 1 opcode byte go in fr_fix.  */
name|p
operator|=
name|frag_more
argument_list|(
name|prefix
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|*
name|p
operator|++
operator|=
name|DATA_PREFIX_OPCODE
expr_stmt|;
operator|*
name|p
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
comment|/* 1 possible extra opcode + displacement go in fr_var.  */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|1
operator|+
name|size
argument_list|,
literal|1
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|==
name|JUMP_PC_RELATIVE
condition|?
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|SMALL
argument_list|)
operator||
name|code16
else|:
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|SMALL
argument_list|)
operator||
name|code16
operator|)
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_add_symbol
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_add_number
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|JumpByte
operator||
name|JumpDword
operator|)
condition|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpByte
condition|)
block|{
comment|/* This is a loop or jecxz type instruction.  */
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
condition|)
block|{
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|ADDR_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|code16
decl_stmt|;
name|code16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_16bit_code
condition|)
name|code16
operator|=
name|CODE16
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
condition|)
block|{
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|DATA_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
name|code16
operator|^=
name|CODE16
expr_stmt|;
block|}
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|code16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefixes
operator|!=
literal|0
operator|&&
operator|!
name|intel_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping prefixes on this instruction"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fits_in_unsigned_byte
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
condition|)
block|{
name|insn_size
operator|+=
literal|1
operator|+
name|size
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* opcode can be at most two bytes */
name|insn_size
operator|+=
literal|2
operator|+
name|size
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|2
operator|+
name|size
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
argument_list|,
literal|1
argument_list|,
name|reloc
argument_list|(
name|size
argument_list|,
literal|1
argument_list|,
name|i
operator|.
name|disp_reloc
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpInterSegment
condition|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|prefix
decl_stmt|;
name|int
name|code16
decl_stmt|;
name|code16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_16bit_code
condition|)
name|code16
operator|=
name|CODE16
expr_stmt|;
name|prefix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
condition|)
block|{
name|prefix
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
name|code16
operator|^=
name|CODE16
expr_stmt|;
block|}
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|code16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefixes
operator|!=
literal|0
operator|&&
operator|!
name|intel_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping prefixes on this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
name|prefix
operator|+
literal|1
operator|+
literal|2
operator|+
name|size
expr_stmt|;
comment|/* 1 opcode; 2 segment; offset */
name|p
operator|=
name|frag_more
argument_list|(
name|prefix
operator|+
literal|1
operator|+
literal|2
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|*
name|p
operator|++
operator|=
name|DATA_PREFIX_OPCODE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|long
name|n
init|=
operator|(
name|long
operator|)
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|imms
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|2
operator|&&
operator|!
name|fits_in_unsigned_word
argument_list|(
name|n
argument_list|)
operator|&&
operator|!
name|fits_in_signed_word
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"16-bit jump out of range"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|n
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|imms
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|i
operator|.
name|disp_reloc
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|imms
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't handle non absolute segment in `%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
name|size
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|imms
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output normal instructions here. */
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
comment|/* The prefix bytes. */
for|for
control|(
name|q
operator|=
name|i
operator|.
name|prefix
init|;
name|q
operator|<
name|i
operator|.
name|prefix
operator|+
sizeof|sizeof
argument_list|(
name|i
operator|.
name|prefix
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|i
operator|.
name|prefix
index|[
literal|0
index|]
argument_list|)
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
condition|)
block|{
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
operator|*
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now the opcode; be careful about word order here! */
if|if
condition|(
name|fits_in_unsigned_byte
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
condition|)
block|{
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fits_in_unsigned_word
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
condition|)
block|{
name|insn_size
operator|+=
literal|2
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* put out high byte first: can't use md_number_to_chars! */
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* opcode is either 3 or 4 bytes */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff000000
condition|)
block|{
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|insn_size
operator|+=
literal|3
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* Now the modrm byte and sib byte (if present).  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|<<
literal|0
operator||
name|i
operator|.
name|rm
operator|.
name|reg
operator|<<
literal|3
operator||
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|6
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If i.rm.regmem == ESP (4)&& i.rm.mode != (Register mode)&& not 16 bit 	       ==> need second modrm byte.  */
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|==
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
operator|&&
name|i
operator|.
name|rm
operator|.
name|mode
operator|!=
literal|3
operator|&&
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg16
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|i
operator|.
name|sib
operator|.
name|base
operator|<<
literal|0
operator||
name|i
operator|.
name|sib
operator|.
name|index
operator|<<
literal|3
operator||
name|i
operator|.
name|sib
operator|.
name|scale
operator|<<
literal|6
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|disp_operands
condition|)
block|{
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|size
init|=
literal|4
decl_stmt|;
name|long
name|val
init|=
operator|(
name|long
operator|)
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp8
operator||
name|Disp16
operator|)
condition|)
block|{
name|long
name|mask
decl_stmt|;
name|size
operator|=
literal|2
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|long
operator|)
literal|0xffff
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp8
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|long
operator|)
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|val
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%ld shortened to %ld"
argument_list|)
argument_list|,
name|val
argument_list|,
name|val
operator|&
operator|~
name|mask
argument_list|)
expr_stmt|;
block|}
name|insn_size
operator|+=
name|size
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
name|insn_size
operator|+=
name|size
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|i
operator|.
name|disp_reloc
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end displacement output */
comment|/* output immediate */
if|if
condition|(
name|i
operator|.
name|imm_operands
condition|)
block|{
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|size
init|=
literal|4
decl_stmt|;
name|long
name|val
init|=
operator|(
name|long
operator|)
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator|)
condition|)
block|{
name|long
name|mask
decl_stmt|;
name|size
operator|=
literal|2
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|long
operator|)
literal|0xffff
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|long
operator|)
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|val
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%ld shortened to %ld"
argument_list|)
argument_list|,
name|val
argument_list|,
name|val
operator|&
operator|~
name|mask
argument_list|)
expr_stmt|;
block|}
name|insn_size
operator|+=
name|size
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* not absolute_section */
comment|/* Need a 32-bit fixup (don't support 8bit 			   non-absolute imms).  Try to support other 			   sizes ... */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|enum
name|bfd_reloc_code_real
name|reloc_type
decl_stmt|;
else|#
directive|else
name|int
name|reloc_type
decl_stmt|;
endif|#
directive|endif
name|int
name|size
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|insn_size
operator|+=
name|size
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|reloc
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|i
operator|.
name|disp_reloc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|reloc_type
operator|==
name|BFD_RELOC_32
operator|&&
name|GOT_symbol
operator|&&
name|GOT_symbol
operator|==
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_symbol
operator|&&
operator|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
operator|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_add
operator|&&
operator|(
operator|(
name|symbol_get_value_expression
argument_list|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op_symbol
argument_list|)
operator|->
name|X_op
operator|)
operator|==
name|O_subtract
operator|)
operator|)
operator|)
condition|)
block|{
name|reloc_type
operator|=
name|BFD_RELOC_386_GOTPC
expr_stmt|;
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|+=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end immediate output */
block|}
ifdef|#
directive|ifdef
name|DEBUG386
if|if
condition|(
name|flag_debug
condition|)
block|{
name|pi
argument_list|(
name|line
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG386 */
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|i386_immediate
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_immediate
parameter_list|(
name|imm_start
parameter_list|)
name|char
modifier|*
name|imm_start
decl_stmt|;
block|{
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|segT
name|exp_seg
init|=
literal|0
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|imm_operands
operator|==
name|MAX_IMMEDIATE_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"only 1 or 2 immediate operands are allowed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|exp
operator|=
operator|&
name|im_expressions
index|[
name|i
operator|.
name|imm_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
name|exp
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|imm_start
argument_list|)
condition|)
operator|++
name|imm_start
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|imm_start
expr_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
block|{
comment|/*      * We can have operands of the form      *<symbol>@GOTOFF+<nnn>      * Take the easy way out here and copy everything      * into a temporary buffer...      */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmpbuf
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|first
decl_stmt|;
comment|/* GOT relocations are not supported in 16 bit mode */
if|if
condition|(
name|flag_16bit_code
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"GOT relocations not supported in 16 bit mode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GOT_symbol
operator|==
name|NULL
condition|)
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"PLT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_386_PLT32
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"GOTOFF"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_386_GOTOFF
expr_stmt|;
name|len
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"GOT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_386_GOT32
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad reloc specifier in expression"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the relocation token with ' ', so that errors like 	   foo@GOTOFF1 will be detected.  */
name|first
operator|=
name|cp
operator|-
name|input_line_pointer
expr_stmt|;
name|tmpbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|input_line_pointer
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|tmpbuf
index|[
name|first
index|]
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
operator|+
name|first
operator|+
literal|1
argument_list|,
name|cp
operator|+
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|tmpbuf
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ignoring junk `%s' after expression"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* missing or bad expr becomes absolute 0 */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing or invalid immediate expression `%s' taken as 0"
argument_list|)
argument_list|,
name|imm_start
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm32
expr_stmt|;
comment|/* Size it properly later.  */
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
operator|&&
endif|#
directive|endif
name|exp_seg
operator|!=
name|text_section
operator|&&
name|exp_seg
operator|!=
name|data_section
operator|&&
name|exp_seg
operator|!=
name|bss_section
operator|&&
name|exp_seg
operator|!=
name|undefined_section
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|exp_seg
argument_list|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment %s in operand"
argument_list|)
argument_list|,
name|exp_seg
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment type %d in operand"
argument_list|)
argument_list|,
name|exp_seg
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
endif|#
directive|endif
else|else
block|{
comment|/* This is an address.  The size of the address will be 	 determined later, depending on destination register, 	 suffix, or the default for the section.  We exclude 	 Imm8S here so that `push $foo' and other instructions 	 with an Imm8S form will use Imm16 or Imm32.  */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
operator|(
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|i386_scale
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_scale
parameter_list|(
name|scale
parameter_list|)
name|char
modifier|*
name|scale
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|scale
argument_list|)
condition|)
goto|goto
name|bad_scale
goto|;
switch|switch
condition|(
operator|*
name|scale
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|bad_scale
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting scale factor of 1, 2, 4, or 8: got `%s'"
argument_list|)
argument_list|,
name|scale
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|i
operator|.
name|log2_scale_factor
operator|!=
literal|0
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"scale factor of %d without an index register"
argument_list|)
argument_list|,
literal|1
operator|<<
name|i
operator|.
name|log2_scale_factor
argument_list|)
expr_stmt|;
if|#
directive|if
name|SCALE1_WHEN_NO_INDEX
name|i
operator|.
name|log2_scale_factor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|i386_displacement
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_displacement
parameter_list|(
name|disp_start
parameter_list|,
name|disp_end
parameter_list|)
name|char
modifier|*
name|disp_start
decl_stmt|;
name|char
modifier|*
name|disp_end
decl_stmt|;
block|{
specifier|register
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|segT
name|exp_seg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|int
name|bigdisp
init|=
name|Disp32
decl_stmt|;
if|if
condition|(
name|flag_16bit_code
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
name|bigdisp
operator|=
name|Disp16
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|bigdisp
expr_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|disp_operands
operator|++
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|disp_start
expr_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|disp_end
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|GCC_ASM_O_HACK
define|#
directive|define
name|GCC_ASM_O_HACK
value|0
endif|#
directive|endif
if|#
directive|if
name|GCC_ASM_O_HACK
name|END_STRING_AND_SAVE
argument_list|(
name|disp_end
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|BaseIndex
operator|)
operator|!=
literal|0
operator|&&
name|displacement_string_end
index|[
operator|-
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
comment|/* This hack is to avoid a warning when using the "o" 	 constraint within gcc asm statements. 	 For instance:  	 #define _set_tssldt_desc(n,addr,limit,type) \ 	 __asm__ __volatile__ ( \ 	 "movw %w2,%0\n\t" \ 	 "movw %w1,2+%0\n\t" \ 	 "rorl $16,%1\n\t" \ 	 "movb %b1,4+%0\n\t" \ 	 "movb %4,5+%0\n\t" \ 	 "movb $0,6+%0\n\t" \ 	 "movb %h1,7+%0\n\t" \ 	 "rorl $16,%1" \ 	 : "=o"(*(n)) : "q" (addr), "ri"(limit), "i"(type))  	 This works great except that the output assembler ends 	 up looking a bit weird if it turns out that there is 	 no offset.  You end up producing code that looks like:  	 #APP 	 movw $235,(%eax) 	 movw %dx,2+(%eax) 	 rorl $16,%edx 	 movb %dl,4+(%eax) 	 movb $137,5+(%eax) 	 movb $0,6+(%eax) 	 movb %dh,7+(%eax) 	 rorl $16,%edx 	 #NO_APP  	 So here we provide the missing zero.       */
operator|*
name|displacement_string_end
operator|=
literal|'0'
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|LEX_AT
block|{
comment|/*      * We can have operands of the form      *<symbol>@GOTOFF+<nnn>      * Take the easy way out here and copy everything      * into a temporary buffer...      */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmpbuf
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|first
decl_stmt|;
comment|/* GOT relocations are not supported in 16 bit mode */
if|if
condition|(
name|flag_16bit_code
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"GOT relocations not supported in 16 bit mode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GOT_symbol
operator|==
name|NULL
condition|)
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"PLT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_386_PLT32
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"GOTOFF"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_386_GOTOFF
expr_stmt|;
name|len
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"GOT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_386_GOT32
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad reloc specifier in expression"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the relocation token with ' ', so that errors like 	   foo@GOTOFF1 will be detected.  */
name|first
operator|=
name|cp
operator|-
name|input_line_pointer
expr_stmt|;
name|tmpbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|input_line_pointer
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|tmpbuf
index|[
name|first
index|]
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
operator|+
name|first
operator|+
literal|1
argument_list|,
name|cp
operator|+
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|tmpbuf
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* We do this to make sure that the section symbol is in      the symbol table.  We will ultimately change the relocation      to be relative to the beginning of the section */
if|if
condition|(
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_386_GOTOFF
condition|)
block|{
if|if
condition|(
name|S_IS_LOCAL
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|undefined_section
condition|)
name|section_symbol
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
name|GOT_symbol
expr_stmt|;
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_32
expr_stmt|;
block|}
endif|#
directive|endif
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ignoring junk `%s' after expression"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
if|#
directive|if
name|GCC_ASM_O_HACK
name|RESTORE_END_STRING
argument_list|(
name|disp_end
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RESTORE_END_STRING
argument_list|(
name|disp_end
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* missing or bad expr becomes absolute 0 */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing or invalid displacement expression `%s' taken as 0"
argument_list|)
argument_list|,
name|disp_start
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|Disp16
condition|)
block|{
comment|/* We know this operand is at most 16 bits, so convert to a 	     signed 16 bit number before trying to see whether it will 	     fit in an even smaller size.  */
name|exp
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|exp
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|fits_in_signed_byte
argument_list|(
name|exp
operator|->
name|X_add_number
argument_list|)
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Disp8
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
operator|&&
endif|#
directive|endif
name|exp_seg
operator|!=
name|text_section
operator|&&
name|exp_seg
operator|!=
name|data_section
operator|&&
name|exp_seg
operator|!=
name|bss_section
operator|&&
name|exp_seg
operator|!=
name|undefined_section
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment %s in operand"
argument_list|)
argument_list|,
name|exp_seg
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment type %d in operand"
argument_list|)
argument_list|,
name|exp_seg
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|i386_operand_modifier
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_operand_modifier
parameter_list|(
name|op_string
parameter_list|,
name|got_a_float
parameter_list|)
name|char
modifier|*
modifier|*
name|op_string
decl_stmt|;
name|int
name|got_a_float
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
name|op_string
argument_list|,
literal|"BYTE PTR"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
operator|*
name|op_string
operator|+=
literal|8
expr_stmt|;
return|return
name|BYTE_PTR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
name|op_string
argument_list|,
literal|"WORD PTR"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
if|if
condition|(
name|got_a_float
operator|==
literal|2
condition|)
comment|/* "fi..." */
name|i
operator|.
name|suffix
operator|=
name|SHORT_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
operator|*
name|op_string
operator|+=
literal|8
expr_stmt|;
return|return
name|WORD_PTR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
name|op_string
argument_list|,
literal|"DWORD PTR"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
if|if
condition|(
name|got_a_float
operator|==
literal|1
condition|)
comment|/* "f..." */
name|i
operator|.
name|suffix
operator|=
name|SHORT_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
operator|*
name|op_string
operator|+=
literal|9
expr_stmt|;
return|return
name|DWORD_PTR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
name|op_string
argument_list|,
literal|"QWORD PTR"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|DWORD_MNEM_SUFFIX
expr_stmt|;
operator|*
name|op_string
operator|+=
literal|9
expr_stmt|;
return|return
name|QWORD_PTR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
name|op_string
argument_list|,
literal|"XWORD PTR"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|LONG_DOUBLE_MNEM_SUFFIX
expr_stmt|;
operator|*
name|op_string
operator|+=
literal|9
expr_stmt|;
return|return
name|XWORD_PTR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
name|op_string
argument_list|,
literal|"SHORT"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
operator|*
name|op_string
operator|+=
literal|5
expr_stmt|;
return|return
name|SHORT
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
name|op_string
argument_list|,
literal|"OFFSET FLAT:"
argument_list|,
literal|12
argument_list|)
condition|)
block|{
operator|*
name|op_string
operator|+=
literal|12
expr_stmt|;
return|return
name|OFFSET_FLAT
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
name|op_string
argument_list|,
literal|"FLAT"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
operator|*
name|op_string
operator|+=
literal|4
expr_stmt|;
return|return
name|FLAT
return|;
block|}
else|else
return|return
name|NONE_FOUND
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_displacement_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|build_displacement_string
parameter_list|(
name|initial_disp
parameter_list|,
name|op_string
parameter_list|)
name|int
name|initial_disp
decl_stmt|;
name|char
modifier|*
name|op_string
decl_stmt|;
block|{
name|char
modifier|*
name|temp_string
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|op_string
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|end_of_operand_string
decl_stmt|;
name|char
modifier|*
name|tc
decl_stmt|;
name|char
modifier|*
name|temp_disp
decl_stmt|;
name|temp_string
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tc
operator|=
name|end_of_operand_string
operator|=
name|strchr
argument_list|(
name|op_string
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_disp
operator|&&
operator|!
name|end_of_operand_string
condition|)
block|{
name|strcpy
argument_list|(
name|temp_string
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
name|temp_string
return|;
block|}
comment|/* Build the whole displacement string */
if|if
condition|(
name|initial_disp
condition|)
block|{
name|strncpy
argument_list|(
name|temp_string
argument_list|,
name|op_string
argument_list|,
name|end_of_operand_string
operator|-
name|op_string
argument_list|)
expr_stmt|;
name|temp_string
index|[
name|end_of_operand_string
operator|-
name|op_string
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp_disp
operator|=
name|tc
expr_stmt|;
block|}
else|else
name|temp_disp
operator|=
name|op_string
expr_stmt|;
while|while
condition|(
operator|*
name|temp_disp
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|end_op
decl_stmt|;
name|int
name|add_minus
init|=
operator|(
operator|*
name|temp_disp
operator|==
literal|'-'
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|temp_disp
operator|==
literal|'+'
operator|||
operator|*
name|temp_disp
operator|==
literal|'-'
operator|||
operator|*
name|temp_disp
operator|==
literal|'['
condition|)
name|temp_disp
operator|++
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|temp_disp
argument_list|)
condition|)
name|temp_disp
operator|++
expr_stmt|;
comment|/* Don't consider registers */
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|temp_disp
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
name|parse_register
argument_list|(
name|temp_disp
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|string_start
init|=
name|temp_disp
decl_stmt|;
while|while
condition|(
operator|*
name|temp_disp
operator|!=
literal|']'
operator|&&
operator|*
name|temp_disp
operator|!=
literal|'+'
operator|&&
operator|*
name|temp_disp
operator|!=
literal|'-'
operator|&&
operator|*
name|temp_disp
operator|!=
literal|'*'
condition|)
operator|++
name|temp_disp
expr_stmt|;
if|if
condition|(
name|add_minus
condition|)
name|strcat
argument_list|(
name|temp_string
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|temp_string
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|temp_string
argument_list|,
name|string_start
argument_list|,
name|temp_disp
operator|-
name|string_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|temp_disp
operator|==
literal|'+'
operator|||
operator|*
name|temp_disp
operator|==
literal|'-'
condition|)
operator|--
name|temp_disp
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|temp_disp
operator|!=
literal|'\0'
operator|&&
operator|*
name|temp_disp
operator|!=
literal|'+'
operator|&&
operator|*
name|temp_disp
operator|!=
literal|'-'
condition|)
operator|++
name|temp_disp
expr_stmt|;
block|}
return|return
name|temp_string
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|i386_parse_seg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_parse_seg
parameter_list|(
name|op_string
parameter_list|)
name|char
modifier|*
name|op_string
decl_stmt|;
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
comment|/* Should be one of es, cs, ss, ds fs or gs */
switch|switch
condition|(
operator|*
name|op_string
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|gs
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad segment name `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|op_string
operator|++
operator|!=
literal|'s'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad segment name `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
operator|*
name|op_string
operator|!=
literal|':'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad segment name `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|i386_index_check
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make sure the memory operand we've been dealt is valid.    Returns 1 on success, 0 on a failure. */
end_comment

begin_function
specifier|static
name|int
name|i386_index_check
parameter_list|(
name|operand_string
parameter_list|)
specifier|const
name|char
modifier|*
name|operand_string
decl_stmt|;
block|{
if|#
directive|if
name|INFER_ADDR_PREFIX
name|int
name|fudged
init|=
literal|0
decl_stmt|;
name|tryprefix
label|:
endif|#
directive|endif
if|if
condition|(
name|flag_16bit_code
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
comment|/* 16 bit mode checks */
condition|?
operator|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|!=
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
operator|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|!=
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|||
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|<
literal|6
operator|&&
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|>=
literal|6
operator|&&
name|i
operator|.
name|log2_scale_factor
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
comment|/* 32 bit mode checks */
else|:
operator|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg32
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg32
operator||
name|BaseIndex
operator|)
operator|)
operator|!=
operator|(
name|Reg32
operator||
name|BaseIndex
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|INFER_ADDR_PREFIX
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|==
literal|0
operator|&&
name|stackop_size
operator|!=
literal|'\0'
condition|)
block|{
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|=
name|ADDR_PREFIX_OPCODE
expr_stmt|;
name|i
operator|.
name|prefixes
operator|+=
literal|1
expr_stmt|;
comment|/* Change the size of any displacement too.  At most one of 	     Disp16 or Disp32 is set. 	     FIXME.  There doesn't seem to be any real need for separate 	     Disp16 and Disp32 flags.  The same goes for Imm16 and Imm32. 	     Removing them would probably clean up the code quite a lot. 	  */
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
operator|(
name|Disp16
operator||
name|Disp32
operator|)
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|^=
operator|(
name|Disp16
operator||
name|Disp32
operator|)
expr_stmt|;
name|fudged
operator|=
literal|1
expr_stmt|;
goto|goto
name|tryprefix
goto|;
block|}
if|if
condition|(
name|fudged
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is not a valid base/index expression"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is not a valid %s bit base/index expression"
argument_list|)
argument_list|,
name|operand_string
argument_list|,
name|flag_16bit_code
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|?
literal|"16"
else|:
literal|"32"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|i386_intel_memory_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_intel_memory_operand
parameter_list|(
name|operand_string
parameter_list|)
name|char
modifier|*
name|operand_string
decl_stmt|;
block|{
name|char
modifier|*
name|op_string
init|=
name|operand_string
decl_stmt|;
name|char
modifier|*
name|end_of_operand_string
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|mem_operands
operator|==
literal|1
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|==
literal|0
operator|)
operator|||
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many memory references for `%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* First check for a segment override.  */
if|if
condition|(
operator|*
name|op_string
operator|!=
literal|'['
condition|)
block|{
name|char
modifier|*
name|end_seg
decl_stmt|;
name|end_seg
operator|=
name|strchr
argument_list|(
name|op_string
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_seg
condition|)
block|{
if|if
condition|(
operator|!
name|i386_parse_seg
argument_list|(
name|op_string
argument_list|)
condition|)
return|return
literal|0
return|;
name|op_string
operator|=
name|end_seg
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Look for displacement preceding open bracket */
if|if
condition|(
operator|*
name|op_string
operator|!=
literal|'['
condition|)
block|{
name|char
modifier|*
name|temp_string
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_operands
condition|)
return|return
literal|0
return|;
name|temp_string
operator|=
name|build_displacement_string
argument_list|(
name|true
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i386_displacement
argument_list|(
name|temp_string
argument_list|,
name|temp_string
operator|+
name|strlen
argument_list|(
name|temp_string
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|end_of_operand_string
operator|=
name|strchr
argument_list|(
name|op_string
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end_of_operand_string
condition|)
name|end_of_operand_string
operator|=
name|op_string
operator|+
name|strlen
argument_list|(
name|op_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|end_of_operand_string
argument_list|)
condition|)
operator|--
name|end_of_operand_string
expr_stmt|;
name|op_string
operator|=
name|end_of_operand_string
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|op_string
operator|==
literal|'['
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
comment|/* Pick off each component and figure out where it belongs */
name|end_of_operand_string
operator|=
name|op_string
expr_stmt|;
while|while
condition|(
operator|*
name|op_string
operator|!=
literal|']'
condition|)
block|{
specifier|const
name|reg_entry
modifier|*
name|temp_reg
decl_stmt|;
name|char
modifier|*
name|end_op
decl_stmt|;
name|char
modifier|*
name|temp_string
decl_stmt|;
while|while
condition|(
operator|*
name|end_of_operand_string
operator|!=
literal|'+'
operator|&&
operator|*
name|end_of_operand_string
operator|!=
literal|'-'
operator|&&
operator|*
name|end_of_operand_string
operator|!=
literal|'*'
operator|&&
operator|*
name|end_of_operand_string
operator|!=
literal|']'
condition|)
name|end_of_operand_string
operator|++
expr_stmt|;
name|temp_string
operator|=
name|op_string
expr_stmt|;
if|if
condition|(
operator|*
name|temp_string
operator|==
literal|'+'
condition|)
block|{
operator|++
name|temp_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|temp_string
argument_list|)
condition|)
operator|++
name|temp_string
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|temp_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
operator|(
name|temp_reg
operator|=
name|parse_register
argument_list|(
name|temp_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|NULL
condition|)
name|i
operator|.
name|base_reg
operator|=
name|temp_reg
expr_stmt|;
else|else
name|i
operator|.
name|index_reg
operator|=
name|temp_reg
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|temp_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|temp_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
operator|*
name|op_string
operator|==
literal|'+'
operator|||
operator|*
name|op_string
operator|==
literal|'-'
condition|)
block|{
name|char
modifier|*
name|temp_str
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|temp_string
operator|=
name|build_displacement_string
argument_list|(
name|false
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
name|temp_str
operator|=
name|temp_string
expr_stmt|;
if|if
condition|(
operator|*
name|temp_str
operator|==
literal|'+'
condition|)
operator|++
name|temp_str
expr_stmt|;
if|if
condition|(
operator|!
name|i386_displacement
argument_list|(
name|temp_str
argument_list|,
name|temp_str
operator|+
name|strlen
argument_list|(
name|temp_str
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
operator|++
name|op_string
expr_stmt|;
name|end_of_operand_string
operator|=
name|op_string
expr_stmt|;
while|while
condition|(
operator|*
name|end_of_operand_string
operator|!=
literal|']'
operator|&&
operator|*
name|end_of_operand_string
operator|!=
literal|'+'
operator|&&
operator|*
name|end_of_operand_string
operator|!=
literal|'-'
operator|&&
operator|*
name|end_of_operand_string
operator|!=
literal|'*'
condition|)
operator|++
name|end_of_operand_string
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
literal|'*'
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
name|i
operator|.
name|index_reg
operator|=
name|i
operator|.
name|base_reg
expr_stmt|;
name|i
operator|.
name|base_reg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i386_scale
argument_list|(
name|op_string
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|op_string
operator|=
name|end_of_operand_string
expr_stmt|;
operator|++
name|end_of_operand_string
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i386_index_check
argument_list|(
name|operand_string
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i386_intel_operand
parameter_list|(
name|operand_string
parameter_list|,
name|got_a_float
parameter_list|)
name|char
modifier|*
name|operand_string
decl_stmt|;
name|int
name|got_a_float
decl_stmt|;
block|{
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|end_op
decl_stmt|;
name|char
modifier|*
name|op_string
init|=
name|operand_string
decl_stmt|;
name|int
name|operand_modifier
init|=
name|i386_operand_modifier
argument_list|(
operator|&
name|op_string
argument_list|,
name|got_a_float
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
switch|switch
condition|(
name|operand_modifier
condition|)
block|{
case|case
name|BYTE_PTR
case|:
case|case
name|WORD_PTR
case|:
case|case
name|DWORD_PTR
case|:
case|case
name|QWORD_PTR
case|:
case|case
name|XWORD_PTR
case|:
if|if
condition|(
operator|!
name|i386_intel_memory_operand
argument_list|(
name|op_string
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|FLAT
case|:
case|case
name|OFFSET_FLAT
case|:
if|if
condition|(
operator|!
name|i386_immediate
argument_list|(
name|op_string
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|SHORT
case|:
case|case
name|NONE_FOUND
case|:
comment|/* Should be register or immediate */
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
name|strchr
argument_list|(
name|op_string
argument_list|,
literal|'['
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|i386_immediate
argument_list|(
name|op_string
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
operator|(
name|r
operator|=
name|parse_register
argument_list|(
name|op_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Check for a segment override by searching for ':' after a 	     segment register.  */
name|op_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
operator|*
name|op_string
operator|==
literal|':'
operator|&&
operator|(
name|r
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|reg_num
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|gs
expr_stmt|;
break|break;
block|}
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|r
operator|->
name|reg_type
operator|&
operator|~
name|BaseIndex
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|regs
operator|=
name|r
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|i386_intel_memory_operand
argument_list|(
name|op_string
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
comment|/* end switch */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero    on error. */
end_comment

begin_function
specifier|static
name|int
name|i386_operand
parameter_list|(
name|operand_string
parameter_list|)
name|char
modifier|*
name|operand_string
decl_stmt|;
block|{
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|end_op
decl_stmt|;
name|char
modifier|*
name|op_string
init|=
name|operand_string
decl_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
comment|/* We check for an absolute prefix (differentiating,      for example, 'jmp pc_relative_label' from 'jmp *absolute_label'. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
comment|/* Check if operand is a register. */
if|if
condition|(
operator|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
operator|(
name|r
operator|=
name|parse_register
argument_list|(
name|op_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Check for a segment override by searching for ':' after a 	 segment register.  */
name|op_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
operator|*
name|op_string
operator|==
literal|':'
operator|&&
operator|(
name|r
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|reg_num
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|gs
expr_stmt|;
break|break;
block|}
comment|/* Skip the ':' and whitespace.  */
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
operator|!
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|!
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|*
name|op_string
operator|!=
literal|'('
operator|&&
operator|*
name|op_string
operator|!=
name|ABSOLUTE_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad memory operand `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Handle case of %es:*foo. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
goto|goto
name|do_memory_reference
goto|;
block|}
if|if
condition|(
operator|*
name|op_string
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk `%s' after register"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|r
operator|->
name|reg_type
operator|&
operator|~
name|BaseIndex
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|regs
operator|=
name|r
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|IMMEDIATE_PREFIX
condition|)
block|{
comment|/* ... or an immediate */
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|JumpAbsolute
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate operand illegal with absolute jump"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|i386_immediate
argument_list|(
name|op_string
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
operator|*
name|op_string
operator|==
literal|'('
condition|)
block|{
comment|/* This is a memory reference of some sort. */
name|char
modifier|*
name|base_string
decl_stmt|;
comment|/* Start and end of displacement string expression (if found). */
name|char
modifier|*
name|displacement_string_start
decl_stmt|;
name|char
modifier|*
name|displacement_string_end
decl_stmt|;
name|do_memory_reference
label|:
if|if
condition|(
operator|(
name|i
operator|.
name|mem_operands
operator|==
literal|1
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|==
literal|0
operator|)
operator|||
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many memory references for `%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for base index form.  We detect the base index form by 	 looking for an ')' at the end of the operand, searching 	 for the '(' matching it, and finding a REGISTER_PREFIX or ',' 	 after the '('.  */
name|base_string
operator|=
name|op_string
operator|+
name|strlen
argument_list|(
name|op_string
argument_list|)
expr_stmt|;
operator|--
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|--
name|base_string
expr_stmt|;
comment|/* If we only have a displacement, set-up for it to be parsed later. */
name|displacement_string_start
operator|=
name|op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|base_string
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
block|{
name|char
modifier|*
name|temp_string
decl_stmt|;
name|unsigned
name|int
name|parens_balanced
init|=
literal|1
decl_stmt|;
comment|/* We've already checked that the number of left& right ()'s are 	     equal, so this loop will not be infinite. */
do|do
block|{
name|base_string
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
name|parens_balanced
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|'('
condition|)
name|parens_balanced
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|parens_balanced
condition|)
do|;
name|temp_string
operator|=
name|base_string
expr_stmt|;
comment|/* Skip past '(' and whitespace.  */
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
operator|||
operator|(
operator|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|=
name|parse_register
argument_list|(
name|base_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|displacement_string_end
operator|=
name|temp_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
condition|)
block|{
name|base_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
block|}
comment|/* There may be an index reg or scale factor here.  */
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
condition|)
block|{
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
operator|(
name|i
operator|.
name|index_reg
operator|=
name|parse_register
argument_list|(
name|base_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|base_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
condition|)
block|{
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting `,' or `)' after index register in `%s'"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|base_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for scale factor. */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|base_string
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|i386_scale
argument_list|(
name|base_string
argument_list|)
condition|)
return|return
literal|0
return|;
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting `)' after scale factor in `%s'"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting index register or scale factor after `,'; got '%c'"
argument_list|)
argument_list|,
operator|*
name|base_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting `,' or `)' after base register in `%s'"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|base_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If there's an expression beginning the operand, parse it, 	 assuming displacement_string_start and 	 displacement_string_end are meaningful.  */
if|if
condition|(
name|displacement_string_start
operator|!=
name|displacement_string_end
condition|)
block|{
if|if
condition|(
operator|!
name|i386_displacement
argument_list|(
name|displacement_string_start
argument_list|,
name|displacement_string_end
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Special case for (%dx) while doing input/output op.  */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|==
operator|(
name|Reg16
operator||
name|InOutPortReg
operator|)
operator|&&
name|i
operator|.
name|index_reg
operator|==
literal|0
operator|&&
name|i
operator|.
name|log2_scale_factor
operator|==
literal|0
operator|&&
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|==
literal|0
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|Disp
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|InOutPortReg
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|i386_index_check
argument_list|(
name|operand_string
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* it's not a memory operand; argh! */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid char %s beginning operand %d `%s'"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|op_string
argument_list|)
argument_list|,
name|this_operand
operator|+
literal|1
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* normal return */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * md_estimate_size_before_relax()  *  * Called just before relax().  * Any symbol that is now undefined will not become defined.  * Return the correct fr_subtype in the frag.  * Return the initial "guess for fr_var" to caller.  * The guess for fr_var is ACTUALLY the growth beyond fr_fix.  * Whatever we do to grow fr_fix or fr_var contributes to our returned value.  * Although it may not be explicit in the frag, pretend fr_var starts with a  * 0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
specifier|register
name|int
name|old_fr_fix
decl_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* We've already got fragP->fr_subtype right;  all we have to do is      check for un-relaxable symbols.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
condition|)
block|{
comment|/* symbol is undefined in this segment */
name|int
name|code16
init|=
name|fragP
operator|->
name|fr_subtype
operator|&
name|CODE16
decl_stmt|;
name|int
name|size
init|=
name|code16
condition|?
literal|2
else|:
literal|4
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|enum
name|bfd_reloc_code_real
name|reloc_type
decl_stmt|;
else|#
directive|else
name|int
name|reloc_type
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GOT_symbol
comment|/* Not quite right - we should switch on presence of 			@PLT, but I cannot see how to get to that from 			here.  We should have done this in md_assemble to 			really get it right all of the time, but I think it 			does not matter that much, as this will be right 			most of the time. ERY  */
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|undefined_section
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_386_PLT32
expr_stmt|;
elseif|else
if|if
condition|(
name|code16
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
else|else
name|reloc_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
switch|switch
condition|(
name|opcode
index|[
literal|0
index|]
condition|)
block|{
case|case
name|JUMP_PC_RELATIVE
case|:
comment|/* make jmp (0xeb) a dword displacement jump */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
comment|/* dword disp jmp */
name|fragP
operator|->
name|fr_fix
operator|+=
name|size
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
argument_list|,
name|size
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This changes the byte-displacement jump 0x7N 	     to the dword-displacement jump 0x0f,0x8N.  */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
name|size
expr_stmt|;
comment|/* we've added an opcode byte */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
name|size
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fragP
operator|->
name|fr_var
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			md_convert_frag();  *  * Called after relax() is finished.  * In:	Address of frag.  *	fr_type == rs_machine_dependent.  *	fr_subtype is what the address relaxed to.  *  * Out:	Any fixSs and constants are set up.  *	Caller will turn frag into a ".space 0".  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
else|#
directive|else
function|void md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|char
modifier|*
name|where_to_put_displacement
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|target_address
decl_stmt|;
name|unsigned
name|int
name|opcode_address
decl_stmt|;
name|unsigned
name|int
name|extension
init|=
literal|0
decl_stmt|;
name|int
name|displacement_from_opcode_start
decl_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* Address we want to reach in file space. */
name|target_address
operator|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* not needed otherwise? */
name|target_address
operator|+=
name|symbol_get_frag
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|->
name|fr_address
expr_stmt|;
endif|#
directive|endif
comment|/* Address opcode resides at in file space. */
name|opcode_address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* Displacement from opcode start to fill into instruction. */
name|displacement_from_opcode_start
operator|=
name|target_address
operator|-
name|opcode_address
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|SMALL
argument_list|)
case|:
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|SMALL16
argument_list|)
case|:
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|SMALL
argument_list|)
case|:
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|SMALL16
argument_list|)
case|:
comment|/* don't have to change opcode */
name|extension
operator|=
literal|1
expr_stmt|;
comment|/* 1 opcode + 1 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BIG
argument_list|)
case|:
name|extension
operator|=
literal|5
expr_stmt|;
comment|/* 2 opcode + 4 displacement */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BIG
argument_list|)
case|:
name|extension
operator|=
literal|4
expr_stmt|;
comment|/* 1 opcode + 4 displacement */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BIG16
argument_list|)
case|:
name|extension
operator|=
literal|3
expr_stmt|;
comment|/* 2 opcode + 2 displacement */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BIG16
argument_list|)
case|:
name|extension
operator|=
literal|2
expr_stmt|;
comment|/* 1 opcode + 2 displacement */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* now put displacement after opcode */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|where_to_put_displacement
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|displacement_from_opcode_start
operator|-
name|extension
argument_list|)
argument_list|,
name|SIZE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of byte displacement jmp */
end_comment

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of dword displacement jmp */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xeb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* opcode for byte-disp jump */
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|flag_do_long_jump
condition|)
block|{
name|offset
operator|=
name|to_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|to_symbol
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* opcode for long jmp */
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|5
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Apply a fixup (fixS) to segment data, once it has been determined    by our caller that we have all the info we need to fix it up.     On the 386, immediates, displacements, and data pointers are all in    the same (little-endian) format, so we don't need to care about which    we are handling.  */
end_comment

begin_function
name|int
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valp
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* The fix we're to put in.  */
name|valueT
modifier|*
name|valp
decl_stmt|;
comment|/* Pointer to the value of the bits.  */
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
comment|/* Segment fix is from.  */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_Mach
argument_list|)
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
default|default:
break|break;
case|case
name|BFD_RELOC_32
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
block|}
block|}
comment|/* This is a hack.  There should be a better way to handle this.      This covers for the fact that bfd_install_relocation will      subtract the current location (for partial_inplace, PC relative      relocations); see more below.  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_8_PCREL
operator|)
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
ifndef|#
directive|ifndef
name|OBJ_AOUT
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
ifdef|#
directive|ifdef
name|TE_PE
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_coff_flavour
endif|#
directive|endif
condition|)
name|value
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|segT
name|fseg
init|=
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fseg
operator|==
name|seg
operator|||
operator|(
name|symbol_section_p
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|fseg
operator|!=
name|absolute_section
operator|)
operator|)
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* Yes, we add the values in twice.  This is because 		 bfd_perform_relocation subtracts them out again.  I think 		 bfd_perform_relocation is broken, but I don't dare change 		 it.  FIXME.  */
name|value
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|&&
name|defined
argument_list|(
name|TE_PE
argument_list|)
comment|/* For some reason, the PE format does not store a section 	 address offset for a PC relative symbol.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
condition|)
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* We are generating an external relocation for this defined              symbol.  We add the address, because              bfd_install_relocation will subtract it.  VALUE already              holds the symbol value, because fixup_segment added it              in.  We subtract it out, and then we subtract it out              again because bfd_install_relocation will add it in              again.  */
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
name|value
operator|-=
literal|2
operator|*
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TE_PE
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
condition|)
block|{
comment|/* We are generating an external relocation for this defined          symbol.  VALUE already holds the symbol value, and          bfd_install_relocation will add it in again.  We don't want          either addition.  */
name|value
operator|-=
literal|2
operator|*
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Fix a few things - the dynamic linker expects certain values here,      and we must not dissappoint it. */
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_386_PLT32
case|:
comment|/* Make the jump instruction point to the address of the operand.  At 	 runtime we merely add the offset to the actual PLT entry. */
name|value
operator|=
literal|0xfffffffc
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_386_GOTPC
case|:
comment|/*  *   This is tough to explain.  We end up with this one if we have  * operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal  * here is to obtain the absolute address of the GOT, and it is strongly  * preferable from a performance point of view to avoid using a runtime  * relocation for this.  The actual sequence of instructions often look  * something like:  *  *	call	.L66  * .L66:  *	popl	%ebx  *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx  *  *   The call and pop essentially return the absolute address of  * the label .L66 and store it in %ebx.  The linker itself will  * ultimately change the first operand of the addl so that %ebx points to  * the GOT, but to keep things simple, the .o file must have this operand  * set so that it generates not the absolute address of .L66, but the  * absolute address of itself.  This allows the linker itself simply  * treat a GOTPC relocation as asking for a pcrel offset to the GOT to be  * added in, and the addend of the relocation is stored in the operand  * field for the instruction itself.  *  *   Our job here is to fix the operand so that it would add the correct  * offset so that %ebx would point to itself.  The thing that is tricky is  * that .-.L66 will point to the beginning of the instruction, so we need  * to further modify the operand so that it will point to itself.  * There are other cases where you have something like:  *  *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]  *  * and here no correction would be required.  Internally in the assembler  * we treat operands of this form as not being pcrel since the '.' is  * explicitly mentioned, and I wonder whether it would simplify matters  * to do it this way.  Who knows.  In earlier versions of the PIC patches,  * the pcrel_adjust field was used to store the correction, but since the  * expression is not pcrel, I felt it would be confusing to do it this way.  */
name|value
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_386_GOT32
case|:
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Fully resolved at runtime.  No addend.  */
break|break;
case|case
name|BFD_RELOC_386_GOTOFF
case|:
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) */
operator|*
name|valp
operator|=
name|value
expr_stmt|;
endif|#
directive|endif
comment|/* defined (BFD_ASSEMBLER)&& !defined (TE_Mach) */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is never used.  */
end_comment

begin_comment
unit|long
comment|/* Knows about the byte order in a word. */
end_comment

begin_comment
unit|md_chars_to_number (con, nbytes)      unsigned char con[];
comment|/* Low order byte 1st. */
end_comment

begin_comment
unit|int nbytes;
comment|/* Number of bytes in the input. */
end_comment

begin_endif
unit|{   long retval;   for (retval = 0, con += nbytes - 1; nbytes--; con--)     {       retval<<= BITS_PER_CHAR;       retval |= *con;     }   return retval; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn the string pointed to by litP into a floating point constant of type    type, and emit the appropriate bytes.  The number of LITTLENUMS emitted    is stored in *sizeP .  An error message is returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof ()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loops outputs the LITTLENUMs in REVERSE order; in accord with      the bigendian 386.  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|char
name|output_invalid_buf
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_invalid
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|output_invalid
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"(0x%x)"
argument_list|,
operator|(
name|unsigned
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
name|output_invalid_buf
return|;
block|}
end_function

begin_comment
comment|/* REG_STRING starts *before* REGISTER_PREFIX.  */
end_comment

begin_function
specifier|static
specifier|const
name|reg_entry
modifier|*
name|parse_register
parameter_list|(
name|reg_string
parameter_list|,
name|end_op
parameter_list|)
name|char
modifier|*
name|reg_string
decl_stmt|;
name|char
modifier|*
modifier|*
name|end_op
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|reg_string
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|reg_name_given
index|[
name|MAX_REG_NAME_SIZE
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
comment|/* Skip possible REGISTER_PREFIX and possible whitespace.  */
if|if
condition|(
operator|*
name|s
operator|==
name|REGISTER_PREFIX
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|p
operator|=
name|reg_name_given
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|register_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|reg_name_given
operator|+
name|MAX_REG_NAME_SIZE
condition|)
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|end_op
operator|=
name|s
expr_stmt|;
name|r
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name_given
argument_list|)
expr_stmt|;
comment|/* Handle floating point regs, allowing spaces in the (i) part.  */
if|if
condition|(
name|r
operator|==
name|i386_regtab
comment|/* %st is first entry of table */
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
condition|)
block|{
name|r
operator|=
operator|&
name|i386_float_regtab
index|[
operator|*
name|s
operator|-
literal|'0'
index|]
expr_stmt|;
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
block|{
operator|*
name|end_op
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
comment|/* We have "%st(" then garbage */
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"kmVQ:sq"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"m"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'m'
case|:
name|flag_do_long_jump
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
comment|/* -k: Ignore for FreeBSD compatibility.  */
case|case
literal|'k'
case|:
break|break;
comment|/* -V: SVR4 argument to print version ID.  */
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section 	 should be emitted or not.  FIXME: Not implemented.  */
case|case
literal|'Q'
case|:
break|break;
case|case
literal|'s'
case|:
comment|/* -s: On i386 Solaris, this tells the native assembler to use          .stab instead of .stab.excl.  We always use .stab anyhow.  */
break|break;
case|case
literal|'q'
case|:
comment|/* -q: On i386 Solaris, this tells the native assembler does          fewer checks.  */
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -m			  do long jump\n"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -V			  print assembler version number\n\   -k			  ignored\n\   -Qy, -Qn		  ignored\n\   -q			  ignored\n\   -s			  ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_if
if|#
directive|if
operator|(
operator|(
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_MAYBE_COFF
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|OBJ_MAYBE_COFF
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
operator|)
end_if

begin_comment
comment|/* Pick the target format to use.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_target_format
parameter_list|()
block|{
switch|switch
condition|(
name|OUTPUT_FLAVOR
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_MAYBE_AOUT
case|case
name|bfd_target_aout_flavour
case|:
return|return
name|AOUT_TARGET_FORMAT
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_MAYBE_COFF
case|case
name|bfd_target_coff_flavour
case|:
return|return
literal|"coff-i386"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_MAYBE_ELF
case|case
name|bfd_target_elf_flavour
case|:
return|return
literal|"elf32-i386"
return|;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_MAYBE_ more than one */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

begin_escape
end_escape

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|GLOBAL_OFFSET_TABLE_NAME
index|[
literal|0
index|]
operator|&&
name|name
index|[
literal|1
index|]
operator|==
name|GLOBAL_OFFSET_TABLE_NAME
index|[
literal|1
index|]
operator|&&
name|name
index|[
literal|2
index|]
operator|==
name|GLOBAL_OFFSET_TABLE_NAME
index|[
literal|2
index|]
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|name
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"GOT already in symbol table"
argument_list|)
argument_list|)
expr_stmt|;
name|GOT_symbol
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
name|GOT_symbol
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
condition|)
block|{
comment|/* For a.out, force the section size to be aligned.  If we don't do 	 this, BFD will align it for us, but it will not write out the 	 final bytes of the section.  This may be a bug in BFD, but it is 	 easier to fix it here since that is how the other a.out targets 	 work.  */
name|int
name|align
decl_stmt|;
name|align
operator|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|(
name|valueT
operator|)
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* On the i386, PC-relative offsets are relative to the start of the    next instruction.  That is, the address of the offset, plus its    size, since the offset is always the last part of the insn.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|I386COFF
end_ifndef

begin_function
specifier|static
name|void
name|s_bss
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|void
name|i386_validate_fix
parameter_list|(
name|fixp
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|&&
name|fixp
operator|->
name|fx_subsy
operator|==
name|GOT_symbol
condition|)
block|{
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_386_GOTOFF
expr_stmt|;
name|fixp
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_386_PLT32
case|:
case|case
name|BFD_RELOC_386_GOT32
case|:
case|case
name|BFD_RELOC_386_GOTOFF
case|:
case|case
name|BFD_RELOC_386_GOTPC
case|:
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_size
condition|)
block|{
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can not do %d byte pc-relative relocation"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_size
condition|)
block|{
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can not do %d byte relocation"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_32
operator|&&
name|GOT_symbol
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|GOT_symbol
condition|)
name|code
operator|=
name|BFD_RELOC_386_GOTPC
expr_stmt|;
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
comment|/* HACK: Since i386 ELF uses Rel instead of Rela, encode the      vtable entry to be used in the relocation's section offset.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent relocation type %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
operator|)
end_if

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
comment|/*    * In: length of relocation (or of address) in chars: 1, 2 or 4.    * Out: GNU LD relocation length code: 0, 1, or 2.    */
specifier|static
specifier|const
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|long
name|r_symbolnum
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT or OBJ_BOUT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I386COFF
argument_list|)
end_if

begin_function
name|short
name|tc_coff_fix2rtype
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|R_IMAGEBASE
condition|)
return|return
name|R_IMAGEBASE
return|;
return|return
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_PCRBYTE
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_PCRWORD
else|:
name|R_PCRLONG
operator|)
else|:
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_RELBYTE
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_RELWORD
else|:
name|R_DIR32
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tc_coff_sizemachdep
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
if|if
condition|(
name|frag
operator|->
name|fr_next
condition|)
return|return
operator|(
name|frag
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|frag
operator|->
name|fr_address
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I386COFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_escape
end_escape

begin_comment
comment|/* end of tc-i386.c */
end_comment

end_unit

