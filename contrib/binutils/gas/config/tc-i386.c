begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i386.c -- Assemble code for the Intel 80386    Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Intel 80386 machine specific gas.    Written by Eliot Dresselhaus (eliot@mgm.mit.edu).    x86_64 support by Jan Hubicka (jh@suse.cz)    Bugs& suggestions are completely welcome.  This is free software.    Please help us make it better.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"opcode/i386.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_WARNINGS
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_WARNINGS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INFER_ADDR_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|INFER_ADDR_PREFIX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SCALE1_WHEN_NO_INDEX
end_ifndef

begin_comment
comment|/* Specifying a scale factor besides 1 when there is no index is    futile.  eg. `mov (%ebx,2),%al' does exactly the same as    `mov (%ebx),%al'.  To slavishly follow what the programmer    specified, set SCALE1_WHEN_NO_INDEX to 0.  */
end_comment

begin_define
define|#
directive|define
name|SCALE1_WHEN_NO_INDEX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|true
end_ifndef

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|false
end_ifndef

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mode_from_disp_size
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_signed_byte
name|PARAMS
argument_list|(
operator|(
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_unsigned_byte
name|PARAMS
argument_list|(
operator|(
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_unsigned_word
name|PARAMS
argument_list|(
operator|(
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_signed_word
name|PARAMS
argument_list|(
operator|(
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_unsigned_long
name|PARAMS
argument_list|(
operator|(
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_signed_long
name|PARAMS
argument_list|(
operator|(
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|smallest_imm_type
name|PARAMS
argument_list|(
operator|(
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|offsetT
name|offset_in_range
name|PARAMS
argument_list|(
operator|(
name|offsetT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_prefix
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_code_flag
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_16bit_gcc_code_flag
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_intel_syntax
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_cpu_arch
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|reloc
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RELOC_ENUM
value|enum bfd_reloc_code_real
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RELOC_ENUM
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_ARCH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|"i386"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_arch
init|=
name|DEFAULT_ARCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'md_assemble ()' gathers together information and puts it into a    i386_insn.  */
end_comment

begin_union
union|union
name|i386_op
block|{
name|expressionS
modifier|*
name|disps
decl_stmt|;
name|expressionS
modifier|*
name|imms
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|regs
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|_i386_insn
block|{
comment|/* TM holds the template for the insn were currently assembling.  */
name|template
name|tm
decl_stmt|;
comment|/* SUFFIX holds the instruction mnemonic suffix if given.        (e.g. 'l' for 'movl')  */
name|char
name|suffix
decl_stmt|;
comment|/* OPERANDS gives the number of given operands.  */
name|unsigned
name|int
name|operands
decl_stmt|;
comment|/* REG_OPERANDS, DISP_OPERANDS, MEM_OPERANDS, IMM_OPERANDS give the number        of given register, displacement, memory operands and immediate        operands.  */
name|unsigned
name|int
name|reg_operands
decl_stmt|,
name|disp_operands
decl_stmt|,
name|mem_operands
decl_stmt|,
name|imm_operands
decl_stmt|;
comment|/* TYPES [i] is the type (see above #defines) which tells us how to        use OP[i] for the corresponding operand.  */
name|unsigned
name|int
name|types
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Displacement expression, immediate expression, or register for each        operand.  */
name|union
name|i386_op
name|op
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Flags for operands.  */
name|unsigned
name|int
name|flags
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
define|#
directive|define
name|Operand_PCrel
value|1
comment|/* Relocation type for operand */
name|RELOC_ENUM
name|reloc
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* BASE_REG, INDEX_REG, and LOG2_SCALE_FACTOR are used to encode        the base index byte below.  */
specifier|const
name|reg_entry
modifier|*
name|base_reg
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|index_reg
decl_stmt|;
name|unsigned
name|int
name|log2_scale_factor
decl_stmt|;
comment|/* SEG gives the seg_entries of this insn.  They are zero unless        explicit segment overrides are given.  */
specifier|const
name|seg_entry
modifier|*
name|seg
index|[
literal|2
index|]
decl_stmt|;
comment|/* PREFIX holds all the given prefix opcodes (usually null).        PREFIXES is the number of prefix opcodes.  */
name|unsigned
name|int
name|prefixes
decl_stmt|;
name|unsigned
name|char
name|prefix
index|[
name|MAX_PREFIXES
index|]
decl_stmt|;
comment|/* RM and SIB are the modrm byte and the sib byte where the        addressing modes of this insn are encoded.  */
name|modrm_byte
name|rm
decl_stmt|;
name|rex_byte
name|rex
decl_stmt|;
name|sib_byte
name|sib
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|_i386_insn
name|i386_insn
typedef|;
end_typedef

begin_comment
comment|/* List of chars besides those in app.c:symbol_chars that can start an    operand.  Used to prevent the scrubber eating vital white-space.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LEX_AT
end_ifdef

begin_decl_stmt
specifier|const
name|char
name|extra_symbol_chars
index|[]
init|=
literal|"*%-(@"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|extra_symbol_chars
index|[]
init|=
literal|"*%-("
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TE_I386AIX
argument_list|)
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_FreeBSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|)
end_if

begin_comment
comment|/* Putting '/' here makes it impossible to use the divide operator.    However, we need it for compatibility with SVR4 systems.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PREFIX_SEPARATOR
value|'\\'
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PREFIX_SEPARATOR
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.    Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.    Also note that comments started like this one will always work if    '/' isn't otherwise defined.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TE_I386AIX
argument_list|)
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_FreeBSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"/"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point    nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant    As in 0f12.456    or    0d1.2345e12.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDxX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tables for lexical analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mnemonic_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|operand_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|identifier_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|digit_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lexical macros.  */
end_comment

begin_define
define|#
directive|define
name|is_mnemonic_char
parameter_list|(
name|x
parameter_list|)
value|(mnemonic_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_operand_char
parameter_list|(
name|x
parameter_list|)
value|(operand_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_register_char
parameter_list|(
name|x
parameter_list|)
value|(register_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_space_char
parameter_list|(
name|x
parameter_list|)
value|((x) == ' ')
end_define

begin_define
define|#
directive|define
name|is_identifier_char
parameter_list|(
name|x
parameter_list|)
value|(identifier_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_digit_char
parameter_list|(
name|x
parameter_list|)
value|(digit_chars[(unsigned char) x])
end_define

begin_comment
comment|/* All non-digit non-letter charcters that may occur in an operand.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|operand_special_chars
index|[]
init|=
literal|"%$-+(,)*._~/<>|&^!:[@]"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* md_assemble() always leaves the strings it's passed unaltered.  To    effect this we maintain a stack of saved characters that we've smashed    with '\0's (indicating end of strings for various sub-fields of the    assembler instruction).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_stack
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_stack_p
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|END_STRING_AND_SAVE
parameter_list|(
name|s
parameter_list|)
define|\
value|do { *save_stack_p++ = *(s); *(s) = '\0'; } while (0)
end_define

begin_define
define|#
directive|define
name|RESTORE_END_STRING
parameter_list|(
name|s
parameter_list|)
define|\
value|do { *(s) = *--save_stack_p; } while (0)
end_define

begin_comment
comment|/* The instruction we're assembling.  */
end_comment

begin_decl_stmt
specifier|static
name|i386_insn
name|i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Possible templates for current insn.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|templates
modifier|*
name|current_templates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per instruction expressionS buffers: 2 displacements& 2 immediate max.  */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|disp_expressions
index|[
literal|2
index|]
decl_stmt|,
name|im_expressions
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current operand we are working on.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We support four different modes.  FLAG_CODE variable is used to distinguish    these.  */
end_comment

begin_enum
enum|enum
name|flag_code
block|{
name|CODE_32BIT
block|,
name|CODE_16BIT
block|,
name|CODE_64BIT
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|NUM_FLAG_CODE
value|((int) CODE_64BIT + 1)
end_define

begin_decl_stmt
specifier|static
name|enum
name|flag_code
name|flag_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_rela_relocations
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The names used to print error messages.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|flag_code_names
index|[]
init|=
block|{
literal|"32"
block|,
literal|"16"
block|,
literal|"64"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 for intel syntax,    0 if att syntax.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|intel_syntax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if register prefix % not required.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allow_naked_reg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in 16 bit gcc mode to add an l suffix to call, ret, enter,    leave, push, and pop instructions so that gcc has the same stack    frame as in 32 bit mode.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|stackop_size
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero to quieten some warnings.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|quiet_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpu_arch_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU feature flags.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cpu_arch_flags
init|=
name|CpuUnknownFlags
operator||
name|CpuNo64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If set, conditional jumps are not automatically promoted to handle    larger than a byte offset.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|no_cond_jump_promotion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interface to relax_segment.    There are 3 major relax states for 386 jump insns because the    different types of jumps add different sizes to frags when we're    figuring out what sort of jump to choose to reach a given label.  */
end_comment

begin_comment
comment|/* Types.  */
end_comment

begin_define
define|#
directive|define
name|UNCOND_JUMP
value|0
end_define

begin_define
define|#
directive|define
name|COND_JUMP
value|1
end_define

begin_define
define|#
directive|define
name|COND_JUMP86
value|2
end_define

begin_comment
comment|/* Sizes.  */
end_comment

begin_define
define|#
directive|define
name|CODE16
value|1
end_define

begin_define
define|#
directive|define
name|SMALL
value|0
end_define

begin_define
define|#
directive|define
name|SMALL16
value|(SMALL|CODE16)
end_define

begin_define
define|#
directive|define
name|BIG
value|2
end_define

begin_define
define|#
directive|define
name|BIG16
value|(BIG|CODE16)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|INLINE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|INLINE
value|__inline__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ENCODE_RELAX_STATE
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|)
define|\
value|((relax_substateT) (((type)<< 2) | (size)))
end_define

begin_define
define|#
directive|define
name|TYPE_FROM_RELAX_STATE
parameter_list|(
name|s
parameter_list|)
define|\
value|((s)>> 2)
end_define

begin_define
define|#
directive|define
name|DISP_SIZE_FROM_RELAX_STATE
parameter_list|(
name|s
parameter_list|)
define|\
value|((((s)& 3) == BIG ? 4 : (((s)& 3) == BIG16 ? 2 : 1)))
end_define

begin_comment
comment|/* This table is used by relax_frag to promote short jumps to long    ones where necessary.  SMALL (short) jumps may be promoted to BIG    (32 bit long) ones, and SMALL16 jumps to BIG16 (16 bit long).  We    don't allow a short jump in a 32 bit code segment to be promoted to    a 16 bit offset jump because it's slower (requires data size    prefix), and doesn't work, unless the destination is in the bottom    64k of the code segment (The top 16 bits of eip are zeroed).  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The fields are:      1) most positive reach of this state,      2) most negative reach of this state,      3) how many bytes this mode will have in the variable part of the frag      4) which index into the table to try if we can't fit into this one.  */
comment|/* UNCOND_JUMP states.  */
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|BIG
argument_list|)
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|BIG16
argument_list|)
block|}
block|,
comment|/* dword jmp adds 4 bytes to frag:      0 extra opcode bytes, 4 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* word jmp adds 2 byte2 to frag:      0 extra opcode bytes, 2 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
comment|/* COND_JUMP states.  */
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|BIG
argument_list|)
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|BIG16
argument_list|)
block|}
block|,
comment|/* dword conditionals adds 5 bytes to frag:      1 extra opcode byte, 4 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* word conditionals add 3 bytes to frag:      1 extra opcode byte, 2 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
comment|/* COND_JUMP86 states.  */
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP86
argument_list|,
argument|BIG
argument_list|)
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP86
argument_list|,
argument|BIG16
argument_list|)
block|}
block|,
comment|/* dword conditionals adds 5 bytes to frag:      1 extra opcode byte, 4 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* word conditionals add 4 bytes to frag:      1 displacement byte and a 3 byte long branch insn.  */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arch_entry
name|cpu_arch
index|[]
init|=
block|{
block|{
literal|"i8086"
block|,
name|Cpu086
block|}
block|,
block|{
literal|"i186"
block|,
name|Cpu086
operator||
name|Cpu186
block|}
block|,
block|{
literal|"i286"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
block|}
block|,
block|{
literal|"i386"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
block|}
block|,
block|{
literal|"i486"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
block|}
block|,
block|{
literal|"i586"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|CpuMMX
block|}
block|,
block|{
literal|"i686"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuMMX
operator||
name|CpuSSE
block|}
block|,
block|{
literal|"pentium"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|CpuMMX
block|}
block|,
block|{
literal|"pentiumpro"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuMMX
operator||
name|CpuSSE
block|}
block|,
block|{
literal|"pentium4"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuSSE
operator||
name|CpuSSE2
block|}
block|,
block|{
literal|"k6"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|CpuK6
operator||
name|CpuMMX
operator||
name|Cpu3dnow
block|}
block|,
block|{
literal|"athlon"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuK6
operator||
name|CpuAthlon
operator||
name|CpuMMX
operator||
name|Cpu3dnow
block|}
block|,
block|{
literal|"sledgehammer"
block|,
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuK6
operator||
name|CpuAthlon
operator||
name|CpuSledgehammer
operator||
name|CpuMMX
operator||
name|Cpu3dnow
operator||
name|CpuSSE
operator||
name|CpuSSE2
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|i386_align_code
parameter_list|(
name|fragP
parameter_list|,
name|count
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
comment|/* Various efficient no-op patterns for aligning code labels.      Note: Don't try to assemble the instructions in the comments.      0L and 0w are not legal.  */
specifier|static
specifier|const
name|char
name|f32_1
index|[]
init|=
block|{
literal|0x90
block|}
decl_stmt|;
comment|/* nop			*/
specifier|static
specifier|const
name|char
name|f32_2
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|}
decl_stmt|;
comment|/* movl %esi,%esi	*/
specifier|static
specifier|const
name|char
name|f32_3
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x76
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f32_4
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi,1),%esi	*/
specifier|static
specifier|const
name|char
name|f32_5
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi,1),%esi	*/
specifier|static
specifier|const
name|char
name|f32_6
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f32_7
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi,1),%esi */
specifier|static
specifier|const
name|char
name|f32_8
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi,1),%esi */
specifier|static
specifier|const
name|char
name|f32_9
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|,
comment|/* movl %esi,%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_10
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x76
block|,
literal|0x00
block|,
comment|/* leal 0(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_11
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|,
comment|/* leal 0(%esi,1),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_12
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbf
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi),%edi	*/
specifier|static
specifier|const
name|char
name|f32_13
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_14
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi,1),%esi */
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_15
index|[]
init|=
block|{
literal|0xeb
block|,
literal|0x0d
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
comment|/* jmp .+15; lotsa nops	*/
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
name|f16_3
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f16_4
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%si),%si	*/
specifier|static
specifier|const
name|char
name|f16_5
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%si),%si	*/
specifier|static
specifier|const
name|char
name|f16_6
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|,
comment|/* mov %si,%si		*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
name|f16_7
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x00
block|,
comment|/* lea 0(%si),%si	*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
name|f16_8
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* lea 0w(%si),%si	*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|f32_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|f32_3
block|,
name|f32_4
block|,
name|f32_5
block|,
name|f32_6
block|,
name|f32_7
block|,
name|f32_8
block|,
name|f32_9
block|,
name|f32_10
block|,
name|f32_11
block|,
name|f32_12
block|,
name|f32_13
block|,
name|f32_14
block|,
name|f32_15
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|f16_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|f16_3
block|,
name|f16_4
block|,
name|f16_5
block|,
name|f16_6
block|,
name|f16_7
block|,
name|f16_8
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|}
decl_stmt|;
comment|/* ??? We can't use these fillers for x86_64, since they often kills the      upper halves.  Solve later.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|count
operator|<=
literal|15
condition|)
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
condition|)
block|{
name|memcpy
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|f16_patt
index|[
name|count
operator|-
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|8
condition|)
comment|/* Adjust jump offset.  */
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
index|]
operator|=
name|count
operator|-
literal|2
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|f32_patt
index|[
name|count
operator|-
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|count
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_invalid
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|i386_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|operand_string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|i386_intel_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|operand_string
operator|,
name|int
name|got_a_float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|reg_entry
modifier|*
name|parse_register
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|reg_string
operator|,
name|char
operator|*
operator|*
name|end_op
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|I386COFF
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|s_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|mode_from_disp_size
parameter_list|(
name|t
parameter_list|)
name|unsigned
name|int
name|t
decl_stmt|;
block|{
return|return
operator|(
name|t
operator|&
name|Disp8
operator|)
condition|?
literal|1
else|:
operator|(
name|t
operator|&
operator|(
name|Disp16
operator||
name|Disp32
operator||
name|Disp32S
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_byte
parameter_list|(
name|num
parameter_list|)
name|offsetT
name|num
decl_stmt|;
block|{
return|return
operator|(
name|num
operator|>=
operator|-
literal|128
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|127
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_byte
parameter_list|(
name|num
parameter_list|)
name|offsetT
name|num
decl_stmt|;
block|{
return|return
operator|(
name|num
operator|&
literal|0xff
operator|)
operator|==
name|num
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_word
parameter_list|(
name|num
parameter_list|)
name|offsetT
name|num
decl_stmt|;
block|{
return|return
operator|(
name|num
operator|&
literal|0xffff
operator|)
operator|==
name|num
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_word
parameter_list|(
name|num
parameter_list|)
name|offsetT
name|num
decl_stmt|;
block|{
return|return
operator|(
operator|-
literal|32768
operator|<=
name|num
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|32767
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_long
parameter_list|(
name|num
parameter_list|)
name|offsetT
name|num
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BFD64
return|return
literal|1
return|;
else|#
directive|else
return|return
operator|(
operator|!
operator|(
operator|(
operator|(
name|offsetT
operator|)
operator|-
literal|1
operator|<<
literal|31
operator|)
operator|&
name|num
operator|)
operator|||
operator|(
operator|(
operator|(
name|offsetT
operator|)
operator|-
literal|1
operator|<<
literal|31
operator|)
operator|&
name|num
operator|)
operator|==
operator|(
operator|(
name|offsetT
operator|)
operator|-
literal|1
operator|<<
literal|31
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* fits_in_signed_long() */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_long
parameter_list|(
name|num
parameter_list|)
name|offsetT
name|num
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BFD64
return|return
literal|1
return|;
else|#
directive|else
return|return
operator|(
name|num
operator|&
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|num
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* fits_in_unsigned_long() */
end_comment

begin_function
specifier|static
name|int
name|smallest_imm_type
parameter_list|(
name|num
parameter_list|)
name|offsetT
name|num
decl_stmt|;
block|{
if|if
condition|(
name|cpu_arch_flags
operator|!=
operator|(
name|Cpu086
operator||
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|CpuNo64
operator|)
condition|)
block|{
comment|/* This code is disabled on the 486 because all the Imm1 forms 	 in the opcode table are slower on the i486.  They're the 	 versions with the implicitly specified single-position 	 displacement, which has another syntax if you really want to 	 use that form.  */
if|if
condition|(
name|num
operator|==
literal|1
condition|)
return|return
name|Imm1
operator||
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
return|;
block|}
return|return
operator|(
name|fits_in_signed_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8S
operator||
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator|)
else|:
name|fits_in_unsigned_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator|)
else|:
operator|(
name|fits_in_signed_word
argument_list|(
name|num
argument_list|)
operator|||
name|fits_in_unsigned_word
argument_list|(
name|num
argument_list|)
operator|)
condition|?
operator|(
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator|)
else|:
name|fits_in_signed_long
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator|)
else|:
name|fits_in_unsigned_long
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm32
operator||
name|Imm64
operator|)
else|:
name|Imm64
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|offsetT
name|offset_in_range
parameter_list|(
name|val
parameter_list|,
name|size
parameter_list|)
name|offsetT
name|val
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|addressT
name|mask
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|mask
operator|=
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mask
operator|=
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mask
operator|=
operator|(
operator|(
name|addressT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BFD64
case|case
literal|8
case|:
name|mask
operator|=
operator|(
operator|(
name|addressT
operator|)
literal|2
operator|<<
literal|63
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If BFD64, sign extend val.  */
if|if
condition|(
operator|!
name|use_rela_relocations
condition|)
if|if
condition|(
operator|(
name|val
operator|&
operator|~
operator|(
operator|(
operator|(
name|addressT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
operator|(
name|val
operator|^
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|-
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|~
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|val
operator|&
operator|~
name|mask
operator|)
operator|!=
operator|~
name|mask
condition|)
block|{
name|char
name|buf1
index|[
literal|40
index|]
decl_stmt|,
name|buf2
index|[
literal|40
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sprint_value
argument_list|(
name|buf2
argument_list|,
name|val
operator|&
name|mask
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s shortened to %s"
argument_list|)
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
return|return
name|val
operator|&
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Returns 0 if attempting to add a prefix where one from the same    class already exists, 1 if non rep/repne added, 2 if rep/repne    added.  */
end_comment

begin_function
specifier|static
name|int
name|add_prefix
parameter_list|(
name|prefix
parameter_list|)
name|unsigned
name|int
name|prefix
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|int
name|q
decl_stmt|;
if|if
condition|(
name|prefix
operator|>=
literal|0x40
operator|&&
name|prefix
operator|<
literal|0x50
operator|&&
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|q
operator|=
name|REX_PREFIX
expr_stmt|;
else|else
switch|switch
condition|(
name|prefix
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|CS_PREFIX_OPCODE
case|:
case|case
name|DS_PREFIX_OPCODE
case|:
case|case
name|ES_PREFIX_OPCODE
case|:
case|case
name|FS_PREFIX_OPCODE
case|:
case|case
name|GS_PREFIX_OPCODE
case|:
case|case
name|SS_PREFIX_OPCODE
case|:
name|q
operator|=
name|SEG_PREFIX
expr_stmt|;
break|break;
case|case
name|REPNE_PREFIX_OPCODE
case|:
case|case
name|REPE_PREFIX_OPCODE
case|:
name|ret
operator|=
literal|2
expr_stmt|;
comment|/* fall thru */
case|case
name|LOCK_PREFIX_OPCODE
case|:
name|q
operator|=
name|LOCKREP_PREFIX
expr_stmt|;
break|break;
case|case
name|FWAIT_OPCODE
case|:
name|q
operator|=
name|WAIT_PREFIX
expr_stmt|;
break|break;
case|case
name|ADDR_PREFIX_OPCODE
case|:
name|q
operator|=
name|ADDR_PREFIX
expr_stmt|;
break|break;
case|case
name|DATA_PREFIX_OPCODE
case|:
name|q
operator|=
name|DATA_PREFIX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|q
index|]
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"same type of prefix used twice"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|prefixes
operator|+=
literal|1
expr_stmt|;
name|i
operator|.
name|prefix
index|[
name|q
index|]
operator|=
name|prefix
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_code_flag
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
name|flag_code
operator|=
name|value
expr_stmt|;
name|cpu_arch_flags
operator|&=
operator|~
operator|(
name|Cpu64
operator||
name|CpuNo64
operator|)
expr_stmt|;
name|cpu_arch_flags
operator||=
operator|(
name|flag_code
operator|==
name|CODE_64BIT
condition|?
name|Cpu64
else|:
name|CpuNo64
operator|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|CODE_64BIT
operator|&&
operator|!
operator|(
name|cpu_arch_flags
operator|&
name|CpuSledgehammer
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"64bit mode not supported on this CPU."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|CODE_32BIT
operator|&&
operator|!
operator|(
name|cpu_arch_flags
operator|&
name|Cpu386
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"32bit mode not supported on this CPU."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stackop_size
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_16bit_gcc_code_flag
parameter_list|(
name|new_code_flag
parameter_list|)
name|int
name|new_code_flag
decl_stmt|;
block|{
name|flag_code
operator|=
name|new_code_flag
expr_stmt|;
name|cpu_arch_flags
operator|&=
operator|~
operator|(
name|Cpu64
operator||
name|CpuNo64
operator|)
expr_stmt|;
name|cpu_arch_flags
operator||=
operator|(
name|flag_code
operator|==
name|CODE_64BIT
condition|?
name|Cpu64
else|:
name|CpuNo64
operator|)
expr_stmt|;
name|stackop_size
operator|=
literal|'l'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_intel_syntax
parameter_list|(
name|syntax_flag
parameter_list|)
name|int
name|syntax_flag
decl_stmt|;
block|{
comment|/* Find out if register prefixing is specified.  */
name|int
name|ask_naked_reg
init|=
literal|0
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|char
modifier|*
name|string
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|e
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"prefix"
argument_list|)
operator|==
literal|0
condition|)
name|ask_naked_reg
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"noprefix"
argument_list|)
operator|==
literal|0
condition|)
name|ask_naked_reg
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad argument to syntax directive."
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|e
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|intel_syntax
operator|=
name|syntax_flag
expr_stmt|;
if|if
condition|(
name|ask_naked_reg
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|allow_naked_reg
operator|=
operator|(
name|intel_syntax
operator|&&
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|stdoutput
argument_list|)
operator|!=
literal|'\0'
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* Conservative default.  */
name|allow_naked_reg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|allow_naked_reg
operator|=
operator|(
name|ask_naked_reg
operator|<
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_cpu_arch
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|char
modifier|*
name|string
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|e
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpu_arch
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|cpu_arch
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_arch_name
operator|=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|cpu_arch_flags
operator|=
operator|(
name|cpu_arch
index|[
name|i
index|]
operator|.
name|flags
operator||
operator|(
name|flag_code
operator|==
name|CODE_64BIT
condition|?
name|Cpu64
else|:
name|CpuNo64
operator|)
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|cpu_arch
index|[
name|i
index|]
operator|.
name|name
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such architecture: `%s'"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|e
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing cpu architecture"
argument_list|)
argument_list|)
expr_stmt|;
name|no_cond_jump_promotion
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
literal|1
index|]
index|]
condition|)
block|{
name|char
modifier|*
name|string
init|=
operator|++
name|input_line_pointer
decl_stmt|;
name|int
name|e
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"nojumps"
argument_list|)
operator|==
literal|0
condition|)
name|no_cond_jump_promotion
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"jumps"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such architecture modifier: `%s'"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|e
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_ALIGN_PTWO
argument_list|)
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"arch"
block|,
name|set_cpu_arch
block|,
literal|0
block|}
block|,
ifndef|#
directive|ifndef
name|I386COFF
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"tfloat"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"value"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"noopt"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"code16gcc"
block|,
name|set_16bit_gcc_code_flag
block|,
name|CODE_16BIT
block|}
block|,
block|{
literal|"code16"
block|,
name|set_code_flag
block|,
name|CODE_16BIT
block|}
block|,
block|{
literal|"code32"
block|,
name|set_code_flag
block|,
name|CODE_32BIT
block|}
block|,
block|{
literal|"code64"
block|,
name|set_code_flag
block|,
name|CODE_64BIT
block|}
block|,
block|{
literal|"intel_syntax"
block|,
name|set_intel_syntax
block|,
literal|1
block|}
block|,
block|{
literal|"att_syntax"
block|,
name|set_intel_syntax
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For interface with expression ().  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table for instruction mnemonic lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table for register lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|unsigned
name|long
name|i386_mach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"x86_64"
argument_list|)
condition|)
return|return
name|bfd_mach_x86_64
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"i386"
argument_list|)
condition|)
return|return
name|bfd_mach_i386_i386
return|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown architecture"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|hash_err
decl_stmt|;
comment|/* Initialize op_hash hash table.  */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
specifier|const
name|template
modifier|*
name|optab
decl_stmt|;
specifier|register
name|templates
modifier|*
name|core_optab
decl_stmt|;
comment|/* Setup for loop.  */
name|optab
operator|=
name|i386_optab
expr_stmt|;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
name|optab
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|++
name|optab
expr_stmt|;
if|if
condition|(
name|optab
operator|->
name|name
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|optab
operator|->
name|name
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* different name --> ship out current template list; 	       add to hash table;& begin anew.  */
name|core_optab
operator|->
name|end
operator|=
name|optab
expr_stmt|;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|core_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optab
operator|->
name|name
operator|==
name|NULL
condition|)
break|break;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
name|optab
expr_stmt|;
block|}
block|}
block|}
comment|/* Initialize reg_hash hash table.  */
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
specifier|const
name|reg_entry
modifier|*
name|regtab
decl_stmt|;
for|for
control|(
name|regtab
operator|=
name|i386_regtab
init|;
name|regtab
operator|<
name|i386_regtab
operator|+
sizeof|sizeof
argument_list|(
name|i386_regtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|i386_regtab
index|[
literal|0
index|]
argument_list|)
condition|;
name|regtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|regtab
operator|->
name|reg_name
argument_list|,
operator|(
name|PTR
operator|)
name|regtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
name|regtab
operator|->
name|reg_name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fill in lexical tables:  mnemonic_chars, operand_chars.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|digit_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISLOWER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|mnemonic_chars
index|[
name|c
index|]
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
operator|||
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|128
condition|)
block|{
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LEX_AT
name|identifier_chars
index|[
literal|'@'
index|]
operator|=
literal|'@'
expr_stmt|;
endif|#
directive|endif
name|digit_chars
index|[
literal|'-'
index|]
operator|=
literal|'-'
expr_stmt|;
name|identifier_chars
index|[
literal|'_'
index|]
operator|=
literal|'_'
expr_stmt|;
name|identifier_chars
index|[
literal|'.'
index|]
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|operand_special_chars
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
name|operand_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|record_alignment
argument_list|(
name|text_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|data_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|i386_print_statistics
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"i386 opcode"
argument_list|,
name|op_hash
argument_list|)
expr_stmt|;
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"i386 register"
argument_list|,
name|reg_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG386
end_ifdef

begin_comment
comment|/* Debugging routines for md_assemble.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|pi
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|i386_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pte
name|PARAMS
argument_list|(
operator|(
name|template
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pt
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pe
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ps
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pi
parameter_list|(
name|line
parameter_list|,
name|x
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|i386_insn
modifier|*
name|x
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: template "
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|pte
argument_list|(
operator|&
name|x
operator|->
name|tm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  address: base %s  index %s  scale %x\n"
argument_list|,
name|x
operator|->
name|base_reg
condition|?
name|x
operator|->
name|base_reg
operator|->
name|reg_name
else|:
literal|"none"
argument_list|,
name|x
operator|->
name|index_reg
condition|?
name|x
operator|->
name|index_reg
operator|->
name|reg_name
else|:
literal|"none"
argument_list|,
name|x
operator|->
name|log2_scale_factor
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  modrm:  mode %x  reg %x  reg/mem %x\n"
argument_list|,
name|x
operator|->
name|rm
operator|.
name|mode
argument_list|,
name|x
operator|->
name|rm
operator|.
name|reg
argument_list|,
name|x
operator|->
name|rm
operator|.
name|regmem
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  sib:  base %x  index %x  scale %x\n"
argument_list|,
name|x
operator|->
name|sib
operator|.
name|base
argument_list|,
name|x
operator|->
name|sib
operator|.
name|index
argument_list|,
name|x
operator|->
name|sib
operator|.
name|scale
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  rex: 64bit %x  extX %x  extY %x  extZ %x\n"
argument_list|,
name|x
operator|->
name|rex
operator|.
name|mode64
argument_list|,
name|x
operator|->
name|rex
operator|.
name|extX
argument_list|,
name|x
operator|->
name|rex
operator|.
name|extY
argument_list|,
name|x
operator|->
name|rex
operator|.
name|extZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d:  "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|x
operator|->
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|RegMMX
operator||
name|RegXMM
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|x
operator|->
name|op
index|[
name|i
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Imm
condition|)
name|pe
argument_list|(
name|x
operator|->
name|op
index|[
name|i
index|]
operator|.
name|imms
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Disp
condition|)
name|pe
argument_list|(
name|x
operator|->
name|op
index|[
name|i
index|]
operator|.
name|disps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pte
parameter_list|(
name|t
parameter_list|)
name|template
modifier|*
name|t
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" %d operands "
argument_list|,
name|t
operator|->
name|operands
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"opcode %x "
argument_list|,
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"ext %x "
argument_list|,
name|t
operator|->
name|extension_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|D
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"W"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d type "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|t
operator|->
name|operand_types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pe
parameter_list|(
name|e
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    operation     %d\n"
argument_list|,
name|e
operator|->
name|X_op
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_number    %ld (%lx)\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|X_add_number
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_add_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|X_op_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    op_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ps
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s type %s%s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|,
name|S_IS_EXTERNAL
argument_list|(
name|s
argument_list|)
condition|?
literal|"EXTERNAL "
else|:
literal|""
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|type_name
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
block|}
name|type_names
index|[]
init|=
block|{
block|{
name|Reg8
block|,
literal|"r8"
block|}
block|,
block|{
name|Reg16
block|,
literal|"r16"
block|}
block|,
block|{
name|Reg32
block|,
literal|"r32"
block|}
block|,
block|{
name|Reg64
block|,
literal|"r64"
block|}
block|,
block|{
name|Imm8
block|,
literal|"i8"
block|}
block|,
block|{
name|Imm8S
block|,
literal|"i8s"
block|}
block|,
block|{
name|Imm16
block|,
literal|"i16"
block|}
block|,
block|{
name|Imm32
block|,
literal|"i32"
block|}
block|,
block|{
name|Imm32S
block|,
literal|"i32s"
block|}
block|,
block|{
name|Imm64
block|,
literal|"i64"
block|}
block|,
block|{
name|Imm1
block|,
literal|"i1"
block|}
block|,
block|{
name|BaseIndex
block|,
literal|"BaseIndex"
block|}
block|,
block|{
name|Disp8
block|,
literal|"d8"
block|}
block|,
block|{
name|Disp16
block|,
literal|"d16"
block|}
block|,
block|{
name|Disp32
block|,
literal|"d32"
block|}
block|,
block|{
name|Disp32S
block|,
literal|"d32s"
block|}
block|,
block|{
name|Disp64
block|,
literal|"d64"
block|}
block|,
block|{
name|InOutPortReg
block|,
literal|"InOutPortReg"
block|}
block|,
block|{
name|ShiftCount
block|,
literal|"ShiftCount"
block|}
block|,
block|{
name|Control
block|,
literal|"control reg"
block|}
block|,
block|{
name|Test
block|,
literal|"test reg"
block|}
block|,
block|{
name|Debug
block|,
literal|"debug reg"
block|}
block|,
block|{
name|FloatReg
block|,
literal|"FReg"
block|}
block|,
block|{
name|FloatAcc
block|,
literal|"FAcc"
block|}
block|,
block|{
name|SReg2
block|,
literal|"SReg2"
block|}
block|,
block|{
name|SReg3
block|,
literal|"SReg3"
block|}
block|,
block|{
name|Acc
block|,
literal|"Acc"
block|}
block|,
block|{
name|JumpAbsolute
block|,
literal|"Jump Absolute"
block|}
block|,
block|{
name|RegMMX
block|,
literal|"rMMX"
block|}
block|,
block|{
name|RegXMM
block|,
literal|"rXMM"
block|}
block|,
block|{
name|EsSeg
block|,
literal|"es"
block|}
block|,
block|{
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pt
parameter_list|(
name|t
parameter_list|)
name|unsigned
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|type_name
modifier|*
name|ty
decl_stmt|;
for|for
control|(
name|ty
operator|=
name|type_names
init|;
name|ty
operator|->
name|mask
condition|;
name|ty
operator|++
control|)
if|if
condition|(
name|t
operator|&
name|ty
operator|->
name|mask
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s, "
argument_list|,
name|ty
operator|->
name|tname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG386 */
end_comment

begin_escape
end_escape

begin_function
name|int
name|tc_i386_force_relocation
parameter_list|(
name|fixp
parameter_list|)
name|struct
name|fix
modifier|*
name|fixp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
else|#
directive|else
comment|/* For COFF.  */
return|return
name|fixp
operator|->
name|fx_r_type
operator|==
literal|7
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|reloc
parameter_list|(
name|size
parameter_list|,
name|pcrel
parameter_list|,
name|sign
parameter_list|,
name|other
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|bfd_reloc_code_real_type
name|other
decl_stmt|;
block|{
if|if
condition|(
name|other
operator|!=
name|NO_RELOC
condition|)
return|return
name|other
return|;
if|if
condition|(
name|pcrel
condition|)
block|{
if|if
condition|(
operator|!
name|sign
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"There are no unsigned pc-relative relocations"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8_PCREL
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16_PCREL
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32_PCREL
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can not do %d byte pc-relative relocation"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sign
condition|)
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
return|return
name|BFD_RELOC_X86_64_32S
return|;
block|}
else|else
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32
return|;
case|case
literal|8
case|:
return|return
name|BFD_RELOC_64
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can not do %s %d byte relocation"
argument_list|)
argument_list|,
name|sign
condition|?
literal|"signed"
else|:
literal|"unsigned"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_comment
comment|/* Here we decide which fixups can be adjusted to make them relative to    the beginning of the section instead of the symbol.  Basically we need    to make sure that the dynamic relocations are done correctly, so in    some cases we force the original symbol to be used.  */
end_comment

begin_function
name|int
name|tc_i386_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
comment|/* Prevent all adjustments to global symbols, or else dynamic      linking will not work correctly.  */
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
comment|/* Don't adjust pc-relative references to merge sections in 64-bit 	 mode.  */
operator|||
operator|(
name|use_rela_relocations
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|!=
literal|0
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* adjust_reloc_syms doesn't know about the GOT.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_GOTOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_PLT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_GOT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_PLT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_GOT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_GOTPCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|reloc
parameter_list|(
name|SIZE
parameter_list|,
name|PCREL
parameter_list|,
name|SIGN
parameter_list|,
name|OTHER
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_16
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_16_PCREL
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_32_PCREL
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_386_PLT32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_386_GOT32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_386_GOTOFF
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_X86_64_PLT32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_X86_64_GOT32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_X86_64_GOTPCREL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|intel_float_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|mnemonic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|intel_float_operand
parameter_list|(
name|mnemonic
parameter_list|)
name|char
modifier|*
name|mnemonic
decl_stmt|;
block|{
if|if
condition|(
name|mnemonic
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|mnemonic
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|mnemonic
index|[
literal|0
index|]
operator|==
literal|'f'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  LINE points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
comment|/* Points to template once we've found it.  */
specifier|const
name|template
modifier|*
name|t
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
name|mnemonic
index|[
name|MAX_MNEM_SIZE
index|]
decl_stmt|;
comment|/* Initialize globals.  */
name|memset
argument_list|(
operator|&
name|i
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_OPERANDS
condition|;
name|j
operator|++
control|)
name|i
operator|.
name|reloc
index|[
name|j
index|]
operator|=
name|NO_RELOC
expr_stmt|;
name|memset
argument_list|(
name|disp_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|disp_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|im_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|im_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|save_stack_p
operator|=
name|save_stack
expr_stmt|;
comment|/* First parse an instruction mnemonic& call i386_operand for the operands.      We assume that the scrubber has arranged it so that line[0] is the valid      start of a (possibly prefixed) mnemonic.  */
block|{
name|char
modifier|*
name|l
init|=
name|line
decl_stmt|;
name|char
modifier|*
name|token_start
init|=
name|l
decl_stmt|;
name|char
modifier|*
name|mnem_p
decl_stmt|;
comment|/* Non-zero if we found a prefix only acceptable with string insns.  */
specifier|const
name|char
modifier|*
name|expecting_string_instruction
init|=
name|NULL
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|mnem_p
operator|=
name|mnemonic
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|mnem_p
operator|=
name|mnemonic_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|l
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|mnem_p
operator|++
expr_stmt|;
if|if
condition|(
name|mnem_p
operator|>=
name|mnemonic
operator|+
sizeof|sizeof
argument_list|(
name|mnemonic
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such instruction: `%s'"
argument_list|)
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
operator|&&
operator|*
name|l
operator|!=
name|PREFIX_SEPARATOR
operator|&&
operator|*
name|l
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s in mnemonic"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|token_start
operator|==
name|l
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
name|PREFIX_SEPARATOR
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting prefix; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting mnemonic; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Look up instruction (or prefix) via hash table.  */
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
operator|&&
operator|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|||
name|l
index|[
literal|1
index|]
operator|!=
name|END_OF_INSN
operator|)
operator|&&
name|current_templates
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsPrefix
operator|)
condition|)
block|{
comment|/* If we are in 16-bit mode, do not allow addr16 or data16. 	       Similarly, in 32-bit mode, do not allow addr32 or data32.  */
if|if
condition|(
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Size16
operator||
name|Size32
operator|)
operator|)
operator|&&
name|flag_code
operator|!=
name|CODE_64BIT
operator|&&
operator|(
operator|(
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|Size32
operator|)
operator|!=
literal|0
operator|)
operator|^
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"redundant %s prefix"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add prefix, checking for repeated prefixes.  */
switch|switch
condition|(
name|add_prefix
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return;
case|case
literal|2
case|:
name|expecting_string_instruction
operator|=
name|current_templates
operator|->
name|start
operator|->
name|name
expr_stmt|;
break|break;
block|}
comment|/* Skip past PREFIX_SEPARATOR and reset token_start.  */
name|token_start
operator|=
operator|++
name|l
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
comment|/* See if we can get a match by trimming off a suffix.  */
switch|switch
condition|(
name|mnem_p
index|[
operator|-
literal|1
index|]
condition|)
block|{
case|case
name|WORD_MNEM_SUFFIX
case|:
case|case
name|BYTE_MNEM_SUFFIX
case|:
case|case
name|QWORD_MNEM_SUFFIX
case|:
name|i
operator|.
name|suffix
operator|=
name|mnem_p
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|mnem_p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHORT_MNEM_SUFFIX
case|:
case|case
name|LONG_MNEM_SUFFIX
case|:
if|if
condition|(
operator|!
name|intel_syntax
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|mnem_p
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|mnem_p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Intel Syntax.  */
case|case
literal|'d'
case|:
if|if
condition|(
name|intel_syntax
condition|)
block|{
if|if
condition|(
name|intel_float_operand
argument_list|(
name|mnemonic
argument_list|)
condition|)
name|i
operator|.
name|suffix
operator|=
name|SHORT_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
name|mnem_p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such instruction: `%s'"
argument_list|)
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpByte
operator|)
condition|)
block|{
comment|/* Check for a branch hint.  We allow ",pt" and ",pn" for 	   predict taken and predict not taken respectively. 	   I'm not sure that branch hints actually do anything on loop 	   and jcxz insns (JumpByte) for current Pentium4 chips.  They 	   may work in the future and it doesn't hurt to accept them 	   now.  */
if|if
condition|(
name|l
index|[
literal|0
index|]
operator|==
literal|','
operator|&&
name|l
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|l
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|DS_PREFIX_OPCODE
argument_list|)
condition|)
return|return;
name|l
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
index|[
literal|2
index|]
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|CS_PREFIX_OPCODE
argument_list|)
condition|)
return|return;
name|l
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
comment|/* Any other comma loses.  */
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s in mnemonic"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if instruction is supported on specified architecture.  */
if|if
condition|(
operator|(
name|current_templates
operator|->
name|start
operator|->
name|cpu_flags
operator|&
operator|~
operator|(
name|Cpu64
operator||
name|CpuNo64
operator|)
operator|)
operator|&
operator|~
operator|(
name|cpu_arch_flags
operator|&
operator|~
operator|(
name|Cpu64
operator||
name|CpuNo64
operator|)
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"`%s' is not supported on `%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|,
name|cpu_arch_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Cpu386
operator|&
operator|~
name|cpu_arch_flags
operator|)
operator|&&
operator|(
name|flag_code
operator|!=
name|CODE_16BIT
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"use .code16 to ensure correct addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for rep/repne without a string instruction.  */
if|if
condition|(
name|expecting_string_instruction
operator|&&
operator|!
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsString
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting string instruction after `%s'"
argument_list|)
argument_list|,
name|expecting_string_instruction
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* There may be operands to parse.  */
if|if
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
comment|/* 1 if operand is pending after ','.  */
name|unsigned
name|int
name|expecting_operand
init|=
literal|0
decl_stmt|;
comment|/* Non-zero if operand parens not balanced.  */
name|unsigned
name|int
name|paren_not_balanced
decl_stmt|;
do|do
block|{
comment|/* Skip optional white space before operand.  */
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
operator|++
name|l
expr_stmt|;
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s before operand %d"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|token_start
operator|=
name|l
expr_stmt|;
comment|/* after white space */
name|paren_not_balanced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|paren_not_balanced
operator|||
operator|*
name|l
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
name|paren_not_balanced
condition|)
block|{
if|if
condition|(
operator|!
name|intel_syntax
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unbalanced parenthesis in operand %d."
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unbalanced brackets in operand %d."
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
comment|/* we are done */
block|}
elseif|else
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s in operand %d"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|intel_syntax
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
literal|'('
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|')'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|l
operator|==
literal|'['
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|']'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
block|}
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
name|token_start
condition|)
block|{
comment|/* Yes, we've read in another operand.  */
name|unsigned
name|int
name|operand_ok
decl_stmt|;
name|this_operand
operator|=
name|i
operator|.
name|operands
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|>
name|MAX_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"spurious operands; (%d operands/instruction max)"
argument_list|)
argument_list|,
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now parse operand adding info to 'i' as we go along.  */
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_syntax
condition|)
name|operand_ok
operator|=
name|i386_intel_operand
argument_list|(
name|token_start
argument_list|,
name|intel_float_operand
argument_list|(
name|mnemonic
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|operand_ok
operator|=
name|i386_operand
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand_ok
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
condition|)
block|{
name|expecting_operand_after_comma
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting operand after ','; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting operand before ','; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Now *l must be either ',' or END_OF_INSN.  */
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
comment|/* Just skip it, if it's \n complain.  */
goto|goto
name|expecting_operand_after_comma
goto|;
block|}
name|expecting_operand
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
do|;
block|}
block|}
comment|/* Now we've parsed the mnemonic into a set of templates, and have the      operands at hand.       Next, we find a template that matches the given insn,      making sure the overlap of the given operands types is consistent      with the template operand types.  */
define|#
directive|define
name|MATCH
parameter_list|(
name|overlap
parameter_list|,
name|given
parameter_list|,
name|template
parameter_list|)
define|\
value|((overlap& ~JumpAbsolute) \&& ((given)& (BaseIndex|JumpAbsolute)) == ((overlap)& (BaseIndex|JumpAbsolute)))
comment|/* If given types r0 and r1 are registers they must be of the same type      unless the expected operand type register overlap is null.      Note that Acc in a template matches every size of reg.  */
define|#
directive|define
name|CONSISTENT_REGISTER_MATCH
parameter_list|(
name|m0
parameter_list|,
name|g0
parameter_list|,
name|t0
parameter_list|,
name|m1
parameter_list|,
name|g1
parameter_list|,
name|t1
parameter_list|)
define|\
value|( ((g0)& Reg) == 0 || ((g1)& Reg) == 0 || \     ((g0)& Reg) == ((g1)& Reg) || \     ((((m0)& Acc) ? Reg : (t0))& (((m1)& Acc) ? Reg : (t1))& Reg) == 0 )
block|{
specifier|register
name|unsigned
name|int
name|overlap0
decl_stmt|,
name|overlap1
decl_stmt|;
name|unsigned
name|int
name|overlap2
decl_stmt|;
name|unsigned
name|int
name|found_reverse_match
decl_stmt|;
name|int
name|suffix_check
decl_stmt|;
comment|/* All intel opcodes have reversed operands except for "bound" and        "enter".  We also don't reverse intersegment "jmp" and "call"        instructions with 2 immediate operands so that the immediate segment        precedes the offset, as it does when in AT&T mode.  "enter" and the        intersegment "jmp" and "call" instructions are the only ones that        have two immediate operands.  */
if|if
condition|(
name|intel_syntax
operator|&&
name|i
operator|.
name|operands
operator|>
literal|1
operator|&&
operator|(
name|strcmp
argument_list|(
name|mnemonic
argument_list|,
literal|"bound"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Imm
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Imm
operator|)
operator|)
condition|)
block|{
name|union
name|i386_op
name|temp_op
decl_stmt|;
name|unsigned
name|int
name|temp_type
decl_stmt|;
name|RELOC_ENUM
name|temp_reloc
decl_stmt|;
name|int
name|xchg1
init|=
literal|0
decl_stmt|;
name|int
name|xchg2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|2
condition|)
block|{
name|xchg1
operator|=
literal|0
expr_stmt|;
name|xchg2
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|3
condition|)
block|{
name|xchg1
operator|=
literal|0
expr_stmt|;
name|xchg2
operator|=
literal|2
expr_stmt|;
block|}
name|temp_type
operator|=
name|i
operator|.
name|types
index|[
name|xchg2
index|]
expr_stmt|;
name|i
operator|.
name|types
index|[
name|xchg2
index|]
operator|=
name|i
operator|.
name|types
index|[
name|xchg1
index|]
expr_stmt|;
name|i
operator|.
name|types
index|[
name|xchg1
index|]
operator|=
name|temp_type
expr_stmt|;
name|temp_op
operator|=
name|i
operator|.
name|op
index|[
name|xchg2
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|xchg2
index|]
operator|=
name|i
operator|.
name|op
index|[
name|xchg1
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|xchg1
index|]
operator|=
name|temp_op
expr_stmt|;
name|temp_reloc
operator|=
name|i
operator|.
name|reloc
index|[
name|xchg2
index|]
expr_stmt|;
name|i
operator|.
name|reloc
index|[
name|xchg2
index|]
operator|=
name|i
operator|.
name|reloc
index|[
name|xchg1
index|]
expr_stmt|;
name|i
operator|.
name|reloc
index|[
name|xchg1
index|]
operator|=
name|temp_reloc
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
specifier|const
name|seg_entry
modifier|*
name|temp_seg
decl_stmt|;
name|temp_seg
operator|=
name|i
operator|.
name|seg
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|seg
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|seg
index|[
literal|1
index|]
operator|=
name|temp_seg
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|imm_operands
condition|)
block|{
comment|/* Try to ensure constant immediates are represented in the smallest 	   opcode possible.  */
name|char
name|guess_suffix
init|=
literal|0
decl_stmt|;
name|int
name|op
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
name|guess_suffix
operator|=
name|i
operator|.
name|suffix
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
comment|/* Figure out a suffix from the last register operand specified. 	       We can't do this properly yet, ie. excluding InOutPortReg, 	       but the following works for instructions with immediates. 	       In any case, we can't set i.suffix yet.  */
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
condition|)
name|guess_suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
condition|)
name|guess_suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg32
condition|)
name|guess_suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg64
condition|)
name|guess_suffix
operator|=
name|QWORD_MNEM_SUFFIX
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
name|guess_suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Imm
condition|)
block|{
switch|switch
condition|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
comment|/* If a suffix is given, this operand may be shortened.  */
switch|switch
condition|(
name|guess_suffix
condition|)
block|{
case|case
name|LONG_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Imm32
operator||
name|Imm64
expr_stmt|;
break|break;
case|case
name|WORD_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Imm16
operator||
name|Imm32S
operator||
name|Imm32
operator||
name|Imm64
expr_stmt|;
break|break;
case|case
name|BYTE_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Imm16
operator||
name|Imm8
operator||
name|Imm8S
operator||
name|Imm32S
operator||
name|Imm32
operator||
name|Imm64
expr_stmt|;
break|break;
block|}
comment|/* If this operand is at most 16 bits, convert it 		       to a signed 16 bit number before trying to see 		       whether it will fit in an even smaller size. 		       This allows a 16-bit operand such as $0xffe0 to 		       be recognised as within Imm8S range.  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Imm16
operator|)
operator|&&
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|&
operator|~
operator|(
name|offsetT
operator|)
literal|0xffff
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Imm32
operator|)
operator|&&
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|&
operator|~
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|=
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|^
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|-
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
block|}
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|smallest_imm_type
argument_list|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
comment|/* We must avoid matching of Imm32 templates when 64bit only immediate is available.  */
if|if
condition|(
name|guess_suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Imm32
expr_stmt|;
break|break;
case|case
name|O_absent
case|:
case|case
name|O_register
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Symbols and expressions.  */
default|default:
comment|/* Convert symbolic operand to proper sizes for matching.  */
switch|switch
condition|(
name|guess_suffix
condition|)
block|{
case|case
name|QWORD_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
name|Imm64
operator||
name|Imm32S
expr_stmt|;
break|break;
case|case
name|LONG_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
name|Imm32
operator||
name|Imm64
expr_stmt|;
break|break;
case|case
name|WORD_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
name|Imm16
operator||
name|Imm32
operator||
name|Imm64
expr_stmt|;
break|break;
break|break;
case|case
name|BYTE_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32S
operator||
name|Imm32
expr_stmt|;
break|break;
break|break;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|.
name|disp_operands
condition|)
block|{
comment|/* Try to use the smallest displacement type too.  */
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp
operator|)
operator|&&
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|offsetT
name|disp
init|=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp16
condition|)
block|{
comment|/* We know this operand is at most 16 bits, so 		     convert to a signed 16 bit number before trying 		     to see whether it will fit in an even smaller 		     size.  */
name|disp
operator|=
operator|(
operator|(
operator|(
name|disp
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp32
condition|)
block|{
comment|/* We know this operand is at most 32 bits, so convert to a 		     signed 32 bit number before trying to see whether it will 		     fit in an even smaller size.  */
name|disp
operator|&=
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|disp
operator|=
operator|(
name|disp
operator|^
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|-
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
if|if
condition|(
name|fits_in_signed_long
argument_list|(
name|disp
argument_list|)
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32S
expr_stmt|;
if|if
condition|(
name|fits_in_unsigned_long
argument_list|(
name|disp
argument_list|)
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
operator|(
name|Disp32
operator||
name|Disp32S
operator||
name|Disp16
operator|)
operator|)
operator|&&
name|fits_in_signed_byte
argument_list|(
name|disp
argument_list|)
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
block|}
block|}
name|overlap0
operator|=
literal|0
expr_stmt|;
name|overlap1
operator|=
literal|0
expr_stmt|;
name|overlap2
operator|=
literal|0
expr_stmt|;
name|found_reverse_match
operator|=
literal|0
expr_stmt|;
name|suffix_check
operator|=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|?
name|No_bSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|?
name|No_wSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|SHORT_MNEM_SUFFIX
condition|?
name|No_sSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
condition|?
name|No_lSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|?
name|No_qSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|LONG_DOUBLE_MNEM_SUFFIX
condition|?
name|No_xSuf
else|:
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
name|t
operator|++
control|)
block|{
comment|/* Must have right number of operands.  */
if|if
condition|(
name|i
operator|.
name|operands
operator|!=
name|t
operator|->
name|operands
condition|)
continue|continue;
comment|/* Check the suffix, except for some instructions in intel mode.  */
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|suffix_check
operator|)
operator|&&
operator|!
operator|(
name|intel_syntax
operator|&&
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|IgnoreSize
operator|)
operator|)
operator|&&
operator|!
operator|(
name|intel_syntax
operator|&&
name|t
operator|->
name|base_opcode
operator|==
literal|0xd9
operator|&&
operator|(
name|t
operator|->
name|extension_opcode
operator|==
literal|5
comment|/* 0xd9,5 "fldcw"  */
operator|||
name|t
operator|->
name|extension_opcode
operator|==
literal|7
operator|)
operator|)
condition|)
comment|/* 0xd9,7 "f{n}stcw"  */
continue|continue;
comment|/* Do not verify operands when there are none.  */
elseif|else
if|if
condition|(
operator|!
name|t
operator|->
name|operands
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|cpu_flags
operator|&
operator|~
name|cpu_arch_flags
condition|)
continue|continue;
comment|/* We've found a match; break out of loop.  */
break|break;
block|}
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|operands
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Check if other direction is valid ...  */
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|D
operator||
name|FloatD
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Try reversing direction of operands.  */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Does not match either direction.  */
continue|continue;
block|}
comment|/* found_reverse_match holds which of D or FloatDR 		   we've found.  */
name|found_reverse_match
operator|=
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|D
operator||
name|FloatDR
operator|)
expr_stmt|;
block|}
comment|/* Found a forward 2 operand match here.  */
elseif|else
if|if
condition|(
name|t
operator|->
name|operands
operator|==
literal|3
condition|)
block|{
comment|/* Here we make use of the fact that there are no 		   reverse match 3 operand instructions, and all 3 		   operand instructions only need to be checked for 		   register consistency between operands 2 and 3.  */
name|overlap2
operator|=
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
condition|)
continue|continue;
block|}
comment|/* Found either forward/reverse 2 or 3 operand match here: 	       slip through to break.  */
block|}
if|if
condition|(
name|t
operator|->
name|cpu_flags
operator|&
operator|~
name|cpu_arch_flags
condition|)
block|{
name|found_reverse_match
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* We've found a match; break out of loop.  */
break|break;
block|}
if|if
condition|(
name|t
operator|==
name|current_templates
operator|->
name|end
condition|)
block|{
comment|/* We found no match.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"suffix or operands invalid for `%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|quiet_warnings
condition|)
block|{
if|if
condition|(
operator|!
name|intel_syntax
operator|&&
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|JumpAbsolute
operator|)
operator|!=
operator|(
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
operator|&
name|JumpAbsolute
operator|)
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"indirect %s without `*'"
argument_list|)
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|IsPrefix
operator||
name|IgnoreSize
operator|)
operator|)
operator|==
operator|(
name|IsPrefix
operator||
name|IgnoreSize
operator|)
condition|)
block|{
comment|/* Warn them that a data or address size prefix doesn't 	       affect assembly of the next line of code.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"stand-alone `%s' prefix"
argument_list|)
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy the template we found.  */
name|i
operator|.
name|tm
operator|=
operator|*
name|t
expr_stmt|;
if|if
condition|(
name|found_reverse_match
condition|)
block|{
comment|/* If we found a reverse match we must alter the opcode 	   direction bit.  found_reverse_match holds bits to change 	   (different for int& float insns).  */
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|^=
name|found_reverse_match
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|1
index|]
operator|=
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
if|if
condition|(
name|SYSV386_COMPAT
operator|&&
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xfffffde0
operator|)
operator|==
literal|0xdce0
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|^=
name|FloatR
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|FWait
condition|)
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|FWAIT_OPCODE
argument_list|)
condition|)
return|return;
comment|/* Check string instruction segment overrides.  */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|!=
literal|0
operator|&&
name|i
operator|.
name|mem_operands
operator|!=
literal|0
condition|)
block|{
name|int
name|mem_op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|AnyMem
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|mem_op
index|]
operator|&
name|EsSeg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|!=
operator|&
name|es
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' operand %d must use `%%es' segment"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|mem_op
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* There's only ever one segment override allowed per instruction. 	       This instruction possibly has a legal segment override on the 	       second operand, so copy the segment to where non-string 	       instructions store it, allowing common code.  */
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|seg
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|mem_op
operator|+
literal|1
index|]
operator|&
name|EsSeg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|seg
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|i
operator|.
name|seg
index|[
literal|1
index|]
operator|!=
operator|&
name|es
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' operand %d must use `%%es' segment"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|mem_op
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If matched instruction specifies an explicit instruction mnemonic        suffix, use it.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|Size16
operator||
name|Size32
operator||
name|Size64
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Size16
condition|)
name|i
operator|.
name|suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Size64
condition|)
name|i
operator|.
name|suffix
operator|=
name|QWORD_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
comment|/* If there's no instruction mnemonic suffix we try to invent one 	   based on register operands.  */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
comment|/* We take i.suffix from the last register operand specified, 	       Destination register type is more significant than source 	       register type.  */
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg
operator|)
operator|&&
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
name|InOutPortReg
operator|)
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
condition|?
name|BYTE_MNEM_SUFFIX
else|:
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
operator|)
condition|?
name|WORD_MNEM_SUFFIX
else|:
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg64
operator|)
condition|?
name|QWORD_MNEM_SUFFIX
else|:
name|LONG_MNEM_SUFFIX
operator|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* If this is an eight bit register, it's OK.  If it's 		   the 16 or 32 bit version of an eight bit register, 		   we will just use the low portion, and that's OK too.  */
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
condition|)
continue|continue;
comment|/* movzx and movsx should not generate this warning.  */
if|if
condition|(
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfb7
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfb6
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x63
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfbe
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfbf
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|WordReg
operator|)
operator|&&
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|<
literal|4
if|#
directive|if
literal|0
comment|/* Check that the template allows eight bit regs 		       This kills insns such as `orb $1,%edx', which 		       maybe should be allowed.  */
condition|&& (i.tm.operand_types[op]& (Reg8|InOutPortReg))
endif|#
directive|endif
condition|)
block|{
comment|/* Prohibit these changes in the 64bit mode, since 		       the lowering is more complicated.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
name|InOutPortReg
operator|)
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%%%s' used with`%c' suffix"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
if|#
directive|if
name|REGISTER_WARNINGS
if|if
condition|(
operator|!
name|quiet_warnings
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
name|InOutPortReg
operator|)
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using `%%%s' instead of `%%%s' due to `%c' suffix"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|+
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
condition|?
name|REGNAM_AL
operator|-
name|REGNAM_AX
else|:
name|REGNAM_AL
operator|-
name|REGNAM_EAX
operator|)
operator|)
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* Any other register is bad.  */
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|FloatReg
operator||
name|FloatAcc
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%%%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
condition|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
comment|/* Reject eight bit registers, except where the template 		 requires them. (eg. movzb)  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%%%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Warn if the e prefix on a general reg is missing.  */
elseif|else
if|if
condition|(
operator|(
operator|!
name|quiet_warnings
operator|||
name|flag_code
operator|==
name|CODE_64BIT
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Prohibit these changes in the 64bit mode, since 		     the lowering is more complicated.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%%%s' used with`%c' suffix"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
if|#
directive|if
name|REGISTER_WARNINGS
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using `%%%s' instead of `%%%s' due to `%c' suffix"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|+
name|REGNAM_EAX
operator|-
name|REGNAM_AX
operator|)
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Warn if the r prefix on a general reg is missing.  */
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg64
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%%%s' used with`%c' suffix"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
comment|/* Reject eight bit registers, except where the template 		 requires them. (eg. movzb)  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%%%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Warn if the e prefix on a general reg is missing.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
operator|)
operator|!=
literal|0
operator|||
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg32
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Prohibit these changes in the 64bit mode, since 		     the lowering is more complicated.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%%%s' used with`%c' suffix"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
comment|/* Reject eight bit registers, except where the template 		 requires them. (eg. movzb)  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%%%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Warn if the e prefix on a general reg is present.  */
elseif|else
if|if
condition|(
operator|(
operator|!
name|quiet_warnings
operator|||
name|flag_code
operator|==
name|CODE_64BIT
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg32
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Prohibit these changes in the 64bit mode, since 		     the lowering is more complicated.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%%%s' used with`%c' suffix"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
else|else
if|#
directive|if
name|REGISTER_WARNINGS
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using `%%%s' instead of `%%%s' due to `%c' suffix"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|+
name|REGNAM_AX
operator|-
name|REGNAM_EAX
operator|)
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IgnoreSize
operator|)
condition|)
comment|/* Do nothing if the instruction is going to ignore the prefix.  */
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|DefaultSize
operator|)
operator|&&
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|stackop_size
expr_stmt|;
block|}
comment|/* Make still unresolved immediate matches conform to size of immediate        given in i.suffix.  Note: overlap2 cannot be an immediate!  */
if|if
condition|(
operator|(
name|overlap0
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator|)
operator|)
operator|&&
name|overlap0
operator|!=
name|Imm8
operator|&&
name|overlap0
operator|!=
name|Imm8S
operator|&&
name|overlap0
operator|!=
name|Imm16
operator|&&
name|overlap0
operator|!=
name|Imm32S
operator|&&
name|overlap0
operator|!=
name|Imm32
operator|&&
name|overlap0
operator|!=
name|Imm64
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
name|overlap0
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|?
name|Imm16
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|?
name|Imm64
operator||
name|Imm32S
else|:
name|Imm32
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overlap0
operator|==
operator|(
name|Imm16
operator||
name|Imm32S
operator||
name|Imm32
operator|)
operator|||
name|overlap0
operator|==
operator|(
name|Imm16
operator||
name|Imm32
operator|)
operator|||
name|overlap0
operator|==
operator|(
name|Imm16
operator||
name|Imm32S
operator|)
condition|)
block|{
name|overlap0
operator|=
operator|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
operator|)
condition|?
name|Imm16
else|:
name|Imm32S
expr_stmt|;
block|}
if|if
condition|(
name|overlap0
operator|!=
name|Imm8
operator|&&
name|overlap0
operator|!=
name|Imm8S
operator|&&
name|overlap0
operator|!=
name|Imm16
operator|&&
name|overlap0
operator|!=
name|Imm32S
operator|&&
name|overlap0
operator|!=
name|Imm32
operator|&&
name|overlap0
operator|!=
name|Imm64
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no instruction mnemonic suffix given; can't determine immediate size"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|overlap1
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32S
operator||
name|Imm32
operator|)
operator|)
operator|&&
name|overlap1
operator|!=
name|Imm8
operator|&&
name|overlap1
operator|!=
name|Imm8S
operator|&&
name|overlap1
operator|!=
name|Imm16
operator|&&
name|overlap1
operator|!=
name|Imm32S
operator|&&
name|overlap1
operator|!=
name|Imm32
operator|&&
name|overlap1
operator|!=
name|Imm64
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
name|overlap1
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|?
name|Imm16
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|?
name|Imm64
operator||
name|Imm32S
else|:
name|Imm32
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overlap1
operator|==
operator|(
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator|)
operator|||
name|overlap1
operator|==
operator|(
name|Imm16
operator||
name|Imm32
operator|)
operator|||
name|overlap1
operator|==
operator|(
name|Imm16
operator||
name|Imm32S
operator|)
condition|)
block|{
name|overlap1
operator|=
operator|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
operator|)
condition|?
name|Imm16
else|:
name|Imm32S
expr_stmt|;
block|}
if|if
condition|(
name|overlap1
operator|!=
name|Imm8
operator|&&
name|overlap1
operator|!=
name|Imm8S
operator|&&
name|overlap1
operator|!=
name|Imm16
operator|&&
name|overlap1
operator|!=
name|Imm32S
operator|&&
name|overlap1
operator|!=
name|Imm32
operator|&&
name|overlap1
operator|!=
name|Imm64
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no instruction mnemonic suffix given; can't determine immediate size %x %c"
argument_list|)
argument_list|,
name|overlap1
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|assert
argument_list|(
operator|(
name|overlap2
operator|&
name|Imm
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|=
name|overlap0
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|Imm1
condition|)
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
comment|/* kludge for shift insns.  */
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|=
name|overlap1
expr_stmt|;
if|if
condition|(
name|overlap1
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|=
name|overlap2
expr_stmt|;
if|if
condition|(
name|overlap2
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
comment|/* Finalize opcode.  First, we change the opcode based on the operand        size given by i.suffix:  We need not change things for byte insns.  */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|W
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no instruction mnemonic suffix given and no register operands; can't size instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For movzx and movsx, need to check the register type.  */
if|if
condition|(
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfb6
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfbe
operator|)
condition|)
if|if
condition|(
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|)
block|{
name|unsigned
name|int
name|prefix
init|=
name|DATA_PREFIX_OPCODE
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|regs
operator|->
name|reg_type
operator|&
name|Reg16
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|prefix
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|suffix
operator|!=
name|BYTE_MNEM_SUFFIX
condition|)
block|{
comment|/* It's not a byte, select word/dword operation.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|W
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ShortForm
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
literal|8
expr_stmt|;
else|else
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
literal|1
expr_stmt|;
block|}
comment|/* Now select between word& dword operations via the operand 	   size prefix, except for instructions that will ignore this 	   prefix anyway.  */
if|if
condition|(
name|i
operator|.
name|suffix
operator|!=
name|QWORD_MNEM_SUFFIX
operator|&&
operator|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
operator|)
operator|==
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|&&
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IgnoreSize
operator|)
condition|)
block|{
name|unsigned
name|int
name|prefix
init|=
name|DATA_PREFIX_OPCODE
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpByte
condition|)
comment|/* jcxz, loop */
name|prefix
operator|=
name|ADDR_PREFIX_OPCODE
expr_stmt|;
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|prefix
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|suffix
operator|!=
name|QWORD_MNEM_SUFFIX
operator|&&
operator|(
name|flag_code
operator|==
name|CODE_64BIT
operator|)
operator|&&
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IgnoreSize
operator|)
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpByte
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|ADDR_PREFIX_OPCODE
argument_list|)
condition|)
return|return;
block|}
comment|/* Set mode64 for an operand.  */
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
operator|&&
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|NoRex64
operator|)
condition|)
block|{
name|i
operator|.
name|rex
operator|.
name|mode64
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_code
operator|<
name|CODE_64BIT
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"64bit operations available only in 64bit modes."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Size floating point instruction.  */
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|FloatMF
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|^=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ImmExt
condition|)
block|{
comment|/* These AMD 3DNow! and Intel Katmai New Instructions have an 	   opcode suffix which is coded in the same place as an 8-bit 	   immediate field would be.  Here we fake an 8-bit immediate 	   operand from the opcode suffix stored in tm.extension_opcode.  */
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|assert
argument_list|(
name|i
operator|.
name|imm_operands
operator|==
literal|0
operator|&&
name|i
operator|.
name|operands
operator|<=
literal|2
operator|&&
literal|2
operator|<
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|&
name|im_expressions
index|[
name|i
operator|.
name|imm_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|i
operator|.
name|operands
index|]
operator|.
name|imms
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|i
operator|.
name|operands
operator|++
index|]
operator|=
name|Imm8
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
name|i
operator|.
name|tm
operator|.
name|extension_opcode
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|=
name|None
expr_stmt|;
block|}
comment|/* For insns with operands there are more diddles to do to the opcode.  */
if|if
condition|(
name|i
operator|.
name|operands
condition|)
block|{
comment|/* Default segment register this instruction will use 	   for memory accesses.  0 means unknown. 	   This is only for optimizing out unnecessary segment overrides.  */
specifier|const
name|seg_entry
modifier|*
name|default_seg
init|=
literal|0
decl_stmt|;
comment|/* The imul $imm, %reg instruction is converted into 	   imul $imm, %reg, %reg, and the clr %reg instruction 	   is converted into xor %reg, %reg.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|regKludge
condition|)
block|{
name|unsigned
name|int
name|first_reg_op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Pretend we saw the extra register operand.  */
name|assert
argument_list|(
name|i
operator|.
name|op
index|[
name|first_reg_op
operator|+
literal|1
index|]
operator|.
name|regs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|i
operator|.
name|op
index|[
name|first_reg_op
operator|+
literal|1
index|]
operator|.
name|regs
operator|=
name|i
operator|.
name|op
index|[
name|first_reg_op
index|]
operator|.
name|regs
expr_stmt|;
name|i
operator|.
name|types
index|[
name|first_reg_op
operator|+
literal|1
index|]
operator|=
name|i
operator|.
name|types
index|[
name|first_reg_op
index|]
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ShortForm
condition|)
block|{
comment|/* The register or float register operand is in operand 0 or 1.  */
name|unsigned
name|int
name|op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|FloatReg
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Register goes in low 3 bits of opcode.  */
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extZ
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_warnings
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Ugh
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Warn about some common errors, but press on regardless. 		   The first case can be generated by gcc (<= 2.8.1).  */
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|2
condition|)
block|{
comment|/* Reversed arguments on faddp, fsubp, etc.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating to `%s %%%s,%%%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Extraneous `l' suffix on fp insn.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating to `%s %%%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
comment|/* The opcode is completed (modulo i.tm.extension_opcode which 	       must be put into the modrm byte). 	       Now, we make the modrm& index base bytes based on all the 	       info we've collected.  */
comment|/* i.reg_operands MUST be the number of real register operands; 	       implicit registers do not count.  */
if|if
condition|(
name|i
operator|.
name|reg_operands
operator|==
literal|2
condition|)
block|{
name|unsigned
name|int
name|source
decl_stmt|,
name|dest
decl_stmt|;
name|source
operator|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|dest
operator|=
name|source
operator|+
literal|1
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
comment|/* One of the register operands will be encoded in the 		   i.tm.reg field, the other in the combined i.tm.mode 		   and i.tm.regmem fields.  If no form of this 		   instruction supports a memory destination operand, 		   then we assume the source operand may sometimes be 		   a memory operand and so we need to store the 		   destination in the i.rm.reg field.  */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|dest
index|]
operator|&
name|AnyMem
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extX
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extZ
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extZ
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extX
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If it's not 2 reg operands...  */
if|if
condition|(
name|i
operator|.
name|mem_operands
condition|)
block|{
name|unsigned
name|int
name|fake_zero_displacement
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|op
init|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|AnyMem
operator|)
condition|?
literal|0
else|:
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|AnyMem
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
decl_stmt|;
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|base_reg
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|disp_operands
condition|)
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/* Operand is just<disp>  */
if|if
condition|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|flag_code
operator|!=
name|CODE_64BIT
operator|)
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|NO_BASE_REGISTER_16
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_code
operator|!=
name|CODE_64BIT
operator|||
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32
expr_stmt|;
block|}
else|else
block|{
comment|/* 64bit mode overwrites the 32bit 				   absolute addressing by RIP relative 				   addressing and absolute addressing 				   is encoded by one of the redundant 				   SIB forms.  */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|base
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32S
expr_stmt|;
block|}
block|}
else|else
comment|/* ! i.base_reg&& i.index_reg  */
block|{
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|base
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
if|if
condition|(
name|flag_code
operator|!=
name|CODE_64BIT
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32
expr_stmt|;
comment|/* Must be 32 bit */
else|else
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32S
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|index_reg
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extY
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* RIP addressing for 64bit mode.  */
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|==
name|BaseIndex
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32S
expr_stmt|;
name|i
operator|.
name|flags
index|[
name|op
index|]
operator|=
name|Operand_PCrel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg16
condition|)
block|{
switch|switch
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_num
condition|)
block|{
case|case
literal|3
case|:
comment|/* (%bx)  */
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
literal|7
expr_stmt|;
else|else
comment|/* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|-
literal|6
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* (%bp)  */
name|default_seg
operator|=
operator|&
name|ss
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
literal|6
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* fake (%bp) into 0(%bp)  */
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|-
literal|6
operator|+
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* (%si) -> 4 or (%di) -> 5  */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|-
literal|6
operator|+
literal|4
expr_stmt|;
block|}
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* i.base_reg and 32/64 bit mode  */
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp8
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
name|Disp8
operator||
name|Disp32S
expr_stmt|;
else|else
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
name|Disp32S
expr_stmt|;
block|}
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extZ
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|base
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
comment|/* x86-64 ignores REX prefix bit here to avoid 			   decoder complications.  */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|&
literal|7
operator|)
operator|==
name|EBP_REG_NUM
condition|)
block|{
name|default_seg
operator|=
operator|&
name|ss
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|==
literal|0
condition|)
block|{
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|==
name|ESP_REG_NUM
condition|)
block|{
name|default_seg
operator|=
operator|&
name|ss
expr_stmt|;
block|}
name|i
operator|.
name|sib
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/*<disp>(%esp) becomes two byte modrm 			       with no index register.  We've already 			       stored the code for esp in i.rm.regmem 			       ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.  Any 			       base register besides %esp will not use 			       the extra modrm byte.  */
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
if|#
directive|if
operator|!
name|SCALE1_WHEN_NO_INDEX
comment|/* Another case where we force the second 			       modrm byte.  */
if|if
condition|(
name|i
operator|.
name|log2_scale_factor
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|index_reg
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extY
operator|=
literal|1
expr_stmt|;
block|}
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fake_zero_displacement
condition|)
block|{
comment|/* Fakes a zero displacement assuming that i.types[op] 			   holds the correct displacement size.  */
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|assert
argument_list|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|==
literal|0
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|=
name|exp
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* Fill in i.rm.reg or i.rm.regmem field with register 		   operand (if any) based on i.tm.extension_opcode. 		   Again, we must be careful to make sure that 		   segment/control/debug/test/MMX registers are coded 		   into the i.rm.reg field.  */
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
name|unsigned
name|int
name|op
init|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
operator|)
decl_stmt|;
comment|/* If there is an extension opcode to put here, the 		       register number must be put into the regmem field.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|!=
name|None
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extZ
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extX
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now, if no memory operand has set i.rm.mode = 0, 1, 2 		       we must set it to 3 to indicate this is a register 		       operand in the regmem field.  */
if|if
condition|(
operator|!
name|i
operator|.
name|mem_operands
condition|)
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Fill in i.rm.reg field with extension opcode (if any).  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|tm
operator|.
name|extension_opcode
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|Seg2ShortForm
operator||
name|Seg3ShortForm
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
name|POP_SEG_SHORT
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|==
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"you can't `pop %%cs'"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
operator|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
condition|)
name|i
operator|.
name|rex
operator|.
name|extZ
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
operator|~
operator|(
name|D
operator||
name|W
operator|)
operator|)
operator|==
name|MOV_AX_DISP32
condition|)
block|{
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* For the string instructions that allow a segment override 	       on one of their operands, the default segment is ds.  */
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
block|}
comment|/* If a segment was explicitly specified, 	   and the specified segment is not the default, 	   use an opcode prefix to select it. 	   If we never figured out what the default segment is, 	   then default_seg will be zero at this point, 	   and the specified segment prefix will always be used.  */
if|if
condition|(
operator|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|!=
name|default_seg
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|->
name|seg_prefix
argument_list|)
condition|)
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|quiet_warnings
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Ugh
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating to `%sp'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle conversion of 'int $3' --> special int3 insn.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
name|INT_OPCODE
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|==
literal|3
condition|)
block|{
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|=
name|INT3_OPCODE
expr_stmt|;
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpByte
operator||
name|JumpDword
operator|)
operator|)
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Convert "jmp constant" (and "call constant") to a jump (call) to 	 the absolute address given by the constant.  Since ix86 jumps and 	 calls are pc relative, we need to generate a reloc.  */
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_add_symbol
operator|=
operator|&
name|abs_symbol
expr_stmt|;
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Rex64
condition|)
name|i
operator|.
name|rex
operator|.
name|mode64
operator|=
literal|1
expr_stmt|;
comment|/* For 8bit registers we would need an empty rex prefix.      Also in the case instruction is already having prefix,      we need to convert old registers to new ones.  */
if|if
condition|(
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg8
operator|)
operator|&&
operator|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex64
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Reg8
operator|)
operator|&&
operator|(
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex64
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|.
name|rex
operator|.
name|mode64
operator|||
name|i
operator|.
name|rex
operator|.
name|extX
operator|||
name|i
operator|.
name|rex
operator|.
name|extY
operator|||
name|i
operator|.
name|rex
operator|.
name|extZ
operator|||
name|i
operator|.
name|rex
operator|.
name|empty
operator|)
operator|&&
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg8
operator|)
operator|||
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Reg8
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|x
decl_stmt|;
name|i
operator|.
name|rex
operator|.
name|empty
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|2
condition|;
name|x
operator|++
control|)
block|{
comment|/* Look for 8bit operand that does use old registers.  */
if|if
condition|(
name|i
operator|.
name|types
index|[
name|x
index|]
operator|&
name|Reg8
operator|&&
operator|!
operator|(
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex64
operator|)
condition|)
block|{
comment|/* In case it is "hi" register, give up.  */
if|if
condition|(
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|>
literal|3
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can't encode registers '%%%s' in the instruction requiring REX prefix.\n"
argument_list|)
argument_list|,
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
comment|/* Otherwise it is equivalent to the extended register. 	         Since the encoding don't change this is merely cosmetical 	         cleanup for debug output.  */
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|=
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|+
literal|8
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|.
name|rex
operator|.
name|mode64
operator|||
name|i
operator|.
name|rex
operator|.
name|extX
operator|||
name|i
operator|.
name|rex
operator|.
name|extY
operator|||
name|i
operator|.
name|rex
operator|.
name|extZ
operator|||
name|i
operator|.
name|rex
operator|.
name|empty
condition|)
name|add_prefix
argument_list|(
literal|0x40
operator||
operator|(
name|i
operator|.
name|rex
operator|.
name|mode64
condition|?
literal|8
else|:
literal|0
operator|)
operator||
operator|(
name|i
operator|.
name|rex
operator|.
name|extX
condition|?
literal|4
else|:
literal|0
operator|)
operator||
operator|(
name|i
operator|.
name|rex
operator|.
name|extY
condition|?
literal|2
else|:
literal|0
operator|)
operator||
operator|(
name|i
operator|.
name|rex
operator|.
name|extZ
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* We are ready to output the insn.  */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Tie dwarf2 debug info to the address at the start of the insn.        We can't do this after the insn has been output as the current        frag may have been closed off.  eg. by frag_var.  */
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Output jumps.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Jump
condition|)
block|{
name|int
name|code16
decl_stmt|;
name|int
name|prefix
decl_stmt|;
name|relax_substateT
name|subtype
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|off
decl_stmt|;
name|code16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
condition|)
name|code16
operator|=
name|CODE16
expr_stmt|;
name|prefix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
condition|)
block|{
name|prefix
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
name|code16
operator|^=
name|CODE16
expr_stmt|;
block|}
comment|/* Pentium4 branch hints.  */
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|CS_PREFIX_OPCODE
comment|/* not taken */
operator|||
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|DS_PREFIX_OPCODE
comment|/* taken */
condition|)
block|{
name|prefix
operator|++
expr_stmt|;
name|i
operator|.
name|prefixes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
condition|)
block|{
name|prefix
operator|++
expr_stmt|;
name|i
operator|.
name|prefixes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefixes
operator|!=
literal|0
operator|&&
operator|!
name|intel_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping prefixes on this instruction"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It's always a symbol;  End frag& setup for relax. 	   Make sure there is enough room in this frag for the largest 	   instruction we may generate in md_convert_frag.  This is 2 	   bytes for the opcode and room for the prefix and largest 	   displacement.  */
name|frag_grow
argument_list|(
name|prefix
operator|+
literal|2
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Prefix and 1 opcode byte go in fr_fix.  */
name|p
operator|=
name|frag_more
argument_list|(
name|prefix
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
condition|)
operator|*
name|p
operator|++
operator|=
name|DATA_PREFIX_OPCODE
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|CS_PREFIX_OPCODE
operator|||
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|DS_PREFIX_OPCODE
condition|)
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
condition|)
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
expr_stmt|;
operator|*
name|p
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|==
name|JUMP_PC_RELATIVE
condition|)
name|subtype
operator|=
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|SMALL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cpu_arch_flags
operator|&
name|Cpu386
operator|)
operator|!=
literal|0
condition|)
name|subtype
operator|=
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|SMALL
argument_list|)
expr_stmt|;
else|else
name|subtype
operator|=
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP86
argument_list|,
name|SMALL
argument_list|)
expr_stmt|;
name|subtype
operator||=
name|code16
expr_stmt|;
name|sym
operator|=
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
comment|/* Handle complex expressions.  */
name|sym
operator|=
name|make_expr_symbol
argument_list|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 1 possible extra opcode + 4 byte displacement go in var part. 	   Pass reloc in fr_var.  */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|5
argument_list|,
name|i
operator|.
name|reloc
index|[
literal|0
index|]
argument_list|,
name|subtype
argument_list|,
name|sym
argument_list|,
name|off
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|JumpByte
operator||
name|JumpDword
operator|)
condition|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpByte
condition|)
block|{
comment|/* This is a loop or jecxz type instruction.  */
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|ADDR_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* Pentium4 branch hints.  */
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|CS_PREFIX_OPCODE
comment|/* not taken */
operator|||
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|DS_PREFIX_OPCODE
comment|/* taken */
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|code16
decl_stmt|;
name|code16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
condition|)
name|code16
operator|=
name|CODE16
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|DATA_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
name|code16
operator|^=
name|CODE16
expr_stmt|;
block|}
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|code16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefixes
operator|!=
literal|0
operator|&&
operator|!
name|intel_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping prefixes on this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
argument_list|,
literal|1
argument_list|,
name|reloc
argument_list|(
name|size
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|i
operator|.
name|reloc
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpInterSegment
condition|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|prefix
decl_stmt|;
name|int
name|code16
decl_stmt|;
name|code16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
condition|)
name|code16
operator|=
name|CODE16
expr_stmt|;
name|prefix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
condition|)
block|{
name|prefix
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
name|code16
operator|^=
name|CODE16
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
condition|)
block|{
name|prefix
operator|++
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
block|}
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|code16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefixes
operator|!=
literal|0
operator|&&
operator|!
name|intel_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping prefixes on this instruction"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1 opcode; 2 segment; offset  */
name|p
operator|=
name|frag_more
argument_list|(
name|prefix
operator|+
literal|1
operator|+
literal|2
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
condition|)
operator|*
name|p
operator|++
operator|=
name|DATA_PREFIX_OPCODE
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
condition|)
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|offsetT
name|n
init|=
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|imms
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|2
operator|&&
operator|!
name|fits_in_unsigned_word
argument_list|(
name|n
argument_list|)
operator|&&
operator|!
name|fits_in_signed_word
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"16-bit jump out of range"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|imms
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|i
operator|.
name|reloc
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|imms
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't handle non absolute segment in `%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
name|size
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|imms
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output normal instructions here.  */
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
comment|/* All opcodes on i386 have eighter 1 or 2 bytes.  We may use third 	   byte for the SSE instructions to specify prefix they require.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff0000
condition|)
name|add_prefix
argument_list|(
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* The prefix bytes.  */
for|for
control|(
name|q
operator|=
name|i
operator|.
name|prefix
init|;
name|q
operator|<
name|i
operator|.
name|prefix
operator|+
sizeof|sizeof
argument_list|(
name|i
operator|.
name|prefix
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|i
operator|.
name|prefix
index|[
literal|0
index|]
argument_list|)
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
operator|*
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now the opcode; be careful about word order here!  */
if|if
condition|(
name|fits_in_unsigned_byte
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Put out high byte first: can't use md_number_to_chars!  */
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* Now the modrm byte and sib byte (if present).  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|<<
literal|0
operator||
name|i
operator|.
name|rm
operator|.
name|reg
operator|<<
literal|3
operator||
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|6
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If i.rm.regmem == ESP (4)&& i.rm.mode != (Register mode)&& not 16 bit 	       ==> need second modrm byte.  */
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|==
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
operator|&&
name|i
operator|.
name|rm
operator|.
name|mode
operator|!=
literal|3
operator|&&
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg16
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|i
operator|.
name|sib
operator|.
name|base
operator|<<
literal|0
operator||
name|i
operator|.
name|sib
operator|.
name|index
operator|<<
literal|3
operator||
name|i
operator|.
name|sib
operator|.
name|scale
operator|<<
literal|6
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|disp_operands
condition|)
block|{
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|size
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp8
operator||
name|Disp16
operator||
name|Disp64
operator|)
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp8
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp64
condition|)
name|size
operator|=
literal|8
expr_stmt|;
block|}
name|val
operator|=
name|offset_in_range
argument_list|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
literal|4
decl_stmt|;
name|int
name|sign
init|=
literal|0
decl_stmt|;
name|int
name|pcrel
init|=
operator|(
name|i
operator|.
name|flags
index|[
name|n
index|]
operator|&
name|Operand_PCrel
operator|)
operator|!=
literal|0
decl_stmt|;
comment|/* The PC relative address is computed relative 			   to the instruction boundary, so in case immediate 			   fields follows, we need to adjust the value.  */
if|if
condition|(
name|pcrel
operator|&&
name|i
operator|.
name|imm_operands
condition|)
block|{
name|int
name|imm_size
init|=
literal|4
decl_stmt|;
specifier|register
name|unsigned
name|int
name|n1
decl_stmt|;
for|for
control|(
name|n1
operator|=
literal|0
init|;
name|n1
operator|<
name|i
operator|.
name|operands
condition|;
name|n1
operator|++
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n1
index|]
operator|&
name|Imm
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n1
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm64
operator|)
condition|)
block|{
name|imm_size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n1
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
name|imm_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n1
index|]
operator|&
name|Imm64
condition|)
name|imm_size
operator|=
literal|8
expr_stmt|;
block|}
break|break;
block|}
comment|/* We should find the immediate.  */
if|if
condition|(
name|n1
operator|==
name|i
operator|.
name|operands
condition|)
name|abort
argument_list|()
expr_stmt|;
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_add_number
operator|-=
name|imm_size
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp32S
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp16
operator||
name|Disp64
operator|)
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp64
condition|)
name|size
operator|=
literal|8
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
argument_list|,
name|pcrel
argument_list|,
name|reloc
argument_list|(
name|size
argument_list|,
name|pcrel
argument_list|,
name|sign
argument_list|,
name|i
operator|.
name|reloc
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Output immediate.  */
if|if
condition|(
name|i
operator|.
name|imm_operands
condition|)
block|{
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|size
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm64
operator|)
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
name|size
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm64
condition|)
name|size
operator|=
literal|8
expr_stmt|;
block|}
name|val
operator|=
name|offset_in_range
argument_list|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not absolute_section. 			   Need a 32-bit fixup (don't support 8bit 			   non-absolute imms).  Try to support other 			   sizes ...  */
name|RELOC_ENUM
name|reloc_type
decl_stmt|;
name|int
name|size
init|=
literal|4
decl_stmt|;
name|int
name|sign
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm32S
operator|)
operator|)
operator|&&
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm64
operator|)
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm64
condition|)
name|size
operator|=
literal|8
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|reloc
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|sign
argument_list|,
name|i
operator|.
name|reloc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|reloc_type
operator|==
name|BFD_RELOC_32
operator|&&
name|GOT_symbol
operator|&&
name|GOT_symbol
operator|==
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_symbol
operator|&&
operator|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
operator|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_add
operator|&&
operator|(
operator|(
name|symbol_get_value_expression
argument_list|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op_symbol
argument_list|)
operator|->
name|X_op
operator|)
operator|==
name|O_subtract
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We don't support dynamic linking on x86-64 yet.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reloc_type
operator|=
name|BFD_RELOC_386_GOTPC
expr_stmt|;
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|+=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG386
if|if
condition|(
name|flag_debug
condition|)
block|{
name|pi
argument_list|(
name|line
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG386  */
block|}
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_AT
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lex_got
name|PARAMS
argument_list|(
operator|(
name|RELOC_ENUM
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse operands of the form<symbol>@GOTOFF+<nnn>    and similar .plt or .got references.     If we find one, set up the correct relocation in RELOC and copy the    input string, minus the `@GOTOFF' into a malloc'd buffer for    parsing by the calling routine.  Return this buffer, and if ADJUST    is non-null set it to the length of the string we removed from the    input line.  Otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lex_got
parameter_list|(
name|reloc
parameter_list|,
name|adjust
parameter_list|)
name|RELOC_ENUM
modifier|*
name|reloc
decl_stmt|;
name|int
modifier|*
name|adjust
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mode_name
index|[
name|NUM_FLAG_CODE
index|]
init|=
block|{
literal|"32"
block|,
literal|"16"
block|,
literal|"64"
block|}
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|RELOC_ENUM
name|rel
index|[
name|NUM_FLAG_CODE
index|]
decl_stmt|;
block|}
name|gotrel
index|[]
init|=
block|{
block|{
literal|"PLT"
block|,
block|{
name|BFD_RELOC_386_PLT32
block|,
literal|0
block|,
name|BFD_RELOC_X86_64_PLT32
block|}
block|}
block|,
block|{
literal|"GOTOFF"
block|,
block|{
name|BFD_RELOC_386_GOTOFF
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
literal|"GOTPCREL"
block|,
block|{
literal|0
block|,
literal|0
block|,
name|BFD_RELOC_X86_64_GOTPCREL
block|}
block|}
block|,
block|{
literal|"GOT"
block|,
block|{
name|BFD_RELOC_386_GOT32
block|,
literal|0
block|,
name|BFD_RELOC_X86_64_GOT32
block|}
block|}
block|}
struct|;
name|char
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|input_line_pointer
init|;
operator|*
name|cp
operator|!=
literal|'@'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
index|]
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|gotrel
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|gotrel
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|gotrel
index|[
name|j
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|gotrel
index|[
name|j
index|]
operator|.
name|str
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gotrel
index|[
name|j
index|]
operator|.
name|rel
index|[
operator|(
name|unsigned
name|int
operator|)
name|flag_code
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|first
decl_stmt|,
name|second
decl_stmt|;
name|char
modifier|*
name|tmpbuf
decl_stmt|,
modifier|*
name|past_reloc
decl_stmt|;
operator|*
name|reloc
operator|=
name|gotrel
index|[
name|j
index|]
operator|.
name|rel
index|[
operator|(
name|unsigned
name|int
operator|)
name|flag_code
index|]
expr_stmt|;
if|if
condition|(
name|adjust
condition|)
operator|*
name|adjust
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|GOT_symbol
operator|==
name|NULL
condition|)
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
expr_stmt|;
comment|/* Replace the relocation token with ' ', so that 		 errors like foo@GOTOFF1 will be detected.  */
comment|/* The length of the first part of our input line.  */
name|first
operator|=
name|cp
operator|-
name|input_line_pointer
expr_stmt|;
comment|/* The second part goes from after the reloc token until 		 (and including) an end_of_line char.  Don't use strlen 		 here as the end_of_line char may not be a NUL.  */
name|past_reloc
operator|=
name|cp
operator|+
literal|1
operator|+
name|len
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|past_reloc
init|;
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
operator|++
index|]
condition|;
control|)
empty_stmt|;
name|second
operator|=
name|cp
operator|-
name|past_reloc
expr_stmt|;
comment|/* Allocate and copy string.  The trailing NUL shouldn't 		 be necessary, but be safe.  */
name|tmpbuf
operator|=
name|xmalloc
argument_list|(
name|first
operator|+
name|second
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|tmpbuf
index|[
name|first
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuf
operator|+
name|first
operator|+
literal|1
argument_list|,
name|past_reloc
argument_list|,
name|second
argument_list|)
expr_stmt|;
name|tmpbuf
index|[
name|first
operator|+
name|second
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|tmpbuf
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"@%s reloc is not supported in %s bit mode"
argument_list|)
argument_list|,
name|gotrel
index|[
name|j
index|]
operator|.
name|str
argument_list|,
name|mode_name
index|[
operator|(
name|unsigned
name|int
operator|)
name|flag_code
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Might be a symbol version string.  Don't as_bad here.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* x86_cons_fix_new is called via the expression parsing code when a    reloc is needed.  We use this hook to get the correct .got reloc.  */
end_comment

begin_decl_stmt
specifier|static
name|RELOC_ENUM
name|got_reloc
init|=
name|NO_RELOC
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|x86_cons_fix_new
parameter_list|(
name|frag
parameter_list|,
name|off
parameter_list|,
name|len
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|unsigned
name|int
name|off
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|RELOC_ENUM
name|r
init|=
name|reloc
argument_list|(
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|got_reloc
argument_list|)
decl_stmt|;
name|got_reloc
operator|=
name|NO_RELOC
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|x86_cons
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
comment|/* Handle @GOTOFF and the like in an expression.  */
name|char
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
name|gotfree_input_line
decl_stmt|;
name|int
name|adjust
decl_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|gotfree_input_line
operator|=
name|lex_got
argument_list|(
operator|&
name|got_reloc
argument_list|,
operator|&
name|adjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
name|input_line_pointer
operator|=
name|gotfree_input_line
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
block|{
comment|/* expression () has merrily parsed up to the end of line, 	     or a comma - in the wrong buffer.  Transfer how far 	     input_line_pointer has moved to the right buffer.  */
name|input_line_pointer
operator|=
operator|(
name|save
operator|+
operator|(
name|input_line_pointer
operator|-
name|gotfree_input_line
operator|)
operator|+
name|adjust
operator|)
expr_stmt|;
name|free
argument_list|(
name|gotfree_input_line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|i386_immediate
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_immediate
parameter_list|(
name|imm_start
parameter_list|)
name|char
modifier|*
name|imm_start
decl_stmt|;
block|{
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
name|char
modifier|*
name|gotfree_input_line
decl_stmt|;
endif|#
directive|endif
name|segT
name|exp_seg
init|=
literal|0
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|imm_operands
operator|==
name|MAX_IMMEDIATE_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"only 1 or 2 immediate operands are allowed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|exp
operator|=
operator|&
name|im_expressions
index|[
name|i
operator|.
name|imm_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
name|exp
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|imm_start
argument_list|)
condition|)
operator|++
name|imm_start
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|imm_start
expr_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
name|gotfree_input_line
operator|=
name|lex_got
argument_list|(
operator|&
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
name|input_line_pointer
operator|=
name|gotfree_input_line
expr_stmt|;
endif|#
directive|endif
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk `%s' after expression"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
if|if
condition|(
name|gotfree_input_line
condition|)
name|free
argument_list|(
name|gotfree_input_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* Missing or bad expr becomes absolute 0.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing or invalid immediate expression `%s' taken as 0"
argument_list|)
argument_list|,
name|imm_start
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Size it properly later.  */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm64
expr_stmt|;
comment|/* If BFD64, sign extend val.  */
if|if
condition|(
operator|!
name|use_rela_relocations
condition|)
if|if
condition|(
operator|(
name|exp
operator|->
name|X_add_number
operator|&
operator|~
operator|(
operator|(
operator|(
name|addressT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|exp
operator|->
name|X_add_number
operator|=
operator|(
name|exp
operator|->
name|X_add_number
operator|^
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|-
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
elseif|else
if|if
condition|(
literal|1
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
operator|&&
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
endif|#
directive|endif
operator|&&
name|exp_seg
operator|!=
name|text_section
operator|&&
name|exp_seg
operator|!=
name|data_section
operator|&&
name|exp_seg
operator|!=
name|bss_section
operator|&&
name|exp_seg
operator|!=
name|undefined_section
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|exp_seg
argument_list|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment %s in operand"
argument_list|)
argument_list|,
name|exp_seg
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment type %d in operand"
argument_list|)
argument_list|,
name|exp_seg
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
endif|#
directive|endif
else|else
block|{
comment|/* This is an address.  The size of the address will be 	 determined later, depending on destination register, 	 suffix, or the default for the section.  */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|i386_scale
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|i386_scale
parameter_list|(
name|scale
parameter_list|)
name|char
modifier|*
name|scale
decl_stmt|;
block|{
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
name|scale
expr_stmt|;
name|val
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting scale factor of 1, 2, 4, or 8: got `%s'"
argument_list|)
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|i
operator|.
name|log2_scale_factor
operator|!=
literal|0
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"scale factor of %d without an index register"
argument_list|)
argument_list|,
literal|1
operator|<<
name|i
operator|.
name|log2_scale_factor
argument_list|)
expr_stmt|;
if|#
directive|if
name|SCALE1_WHEN_NO_INDEX
name|i
operator|.
name|log2_scale_factor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|scale
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|scale
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|i386_displacement
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_displacement
parameter_list|(
name|disp_start
parameter_list|,
name|disp_end
parameter_list|)
name|char
modifier|*
name|disp_start
decl_stmt|;
name|char
modifier|*
name|disp_end
decl_stmt|;
block|{
specifier|register
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|segT
name|exp_seg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
name|char
modifier|*
name|gotfree_input_line
decl_stmt|;
endif|#
directive|endif
name|int
name|bigdisp
init|=
name|Disp32
decl_stmt|;
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
condition|)
name|bigdisp
operator|=
name|Disp64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
name|bigdisp
operator|=
name|Disp16
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|bigdisp
expr_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|disp_operands
operator|++
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|disp_start
expr_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|disp_end
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|GCC_ASM_O_HACK
define|#
directive|define
name|GCC_ASM_O_HACK
value|0
endif|#
directive|endif
if|#
directive|if
name|GCC_ASM_O_HACK
name|END_STRING_AND_SAVE
argument_list|(
name|disp_end
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|BaseIndex
operator|)
operator|!=
literal|0
operator|&&
name|displacement_string_end
index|[
operator|-
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
comment|/* This hack is to avoid a warning when using the "o" 	 constraint within gcc asm statements. 	 For instance:  	 #define _set_tssldt_desc(n,addr,limit,type) \ 	 __asm__ __volatile__ ( \ 	 "movw %w2,%0\n\t" \ 	 "movw %w1,2+%0\n\t" \ 	 "rorl $16,%1\n\t" \ 	 "movb %b1,4+%0\n\t" \ 	 "movb %4,5+%0\n\t" \ 	 "movb $0,6+%0\n\t" \ 	 "movb %h1,7+%0\n\t" \ 	 "rorl $16,%1" \ 	 : "=o"(*(n)) : "q" (addr), "ri"(limit), "i"(type))  	 This works great except that the output assembler ends 	 up looking a bit weird if it turns out that there is 	 no offset.  You end up producing code that looks like:  	 #APP 	 movw $235,(%eax) 	 movw %dx,2+(%eax) 	 rorl $16,%edx 	 movb %dl,4+(%eax) 	 movb $137,5+(%eax) 	 movb $0,6+(%eax) 	 movb %dh,7+(%eax) 	 rorl $16,%edx 	 #NO_APP  	 So here we provide the missing zero.  */
operator|*
name|displacement_string_end
operator|=
literal|'0'
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|LEX_AT
name|gotfree_input_line
operator|=
name|lex_got
argument_list|(
operator|&
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
name|input_line_pointer
operator|=
name|gotfree_input_line
expr_stmt|;
endif|#
directive|endif
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk `%s' after expression"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
if|#
directive|if
name|GCC_ASM_O_HACK
name|RESTORE_END_STRING
argument_list|(
name|disp_end
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RESTORE_END_STRING
argument_list|(
name|disp_end
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
if|if
condition|(
name|gotfree_input_line
condition|)
name|free
argument_list|(
name|gotfree_input_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* We do this to make sure that the section symbol is in      the symbol table.  We will ultimately change the relocation      to be relative to the beginning of the section.  */
if|if
condition|(
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_386_GOTOFF
operator|||
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_X86_64_GOTPCREL
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad expression used with @%s"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_X86_64_GOTPCREL
condition|?
literal|"GOTPCREL"
else|:
literal|"GOTOFF"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|S_IS_LOCAL
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|undefined_section
condition|)
name|section_symbol
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
name|GOT_symbol
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_X86_64_GOTPCREL
condition|)
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
else|else
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_32
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* Missing or bad expr becomes absolute 0.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing or invalid displacement expression `%s' taken as 0"
argument_list|)
argument_list|,
name|disp_start
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
operator|&&
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
endif|#
directive|endif
operator|&&
name|exp_seg
operator|!=
name|text_section
operator|&&
name|exp_seg
operator|!=
name|data_section
operator|&&
name|exp_seg
operator|!=
name|bss_section
operator|&&
name|exp_seg
operator|!=
name|undefined_section
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment %s in operand"
argument_list|)
argument_list|,
name|exp_seg
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment type %d in operand"
argument_list|)
argument_list|,
name|exp_seg
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Disp32S
operator||
name|Disp32
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|i386_index_check
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make sure the memory operand we've been dealt is valid.    Return 1 on success, 0 on a failure.  */
end_comment

begin_function
specifier|static
name|int
name|i386_index_check
parameter_list|(
name|operand_string
parameter_list|)
specifier|const
name|char
modifier|*
name|operand_string
decl_stmt|;
block|{
name|int
name|ok
decl_stmt|;
if|#
directive|if
name|INFER_ADDR_PREFIX
name|int
name|fudged
init|=
literal|0
decl_stmt|;
name|tryprefix
label|:
endif|#
directive|endif
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 64bit checks.  */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg64
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|!=
name|BaseIndex
operator|||
name|i
operator|.
name|index_reg
operator|)
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg64
operator||
name|BaseIndex
operator|)
operator|)
operator|!=
operator|(
name|Reg64
operator||
name|BaseIndex
operator|)
operator|)
operator|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 32bit checks.  */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg32
operator||
name|RegRex
operator|)
operator|)
operator|!=
name|Reg32
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg32
operator||
name|BaseIndex
operator||
name|RegRex
operator|)
operator|)
operator|!=
operator|(
name|Reg32
operator||
name|BaseIndex
operator|)
operator|)
operator|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 16bit checks.  */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg16
operator||
name|BaseIndex
operator||
name|RegRex
operator|)
operator|)
operator|!=
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
operator|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|!=
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|||
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|<
literal|6
operator|&&
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|>=
literal|6
operator|&&
name|i
operator|.
name|log2_scale_factor
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 32bit checks.  */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg32
operator||
name|RegRex
operator|)
operator|)
operator|!=
name|Reg32
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg32
operator||
name|BaseIndex
operator||
name|RegRex
operator|)
operator|)
operator|!=
operator|(
name|Reg32
operator||
name|BaseIndex
operator|)
operator|)
operator|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|#
directive|if
name|INFER_ADDR_PREFIX
if|if
condition|(
name|flag_code
operator|!=
name|CODE_64BIT
operator|&&
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|==
literal|0
operator|&&
name|stackop_size
operator|!=
literal|'\0'
condition|)
block|{
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|=
name|ADDR_PREFIX_OPCODE
expr_stmt|;
name|i
operator|.
name|prefixes
operator|+=
literal|1
expr_stmt|;
comment|/* Change the size of any displacement too.  At most one of 	     Disp16 or Disp32 is set. 	     FIXME.  There doesn't seem to be any real need for separate 	     Disp16 and Disp32 flags.  The same goes for Imm16 and Imm32. 	     Removing them would probably clean up the code quite a lot.  */
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
operator|(
name|Disp16
operator||
name|Disp32
operator|)
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|^=
operator|(
name|Disp16
operator||
name|Disp32
operator|)
expr_stmt|;
name|fudged
operator|=
literal|1
expr_stmt|;
goto|goto
name|tryprefix
goto|;
block|}
if|if
condition|(
name|fudged
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is not a valid base/index expression"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is not a valid %s bit base/index expression"
argument_list|)
argument_list|,
name|operand_string
argument_list|,
name|flag_code_names
index|[
name|flag_code
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero    on error.  */
end_comment

begin_function
specifier|static
name|int
name|i386_operand
parameter_list|(
name|operand_string
parameter_list|)
name|char
modifier|*
name|operand_string
decl_stmt|;
block|{
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|end_op
decl_stmt|;
name|char
modifier|*
name|op_string
init|=
name|operand_string
decl_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
comment|/* We check for an absolute prefix (differentiating,      for example, 'jmp pc_relative_label' from 'jmp *absolute_label'.  */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
comment|/* Check if operand is a register.  */
if|if
condition|(
operator|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
operator|(
name|r
operator|=
name|parse_register
argument_list|(
name|op_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Check for a segment override by searching for ':' after a 	 segment register.  */
name|op_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
operator|*
name|op_string
operator|==
literal|':'
operator|&&
operator|(
name|r
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|reg_num
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|gs
expr_stmt|;
break|break;
block|}
comment|/* Skip the ':' and whitespace.  */
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
operator|!
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|!
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|*
name|op_string
operator|!=
literal|'('
operator|&&
operator|*
name|op_string
operator|!=
name|ABSOLUTE_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad memory operand `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Handle case of %es:*foo.  */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
goto|goto
name|do_memory_reference
goto|;
block|}
if|if
condition|(
operator|*
name|op_string
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk `%s' after register"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|r
operator|->
name|reg_type
operator|&
operator|~
name|BaseIndex
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|regs
operator|=
name|r
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|IMMEDIATE_PREFIX
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|JumpAbsolute
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate operand illegal with absolute jump"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|i386_immediate
argument_list|(
name|op_string
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
operator|*
name|op_string
operator|==
literal|'('
condition|)
block|{
comment|/* This is a memory reference of some sort.  */
name|char
modifier|*
name|base_string
decl_stmt|;
comment|/* Start and end of displacement string expression (if found).  */
name|char
modifier|*
name|displacement_string_start
decl_stmt|;
name|char
modifier|*
name|displacement_string_end
decl_stmt|;
name|do_memory_reference
label|:
if|if
condition|(
operator|(
name|i
operator|.
name|mem_operands
operator|==
literal|1
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|==
literal|0
operator|)
operator|||
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many memory references for `%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for base index form.  We detect the base index form by 	 looking for an ')' at the end of the operand, searching 	 for the '(' matching it, and finding a REGISTER_PREFIX or ',' 	 after the '('.  */
name|base_string
operator|=
name|op_string
operator|+
name|strlen
argument_list|(
name|op_string
argument_list|)
expr_stmt|;
operator|--
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|--
name|base_string
expr_stmt|;
comment|/* If we only have a displacement, set-up for it to be parsed later.  */
name|displacement_string_start
operator|=
name|op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|base_string
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
block|{
name|char
modifier|*
name|temp_string
decl_stmt|;
name|unsigned
name|int
name|parens_balanced
init|=
literal|1
decl_stmt|;
comment|/* We've already checked that the number of left& right ()'s are 	     equal, so this loop will not be infinite.  */
do|do
block|{
name|base_string
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
name|parens_balanced
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|'('
condition|)
name|parens_balanced
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|parens_balanced
condition|)
do|;
name|temp_string
operator|=
name|base_string
expr_stmt|;
comment|/* Skip past '(' and whitespace.  */
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
operator|||
operator|(
operator|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|=
name|parse_register
argument_list|(
name|base_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|displacement_string_end
operator|=
name|temp_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
condition|)
block|{
name|base_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
block|}
comment|/* There may be an index reg or scale factor here.  */
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
condition|)
block|{
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
operator|(
name|i
operator|.
name|index_reg
operator|=
name|parse_register
argument_list|(
name|base_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|base_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
condition|)
block|{
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting `,' or `)' after index register in `%s'"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|base_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for scale factor.  */
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|char
modifier|*
name|end_scale
init|=
name|i386_scale
argument_list|(
name|base_string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|end_scale
condition|)
return|return
literal|0
return|;
name|base_string
operator|=
name|end_scale
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting `)' after scale factor in `%s'"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting index register or scale factor after `,'; got '%c'"
argument_list|)
argument_list|,
operator|*
name|base_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting `,' or `)' after base register in `%s'"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|base_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If there's an expression beginning the operand, parse it, 	 assuming displacement_string_start and 	 displacement_string_end are meaningful.  */
if|if
condition|(
name|displacement_string_start
operator|!=
name|displacement_string_end
condition|)
block|{
if|if
condition|(
operator|!
name|i386_displacement
argument_list|(
name|displacement_string_start
argument_list|,
name|displacement_string_end
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Special case for (%dx) while doing input/output op.  */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|==
operator|(
name|Reg16
operator||
name|InOutPortReg
operator|)
operator|&&
name|i
operator|.
name|index_reg
operator|==
literal|0
operator|&&
name|i
operator|.
name|log2_scale_factor
operator|==
literal|0
operator|&&
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|==
literal|0
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|Disp
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|InOutPortReg
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|i386_index_check
argument_list|(
name|operand_string
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* It's not a memory operand; argh!  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid char %s beginning operand %d `%s'"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|op_string
argument_list|)
argument_list|,
name|this_operand
operator|+
literal|1
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* Normal return.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* md_estimate_size_before_relax()     Called just before relax() for rs_machine_dependent frags.  The x86    assembler uses these frags to handle variable size jump    instructions.     Any symbol that is now undefined will not become defined.    Return the correct fr_subtype in the frag.    Return the initial "guess for variable size of frag" to caller.    The guess is actually the growth beyond the fixed part.  Whatever    we do to grow the fixed or variable part contributes to our    returned value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
block|{
comment|/* We've already got fragP->fr_subtype right;  all we have to do is      check for un-relaxable symbols.  On an ELF system, we can't relax      an externally visible symbol, because it may be overridden by a      shared library.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
endif|#
directive|endif
condition|)
block|{
comment|/* Symbol is undefined in this segment, or we need to keep a 	 reloc so that weak symbols can be overridden.  */
name|int
name|size
init|=
operator|(
name|fragP
operator|->
name|fr_subtype
operator|&
name|CODE16
operator|)
condition|?
literal|2
else|:
literal|4
decl_stmt|;
name|RELOC_ENUM
name|reloc_type
decl_stmt|;
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
name|int
name|old_fr_fix
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_var
operator|!=
name|NO_RELOC
condition|)
name|reloc_type
operator|=
name|fragP
operator|->
name|fr_var
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
else|else
name|reloc_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
switch|switch
condition|(
name|TYPE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
case|case
name|UNCOND_JUMP
case|:
comment|/* Make jmp (0xeb) a (d)word displacement jump.  */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|size
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
argument_list|,
name|size
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_JUMP86
case|:
if|if
condition|(
name|no_cond_jump_promotion
condition|)
goto|goto
name|relax_guess
goto|;
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
comment|/* Negate the condition, and branch past an 		 unconditional jump.  */
name|opcode
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
name|opcode
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* Insert an unconditional jump.  */
name|opcode
index|[
literal|2
index|]
operator|=
literal|0xe9
expr_stmt|;
comment|/* We added two extra opcode bytes, and have a two byte 		 offset.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
operator|+
literal|2
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|COND_JUMP
case|:
if|if
condition|(
name|no_cond_jump_promotion
condition|)
goto|goto
name|relax_guess
goto|;
comment|/* This changes the byte-displacement jump 0x7N 	     to the (d)word-displacement jump 0x0f,0x8N.  */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
comment|/* We've added an opcode byte.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
name|size
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
name|size
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
return|return
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
return|;
block|}
name|relax_guess
label|:
comment|/* Guess size depending on current relax state.  Initially the relax      state will correspond to a short jump and we return 1, because      the variable part of the frag (the branch offset) is one byte      long.  However, we can relax a section more than once and in that      case we must either set fr_subtype back to the unrelaxed state,      or return the value for the appropriate branch.  */
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_comment
comment|/* Called after relax() is finished.     In:	Address of frag. 	fr_type == rs_machine_dependent. 	fr_subtype is what the address relaxed to.     Out:	Any fixSs and constants are set up. 	Caller will turn frag into a ".space 0".  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
else|#
directive|else
function|void md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|char
modifier|*
name|where_to_put_displacement
init|=
name|NULL
decl_stmt|;
name|offsetT
name|target_address
decl_stmt|;
name|offsetT
name|opcode_address
decl_stmt|;
name|unsigned
name|int
name|extension
init|=
literal|0
decl_stmt|;
name|offsetT
name|displacement_from_opcode_start
decl_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* Address we want to reach in file space.  */
name|target_address
operator|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
comment|/* Address opcode resides at in file space.  */
name|opcode_address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* Displacement from opcode start to fill into instruction.  */
name|displacement_from_opcode_start
operator|=
name|target_address
operator|-
name|opcode_address
expr_stmt|;
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_subtype
operator|&
name|BIG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't have to change opcode.  */
name|extension
operator|=
literal|1
expr_stmt|;
comment|/* 1 opcode + 1 displacement  */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|no_cond_jump_promotion
operator|&&
name|TYPE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|!=
name|UNCOND_JUMP
condition|)
name|as_warn_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"long jump required"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BIG
argument_list|)
case|:
name|extension
operator|=
literal|4
expr_stmt|;
comment|/* 1 opcode + 4 displacement  */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BIG16
argument_list|)
case|:
name|extension
operator|=
literal|2
expr_stmt|;
comment|/* 1 opcode + 2 displacement  */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BIG
argument_list|)
case|:
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP86
argument_list|,
name|BIG
argument_list|)
case|:
name|extension
operator|=
literal|5
expr_stmt|;
comment|/* 2 opcode + 4 displacement  */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BIG16
argument_list|)
case|:
name|extension
operator|=
literal|3
expr_stmt|;
comment|/* 2 opcode + 2 displacement  */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP86
argument_list|,
name|BIG16
argument_list|)
case|:
name|extension
operator|=
literal|4
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
name|opcode
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|opcode
index|[
literal|2
index|]
operator|=
literal|0xe9
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|3
index|]
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now put displacement after opcode.  */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|where_to_put_displacement
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|displacement_from_opcode_start
operator|-
name|extension
argument_list|)
argument_list|,
name|DISP_SIZE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Size of byte displacement jmp.  */
end_comment

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of dword displacement jmp.  */
end_comment

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|offsetT
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* Opcode for byte-disp jump.  */
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xeb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|offsetT
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|5
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Apply a fixup (fixS) to segment data, once it has been determined    by our caller that we have all the info we need to fix it up.     On the 386, immediates, displacements, and data pointers are all in    the same (little-endian) format, so we don't need to care about which    we are handling.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
comment|/* The fix we're to put in.  */
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Pointer to the value of the bits.  */
name|valueT
modifier|*
name|valP
decl_stmt|;
comment|/* Segment fix is from.  */
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valP
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_Mach
argument_list|)
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
default|default:
break|break;
case|case
name|BFD_RELOC_32
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
block|}
block|}
comment|/* This is a hack.  There should be a better way to handle this.      This covers for the fact that bfd_install_relocation will      subtract the current location (for partial_inplace, PC relative      relocations); see more below.  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_8_PCREL
operator|)
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|!
name|use_rela_relocations
condition|)
block|{
ifndef|#
directive|ifndef
name|OBJ_AOUT
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
ifdef|#
directive|ifdef
name|TE_PE
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_coff_flavour
endif|#
directive|endif
condition|)
name|value
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|segT
name|fseg
init|=
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fseg
operator|==
name|seg
operator|||
operator|(
name|symbol_section_p
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|fseg
operator|!=
name|absolute_section
operator|)
operator|)
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* Yes, we add the values in twice.  This is because 		 bfd_perform_relocation subtracts them out again.  I think 		 bfd_perform_relocation is broken, but I don't dare change 		 it.  FIXME.  */
name|value
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|&&
name|defined
argument_list|(
name|TE_PE
argument_list|)
comment|/* For some reason, the PE format does not store a section 	 address offset for a PC relative symbol.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
condition|)
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Fix a few things - the dynamic linker expects certain values here,      and we must not dissappoint it.  */
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_386_PLT32
case|:
case|case
name|BFD_RELOC_X86_64_PLT32
case|:
comment|/* Make the jump instruction point to the address of the operand.  At 	   runtime we merely add the offset to the actual PLT entry.  */
name|value
operator|=
operator|-
literal|4
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_386_GOTPC
case|:
comment|/*   This is tough to explain.  We end up with this one if we have  * operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal  * here is to obtain the absolute address of the GOT, and it is strongly  * preferable from a performance point of view to avoid using a runtime  * relocation for this.  The actual sequence of instructions often look  * something like:  *  *	call	.L66  * .L66:  *	popl	%ebx  *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx  *  *   The call and pop essentially return the absolute address of  * the label .L66 and store it in %ebx.  The linker itself will  * ultimately change the first operand of the addl so that %ebx points to  * the GOT, but to keep things simple, the .o file must have this operand  * set so that it generates not the absolute address of .L66, but the  * absolute address of itself.  This allows the linker itself simply  * treat a GOTPC relocation as asking for a pcrel offset to the GOT to be  * added in, and the addend of the relocation is stored in the operand  * field for the instruction itself.  *  *   Our job here is to fix the operand so that it would add the correct  * offset so that %ebx would point to itself.  The thing that is tricky is  * that .-.L66 will point to the beginning of the instruction, so we need  * to further modify the operand so that it will point to itself.  * There are other cases where you have something like:  *  *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]  *  * and here no correction would be required.  Internally in the assembler  * we treat operands of this form as not being pcrel since the '.' is  * explicitly mentioned, and I wonder whether it would simplify matters  * to do it this way.  Who knows.  In earlier versions of the PIC patches,  * the pcrel_adjust field was used to store the correction, but since the  * expression is not pcrel, I felt it would be confusing to do it this  * way.  */
name|value
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_386_GOT32
case|:
case|case
name|BFD_RELOC_X86_64_GOT32
case|:
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Fully resolved at runtime.  No addend.  */
break|break;
case|case
name|BFD_RELOC_386_GOTOFF
case|:
case|case
name|BFD_RELOC_X86_64_GOTPCREL
case|:
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)  */
operator|*
name|valP
operator|=
name|value
expr_stmt|;
endif|#
directive|endif
comment|/* defined (BFD_ASSEMBLER)&& !defined (TE_Mach)  */
comment|/* Are we finished with this relocation now?  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
elseif|else
if|if
condition|(
name|use_rela_relocations
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn the string pointed to by litP into a floating point constant    of type TYPE, and emit the appropriate bytes.  The number of    LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof ()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loops outputs the LITTLENUMs in REVERSE order; in accord with      the bigendian 386.  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|char
name|output_invalid_buf
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|output_invalid
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"(0x%x)"
argument_list|,
operator|(
name|unsigned
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
name|output_invalid_buf
return|;
block|}
end_function

begin_comment
comment|/* REG_STRING starts *before* REGISTER_PREFIX.  */
end_comment

begin_function
specifier|static
specifier|const
name|reg_entry
modifier|*
name|parse_register
parameter_list|(
name|reg_string
parameter_list|,
name|end_op
parameter_list|)
name|char
modifier|*
name|reg_string
decl_stmt|;
name|char
modifier|*
modifier|*
name|end_op
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|reg_string
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|reg_name_given
index|[
name|MAX_REG_NAME_SIZE
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
comment|/* Skip possible REGISTER_PREFIX and possible whitespace.  */
if|if
condition|(
operator|*
name|s
operator|==
name|REGISTER_PREFIX
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|p
operator|=
name|reg_name_given
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|register_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|reg_name_given
operator|+
name|MAX_REG_NAME_SIZE
condition|)
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
name|s
operator|++
expr_stmt|;
block|}
comment|/* For naked regs, make sure that we are not dealing with an identifier.      This prevents confusing an identifier like `eax_var' with register      `eax'.  */
if|if
condition|(
name|allow_naked_reg
operator|&&
name|identifier_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
condition|)
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
operator|*
name|end_op
operator|=
name|s
expr_stmt|;
name|r
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name_given
argument_list|)
expr_stmt|;
comment|/* Handle floating point regs, allowing spaces in the (i) part.  */
if|if
condition|(
name|r
operator|==
name|i386_regtab
comment|/* %st is first entry of table  */
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
condition|)
block|{
name|r
operator|=
operator|&
name|i386_float_regtab
index|[
operator|*
name|s
operator|-
literal|'0'
index|]
expr_stmt|;
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
block|{
operator|*
name|end_op
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
comment|/* We have "%st(" then garbage.  */
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|reg_flags
operator|&
operator|(
name|RegRex64
operator||
name|RegRex
operator|)
operator|&&
name|flag_code
operator|!=
name|CODE_64BIT
condition|)
block|{
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"kVQ:sq"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"q"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_32
value|(OPTION_MD_BASE + 0)
block|{
literal|"32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_32
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
define|#
directive|define
name|OPTION_64
value|(OPTION_MD_BASE + 1)
block|{
literal|"64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_64
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'q'
case|:
name|quiet_warnings
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section 	 should be emitted or not.  FIXME: Not implemented.  */
case|case
literal|'Q'
case|:
break|break;
comment|/* -V: SVR4 argument to print version ID.  */
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
comment|/* -k: Ignore for FreeBSD compatibility.  */
case|case
literal|'k'
case|:
break|break;
case|case
literal|'s'
case|:
comment|/* -s: On i386 Solaris, this tells the native assembler to use          .stab instead of .stab.excl.  We always use .stab anyhow.  */
break|break;
case|case
name|OPTION_64
case|:
block|{
specifier|const
name|char
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
modifier|*
name|l
decl_stmt|;
name|list
operator|=
name|bfd_target_list
argument_list|()
expr_stmt|;
for|for
control|(
name|l
operator|=
name|list
init|;
operator|*
name|l
operator|!=
name|NULL
condition|;
name|l
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-x86-64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|default_arch
operator|=
literal|"x86_64"
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|l
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"No compiled in support for x86_64"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|OPTION_32
case|:
name|default_arch
operator|=
literal|"i386"
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -Q                      ignored\n\   -V                      print assembler version number\n\   -k                      ignored\n\   -q                      quieten some warnings\n\   -s                      ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -q                      quieten some warnings\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_if
if|#
directive|if
operator|(
operator|(
name|defined
argument_list|(
name|OBJ_MAYBE_COFF
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
expr|\
operator|||
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
end_if

begin_comment
comment|/* Pick the target format to use.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_target_format
parameter_list|()
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"x86_64"
argument_list|)
condition|)
name|set_code_flag
argument_list|(
name|CODE_64BIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"i386"
argument_list|)
condition|)
name|set_code_flag
argument_list|(
name|CODE_32BIT
argument_list|)
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown architecture"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OUTPUT_FLAVOR
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_MAYBE_AOUT
case|case
name|bfd_target_aout_flavour
case|:
return|return
name|AOUT_TARGET_FORMAT
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_MAYBE_COFF
case|case
name|bfd_target_coff_flavour
case|:
return|return
literal|"coff-i386"
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
case|case
name|bfd_target_elf_flavour
case|:
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|use_rela_relocations
operator|=
literal|1
expr_stmt|;
return|return
name|flag_code
operator|==
name|CODE_64BIT
condition|?
literal|"elf64-x86-64"
else|:
literal|"elf32-i386"
return|;
block|}
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_MAYBE_ more than one  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
end_if

begin_function
name|void
name|i386_elf_emit_arch_note
parameter_list|()
block|{
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
name|cpu_arch_name
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|subseg
init|=
name|now_subseg
decl_stmt|;
name|Elf_Internal_Note
name|i_note
decl_stmt|;
name|Elf_External_Note
name|e_note
decl_stmt|;
name|asection
modifier|*
name|note_secp
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Create the .note section.  */
name|note_secp
operator|=
name|subseg_new
argument_list|(
literal|".note"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|note_secp
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
comment|/* Process the arch string.  */
name|len
operator|=
name|strlen
argument_list|(
name|cpu_arch_name
argument_list|)
expr_stmt|;
name|i_note
operator|.
name|namesz
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|i_note
operator|.
name|descsz
operator|=
literal|0
expr_stmt|;
name|i_note
operator|.
name|type
operator|=
name|NT_ARCH
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|namesz
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|namesz
argument_list|,
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|namesz
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|descsz
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|descsz
argument_list|,
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|descsz
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|cpu_arch_name
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER  */
end_comment

begin_escape
end_escape

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|GLOBAL_OFFSET_TABLE_NAME
index|[
literal|0
index|]
operator|&&
name|name
index|[
literal|1
index|]
operator|==
name|GLOBAL_OFFSET_TABLE_NAME
index|[
literal|1
index|]
operator|&&
name|name
index|[
literal|2
index|]
operator|==
name|GLOBAL_OFFSET_TABLE_NAME
index|[
literal|2
index|]
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|name
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"GOT already in symbol table"
argument_list|)
argument_list|)
expr_stmt|;
name|GOT_symbol
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
name|GOT_symbol
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
condition|)
block|{
comment|/* For a.out, force the section size to be aligned.  If we don't do 	 this, BFD will align it for us, but it will not write out the 	 final bytes of the section.  This may be a bug in BFD, but it is 	 easier to fix it here since that is how the other a.out targets 	 work.  */
name|int
name|align
decl_stmt|;
name|align
operator|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|(
name|valueT
operator|)
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* On the i386, PC-relative offsets are relative to the start of the    next instruction.  That is, the address of the offset, plus its    size, since the offset is always the last part of the insn.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|I386COFF
end_ifndef

begin_function
specifier|static
name|void
name|s_bss
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|void
name|i386_validate_fix
parameter_list|(
name|fixp
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|&&
name|fixp
operator|->
name|fx_subsy
operator|==
name|GOT_symbol
condition|)
block|{
comment|/* GOTOFF relocation are nonsense in 64bit mode.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL
condition|)
block|{
if|if
condition|(
name|flag_code
operator|!=
name|CODE_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_X86_64_GOTPCREL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_386_GOTOFF
expr_stmt|;
block|}
name|fixp
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_X86_64_PLT32
case|:
case|case
name|BFD_RELOC_X86_64_GOT32
case|:
case|case
name|BFD_RELOC_X86_64_GOTPCREL
case|:
case|case
name|BFD_RELOC_386_PLT32
case|:
case|case
name|BFD_RELOC_386_GOT32
case|:
case|case
name|BFD_RELOC_386_GOTOFF
case|:
case|case
name|BFD_RELOC_386_GOTPC
case|:
case|case
name|BFD_RELOC_X86_64_32S
case|:
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_size
condition|)
block|{
default|default:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can not do %d byte pc-relative relocation"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_size
condition|)
block|{
default|default:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can not do %d byte relocation"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|code
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_32
operator|&&
name|GOT_symbol
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|GOT_symbol
condition|)
block|{
comment|/* We don't support GOTPC on 64bit targets.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_386_GOTPC
expr_stmt|;
block|}
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
operator|!
name|use_rela_relocations
condition|)
block|{
comment|/* HACK: Since i386 ELF uses Rel instead of Rela, encode the 	 vtable entry to be used in the relocation's section offset.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Use the rela in 64bit mode.  */
else|else
block|{
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|rel
operator|->
name|addend
operator|-=
name|fixp
operator|->
name|fx_size
expr_stmt|;
block|}
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent relocation type %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! BFD_ASSEMBLER  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
operator|)
end_if

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
comment|/* In:  length of relocation (or of address) in chars: 1, 2 or 4.      Out: GNU LD relocation length code: 0, 1, or 2.  */
specifier|static
specifier|const
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|long
name|r_symbolnum
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT or OBJ_BOUT.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I386COFF
argument_list|)
end_if

begin_function
name|short
name|tc_coff_fix2rtype
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|R_IMAGEBASE
condition|)
return|return
name|R_IMAGEBASE
return|;
return|return
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_PCRBYTE
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_PCRWORD
else|:
name|R_PCRLONG
operator|)
else|:
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_RELBYTE
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_RELWORD
else|:
name|R_DIR32
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tc_coff_sizemachdep
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
if|if
condition|(
name|frag
operator|->
name|fr_next
condition|)
return|return
operator|(
name|frag
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|frag
operator|->
name|fr_address
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I386COFF  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! BFD_ASSEMBLER  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Parse operands using Intel syntax. This implements a recursive descent    parser based on the BNF grammar published in Appendix B of the MASM 6.1    Programmer's Guide.     FIXME: We do not recognize the full operand grammar defined in the MASM 	  documentation.  In particular, all the structure/union and 	  high-level macro operands are missing.     Uppercase words are terminals, lower case words are non-terminals.    Objects surrounded by double brackets '[[' ']]' are optional. Vertical    bars '|' denote choices. Most grammar productions are implemented in    functions called 'intel_<production>'.     Initial production is 'expr'.      addOp		+ | -      alpha		[a-zA-Z]      byteRegister	AL | AH | BL | BH | CL | CH | DL | DH      constant		digits [[ radixOverride ]]      dataType		BYTE | WORD | DWORD | QWORD | XWORD      digits		decdigit 			| digits decdigit 			| digits hexdigit      decdigit		[0-9]      e05			e05 addOp e06 			| e06      e06			e06 mulOp e09 			| e09      e09			OFFSET e10 			| e09 PTR e10 			| e09 : e10 			| e10      e10			e10 [ expr ] 			| e11      e11			( expr ) 			| [ expr ] 			| constant 			| dataType 			| id 			| $ 			| register   => expr		SHORT e05 			| e05      gpRegister		AX | EAX | BX | EBX | CX | ECX | DX | EDX 			| BP | EBP | SP | ESP | DI | EDI | SI | ESI      hexdigit		a | b | c | d | e | f 			| A | B | C | D | E | F      id			alpha 			| id alpha 			| id decdigit      mulOp		* | / | MOD      quote		" | '      register		specialRegister 			| gpRegister 			| byteRegister      segmentRegister	CS | DS | ES | FS | GS | SS      specialRegister	CR0 | CR2 | CR3 			| DR0 | DR1 | DR2 | DR3 | DR6 | DR7 			| TR3 | TR4 | TR5 | TR6 | TR7      We simplify the grammar in obvious places (e.g., register parsing is     done by calling parse_register) and eliminate immediate left recursion     to implement a recursive-descent parser.      expr	SHORT e05 		| e05      e05		e06 e05'      e05'	addOp e06 e05' 		| Empty      e06		e09 e06'      e06'	mulOp e09 e06' 		| Empty      e09		OFFSET e10 e09' 		| e10 e09'      e09'	PTR e10 e09' 		| : e10 e09' 		| Empty      e10		e11 e10'      e10'	[ expr ] e10' 		| Empty      e11		( expr ) 		| [ expr ] 		| BYTE 		| WORD 		| DWORD 		| QWORD 		| XWORD 		| . 		| $ 		| register 		| id 		| constant  */
end_comment

begin_comment
comment|/* Parsing structure for the intel syntax parser. Used to implement the    semantic actions for the operand grammar.  */
end_comment

begin_struct
struct|struct
name|intel_parser_s
block|{
name|char
modifier|*
name|op_string
decl_stmt|;
comment|/* The string being parsed.  */
name|int
name|got_a_float
decl_stmt|;
comment|/* Whether the operand is a float.  */
name|int
name|op_modifier
decl_stmt|;
comment|/* Operand modifier.  */
name|int
name|is_mem
decl_stmt|;
comment|/* 1 if operand is memory reference.  */
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
comment|/* Last register reference found.  */
name|char
modifier|*
name|disp
decl_stmt|;
comment|/* Displacement string being built.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|intel_parser_s
name|intel_parser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Token structure for parsing intel syntax.  */
end_comment

begin_struct
struct|struct
name|intel_token
block|{
name|int
name|code
decl_stmt|;
comment|/* Token code.  */
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
comment|/* Register entry for register tokens.  */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* String representation.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|intel_token
name|cur_token
decl_stmt|,
name|prev_token
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Token codes for the intel parser. Since T_SHORT is already used    by COFF, undefine it first to prevent a warning.  */
end_comment

begin_define
define|#
directive|define
name|T_NIL
value|-1
end_define

begin_define
define|#
directive|define
name|T_CONST
value|1
end_define

begin_define
define|#
directive|define
name|T_REG
value|2
end_define

begin_define
define|#
directive|define
name|T_BYTE
value|3
end_define

begin_define
define|#
directive|define
name|T_WORD
value|4
end_define

begin_define
define|#
directive|define
name|T_DWORD
value|5
end_define

begin_define
define|#
directive|define
name|T_QWORD
value|6
end_define

begin_define
define|#
directive|define
name|T_XWORD
value|7
end_define

begin_undef
undef|#
directive|undef
name|T_SHORT
end_undef

begin_define
define|#
directive|define
name|T_SHORT
value|8
end_define

begin_define
define|#
directive|define
name|T_OFFSET
value|9
end_define

begin_define
define|#
directive|define
name|T_PTR
value|10
end_define

begin_define
define|#
directive|define
name|T_ID
value|11
end_define

begin_comment
comment|/* Prototypes for intel parser functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|intel_match_token
name|PARAMS
argument_list|(
operator|(
name|int
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|intel_get_token
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|intel_putback_token
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_expr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_e05
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_e05_1
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_e06
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_e06_1
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_e09
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_e09_1
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_e10
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_e10_1
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intel_e11
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_intel_operand
parameter_list|(
name|operand_string
parameter_list|,
name|got_a_float
parameter_list|)
name|char
modifier|*
name|operand_string
decl_stmt|;
name|int
name|got_a_float
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Initialize token holders.  */
name|cur_token
operator|.
name|code
operator|=
name|prev_token
operator|.
name|code
operator|=
name|T_NIL
expr_stmt|;
name|cur_token
operator|.
name|reg
operator|=
name|prev_token
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|cur_token
operator|.
name|str
operator|=
name|prev_token
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize parser structure.  */
name|p
operator|=
name|intel_parser
operator|.
name|op_string
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|operand_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|intel_parser
operator|.
name|op_string
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
name|intel_parser
operator|.
name|got_a_float
operator|=
name|got_a_float
expr_stmt|;
name|intel_parser
operator|.
name|op_modifier
operator|=
operator|-
literal|1
expr_stmt|;
name|intel_parser
operator|.
name|is_mem
operator|=
literal|0
expr_stmt|;
name|intel_parser
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|intel_parser
operator|.
name|disp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|operand_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_parser
operator|.
name|disp
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|intel_parser
operator|.
name|disp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Read the first token and start the parser.  */
name|intel_get_token
argument_list|()
expr_stmt|;
name|ret
operator|=
name|intel_expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* If we found a memory reference, hand it over to i386_displacement 	 to fill in the rest of the operand fields.  */
if|if
condition|(
name|intel_parser
operator|.
name|is_mem
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|.
name|mem_operands
operator|==
literal|1
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|==
literal|0
operator|)
operator|||
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many memory references for '%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|s
init|=
name|intel_parser
operator|.
name|disp
decl_stmt|;
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
comment|/* Add the displacement expression.  */
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|ret
operator|=
name|i386_displacement
argument_list|(
name|s
argument_list|,
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
operator|&&
name|i386_index_check
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Constant and OFFSET expressions are handled by i386_immediate.  */
elseif|else
if|if
condition|(
name|intel_parser
operator|.
name|op_modifier
operator|==
name|OFFSET_FLAT
operator|||
name|intel_parser
operator|.
name|reg
operator|==
name|NULL
condition|)
name|ret
operator|=
name|i386_immediate
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* expr	SHORT e05 	| e05  */
end_comment

begin_function
specifier|static
name|int
name|intel_expr
parameter_list|()
block|{
comment|/* expr  SHORT e05  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_SHORT
condition|)
block|{
name|intel_parser
operator|.
name|op_modifier
operator|=
name|SHORT
expr_stmt|;
name|intel_match_token
argument_list|(
name|T_SHORT
argument_list|)
expr_stmt|;
return|return
operator|(
name|intel_e05
argument_list|()
operator|)
return|;
block|}
comment|/* expr  e05  */
else|else
return|return
name|intel_e05
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* e05	e06 e05'     e05'	addOp e06 e05' 	| Empty  */
end_comment

begin_function
specifier|static
name|int
name|intel_e05
parameter_list|()
block|{
return|return
operator|(
name|intel_e06
argument_list|()
operator|&&
name|intel_e05_1
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_e05_1
parameter_list|()
block|{
comment|/* e05'  addOp e06 e05'  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'+'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'-'
condition|)
block|{
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|intel_e06
argument_list|()
operator|&&
name|intel_e05_1
argument_list|()
operator|)
return|;
block|}
comment|/* e05'  Empty  */
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* e06	e09 e06'     e06'	mulOp e09 e06' 	| Empty  */
end_comment

begin_function
specifier|static
name|int
name|intel_e06
parameter_list|()
block|{
return|return
operator|(
name|intel_e09
argument_list|()
operator|&&
name|intel_e06_1
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_e06_1
parameter_list|()
block|{
comment|/* e06'  mulOp e09 e06'  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'*'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'/'
condition|)
block|{
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|intel_e09
argument_list|()
operator|&&
name|intel_e06_1
argument_list|()
operator|)
return|;
block|}
comment|/* e06'  Empty  */
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* e09	OFFSET e10 e09' 	| e10 e09'     e09'	PTR e10 e09' 	| : e10 e09' 	| Empty */
end_comment

begin_function
specifier|static
name|int
name|intel_e09
parameter_list|()
block|{
comment|/* e09  OFFSET e10 e09'  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_OFFSET
condition|)
block|{
name|intel_parser
operator|.
name|is_mem
operator|=
literal|0
expr_stmt|;
name|intel_parser
operator|.
name|op_modifier
operator|=
name|OFFSET_FLAT
expr_stmt|;
name|intel_match_token
argument_list|(
name|T_OFFSET
argument_list|)
expr_stmt|;
return|return
operator|(
name|intel_e10
argument_list|()
operator|&&
name|intel_e09_1
argument_list|()
operator|)
return|;
block|}
comment|/* e09  e10 e09'  */
else|else
return|return
operator|(
name|intel_e10
argument_list|()
operator|&&
name|intel_e09_1
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_e09_1
parameter_list|()
block|{
comment|/* e09'  PTR e10 e09' */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_PTR
condition|)
block|{
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_BYTE
condition|)
name|i
operator|.
name|suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_WORD
condition|)
block|{
if|if
condition|(
name|intel_parser
operator|.
name|got_a_float
operator|==
literal|2
condition|)
comment|/* "fi..." */
name|i
operator|.
name|suffix
operator|=
name|SHORT_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_DWORD
condition|)
block|{
if|if
condition|(
name|intel_parser
operator|.
name|got_a_float
operator|==
literal|1
condition|)
comment|/* "f..." */
name|i
operator|.
name|suffix
operator|=
name|SHORT_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_QWORD
condition|)
block|{
if|if
condition|(
name|intel_parser
operator|.
name|got_a_float
operator|==
literal|1
condition|)
comment|/* "f..." */
name|i
operator|.
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|QWORD_MNEM_SUFFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_XWORD
condition|)
name|i
operator|.
name|suffix
operator|=
name|LONG_DOUBLE_MNEM_SUFFIX
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown operand modifier `%s'\n"
argument_list|)
argument_list|,
name|prev_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|intel_match_token
argument_list|(
name|T_PTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|intel_e10
argument_list|()
operator|&&
name|intel_e09_1
argument_list|()
operator|)
return|;
block|}
comment|/* e09  : e10 e09'  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|':'
condition|)
block|{
comment|/* Mark as a memory operand only if it's not already known to be an 	 offset expression.  */
if|if
condition|(
name|intel_parser
operator|.
name|op_modifier
operator|!=
name|OFFSET_FLAT
condition|)
name|intel_parser
operator|.
name|is_mem
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|intel_match_token
argument_list|(
literal|':'
argument_list|)
operator|&&
name|intel_e10
argument_list|()
operator|&&
name|intel_e09_1
argument_list|()
operator|)
return|;
block|}
comment|/* e09'  Empty  */
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* e10	e11 e10'     e10'	[ expr ] e10' 	| Empty  */
end_comment

begin_function
specifier|static
name|int
name|intel_e10
parameter_list|()
block|{
return|return
operator|(
name|intel_e11
argument_list|()
operator|&&
name|intel_e10_1
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_e10_1
parameter_list|()
block|{
comment|/* e10'  [ expr ]  e10'  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'['
condition|)
block|{
name|intel_match_token
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
comment|/* Mark as a memory operand only if it's not already known to be an 	 offset expression.  If it's an offset expression, we need to keep 	 the brace in.  */
if|if
condition|(
name|intel_parser
operator|.
name|op_modifier
operator|!=
name|OFFSET_FLAT
condition|)
name|intel_parser
operator|.
name|is_mem
operator|=
literal|1
expr_stmt|;
else|else
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
comment|/* Add a '+' to the displacement string if necessary.  */
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|disp
operator|!=
literal|'\0'
operator|&&
operator|*
operator|(
name|intel_parser
operator|.
name|disp
operator|+
name|strlen
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|)
operator|-
literal|1
operator|)
operator|!=
literal|'+'
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_expr
argument_list|()
operator|&&
name|intel_match_token
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
comment|/* Preserve brackets when the operand is an offset expression.  */
if|if
condition|(
name|intel_parser
operator|.
name|op_modifier
operator|==
name|OFFSET_FLAT
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|intel_e10_1
argument_list|()
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* e10'  Empty  */
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* e11	( expr ) 	| [ expr ] 	| BYTE 	| WORD 	| DWORD 	| QWORD 	| XWORD 	| $ 	| . 	| register 	| id 	| constant  */
end_comment

begin_function
specifier|static
name|int
name|intel_e11
parameter_list|()
block|{
comment|/* e11  ( expr ) */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'('
condition|)
block|{
name|intel_match_token
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_expr
argument_list|()
operator|&&
name|intel_match_token
argument_list|(
literal|')'
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* e11  [ expr ] */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'['
condition|)
block|{
name|intel_match_token
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
comment|/* Mark as a memory operand only if it's not already known to be an 	 offset expression.  If it's an offset expression, we need to keep 	 the brace in.  */
if|if
condition|(
name|intel_parser
operator|.
name|op_modifier
operator|!=
name|OFFSET_FLAT
condition|)
name|intel_parser
operator|.
name|is_mem
operator|=
literal|1
expr_stmt|;
else|else
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
comment|/* Operands for jump/call inside brackets denote absolute addresses.  */
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|Jump
operator|||
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|JumpDword
operator|||
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|JumpByte
operator|||
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|JumpInterSegment
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
comment|/* Add a '+' to the displacement string if necessary.  */
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|disp
operator|!=
literal|'\0'
operator|&&
operator|*
operator|(
name|intel_parser
operator|.
name|disp
operator|+
name|strlen
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|)
operator|-
literal|1
operator|)
operator|!=
literal|'+'
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_expr
argument_list|()
operator|&&
name|intel_match_token
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
comment|/* Preserve brackets when the operand is an offset expression.  */
if|if
condition|(
name|intel_parser
operator|.
name|op_modifier
operator|==
name|OFFSET_FLAT
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* e11  BYTE 	  | WORD 	  | DWORD 	  | QWORD 	  | XWORD  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_BYTE
operator|||
name|cur_token
operator|.
name|code
operator|==
name|T_WORD
operator|||
name|cur_token
operator|.
name|code
operator|==
name|T_DWORD
operator|||
name|cur_token
operator|.
name|code
operator|==
name|T_QWORD
operator|||
name|cur_token
operator|.
name|code
operator|==
name|T_XWORD
condition|)
block|{
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* e11  $ 	  | .  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'$'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'.'
condition|)
block|{
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
comment|/* Mark as a memory operand only if it's not already known to be an 	 offset expression.  */
if|if
condition|(
name|intel_parser
operator|.
name|op_modifier
operator|!=
name|OFFSET_FLAT
condition|)
name|intel_parser
operator|.
name|is_mem
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* e11  register  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_REG
condition|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
init|=
name|intel_parser
operator|.
name|reg
operator|=
name|cur_token
operator|.
name|reg
decl_stmt|;
name|intel_match_token
argument_list|(
name|T_REG
argument_list|)
expr_stmt|;
comment|/* Check for segment change.  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|reg
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
condition|)
block|{
switch|switch
condition|(
name|reg
operator|->
name|reg_num
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|gs
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is not a valid segment register"
argument_list|)
argument_list|,
name|reg
operator|->
name|reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Not a segment register. Check for register scaling.  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|is_mem
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Register scaling only allowed in memory operands."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* What follows must be a valid scale.  */
if|if
condition|(
name|intel_match_token
argument_list|(
literal|'*'
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"01248"
argument_list|,
operator|*
name|cur_token
operator|.
name|str
argument_list|)
condition|)
block|{
name|i
operator|.
name|index_reg
operator|=
name|reg
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
comment|/* Set the scale after setting the register (otherwise, 		 i386_scale will complain)  */
name|i386_scale
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|intel_match_token
argument_list|(
name|T_CONST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting scale factor of 1, 2, 4, or 8: got `%s'"
argument_list|)
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* No scaling. If this is a memory operand, the register is either a 	 base register (first occurrence) or an index register (second 	 occurrence).  */
elseif|else
if|if
condition|(
name|intel_parser
operator|.
name|is_mem
operator|&&
operator|!
operator|(
name|reg
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|index_reg
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Too many register references in memory operand.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|NULL
condition|)
name|i
operator|.
name|base_reg
operator|=
name|reg
expr_stmt|;
else|else
name|i
operator|.
name|index_reg
operator|=
name|reg
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
block|}
comment|/* Offset modifier. Add the register to the displacement string to be 	 parsed as an immediate expression after we're done.  */
elseif|else
if|if
condition|(
name|intel_parser
operator|.
name|op_modifier
operator|==
name|OFFSET_FLAT
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|reg
operator|->
name|reg_name
argument_list|)
expr_stmt|;
comment|/* It's neither base nor index nor offset.  */
else|else
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|reg
operator|->
name|reg_type
operator|&
operator|~
name|BaseIndex
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|regs
operator|=
name|reg
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
comment|/* Since registers are not part of the displacement string (except 	 when we're parsing offset operands), we may need to remove any 	 preceding '+' from the displacement string.  */
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|disp
operator|!=
literal|'\0'
operator|&&
name|intel_parser
operator|.
name|op_modifier
operator|!=
name|OFFSET_FLAT
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|intel_parser
operator|.
name|disp
decl_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* e11  id  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_ID
condition|)
block|{
comment|/* Add the identifier to the displacement string.  */
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|intel_match_token
argument_list|(
name|T_ID
argument_list|)
expr_stmt|;
comment|/* The identifier represents a memory reference only if it's not 	 preceded by an offset modifier.  */
if|if
condition|(
name|intel_parser
operator|.
name|op_modifier
operator|!=
name|OFFSET_FLAT
condition|)
name|intel_parser
operator|.
name|is_mem
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* e11  constant  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_CONST
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'-'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'+'
condition|)
block|{
name|char
modifier|*
name|save_str
decl_stmt|;
comment|/* Allow constants that start with `+' or `-'.  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'-'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'+'
condition|)
block|{
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_token
operator|.
name|code
operator|!=
name|T_CONST
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Syntax error. Expecting a constant. Got `%s'.\n"
argument_list|)
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|save_str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_str
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|save_str
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
comment|/* Get the next token to check for register scaling.  */
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
comment|/* Check if this constant is a scaling factor for an index register.  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|intel_match_token
argument_list|(
literal|'*'
argument_list|)
operator|&&
name|cur_token
operator|.
name|code
operator|==
name|T_REG
condition|)
block|{
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|is_mem
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Register scaling only allowed in memory operands."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The constant is followed by `* reg', so it must be 		 a valid scale.  */
if|if
condition|(
name|strchr
argument_list|(
literal|"01248"
argument_list|,
operator|*
name|save_str
argument_list|)
condition|)
block|{
name|i
operator|.
name|index_reg
operator|=
name|cur_token
operator|.
name|reg
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
comment|/* Set the scale after setting the register (otherwise, 		     i386_scale will complain)  */
name|i386_scale
argument_list|(
name|save_str
argument_list|)
expr_stmt|;
name|intel_match_token
argument_list|(
name|T_REG
argument_list|)
expr_stmt|;
comment|/* Since registers are not part of the displacement 		     string, we may need to remove any preceding '+' from 		     the displacement string.  */
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|disp
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|intel_parser
operator|.
name|disp
decl_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
name|free
argument_list|(
name|save_str
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* The constant was not used for register scaling. Since we have 	     already consumed the token following `*' we now need to put it 	     back in the stream.  */
else|else
name|intel_putback_token
argument_list|()
expr_stmt|;
block|}
comment|/* Add the constant to the displacement string.  */
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|save_str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_str
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized token '%s'"
argument_list|)
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Match the given token against cur_token. If they match, read the next    token from the operand string.  */
end_comment

begin_function
specifier|static
name|int
name|intel_match_token
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|code
condition|)
block|{
name|intel_get_token
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unexpected token `%s'\n"
argument_list|)
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read a new token from intel_parser.op_string and store it in cur_token.  */
end_comment

begin_function
specifier|static
name|void
name|intel_get_token
parameter_list|()
block|{
name|char
modifier|*
name|end_op
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|struct
name|intel_token
name|new_token
decl_stmt|;
name|new_token
operator|.
name|code
operator|=
name|T_NIL
expr_stmt|;
name|new_token
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|new_token
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
comment|/* Free the memory allocated to the previous token and move      cur_token to prev_token.  */
if|if
condition|(
name|prev_token
operator|.
name|str
condition|)
name|free
argument_list|(
name|prev_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|prev_token
operator|=
name|cur_token
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|is_space_char
argument_list|(
operator|*
name|intel_parser
operator|.
name|op_string
argument_list|)
condition|)
name|intel_parser
operator|.
name|op_string
operator|++
expr_stmt|;
comment|/* Return an empty token if we find nothing else on the line.  */
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|op_string
operator|==
literal|'\0'
condition|)
block|{
name|cur_token
operator|=
name|new_token
expr_stmt|;
return|return;
block|}
comment|/* The new token cannot be larger than the remainder of the operand      string.  */
name|new_token
operator|.
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|intel_parser
operator|.
name|op_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_token
operator|.
name|str
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"0123456789"
argument_list|,
operator|*
name|intel_parser
operator|.
name|op_string
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|new_token
operator|.
name|str
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|intel_parser
operator|.
name|op_string
decl_stmt|;
name|new_token
operator|.
name|code
operator|=
name|T_CONST
expr_stmt|;
comment|/* Allow any kind of identifier char to encompass floating point and 	 hexadecimal numbers.  */
while|while
condition|(
name|is_identifier_char
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Recognize special symbol names [0-9][bf].  */
if|if
condition|(
name|strlen
argument_list|(
name|intel_parser
operator|.
name|op_string
argument_list|)
operator|==
literal|2
operator|&&
operator|(
name|intel_parser
operator|.
name|op_string
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|intel_parser
operator|.
name|op_string
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_ID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"+-/*:[]()"
argument_list|,
operator|*
name|intel_parser
operator|.
name|op_string
argument_list|)
condition|)
block|{
name|new_token
operator|.
name|code
operator|=
operator|*
name|intel_parser
operator|.
name|op_string
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|0
index|]
operator|=
operator|*
name|intel_parser
operator|.
name|op_string
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|intel_parser
operator|.
name|op_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
operator|)
operator|&&
operator|(
operator|(
name|reg
operator|=
name|parse_register
argument_list|(
name|intel_parser
operator|.
name|op_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|new_token
operator|.
name|code
operator|=
name|T_REG
expr_stmt|;
name|new_token
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|op_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|new_token
operator|.
name|str
index|[
literal|0
index|]
operator|=
name|REGISTER_PREFIX
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcat
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
name|reg
operator|->
name|reg_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_identifier_char
argument_list|(
operator|*
name|intel_parser
operator|.
name|op_string
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|new_token
operator|.
name|str
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|intel_parser
operator|.
name|op_string
decl_stmt|;
comment|/* A '.' or '$' followed by an identifier char is an identifier. 	 Otherwise, it's operator '.' followed by an expression.  */
if|if
condition|(
operator|(
operator|*
name|q
operator|==
literal|'.'
operator|||
operator|*
name|q
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|is_identifier_char
argument_list|(
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|new_token
operator|.
name|code
operator|=
operator|*
name|q
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|0
index|]
operator|=
operator|*
name|q
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|is_identifier_char
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'@'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"BYTE"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_BYTE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"WORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_WORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"DWORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_DWORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"QWORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_QWORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"XWORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_XWORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"PTR"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_PTR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"SHORT"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"OFFSET"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new_token
operator|.
name|code
operator|=
name|T_OFFSET
expr_stmt|;
comment|/* ??? This is not mentioned in the MASM grammar but gcc 		     makes use of it with -mintel-syntax.  OFFSET may be 		     followed by FLAT:  */
if|if
condition|(
name|strncasecmp
argument_list|(
name|q
argument_list|,
literal|" FLAT:"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|" FLAT:"
argument_list|)
expr_stmt|;
block|}
comment|/* ??? This is not mentioned in the MASM grammar.  */
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"FLAT"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_OFFSET
expr_stmt|;
else|else
name|new_token
operator|.
name|code
operator|=
name|T_ID
expr_stmt|;
block|}
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized token `%s'\n"
argument_list|)
argument_list|,
name|intel_parser
operator|.
name|op_string
argument_list|)
expr_stmt|;
name|intel_parser
operator|.
name|op_string
operator|+=
name|strlen
argument_list|(
name|new_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|cur_token
operator|=
name|new_token
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put cur_token back into the token stream and make cur_token point to    prev_token.  */
end_comment

begin_function
specifier|static
name|void
name|intel_putback_token
parameter_list|()
block|{
name|intel_parser
operator|.
name|op_string
operator|-=
name|strlen
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|cur_token
operator|=
name|prev_token
expr_stmt|;
comment|/* Forget prev_token.  */
name|prev_token
operator|.
name|code
operator|=
name|T_NIL
expr_stmt|;
name|prev_token
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|prev_token
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

