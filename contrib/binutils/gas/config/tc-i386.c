begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i386.c -- Assemble code for the Intel 80386    Copyright (C) 1989, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/*   Intel 80386 machine specific gas.   Written by Eliot Dresselhaus (eliot@mgm.mit.edu).   Bugs& suggestions are completely welcome.  This is free software.   Please help us make it better.   */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"opcode/i386.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TC_RELOC
end_ifndef

begin_define
define|#
directive|define
name|TC_RELOC
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|(Y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|mode_from_disp_size
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_signed_byte
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_unsigned_byte
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_unsigned_word
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fits_in_signed_word
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|smallest_imm_type
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_16bit_code_flag
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|reloc
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 'md_assemble ()' gathers together information and puts it into a    i386_insn. */
end_comment

begin_struct
struct|struct
name|_i386_insn
block|{
comment|/* TM holds the template for the insn were currently assembling. */
name|template
name|tm
decl_stmt|;
comment|/* SUFFIX holds the opcode suffix (e.g. 'l' for 'movl') if given. */
name|char
name|suffix
decl_stmt|;
comment|/* Operands are coded with OPERANDS, TYPES, DISPS, IMMS, and REGS. */
comment|/* OPERANDS gives the number of given operands. */
name|unsigned
name|int
name|operands
decl_stmt|;
comment|/* REG_OPERANDS, DISP_OPERANDS, MEM_OPERANDS, IMM_OPERANDS give the number        of given register, displacement, memory operands and immediate        operands. */
name|unsigned
name|int
name|reg_operands
decl_stmt|,
name|disp_operands
decl_stmt|,
name|mem_operands
decl_stmt|,
name|imm_operands
decl_stmt|;
comment|/* TYPES [i] is the type (see above #defines) which tells us how to        search through DISPS [i]& IMMS [i]& REGS [i] for the required        operand.  */
name|unsigned
name|int
name|types
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Displacements (if given) for each operand. */
name|expressionS
modifier|*
name|disps
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Relocation type for operand */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|enum
name|bfd_reloc_code_real
name|disp_reloc
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
else|#
directive|else
name|int
name|disp_reloc
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* Immediate operands (if given) for each operand. */
name|expressionS
modifier|*
name|imms
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Register operands (if given) for each operand. */
name|reg_entry
modifier|*
name|regs
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* BASE_REG, INDEX_REG, and LOG2_SCALE_FACTOR are used to encode        the base index byte below.  */
name|reg_entry
modifier|*
name|base_reg
decl_stmt|;
name|reg_entry
modifier|*
name|index_reg
decl_stmt|;
name|unsigned
name|int
name|log2_scale_factor
decl_stmt|;
comment|/* SEG gives the seg_entry of this insn.  It is equal to zero unless        an explicit segment override is given. */
specifier|const
name|seg_entry
modifier|*
name|seg
decl_stmt|;
comment|/* segment for memory operands (if given) */
comment|/* PREFIX holds all the given prefix opcodes (usually null).        PREFIXES is the size of PREFIX. */
comment|/* richfix: really unsigned? */
name|unsigned
name|char
name|prefix
index|[
name|MAX_PREFIXES
index|]
decl_stmt|;
name|unsigned
name|int
name|prefixes
decl_stmt|;
comment|/* RM and BI are the modrm byte and the base index byte where the        addressing modes of this insn are encoded. */
name|modrm_byte
name|rm
decl_stmt|;
name|base_index_byte
name|bi
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|_i386_insn
name|i386_insn
typedef|;
end_typedef

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TE_I386AIX
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output. */
end_comment

begin_comment
comment|/* Also note that comments started like this one will always work if    '/' isn't otherwise defined.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TE_I386AIX
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"/"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDxX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tables for lexical analysis */
end_comment

begin_decl_stmt
specifier|static
name|char
name|opcode_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|operand_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|space_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|identifier_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|digit_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lexical macros */
end_comment

begin_define
define|#
directive|define
name|is_opcode_char
parameter_list|(
name|x
parameter_list|)
value|(opcode_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_operand_char
parameter_list|(
name|x
parameter_list|)
value|(operand_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_register_char
parameter_list|(
name|x
parameter_list|)
value|(register_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_space_char
parameter_list|(
name|x
parameter_list|)
value|(space_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_identifier_char
parameter_list|(
name|x
parameter_list|)
value|(identifier_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_digit_char
parameter_list|(
name|x
parameter_list|)
value|(digit_chars[(unsigned char) x])
end_define

begin_comment
comment|/* put here all non-digit non-letter charcters that may occur in an operand */
end_comment

begin_decl_stmt
specifier|static
name|char
name|operand_special_chars
index|[]
init|=
literal|"%$-+(,)*._~/<>|&^!:[@]"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ordinal_names
index|[]
init|=
block|{
literal|"first"
block|,
literal|"second"
block|,
literal|"third"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for printfs */
end_comment

begin_comment
comment|/* md_assemble() always leaves the strings it's passed unaltered.  To    effect this we maintain a stack of saved characters that we've smashed    with '\0's (indicating end of strings for various sub-fields of the    assembler instruction). */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_stack
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_stack_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack pointer */
end_comment

begin_define
define|#
directive|define
name|END_STRING_AND_SAVE
parameter_list|(
name|s
parameter_list|)
value|*save_stack_p++ = *s; *s = '\0'
end_define

begin_define
define|#
directive|define
name|RESTORE_END_STRING
parameter_list|(
name|s
parameter_list|)
value|*s = *--save_stack_p
end_define

begin_comment
comment|/* The instruction we're assembling. */
end_comment

begin_decl_stmt
specifier|static
name|i386_insn
name|i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per instruction expressionS buffers: 2 displacements& 2 immediate max. */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|disp_expressions
index|[
literal|2
index|]
decl_stmt|,
name|im_expressions
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to ebp& esp entries in reg_hash hash table */
end_comment

begin_decl_stmt
specifier|static
name|reg_entry
modifier|*
name|ebp
decl_stmt|,
modifier|*
name|esp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|this_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current operand we are working on */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_do_long_jump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME what does this do? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_16bit_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if we're writing 16-bit code, 0 if 32-bit */
end_comment

begin_comment
comment|/* Interface to relax_segment.    There are 2 relax states for 386 jump insns: one for conditional&    one for unconditional jumps.  This is because the these two types    of jumps add different sizes to frags when we're figuring out what    sort of jump to choose to reach a given label.  */
end_comment

begin_comment
comment|/* types */
end_comment

begin_define
define|#
directive|define
name|COND_JUMP
value|1
end_define

begin_comment
comment|/* conditional jump */
end_comment

begin_define
define|#
directive|define
name|UNCOND_JUMP
value|2
end_define

begin_comment
comment|/* unconditional jump */
end_comment

begin_comment
comment|/* sizes */
end_comment

begin_define
define|#
directive|define
name|BYTE
value|0
end_define

begin_define
define|#
directive|define
name|WORD
value|1
end_define

begin_define
define|#
directive|define
name|DWORD
value|2
end_define

begin_define
define|#
directive|define
name|UNKNOWN_SIZE
value|3
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|INLINE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|INLINE
value|__inline__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ENCODE_RELAX_STATE
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|)
define|\
value|((relax_substateT)((type<<2) | (size)))
end_define

begin_define
define|#
directive|define
name|SIZE_FROM_RELAX_STATE
parameter_list|(
name|s
parameter_list|)
define|\
value|( (((s)& 0x3) == BYTE ? 1 : (((s)& 0x3) == WORD ? 2 : 4)) )
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The fields are:    1) most positive reach of this state,    2) most negative reach of this state,    3) how many bytes this mode will add to the size of the current frag    4) which index into the table to try if we can't fit into this one.    */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* For now we don't use word displacement jumps; they may be      untrustworthy. */
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* word conditionals add 3 bytes to frag:      2 opcode prefix; 1 displacement bytes */
block|{
literal|32767
operator|+
literal|2
block|,
operator|-
literal|32768
operator|+
literal|2
block|,
literal|3
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* dword conditionals adds 4 bytes to frag:      1 opcode prefix; 3 displacement bytes */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* word jmp adds 2 bytes to frag:      1 opcode prefix; 1 displacement bytes */
block|{
literal|32767
operator|+
literal|2
block|,
operator|-
literal|32768
operator|+
literal|2
block|,
literal|2
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* dword jmp adds 3 bytes to frag:      0 opcode prefix; 3 displacement bytes */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|i386_align_code
parameter_list|(
name|fragP
parameter_list|,
name|count
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
comment|/* Various efficient no-op patterns for aligning code labels.  */
comment|/* Note: Don't try to assemble the instructions in the comments. */
comment|/*       0L and 0w are not legal */
specifier|static
specifier|const
name|char
name|f32_1
index|[]
init|=
block|{
literal|0x90
block|}
decl_stmt|;
comment|/* nop			*/
specifier|static
specifier|const
name|char
name|f32_2
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|}
decl_stmt|;
comment|/* movl %esi,%esi	*/
specifier|static
specifier|const
name|char
name|f32_3
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x76
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f32_4
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi,1),%esi	*/
specifier|static
specifier|const
name|char
name|f32_5
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi,1),%esi	*/
specifier|static
specifier|const
name|char
name|f32_6
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f32_7
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi,1),%esi */
specifier|static
specifier|const
name|char
name|f32_8
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi,1),%esi */
specifier|static
specifier|const
name|char
name|f32_9
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|,
comment|/* movl %esi,%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_10
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x76
block|,
literal|0x00
block|,
comment|/* leal 0(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_11
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|,
comment|/* leal 0(%esi,1),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_12
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbf
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi),%edi	*/
specifier|static
specifier|const
name|char
name|f32_13
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_14
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi,1),%esi */
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_15
index|[]
init|=
block|{
literal|0xeb
block|,
literal|0x0d
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
comment|/* jmp .+15; lotsa nops	*/
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
name|f16_4
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%si),%si	*/
specifier|static
specifier|const
name|char
name|f16_5
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%si),%si	*/
specifier|static
specifier|const
name|char
name|f16_6
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|,
comment|/* mov %si,%si		*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
name|f16_7
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x00
block|,
comment|/* lea 0(%si),%si	*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
name|f16_8
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* lea 0w(%si),%si	*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|f32_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|f32_3
block|,
name|f32_4
block|,
name|f32_5
block|,
name|f32_6
block|,
name|f32_7
block|,
name|f32_8
block|,
name|f32_9
block|,
name|f32_10
block|,
name|f32_11
block|,
name|f32_12
block|,
name|f32_13
block|,
name|f32_14
block|,
name|f32_15
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|f16_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|f32_3
block|,
name|f16_4
block|,
name|f16_5
block|,
name|f16_6
block|,
name|f16_7
block|,
name|f16_8
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|}
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|count
operator|<=
literal|15
condition|)
block|{
if|if
condition|(
name|flag_16bit_code
condition|)
block|{
name|memcpy
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|f16_patt
index|[
name|count
operator|-
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|8
condition|)
comment|/* adjust jump offset */
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
index|]
operator|=
name|count
operator|-
literal|2
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|f32_patt
index|[
name|count
operator|-
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|count
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_invalid
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|i386_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|operand_string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_entry
modifier|*
name|parse_register
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|reg_string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|I386COFF
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|s_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "__GLOBAL_OFFSET_TABLE" */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|long
name|mode_from_disp_size
parameter_list|(
name|t
parameter_list|)
name|unsigned
name|long
name|t
decl_stmt|;
block|{
return|return
operator|(
name|t
operator|&
name|Disp8
operator|)
condition|?
literal|1
else|:
operator|(
name|t
operator|&
name|Disp32
operator|)
condition|?
literal|2
else|:
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not used.  */
end_comment

begin_comment
comment|/* convert opcode suffix ('b' 'w' 'l' typically) into type specifier */
end_comment

begin_comment
unit|static INLINE unsigned long opcode_suffix_to_type (s)      unsigned long s; {   return (s == BYTE_OPCODE_SUFFIX 	  ? Byte : (s == WORD_OPCODE_SUFFIX 		    ? Word : DWord)); }
comment|/* opcode_suffix_to_type() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_byte
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
name|num
operator|>=
operator|-
literal|128
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|127
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fits_in_signed_byte() */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_byte
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
name|num
operator|&
literal|0xff
operator|)
operator|==
name|num
return|;
block|}
end_function

begin_comment
comment|/* fits_in_unsigned_byte() */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_word
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
name|num
operator|&
literal|0xffff
operator|)
operator|==
name|num
return|;
block|}
end_function

begin_comment
comment|/* fits_in_unsigned_word() */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_word
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
operator|-
literal|32768
operator|<=
name|num
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|32767
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fits_in_signed_word() */
end_comment

begin_function
specifier|static
name|int
name|smallest_imm_type
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* This code is disabled because all the Imm1 forms in the opcode table      are slower on the i486, and they're the versions with the implicitly      specified single-position displacement, which has another syntax if      you really want to use that form.  If you really prefer to have the      one-byte-shorter Imm1 form despite these problems, re-enable this      code.  */
block|if (num == 1)     return Imm1 | Imm8 | Imm8S | Imm16 | Imm32;
endif|#
directive|endif
return|return
operator|(
name|fits_in_signed_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8S
operator||
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator|)
else|:
name|fits_in_unsigned_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator|)
else|:
operator|(
name|fits_in_signed_word
argument_list|(
name|num
argument_list|)
operator|||
name|fits_in_unsigned_word
argument_list|(
name|num
argument_list|)
operator|)
condition|?
operator|(
name|Imm16
operator||
name|Imm32
operator|)
else|:
operator|(
name|Imm32
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* smallest_imm_type() */
end_comment

begin_function
specifier|static
name|void
name|set_16bit_code_flag
parameter_list|(
name|new_16bit_code_flag
parameter_list|)
name|int
name|new_16bit_code_flag
decl_stmt|;
block|{
name|flag_16bit_code
operator|=
name|new_16bit_code_flag
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|I386COFF
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_ALIGN_PTWO
argument_list|)
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"tfloat"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"value"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"noopt"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"code16"
block|,
name|set_16bit_code_flag
block|,
literal|1
block|}
block|,
block|{
literal|"code32"
block|,
name|set_16bit_code_flag
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for interface with expression () */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* obstack for constructing various things in md_begin */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|o
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for opcode lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for register lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for prefix lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|prefix_hash
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|hash_err
decl_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|o
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* initialize op_hash hash table */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
specifier|const
name|template
modifier|*
name|optab
decl_stmt|;
specifier|register
name|templates
modifier|*
name|core_optab
decl_stmt|;
name|char
modifier|*
name|prev_name
decl_stmt|;
name|optab
operator|=
name|i386_optab
expr_stmt|;
comment|/* setup for loop */
name|prev_name
operator|=
name|optab
operator|->
name|name
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|o
argument_list|,
name|optab
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|optab
operator|++
init|;
name|optab
operator|<
name|i386_optab_end
condition|;
name|optab
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optab
operator|->
name|name
argument_list|,
name|prev_name
argument_list|)
condition|)
block|{
comment|/* same name as before --> append to current template list */
name|obstack_grow
argument_list|(
operator|&
name|o
argument_list|,
name|optab
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* different name --> ship out current template list; 	       add to hash table;& begin anew */
comment|/* Note: end must be set before start! since obstack_next_free 	       changes upon opstack_finish */
name|core_optab
operator|->
name|end
operator|=
operator|(
name|template
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
operator|(
name|template
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|prev_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|core_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
block|{
name|hash_error
label|:
name|as_fatal
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|,
name|prev_name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
name|prev_name
operator|=
name|optab
operator|->
name|name
expr_stmt|;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|o
argument_list|,
name|optab
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* initialize reg_hash hash table */
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
specifier|const
name|reg_entry
modifier|*
name|regtab
decl_stmt|;
for|for
control|(
name|regtab
operator|=
name|i386_regtab
init|;
name|regtab
operator|<
name|i386_regtab_end
condition|;
name|regtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|regtab
operator|->
name|reg_name
argument_list|,
operator|(
name|PTR
operator|)
name|regtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
goto|goto
name|hash_error
goto|;
block|}
block|}
name|esp
operator|=
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
literal|"esp"
argument_list|)
expr_stmt|;
name|ebp
operator|=
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
literal|"ebp"
argument_list|)
expr_stmt|;
comment|/* initialize reg_hash hash table */
name|prefix_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
specifier|const
name|prefix_entry
modifier|*
name|prefixtab
decl_stmt|;
for|for
control|(
name|prefixtab
operator|=
name|i386_prefixtab
init|;
name|prefixtab
operator|<
name|i386_prefixtab_end
condition|;
name|prefixtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|prefix_hash
argument_list|,
name|prefixtab
operator|->
name|prefix_name
argument_list|,
operator|(
name|PTR
operator|)
name|prefixtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
goto|goto
name|hash_error
goto|;
block|}
block|}
comment|/* fill in lexical tables:  opcode_chars, operand_chars, space_chars */
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|opcode_chars
index|[
name|c
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|PREFIX_SEPERATOR
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|'('
condition|)
block|{
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
operator|||
name|islower
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
condition|)
name|digit_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|LEX_AT
name|identifier_chars
index|[
literal|'@'
index|]
operator|=
literal|'@'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|space_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|operand_special_chars
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
name|operand_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|record_alignment
argument_list|(
name|text_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|data_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|i386_print_statistics
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"i386 opcode"
argument_list|,
name|op_hash
argument_list|)
expr_stmt|;
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"i386 register"
argument_list|,
name|reg_hash
argument_list|)
expr_stmt|;
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"i386 prefix"
argument_list|,
name|prefix_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG386
end_ifdef

begin_comment
comment|/* debugging routines for md_assemble */
end_comment

begin_decl_stmt
specifier|static
name|void
name|pi
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|i386_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pte
name|PARAMS
argument_list|(
operator|(
name|template
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pt
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pe
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ps
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pi
parameter_list|(
name|line
parameter_list|,
name|x
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|i386_insn
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|template
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: template "
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|pte
argument_list|(
operator|&
name|x
operator|->
name|tm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  modrm:  mode %x  reg %x  reg/mem %x"
argument_list|,
name|x
operator|->
name|rm
operator|.
name|mode
argument_list|,
name|x
operator|->
name|rm
operator|.
name|reg
argument_list|,
name|x
operator|->
name|rm
operator|.
name|regmem
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" base %x  index %x  scale %x\n"
argument_list|,
name|x
operator|->
name|bi
operator|.
name|base
argument_list|,
name|x
operator|->
name|bi
operator|.
name|index
argument_list|,
name|x
operator|->
name|bi
operator|.
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d:  "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|x
operator|->
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|RegMMX
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|x
operator|->
name|regs
index|[
name|i
index|]
operator|->
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Imm
condition|)
name|pe
argument_list|(
name|x
operator|->
name|imms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
operator|(
name|Disp
operator||
name|Abs
operator|)
condition|)
name|pe
argument_list|(
name|x
operator|->
name|disps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pte
parameter_list|(
name|t
parameter_list|)
name|template
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" %d operands "
argument_list|,
name|t
operator|->
name|operands
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"opcode %x "
argument_list|,
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"ext %x "
argument_list|,
name|t
operator|->
name|extension_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|D
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"W"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d type "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|t
operator|->
name|operand_types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pe
parameter_list|(
name|e
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    operation       %d\n"
argument_list|,
name|e
operator|->
name|X_op
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_number    %d (%x)\n"
argument_list|,
name|e
operator|->
name|X_add_number
argument_list|,
name|e
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_add_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|X_op_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    op_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ps
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s type %s%s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|,
name|S_IS_EXTERNAL
argument_list|(
name|s
argument_list|)
condition|?
literal|"EXTERNAL "
else|:
literal|""
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|type_name
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
block|}
name|type_names
index|[]
init|=
block|{
block|{
name|Reg8
block|,
literal|"r8"
block|}
block|,
block|{
name|Reg16
block|,
literal|"r16"
block|}
block|,
block|{
name|Reg32
block|,
literal|"r32"
block|}
block|,
block|{
name|Imm8
block|,
literal|"i8"
block|}
block|,
block|{
name|Imm8S
block|,
literal|"i8s"
block|}
block|,
block|{
name|Imm16
block|,
literal|"i16"
block|}
block|,
block|{
name|Imm32
block|,
literal|"i32"
block|}
block|,
block|{
name|Mem8
block|,
literal|"Mem8"
block|}
block|,
block|{
name|Mem16
block|,
literal|"Mem16"
block|}
block|,
block|{
name|Mem32
block|,
literal|"Mem32"
block|}
block|,
block|{
name|BaseIndex
block|,
literal|"BaseIndex"
block|}
block|,
block|{
name|Abs8
block|,
literal|"Abs8"
block|}
block|,
block|{
name|Abs16
block|,
literal|"Abs16"
block|}
block|,
block|{
name|Abs32
block|,
literal|"Abs32"
block|}
block|,
block|{
name|Disp8
block|,
literal|"d8"
block|}
block|,
block|{
name|Disp16
block|,
literal|"d16"
block|}
block|,
block|{
name|Disp32
block|,
literal|"d32"
block|}
block|,
block|{
name|SReg2
block|,
literal|"SReg2"
block|}
block|,
block|{
name|SReg3
block|,
literal|"SReg3"
block|}
block|,
block|{
name|Acc
block|,
literal|"Acc"
block|}
block|,
block|{
name|InOutPortReg
block|,
literal|"InOutPortReg"
block|}
block|,
block|{
name|ShiftCount
block|,
literal|"ShiftCount"
block|}
block|,
block|{
name|Imm1
block|,
literal|"i1"
block|}
block|,
block|{
name|Control
block|,
literal|"control reg"
block|}
block|,
block|{
name|Test
block|,
literal|"test reg"
block|}
block|,
block|{
name|FloatReg
block|,
literal|"FReg"
block|}
block|,
block|{
name|FloatAcc
block|,
literal|"FAcc"
block|}
block|,
block|{
name|JumpAbsolute
block|,
literal|"Jump Absolute"
block|}
block|,
block|{
name|RegMMX
block|,
literal|"rMMX"
block|}
block|,
block|{
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pt
parameter_list|(
name|t
parameter_list|)
name|unsigned
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|type_name
modifier|*
name|ty
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|Unknown
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ty
operator|=
name|type_names
init|;
name|ty
operator|->
name|mask
condition|;
name|ty
operator|++
control|)
if|if
condition|(
name|t
operator|&
name|ty
operator|->
name|mask
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s, "
argument_list|,
name|ty
operator|->
name|tname
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG386 */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|reloc
parameter_list|(
name|size
parameter_list|,
name|pcrel
parameter_list|,
name|other
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|bfd_reloc_code_real_type
name|other
decl_stmt|;
block|{
if|if
condition|(
name|other
operator|!=
name|NO_RELOC
condition|)
return|return
name|other
return|;
if|if
condition|(
name|pcrel
condition|)
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8_PCREL
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16_PCREL
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32_PCREL
return|;
block|}
else|else
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32
return|;
block|}
name|as_bad
argument_list|(
literal|"Can not do %d byte %srelocation"
argument_list|,
name|size
argument_list|,
name|pcrel
condition|?
literal|"pc-relative "
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * Here we decide which fixups can be adjusted to make them relative to  * the beginning of the section instead of the symbol.  Basically we need  * to make sure that the dynamic relocations are done correctly, so in  * some cases we force the original symbol to be used.  */
end_comment

begin_function
name|int
name|tc_i386_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Prevent all adjustments to global symbols. */
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* ! defined (OBJ_AOUT) */
comment|/* adjust_reloc_syms doesn't know about the GOT */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_GOTOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_PLT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_GOT32
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|reloc
parameter_list|(
name|SIZE
parameter_list|,
name|PCREL
parameter_list|,
name|OTHER
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_32_PCREL
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_386_PLT32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_386_GOT32
value|0
end_define

begin_define
define|#
directive|define
name|BFD_RELOC_386_GOTOFF
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  LINE points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
comment|/* Points to template once we've found it. */
specifier|const
name|template
modifier|*
name|t
decl_stmt|;
comment|/* Count the size of the instruction generated.  */
name|int
name|insn_size
init|=
literal|0
decl_stmt|;
comment|/* Possible templates for current insn */
name|templates
modifier|*
name|current_templates
init|=
operator|(
name|templates
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Wait prefix needs to come before any other prefixes, so handle it      specially.  wait_prefix will hold the opcode modifier flag FWait      if a wait prefix is given.  */
name|int
name|wait_prefix
init|=
literal|0
decl_stmt|;
comment|/* Initialize globals. */
name|memset
argument_list|(
operator|&
name|i
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_OPERANDS
condition|;
name|j
operator|++
control|)
name|i
operator|.
name|disp_reloc
index|[
name|j
index|]
operator|=
name|NO_RELOC
expr_stmt|;
name|memset
argument_list|(
name|disp_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|disp_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|im_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|im_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|save_stack_p
operator|=
name|save_stack
expr_stmt|;
comment|/* reset stack pointer */
comment|/* First parse an opcode& call i386_operand for the operands.      We assume that the scrubber has arranged it so that line[0] is the valid      start of a (possibly prefixed) opcode. */
block|{
name|char
modifier|*
name|l
init|=
name|line
decl_stmt|;
comment|/* 1 if operand is pending after ','. */
name|unsigned
name|int
name|expecting_operand
init|=
literal|0
decl_stmt|;
comment|/* 1 if we found a prefix only acceptable with string insns. */
name|unsigned
name|int
name|expecting_string_instruction
init|=
literal|0
decl_stmt|;
comment|/* Non-zero if operand parens not balanced. */
name|unsigned
name|int
name|paren_not_balanced
decl_stmt|;
name|char
modifier|*
name|token_start
init|=
name|l
decl_stmt|;
while|while
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|is_opcode_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid character %s in opcode"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|l
operator|!=
name|PREFIX_SEPERATOR
condition|)
block|{
operator|*
name|l
operator|=
name|opcode_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|l
index|]
expr_stmt|;
comment|/* fold case of opcodes */
name|l
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This opcode's got a prefix.  */
name|unsigned
name|int
name|q
decl_stmt|;
name|prefix_entry
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|token_start
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting prefix; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|prefix
operator|=
operator|(
name|prefix_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|prefix_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
condition|)
block|{
name|as_bad
argument_list|(
literal|"no such opcode prefix ('%s')"
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* check for repeated prefix */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|i
operator|.
name|prefixes
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|q
index|]
operator|==
name|prefix
operator|->
name|prefix_code
condition|)
block|{
name|as_bad
argument_list|(
literal|"same prefix used twice; you don't really want this!"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prefix
operator|->
name|prefix_code
operator|==
name|FWAIT_OPCODE
condition|)
block|{
if|if
condition|(
name|wait_prefix
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"same prefix used twice; you don't really want this!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|wait_prefix
operator|=
name|FWait
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"too many opcode prefixes"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|prefix
operator|->
name|prefix_code
expr_stmt|;
if|if
condition|(
name|prefix
operator|->
name|prefix_code
operator|==
name|REPE
operator|||
name|prefix
operator|->
name|prefix_code
operator|==
name|REPNE
condition|)
name|expecting_string_instruction
operator|=
literal|1
expr_stmt|;
block|}
comment|/* skip past PREFIX_SEPERATOR and reset token_start */
name|token_start
operator|=
operator|++
name|l
expr_stmt|;
block|}
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|token_start
operator|==
name|l
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting opcode; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Lookup insn in hash; try intel& att naming conventions if appropriate;        that is:  we only use the opcode suffix 'b' 'w' or 'l' if we need to. */
name|current_templates
operator|=
operator|(
name|templates
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
name|int
name|last_index
init|=
name|strlen
argument_list|(
name|token_start
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|token_start
index|[
name|last_index
index|]
decl_stmt|;
switch|switch
condition|(
name|last_char
condition|)
block|{
case|case
name|DWORD_OPCODE_SUFFIX
case|:
case|case
name|WORD_OPCODE_SUFFIX
case|:
case|case
name|BYTE_OPCODE_SUFFIX
case|:
name|token_start
index|[
name|last_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
operator|(
name|templates
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
name|token_start
index|[
name|last_index
index|]
operator|=
name|last_char
expr_stmt|;
name|i
operator|.
name|suffix
operator|=
name|last_char
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
name|as_bad
argument_list|(
literal|"no such 386 instruction: `%s'"
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* check for rep/repne without a string instruction */
if|if
condition|(
name|expecting_string_instruction
operator|&&
operator|!
name|IS_STRING_INSTRUCTION
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting string instruction after rep/repne"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* There may be operands to parse. */
if|if
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
operator|&&
comment|/* For string instructions, we ignore any operands if given.  This 	   kludges, for example, 'rep/movsb %ds:(%esi), %es:(%edi)' where 	   the operands are always going to be the same, and are not really 	   encoded in machine code. */
operator|!
name|IS_STRING_INSTRUCTION
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
comment|/* parse operands */
do|do
block|{
comment|/* skip optional white space before operand */
while|while
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid character %s before %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|i
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|++
expr_stmt|;
block|}
name|token_start
operator|=
name|l
expr_stmt|;
comment|/* after white space */
name|paren_not_balanced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|paren_not_balanced
operator|||
operator|*
name|l
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
name|paren_not_balanced
condition|)
block|{
name|as_bad
argument_list|(
literal|"unbalanced parenthesis in %s operand."
argument_list|,
name|ordinal_names
index|[
name|i
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
comment|/* we are done */
block|}
elseif|else
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid character %s in %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|i
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|'('
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|')'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
name|token_start
condition|)
block|{
comment|/* yes, we've read in another operand */
name|unsigned
name|int
name|operand_ok
decl_stmt|;
name|this_operand
operator|=
name|i
operator|.
name|operands
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|>
name|MAX_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"spurious operands; (%d operands/instruction max)"
argument_list|,
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* now parse operand adding info to 'i' as we go along */
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|operand_ok
operator|=
name|i386_operand
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* restore old contents */
if|if
condition|(
operator|!
name|operand_ok
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
condition|)
block|{
name|expecting_operand_after_comma
label|:
name|as_bad
argument_list|(
literal|"expecting operand after ','; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting operand before ','; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* now *l must be either ',' or END_OF_INSN */
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
comment|/* just skip it, if it's \n complain */
goto|goto
name|expecting_operand_after_comma
goto|;
block|}
name|expecting_operand
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
do|;
comment|/* until we get end of insn */
block|}
block|}
comment|/* Now we've parsed the opcode into a set of templates, and have the      operands at hand.       Next, we find a template that matches the given insn,      making sure the overlap of the given operands types is consistent      with the template operand types. */
define|#
directive|define
name|MATCH
parameter_list|(
name|overlap
parameter_list|,
name|given_type
parameter_list|)
define|\
value|(overlap&& \ 	 (((overlap& (JumpAbsolute|BaseIndex|Mem8)) \ 	   == (given_type& (JumpAbsolute|BaseIndex|Mem8))) \ 	  || (overlap == InOutPortReg)))
comment|/* If m0 and m1 are register matches they must be consistent      with the expected operand types t0 and t1.      That is, if both m0& m1 are register matches      i.e. ( ((m0& (Reg))&& (m1& (Reg)) ) ?      then, either 1. or 2. must be true:      1. the expected operand type register overlap is null:      (t0& t1& Reg) == 0      AND      the given register overlap is null:      (m0& m1& Reg) == 0      2. the expected operand type register overlap == the given      operand type overlap:  (t0& t1& m0& m1& Reg).      */
define|#
directive|define
name|CONSISTENT_REGISTER_MATCH
parameter_list|(
name|m0
parameter_list|,
name|m1
parameter_list|,
name|t0
parameter_list|,
name|t1
parameter_list|)
define|\
value|( ((m0& (Reg))&& (m1& (Reg))) ? \ 	     ( ((t0& t1& (Reg)) == 0&& (m0& m1& (Reg)) == 0) || \ 	      ((t0& t1)& (m0& m1)& (Reg)) \ 	      ) : 1)
block|{
specifier|register
name|unsigned
name|int
name|overlap0
decl_stmt|,
name|overlap1
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|overlap2
decl_stmt|;
name|unsigned
name|int
name|found_reverse_match
decl_stmt|;
name|overlap0
operator|=
name|overlap1
operator|=
name|overlap2
operator|=
name|found_reverse_match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
name|t
operator|++
control|)
block|{
comment|/* must have right number of operands */
if|if
condition|(
name|i
operator|.
name|operands
operator|!=
name|t
operator|->
name|operands
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|t
operator|->
name|operands
condition|)
break|break;
comment|/* 0 operands always matches */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|operands
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|overlap1
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* check if other direction is valid ... */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|COMES_IN_BOTH_DIRECTIONS
operator|)
condition|)
continue|continue;
comment|/* try reversing direction of operands */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|overlap1
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* does not match either direction */
continue|continue;
block|}
comment|/* found a reverse match here -- slip through */
comment|/* found_reverse_match holds which of D or FloatD we've found */
name|found_reverse_match
operator|=
name|t
operator|->
name|opcode_modifier
operator|&
name|COMES_IN_BOTH_DIRECTIONS
expr_stmt|;
block|}
comment|/* endif: not forward match */
comment|/* found either forward/reverse 2 operand match here */
if|if
condition|(
name|t
operator|->
name|operands
operator|==
literal|3
condition|)
block|{
name|overlap2
operator|=
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|overlap2
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap1
argument_list|,
name|overlap2
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
condition|)
continue|continue;
block|}
comment|/* found either forward/reverse 2 or 3 operand match here: 	       slip through to break */
block|}
break|break;
comment|/* we've found a match; break out of loop */
block|}
comment|/* for (t = ... */
if|if
condition|(
name|t
operator|==
name|current_templates
operator|->
name|end
condition|)
block|{
comment|/* we found no match */
name|as_bad
argument_list|(
literal|"operands given don't match any known 386 instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Copy the template we found.  */
name|i
operator|.
name|tm
operator|=
operator|*
name|t
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator||=
name|wait_prefix
expr_stmt|;
if|if
condition|(
name|found_reverse_match
condition|)
block|{
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|1
index|]
operator|=
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* If the matched instruction specifies an explicit opcode suffix,        use it - and make sure none has already been specified.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|Data16
operator||
name|Data32
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
name|as_bad
argument_list|(
literal|"extraneous opcode suffix given"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Data16
condition|)
name|i
operator|.
name|suffix
operator|=
name|WORD_OPCODE_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|DWORD_OPCODE_SUFFIX
expr_stmt|;
block|}
comment|/* If there's no opcode suffix we try to invent one based on register        operands. */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|reg_operands
condition|)
block|{
comment|/* We take i.suffix from the LAST register operand specified.  This 	   assumes that the last register operands is the destination register 	   operand. */
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
literal|0
init|;
name|op
operator|<
name|MAX_OPERANDS
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
condition|?
name|BYTE_OPCODE_SUFFIX
else|:
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
operator|)
condition|?
name|WORD_OPCODE_SUFFIX
else|:
name|DWORD_OPCODE_SUFFIX
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|!=
literal|0
operator|&&
name|i
operator|.
name|reg_operands
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|i
operator|.
name|operands
operator|-
literal|1
index|]
operator|&
name|Reg
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|bad
decl_stmt|;
comment|/* If the last operand is a register, make sure it is            compatible with the suffix.  */
name|bad
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|BYTE_OPCODE_SUFFIX
case|:
comment|/* If this is an eight bit register, it's OK.  If it's the                16 or 32 bit version of an eight bit register, we will                just use the low portion, and that's OK too.  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|i
operator|.
name|operands
operator|-
literal|1
index|]
operator|&
name|Reg8
operator|)
operator|==
literal|0
operator|&&
name|i
operator|.
name|regs
index|[
name|i
operator|.
name|operands
operator|-
literal|1
index|]
operator|->
name|reg_num
operator|>=
literal|4
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|WORD_OPCODE_SUFFIX
case|:
case|case
name|DWORD_OPCODE_SUFFIX
case|:
comment|/* We don't insist on the presence or absence of the e                prefix on the register, but we reject eight bit                registers.  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|i
operator|.
name|operands
operator|-
literal|1
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bad
condition|)
name|as_bad
argument_list|(
literal|"register does not match opcode suffix"
argument_list|)
expr_stmt|;
block|}
comment|/* Make still unresolved immediate matches conform to size of immediate        given in i.suffix. Note:  overlap2 cannot be an immediate!        We assume this. */
if|if
condition|(
operator|(
name|overlap0
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator|)
operator|)
operator|&&
name|overlap0
operator|!=
name|Imm8
operator|&&
name|overlap0
operator|!=
name|Imm8S
operator|&&
name|overlap0
operator|!=
name|Imm16
operator|&&
name|overlap0
operator|!=
name|Imm32
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
name|as_bad
argument_list|(
literal|"no opcode suffix given; can't determine immediate size"
argument_list|)
expr_stmt|;
return|return;
block|}
name|overlap0
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_OPCODE_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
condition|?
name|Imm16
else|:
name|Imm32
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|overlap1
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator|)
operator|)
operator|&&
name|overlap1
operator|!=
name|Imm8
operator|&&
name|overlap1
operator|!=
name|Imm8S
operator|&&
name|overlap1
operator|!=
name|Imm16
operator|&&
name|overlap1
operator|!=
name|Imm32
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
name|as_bad
argument_list|(
literal|"no opcode suffix given; can't determine immediate size"
argument_list|)
expr_stmt|;
return|return;
block|}
name|overlap1
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_OPCODE_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
condition|?
name|Imm16
else|:
name|Imm32
operator|)
operator|)
expr_stmt|;
block|}
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|=
name|overlap0
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|=
name|overlap1
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|=
name|overlap2
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap1
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap2
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|Imm1
condition|)
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
comment|/* kludge for shift insns */
comment|/* Finalize opcode.  First, we change the opcode based on the operand        size given by i.suffix: we never have to change things for byte insns,        or when no opcode suffix is need to size the operands. */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|W
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"no opcode suffix given and no register operands; can't size instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|suffix
operator|!=
name|BYTE_OPCODE_SUFFIX
condition|)
block|{
comment|/* Select between byte and word/dword operations. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|W
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
name|W
expr_stmt|;
comment|/* Now select between word& dword operations via the 				   operand size prefix. */
if|if
condition|(
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
operator|)
operator|^
name|flag_16bit_code
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"%d prefixes given and data size prefix gives too many prefixes"
argument_list|,
name|MAX_PREFIXES
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|WORD_PREFIX_OPCODE
expr_stmt|;
block|}
block|}
comment|/* For insns with operands there are more diddles to do to the opcode. */
if|if
condition|(
name|i
operator|.
name|operands
condition|)
block|{
comment|/* Default segment register this instruction will use 	   for memory accesses.  0 means unknown. 	   This is only for optimizing out unnecessary segment overrides.  */
specifier|const
name|seg_entry
modifier|*
name|default_seg
init|=
literal|0
decl_stmt|;
comment|/* True if this instruction uses a memory addressing mode, 	   and therefore may need an address-size prefix.  */
name|int
name|uses_mem_addrmode
init|=
literal|0
decl_stmt|;
comment|/* If we found a reverse match we must alter the opcode direction bit 	   found_reverse_match holds bit to set (different for int& 	   float insns). */
if|if
condition|(
name|found_reverse_match
condition|)
block|{
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
name|found_reverse_match
expr_stmt|;
block|}
comment|/* The imul $imm, %reg instruction is converted into 	   imul $imm, %reg, %reg. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|imulKludge
condition|)
block|{
comment|/* Pretend we saw the 3 operand case. */
name|i
operator|.
name|regs
index|[
literal|2
index|]
operator|=
name|i
operator|.
name|regs
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|=
literal|2
expr_stmt|;
block|}
comment|/* The clr %reg instruction is converted into xor %reg, %reg.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|iclrKludge
condition|)
block|{
name|i
operator|.
name|regs
index|[
literal|1
index|]
operator|=
name|i
operator|.
name|regs
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Certain instructions expect the destination to be in the i.rm.reg 	   field.  This is by far the exceptional case.  For these 	   instructions, if the source operand is a register, we must reverse 	   the i.rm.reg and i.rm.regmem fields.  We accomplish this by faking 	   that the two register operands were given in the reverse order. */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ReverseRegRegmem
operator|)
operator|&&
name|i
operator|.
name|reg_operands
operator|==
literal|2
condition|)
block|{
name|unsigned
name|int
name|first_reg_operand
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|second_reg_operand
init|=
name|first_reg_operand
operator|+
literal|1
decl_stmt|;
name|reg_entry
modifier|*
name|tmp
init|=
name|i
operator|.
name|regs
index|[
name|first_reg_operand
index|]
decl_stmt|;
name|i
operator|.
name|regs
index|[
name|first_reg_operand
index|]
operator|=
name|i
operator|.
name|regs
index|[
name|second_reg_operand
index|]
expr_stmt|;
name|i
operator|.
name|regs
index|[
name|second_reg_operand
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ShortForm
condition|)
block|{
comment|/* The register or float register operand is in operand 0 or 1. */
name|unsigned
name|int
name|op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|FloatReg
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Register goes in low 3 bits of opcode. */
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
name|i
operator|.
name|regs
index|[
name|op
index|]
operator|->
name|reg_num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ShortFormW
condition|)
block|{
comment|/* Short form with 0x8 width bit.  Register is always dest. operand */
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
name|i
operator|.
name|regs
index|[
literal|1
index|]
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
operator|||
name|i
operator|.
name|suffix
operator|==
name|DWORD_OPCODE_SUFFIX
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
literal|0x8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Seg2ShortForm
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
name|POP_SEG_SHORT
operator|&&
name|i
operator|.
name|regs
index|[
literal|0
index|]
operator|->
name|reg_num
operator|==
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"you can't 'pop cs' on the 386."
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
operator|(
name|i
operator|.
name|regs
index|[
literal|0
index|]
operator|->
name|reg_num
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Seg3ShortForm
condition|)
block|{
comment|/* 'push %fs' is 0x0fa0; 'pop %fs' is 0x0fa1. 	       'push %gs' is 0x0fa8; 'pop %fs' is 0x0fa9. 	       So, only if i.regs[0]->reg_num == 5 (%gs) do we need 	       to change the opcode. */
if|if
condition|(
name|i
operator|.
name|regs
index|[
literal|0
index|]
operator|->
name|reg_num
operator|==
literal|5
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
literal|0x08
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
operator|~
name|DW
operator|)
operator|==
name|MOV_AX_DISP32
condition|)
block|{
comment|/* This is a special non-modrm instruction 	       that addresses memory with a 32-bit displacement mode anyway, 	       and thus requires an address-size prefix if in 16-bit mode.  */
name|uses_mem_addrmode
operator|=
literal|1
expr_stmt|;
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
comment|/* The opcode is completed (modulo i.tm.extension_opcode which 	       must be put into the modrm byte). 	       Now, we make the modrm& index base bytes based on all the 	       info we've collected. */
comment|/* i.reg_operands MUST be the number of real register operands; 	       implicit registers do not count. */
if|if
condition|(
name|i
operator|.
name|reg_operands
operator|==
literal|2
condition|)
block|{
name|unsigned
name|int
name|source
decl_stmt|,
name|dest
decl_stmt|;
name|source
operator|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|RegMMX
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|dest
operator|=
name|source
operator|+
literal|1
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
comment|/* We must be careful to make sure that all 		   segment/control/test/debug/MMX registers go into 		   the i.rm.reg field (despite the whether they are 		   source or destination operands). */
if|if
condition|(
name|i
operator|.
name|regs
index|[
name|dest
index|]
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|RegMMX
operator|)
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|regs
index|[
name|dest
index|]
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|regs
index|[
name|source
index|]
operator|->
name|reg_num
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|regs
index|[
name|source
index|]
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|regs
index|[
name|dest
index|]
operator|->
name|reg_num
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if it's not 2 reg operands... */
if|if
condition|(
name|i
operator|.
name|mem_operands
condition|)
block|{
name|unsigned
name|int
name|fake_zero_displacement
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Mem
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Mem
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
decl_stmt|;
comment|/* Encode memory operand into modrm byte and base index 		       byte. */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|esp
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/*<disp>(%esp) becomes two byte modrm with no index 			   register. */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|base
operator|=
name|ESP_REG_NUM
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
literal|0
expr_stmt|;
comment|/* Must be zero! */
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|ebp
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp
operator|)
condition|)
block|{
comment|/* Must fake a zero byte displacement.  There is 			       no direct way to code '(%ebp)' directly. */
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
comment|/* fake_zero_displacement code does not set this. */
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
block|}
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|EBP_REG_NUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|BaseIndex
operator|)
condition|)
block|{
comment|/* There are three cases here. 			   Case 1:  '<32bit disp>(,1)' -- indirect absolute. 			   (Same as cases 2& 3 with NO index register) 			   Case 2:<32bit disp> (,<index>) -- no base register with disp 			   Case 3:  (,<index>)       --- no base register; 			   no disp (must add 32bit 0 disp). */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* 32bit mode */
name|i
operator|.
name|bi
operator|.
name|base
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32
expr_stmt|;
comment|/* Must be 32bit! */
if|if
condition|(
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/* case 2 or case 3 */
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|==
literal|0
condition|)
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
comment|/* case 3 */
block|}
else|else
block|{
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|&&
operator|!
name|i
operator|.
name|base_reg
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/* Operand is just<32bit disp> */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|EBP_REG_NUM
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32
expr_stmt|;
block|}
else|else
block|{
comment|/* It's not a special case; rev'em up. */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|index_reg
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|base
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|ebp
operator|&&
name|i
operator|.
name|disp_operands
operator|==
literal|0
condition|)
block|{
comment|/* pace */
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fake_zero_displacement
condition|)
block|{
comment|/* Fakes a zero displacement assuming that i.types[op] 			   holds the correct displacement size. */
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|disps
index|[
name|op
index|]
operator|=
name|exp
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Find the default segment for the memory operand. 		       Used to optimize out explicit segment specifications.  */
if|if
condition|(
name|i
operator|.
name|seg
condition|)
block|{
name|unsigned
name|int
name|seg_index
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|==
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
condition|)
block|{
name|seg_index
operator|=
operator|(
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|3
operator|)
operator||
name|i
operator|.
name|bi
operator|.
name|base
expr_stmt|;
name|default_seg
operator|=
name|two_byte_segment_defaults
index|[
name|seg_index
index|]
expr_stmt|;
block|}
else|else
block|{
name|seg_index
operator|=
operator|(
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|3
operator|)
operator||
name|i
operator|.
name|rm
operator|.
name|regmem
expr_stmt|;
name|default_seg
operator|=
name|one_byte_segment_defaults
index|[
name|seg_index
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* Fill in i.rm.reg or i.rm.regmem field with register 		   operand (if any) based on i.tm.extension_opcode. 		   Again, we must be careful to make sure that 		   segment/control/debug/test/MMX registers are coded 		   into the i.rm.reg field. */
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
name|unsigned
name|int
name|op
init|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|RegMMX
operator|)
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|RegMMX
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
operator|)
decl_stmt|;
comment|/* If there is an extension opcode to put here, the 		       register number must be put into the regmem field. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|regs
index|[
name|op
index|]
operator|->
name|reg_num
expr_stmt|;
else|else
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|regs
index|[
name|op
index|]
operator|->
name|reg_num
expr_stmt|;
comment|/* Now, if no memory operand has set i.rm.mode = 0, 1, 2 		       we must set it to 3 to indicate this is a register 		       operand int the regmem field */
if|if
condition|(
operator|!
name|i
operator|.
name|mem_operands
condition|)
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Fill in i.rm.reg field with extension opcode (if any). */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|tm
operator|.
name|extension_opcode
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|mode
operator|!=
literal|3
condition|)
name|uses_mem_addrmode
operator|=
literal|1
expr_stmt|;
block|}
comment|/* GAS currently doesn't support 16-bit memory addressing modes at all, 	   so if we're writing 16-bit code and using a memory addressing mode, 	   always spew out an address size prefix.  */
if|if
condition|(
name|uses_mem_addrmode
operator|&&
name|flag_16bit_code
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"%d prefixes given and address size override gives too many prefixes"
argument_list|,
name|MAX_PREFIXES
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|ADDR_PREFIX_OPCODE
expr_stmt|;
block|}
comment|/* If a segment was explicitly specified, 	   and the specified segment is not the default, 	   use an opcode prefix to select it. 	   If we never figured out what the default segment is, 	   then default_seg will be zero at this point, 	   and the specified segment prefix will always be used.  */
if|if
condition|(
operator|(
name|i
operator|.
name|seg
operator|)
operator|&&
operator|(
name|i
operator|.
name|seg
operator|!=
name|default_seg
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"%d prefixes given and %s segment override gives too many prefixes"
argument_list|,
name|MAX_PREFIXES
argument_list|,
name|i
operator|.
name|seg
operator|->
name|seg_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|i
operator|.
name|seg
operator|->
name|seg_prefix
expr_stmt|;
block|}
block|}
block|}
comment|/* Handle conversion of 'int $3' --> special int3 insn. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
name|INT_OPCODE
operator|&&
name|i
operator|.
name|imms
index|[
literal|0
index|]
operator|->
name|X_add_number
operator|==
literal|3
condition|)
block|{
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|=
name|INT3_OPCODE
expr_stmt|;
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We are ready to output the insn. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Output jumps. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Jump
condition|)
block|{
name|unsigned
name|long
name|n
init|=
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|fits_in_signed_byte
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|2
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
comment|/* It's an absolute word/dword displacement. */
comment|/* Use only 16-bit jumps for 16-bit code, 		   because text segments are limited to 64K anyway; 	           use only 32-bit jumps for 32-bit code, 		   because they're faster.  */
name|int
name|jmp_size
init|=
name|flag_16bit_code
condition|?
literal|2
else|:
literal|4
decl_stmt|;
if|if
condition|(
name|flag_16bit_code
operator|&&
operator|!
name|fits_in_signed_word
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"16-bit jump out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
name|JUMP_PC_RELATIVE
condition|)
block|{
comment|/* pace */
comment|/* unconditional jump */
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|+
name|jmp_size
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
operator|+
name|jmp_size
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0xe9
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|,
operator|(
name|valueT
operator|)
name|n
argument_list|,
name|jmp_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* conditional jump */
name|p
operator|=
name|frag_more
argument_list|(
literal|2
operator|+
name|jmp_size
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|2
operator|+
name|jmp_size
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|+
literal|0x10
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
operator|(
name|valueT
operator|)
name|n
argument_list|,
name|jmp_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|flag_16bit_code
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|WORD_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* It's a symbol; end frag& setup for relax. 	       Make sure there are more than 6 chars left in the current frag; 	       if not we'll have to start a new one. */
name|frag_grow
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|6
argument_list|,
comment|/* 2 opcode/prefix + 4 displacement */
literal|1
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|==
name|JUMP_PC_RELATIVE
condition|?
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BYTE
argument_list|)
else|:
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BYTE
argument_list|)
operator|)
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_symbol
argument_list|,
operator|(
name|offsetT
operator|)
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|JumpByte
operator||
name|JumpDword
operator|)
condition|)
block|{
name|int
name|size
init|=
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpByte
operator|)
condition|?
literal|1
else|:
literal|4
decl_stmt|;
name|unsigned
name|long
name|n
init|=
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_number
decl_stmt|;
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
comment|/* The jcx/jecx instruction might need a data size prefix.  */
for|for
control|(
name|q
operator|=
name|i
operator|.
name|prefix
init|;
name|q
operator|<
name|i
operator|.
name|prefix
operator|+
name|i
operator|.
name|prefixes
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
name|WORD_PREFIX_OPCODE
condition|)
block|{
comment|/* The jcxz/jecxz instructions are marked with Data16 		   and Data32, which means that they may get 		   WORD_PREFIX_OPCODE added to the list of prefixes. 		   However, the are correctly distinguished using 		   ADDR_PREFIX_OPCODE.  Here we look for 		   WORD_PREFIX_OPCODE, and actually emit 		   ADDR_PREFIX_OPCODE.  This is a hack, but, then, so 		   is the instruction itself.  		   If an explicit suffix is used for the loop 		   instruction, that actually controls whether we use 		   cx vs. ecx.  This is also controlled by 		   ADDR_PREFIX_OPCODE.  		   I don't know if there is any valid case in which we 		   want to emit WORD_PREFIX_OPCODE, but I am keeping 		   the old behaviour for safety.  */
if|if
condition|(
name|IS_JUMP_ON_CX_ZERO
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
operator|||
name|IS_LOOP_ECX_TIMES
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
condition|)
name|FRAG_APPEND_1_CHAR
argument_list|(
name|ADDR_PREFIX_OPCODE
argument_list|)
expr_stmt|;
else|else
name|FRAG_APPEND_1_CHAR
argument_list|(
name|WORD_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|size
operator|==
literal|4
operator|)
operator|&&
operator|(
name|flag_16bit_code
operator|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|WORD_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fits_in_unsigned_byte
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* opcode can be at most two bytes */
name|insn_size
operator|+=
literal|2
expr_stmt|;
comment|/* put out high byte first: can't use md_number_to_chars! */
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|n
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
operator|&&
operator|!
name|fits_in_signed_byte
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"loop/jecx only takes byte displacement; %lu shortened to %d"
argument_list|,
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|reloc
argument_list|(
name|size
argument_list|,
literal|1
argument_list|,
name|i
operator|.
name|disp_reloc
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpInterSegment
condition|)
block|{
if|if
condition|(
name|flag_16bit_code
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|WORD_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|+
literal|2
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* 1 opcode; 2 segment; 4 offset */
name|insn_size
operator|+=
literal|1
operator|+
literal|2
operator|+
literal|4
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_op
operator|==
name|O_constant
condition|)
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|imms
index|[
literal|0
index|]
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"can't handle non absolute segment in long call/jmp"
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|5
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|imms
index|[
literal|0
index|]
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output normal instructions here. */
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Hack for fwait.  It must come before any prefixes, as it 	   really is an instruction rather than a prefix. */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|FWait
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|FWAIT_OPCODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The prefix bytes. */
for|for
control|(
name|q
operator|=
name|i
operator|.
name|prefix
init|;
name|q
operator|<
name|i
operator|.
name|prefix
operator|+
name|i
operator|.
name|prefixes
condition|;
name|q
operator|++
control|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
operator|*
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now the opcode; be careful about word order here! */
if|if
condition|(
name|fits_in_unsigned_byte
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fits_in_unsigned_word
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|2
expr_stmt|;
comment|/* put out high byte first: can't use md_number_to_chars! */
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* opcode is either 3 or 4 bytes */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff000000
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|3
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* Now the modrm byte and base index byte (if present). */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
comment|/* md_number_to_chars (p, i.rm, 1); */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|<<
literal|0
operator||
name|i
operator|.
name|rm
operator|.
name|reg
operator|<<
literal|3
operator||
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|6
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If i.rm.regmem == ESP (4)&& i.rm.mode != Mode 3 (Register mode) 				   ==> need second modrm byte. */
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|==
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
operator|&&
name|i
operator|.
name|rm
operator|.
name|mode
operator|!=
literal|3
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
comment|/* md_number_to_chars (p, i.bi, 1); */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|i
operator|.
name|bi
operator|.
name|base
operator|<<
literal|0
operator||
name|i
operator|.
name|bi
operator|.
name|index
operator|<<
literal|3
operator||
name|i
operator|.
name|bi
operator|.
name|scale
operator|<<
literal|6
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|disp_operands
condition|)
block|{
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|disps
index|[
name|n
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp8
operator||
name|Abs8
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp16
operator||
name|Abs16
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|2
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Disp32|Abs32 */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not absolute_section */
comment|/* need a 32-bit fixup (don't support 8bit non-absolute disps) */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
argument_list|,
literal|0
argument_list|,
name|TC_RELOC
argument_list|(
name|i
operator|.
name|disp_reloc
index|[
name|n
index|]
argument_list|,
name|BFD_RELOC_32
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end displacement output */
comment|/* output immediate */
if|if
condition|(
name|i
operator|.
name|imm_operands
condition|)
block|{
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|imms
index|[
name|n
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm16
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|2
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not absolute_section */
comment|/* Need a 32-bit fixup (don't support 8bit 			   non-absolute ims).  Try to support other 			   sizes ... */
name|int
name|r_type
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|pcrel
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
name|size
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
else|else
name|size
operator|=
literal|4
expr_stmt|;
name|r_type
operator|=
name|reloc
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|i
operator|.
name|disp_reloc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_32
operator|&&
name|GOT_symbol
operator|&&
name|GOT_symbol
operator|==
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_symbol
operator|&&
operator|(
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
operator|(
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_op
operator|==
name|O_add
operator|&&
operator|(
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_op_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_subtract
operator|)
operator|)
operator|)
condition|)
block|{
name|r_type
operator|=
name|BFD_RELOC_386_GOTPC
expr_stmt|;
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
operator|+=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end immediate output */
block|}
ifdef|#
directive|ifdef
name|DEBUG386
if|if
condition|(
name|flag_debug
condition|)
block|{
name|pi
argument_list|(
name|line
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG386 */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero    on error. */
end_comment

begin_function
specifier|static
name|int
name|i386_operand
parameter_list|(
name|operand_string
parameter_list|)
name|char
modifier|*
name|operand_string
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|op_string
init|=
name|operand_string
decl_stmt|;
comment|/* Address of '\0' at end of operand_string. */
name|char
modifier|*
name|end_of_operand_string
init|=
name|operand_string
operator|+
name|strlen
argument_list|(
name|operand_string
argument_list|)
decl_stmt|;
comment|/* Start and end of displacement string expression (if found). */
name|char
modifier|*
name|displacement_string_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|displacement_string_end
init|=
name|NULL
decl_stmt|;
comment|/* We check for an absolute prefix (differentiating,      for example, 'jmp pc_relative_label' from 'jmp *absolute_label'. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
name|op_string
operator|++
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
comment|/* Check if operand is a register. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
specifier|register
name|reg_entry
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|parse_register
argument_list|(
name|op_string
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad register name ('%s')"
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for segment override, rather than segment register by 	 searching for ':' after %<x>s where<x> = s, c, d, e, f, g. */
if|if
condition|(
operator|(
name|r
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
operator|)
operator|&&
name|op_string
index|[
literal|3
index|]
operator|==
literal|':'
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|reg_num
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|gs
expr_stmt|;
break|break;
block|}
name|op_string
operator|+=
literal|4
expr_stmt|;
comment|/* skip %<x> s : */
name|operand_string
operator|=
name|op_string
expr_stmt|;
comment|/* Pretend given string starts here. */
if|if
condition|(
operator|!
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|!
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|*
name|op_string
operator|!=
literal|'('
operator|&&
operator|*
name|op_string
operator|!=
name|ABSOLUTE_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad memory operand after segment override"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Handle case of %es:*foo. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
name|op_string
operator|++
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
goto|goto
name|do_memory_reference
goto|;
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|r
operator|->
name|reg_type
expr_stmt|;
name|i
operator|.
name|regs
index|[
name|this_operand
index|]
operator|=
name|r
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|IMMEDIATE_PREFIX
condition|)
block|{
comment|/* ... or an immediate */
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|segT
name|exp_seg
init|=
literal|0
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|imm_operands
operator|==
name|MAX_IMMEDIATE_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"only 1 or 2 immediate operands are allowed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|exp
operator|=
operator|&
name|im_expressions
index|[
name|i
operator|.
name|imm_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|imms
index|[
name|this_operand
index|]
operator|=
name|exp
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|++
name|op_string
expr_stmt|;
comment|/* must advance op_string! */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\0'
condition|)
block|{
comment|/* This should be as_bad, but some versions of gcc, up to              about 2.8 and egcs 1.01, generate a bogus @GOTOFF(%ebx)              in certain cases.  Oddly, the code in question turns out              to work correctly anyhow, so we make this just a warning              until those versions of gcc are obsolete.  */
name|as_warn
argument_list|(
literal|"warning: unrecognized characters `%s' in expression"
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
comment|/* missing or bad expr becomes absolute 0 */
name|as_bad
argument_list|(
literal|"missing or invalid immediate expression '%s' taken as 0"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|smallest_imm_type
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_AOUT
elseif|else
if|if
condition|(
name|exp_seg
operator|!=
name|text_section
operator|&&
name|exp_seg
operator|!=
name|data_section
operator|&&
name|exp_seg
operator|!=
name|bss_section
operator|&&
name|exp_seg
operator|!=
name|undefined_section
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|exp_seg
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|seg_unimplemented
label|:
name|as_bad
argument_list|(
literal|"Unimplemented segment type %d in parse_operand"
argument_list|,
name|exp_seg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
else|else
block|{
comment|/* this is an address ==> 32bit */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm32
expr_stmt|;
block|}
comment|/* shorten this type of this operand if the instruction wants        * fewer bits than are present in the immediate.  The bit field        * code can put out 'andb $0xffffff, %al', for example.   pace        * also 'movw $foo,(%eax)'        */
switch|switch
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
case|case
name|WORD_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm16
expr_stmt|;
break|break;
case|case
name|BYTE_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm16
operator||
name|Imm8
operator||
name|Imm8S
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
operator|*
name|op_string
operator|==
literal|'('
condition|)
block|{
comment|/* This is a memory reference of some sort. */
specifier|register
name|char
modifier|*
name|base_string
decl_stmt|;
name|unsigned
name|int
name|found_base_index_form
decl_stmt|;
name|do_memory_reference
label|:
if|if
condition|(
name|i
operator|.
name|mem_operands
operator|==
name|MAX_MEMORY_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"more than 1 memory reference in instruction"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
comment|/* Determine type of memory operand from opcode_suffix; 	 no opcode suffix implies general memory references. */
switch|switch
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
case|case
name|BYTE_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Mem8
expr_stmt|;
break|break;
case|case
name|WORD_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Mem16
expr_stmt|;
break|break;
case|case
name|DWORD_OPCODE_SUFFIX
case|:
default|default:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Mem32
expr_stmt|;
block|}
comment|/* Check for base index form.  We detect the base index form by 	 looking for an ')' at the end of the operand, searching 	 for the '(' matching it, and finding a REGISTER_PREFIX or ',' 	 after it. */
name|base_string
operator|=
name|end_of_operand_string
operator|-
literal|1
expr_stmt|;
name|found_base_index_form
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
block|{
name|unsigned
name|int
name|parens_balanced
init|=
literal|1
decl_stmt|;
comment|/* We've already checked that the number of left& right ()'s are 	     equal, so this loop will not be infinite. */
do|do
block|{
name|base_string
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
name|parens_balanced
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|'('
condition|)
name|parens_balanced
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|parens_balanced
condition|)
do|;
name|base_string
operator|++
expr_stmt|;
comment|/* Skip past '('. */
if|if
condition|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
operator|||
operator|*
name|base_string
operator|==
literal|','
condition|)
name|found_base_index_form
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we can't parse a base index register expression, we've found 	 a pure displacement expression.  We set up displacement_string_start 	 and displacement_string_end for the code below. */
if|if
condition|(
operator|!
name|found_base_index_form
condition|)
block|{
name|displacement_string_start
operator|=
name|op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|end_of_operand_string
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|base_reg_name
decl_stmt|,
modifier|*
name|index_reg_name
decl_stmt|,
modifier|*
name|num_string
decl_stmt|;
name|int
name|num
decl_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
comment|/* If there is a displacement set-up for it to be parsed later. */
if|if
condition|(
name|base_string
operator|!=
name|op_string
operator|+
literal|1
condition|)
block|{
name|displacement_string_start
operator|=
name|op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|base_string
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Find base register (if any). */
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|','
condition|)
block|{
name|base_reg_name
operator|=
name|base_string
operator|++
expr_stmt|;
comment|/* skip past register name& parse it */
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
name|base_string
operator|++
expr_stmt|;
if|if
condition|(
name|base_string
operator|==
name|base_reg_name
operator|+
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't find base register name after '(%c'"
argument_list|,
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|=
name|parse_register
argument_list|(
name|base_reg_name
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad base register name ('%s')"
argument_list|,
name|base_reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RESTORE_END_STRING
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
block|}
comment|/* Now check seperator; must be ',' ==> index reg 			   OR num ==> no index reg. just scale factor 			   OR ')' ==> end. (scale factor = 1) */
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|','
operator|&&
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting ',' or ')' after base register in `%s'"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* There may index reg here; and there may be a scale factor. */
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
operator|&&
operator|*
operator|(
name|base_string
operator|+
literal|1
operator|)
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|index_reg_name
operator|=
operator|++
name|base_string
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
operator|++
name|base_string
argument_list|)
condition|)
empty_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|index_reg
operator|=
name|parse_register
argument_list|(
name|index_reg_name
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad index register name ('%s')"
argument_list|,
name|index_reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RESTORE_END_STRING
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
block|}
comment|/* Check for scale factor. */
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
operator|&&
name|isdigit
argument_list|(
operator|*
operator|(
name|base_string
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|num_string
operator|=
operator|++
name|base_string
expr_stmt|;
while|while
condition|(
name|is_digit_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
name|base_string
operator|++
expr_stmt|;
if|if
condition|(
name|base_string
operator|==
name|num_string
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't find a scale factor after ','"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
comment|/* We've got a scale factor. */
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|num_string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|num
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't parse scale factor from '%s'"
argument_list|,
name|num_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RESTORE_END_STRING
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
comment|/* must be 1 digit scale */
case|case
literal|1
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"expecting scale factor of 1, 2, 4, 8; got %d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
operator|&&
operator|*
name|base_string
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting index register or scale factor after ','; got '%c'"
argument_list|,
operator|*
operator|(
name|base_string
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* If there's an expression begining the operand, parse it, 	 assuming displacement_string_start and displacement_string_end 	 are meaningful. */
if|if
condition|(
name|displacement_string_start
condition|)
block|{
specifier|register
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|segT
name|exp_seg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
index|]
expr_stmt|;
name|i
operator|.
name|disps
index|[
name|this_operand
index|]
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|NO_RELOC
expr_stmt|;
name|i
operator|.
name|disp_operands
operator|++
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|displacement_string_start
expr_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|displacement_string_end
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
block|{
comment|/* 	     * We can have operands of the form 	     *<symbol>@GOTOFF+<nnn> 	     * Take the easy way out here and copy everything 	     * into a temporary buffer... 	     */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmpbuf
decl_stmt|;
if|if
condition|(
name|GOT_symbol
operator|==
name|NULL
condition|)
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
expr_stmt|;
name|tmpbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|cp
operator|-
name|input_line_pointer
operator|)
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"PLT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_386_PLT32
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|cp
operator|+
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"GOTOFF"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_386_GOTOFF
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|cp
operator|+
literal|1
operator|+
literal|6
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"GOT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_386_GOT32
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|cp
operator|+
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Bad reloc specifier '%s' in expression"
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|tmpbuf
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* We do this to make sure that the section symbol is in 	     the symbol table.  We will ultimately change the relocation 	     to be relative to the beginning of the section */
if|if
condition|(
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_386_GOTOFF
condition|)
block|{
if|if
condition|(
name|S_IS_LOCAL
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|undefined_section
condition|)
name|section_symbol
argument_list|(
name|exp
operator|->
name|X_add_symbol
operator|->
name|bsym
operator|->
name|section
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
name|GOT_symbol
expr_stmt|;
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_32
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
literal|"Ignoring junk '%s' after expression"
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|displacement_string_end
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
comment|/* missing expr becomes absolute 0 */
name|as_bad
argument_list|(
literal|"missing or invalid displacement '%s' taken as 0"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
operator|(
name|Disp
operator||
name|Abs
operator|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|SMALLEST_DISP_TYPE
argument_list|(
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp_seg
operator|==
name|text_section
operator|||
name|exp_seg
operator|==
name|data_section
operator|||
name|exp_seg
operator|==
name|bss_section
operator|||
name|exp_seg
operator|==
name|undefined_section
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Disp32
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|OBJ_AOUT
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Disp32
expr_stmt|;
else|#
directive|else
goto|goto
name|seg_unimplemented
goto|;
endif|#
directive|endif
block|}
block|}
comment|/* Make sure the memory operand we've been dealt is valid. */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|index_reg
operator|&&
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
name|Reg
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"register size mismatch in (base,index,scale) expression"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*        * special case for (%dx) while doing input/output op        */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|==
operator|(
name|Reg16
operator||
name|InOutPortReg
operator|)
operator|)
operator|&&
operator|(
name|i
operator|.
name|index_reg
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|InOutPortReg
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg32
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
name|Reg32
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"base/index register must be 32 bit register"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|i
operator|.
name|index_reg
operator|&&
name|i
operator|.
name|index_reg
operator|==
name|esp
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s may not be used as an index register"
argument_list|,
name|esp
operator|->
name|reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* it's not a memory operand; argh! */
name|as_bad
argument_list|(
literal|"invalid char %s begining %s operand '%s'"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|op_string
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|this_operand
index|]
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* normal return */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			md_estimate_size_before_relax()  *  * Called just before relax().  * Any symbol that is now undefined will not become defined.  * Return the correct fr_subtype in the frag.  * Return the initial "guess for fr_var" to caller.  * The guess for fr_var is ACTUALLY the growth beyond fr_fix.  * Whatever we do to grow fr_fix or fr_var contributes to our returned value.  * Although it may not be explicit in the frag, pretend fr_var starts with a  * 0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
specifier|register
name|int
name|old_fr_fix
decl_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* We've already got fragP->fr_subtype right;  all we have to do is check 	   for un-relaxable symbols. */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
condition|)
block|{
comment|/* symbol is undefined in this segment */
switch|switch
condition|(
name|opcode
index|[
literal|0
index|]
condition|)
block|{
case|case
name|JUMP_PC_RELATIVE
case|:
comment|/* make jmp (0xeb) a dword displacement jump */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
comment|/* dword disp jmp */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
operator|(
name|GOT_symbol
operator|&&
comment|/* Not quite right - we should switch on 				     presence of @PLT, but I cannot see how 				     to get to that from here.  We should have 				     done this in md_assemble to really 				     get it right all of the time, but I 				     think it does not matter that much, as 				     this will be right most of the time. ERY*/
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|undefined_section
operator|)
condition|?
name|BFD_RELOC_386_PLT32
else|:
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This changes the byte-displacement jump 0x7N --> 			   the dword-displacement jump 0x0f8N */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
comment|/* two-byte escape */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|4
expr_stmt|;
comment|/* we've added an opcode byte */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
operator|(
name|GOT_symbol
operator|&&
comment|/* Not quite right - we should switch on 				     presence of @PLT, but I cannot see how 				     to get to that from here.  ERY */
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|undefined_section
operator|)
condition|?
name|BFD_RELOC_386_PLT32
else|:
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
break|break;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fragP
operator|->
name|fr_var
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			md_convert_frag();  *  * Called after relax() is finished.  * In:	Address of frag.  *	fr_type == rs_machine_dependent.  *	fr_subtype is what the address relaxed to.  *  * Out:	Any fixSs and constants are set up.  *	Caller will turn frag into a ".space 0".  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
name|segT
name|sec
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
else|#
directive|else
function|void md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|segT
name|sec
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|char
modifier|*
name|where_to_put_displacement
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|target_address
decl_stmt|;
name|unsigned
name|int
name|opcode_address
decl_stmt|;
name|unsigned
name|int
name|extension
init|=
literal|0
decl_stmt|;
name|int
name|displacement_from_opcode_start
decl_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* Address we want to reach in file space. */
name|target_address
operator|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* not needed otherwise? */
name|target_address
operator|+=
name|fragP
operator|->
name|fr_symbol
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
endif|#
directive|endif
comment|/* Address opcode resides at in file space. */
name|opcode_address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* Displacement from opcode start to fill into instruction. */
name|displacement_from_opcode_start
operator|=
name|target_address
operator|-
name|opcode_address
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BYTE
argument_list|)
case|:
comment|/* don't have to change opcode */
name|extension
operator|=
literal|1
expr_stmt|;
comment|/* 1 opcode + 1 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|WORD
argument_list|)
case|:
name|opcode
index|[
literal|1
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|opcode
index|[
literal|2
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|WORD_PREFIX_OPCODE
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
comment|/* 3 opcode + 2 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|WORD
argument_list|)
case|:
name|opcode
index|[
literal|1
index|]
operator|=
literal|0xe9
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|WORD_PREFIX_OPCODE
expr_stmt|;
name|extension
operator|=
literal|3
expr_stmt|;
comment|/* 2 opcode + 2 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|DWORD
argument_list|)
case|:
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|extension
operator|=
literal|5
expr_stmt|;
comment|/* 2 opcode + 4 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|DWORD
argument_list|)
case|:
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
comment|/* 1 opcode + 4 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* now put displacement after opcode */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|where_to_put_displacement
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|displacement_from_opcode_start
operator|-
name|extension
argument_list|)
argument_list|,
name|SIZE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of byte displacement jmp */
end_comment

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of dword displacement jmp */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xeb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* opcode for byte-disp jump */
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|flag_do_long_jump
condition|)
block|{
name|offset
operator|=
name|to_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|to_symbol
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* opcode for long jmp */
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|5
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Apply a fixup (fixS) to segment data, once it has been determined    by our caller that we have all the info we need to fix it up.     On the 386, immediates, displacements, and data pointers are all in    the same (little-endian) format, so we don't need to care about which    we are handling.  */
end_comment

begin_function
name|int
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valp
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* The fix we're to put in.  */
name|valueT
modifier|*
name|valp
decl_stmt|;
comment|/* Pointer to the value of the bits.  */
name|segT
name|seg
decl_stmt|;
comment|/* Segment fix is from.  */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valp
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32
operator|&&
name|fixP
operator|->
name|fx_pcrel
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_Mach
argument_list|)
comment|/*    * This is a hack.  There should be a better way to    * handle this.    */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
ifndef|#
directive|ifndef
name|OBJ_AOUT
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_coff_flavour
condition|)
name|value
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|seg
operator|||
operator|(
name|fixP
operator|->
name|fx_addsy
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Yes, we add the values in twice.  This is because 	     bfd_perform_relocation subtracts them out again.  I think 	     bfd_perform_relocation is broken, but I don't dare change 	     it.  FIXME.  */
name|value
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|&&
name|defined
argument_list|(
name|TE_PE
argument_list|)
comment|/* For some reason, the PE format does not store a section          address offset for a PC relative symbol.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
condition|)
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Fix a few things - the dynamic linker expects certain values here,      and we must not dissappoint it. */
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_386_PLT32
case|:
comment|/* Make the jump instruction point to the address of the operand.  At 	 runtime we merely add the offset to the actual PLT entry. */
name|value
operator|=
literal|0xfffffffc
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_386_GOTPC
case|:
comment|/*  *  This is tough to explain.  We end up with this one if we have  * operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal  * here is to obtain the absolute address of the GOT, and it is strongly  * preferable from a performance point of view to avoid using a runtime  * relocation for this.  The actual sequence of instructions often look   * something like:  *   * 	call	.L66  * .L66:  * 	popl	%ebx  * 	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx  *   * 	The call and pop essentially return the absolute address of  * the label .L66 and store it in %ebx.  The linker itself will  * ultimately change the first operand of the addl so that %ebx points to  * the GOT, but to keep things simple, the .o file must have this operand  * set so that it generates not the absolute address of .L66, but the  * absolute address of itself.  This allows the linker itself simply  * treat a GOTPC relocation as asking for a pcrel offset to the GOT to be  * added in, and the addend of the relocation is stored in the operand  * field for the instruction itself.  *   * 	Our job here is to fix the operand so that it would add the correct  * offset so that %ebx would point to itself.  The thing that is tricky is  * that .-.L66 will point to the beginning of the instruction, so we need  * to further modify the operand so that it will point to itself.  * There are other cases where you have something like:  *   * 	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]  *   * and here no correction would be required.  Internally in the assembler  * we treat operands of this form as not being pcrel since the '.' is   * explicitly mentioned, and I wonder whether it would simplify matters  * to do it this way.  Who knows.  In earlier versions of the PIC patches,  * the pcrel_adjust field was used to store the correction, but since the  * expression is not pcrel, I felt it would be confusing to do it this way.  */
name|value
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_386_GOT32
case|:
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Fully resolved at runtime.  No addend. */
break|break;
case|case
name|BFD_RELOC_386_GOTOFF
case|:
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is never used.  */
end_comment

begin_comment
unit|long
comment|/* Knows about the byte order in a word. */
end_comment

begin_comment
unit|md_chars_to_number (con, nbytes)      unsigned char con[];
comment|/* Low order byte 1st. */
end_comment

begin_comment
unit|int nbytes;
comment|/* Number of bytes in the input. */
end_comment

begin_endif
unit|{   long retval;   for (retval = 0, con += nbytes - 1; nbytes--; con--)     {       retval<<= BITS_PER_CHAR;       retval |= *con;     }   return retval; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn the string pointed to by litP into a floating point constant of type    type, and emit the appropriate bytes.  The number of LITTLENUMS emitted    is stored in *sizeP .  An error message is returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to md_atof ()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loops outputs the LITTLENUMs in REVERSE order; in accord with      the bigendian 386.  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|char
name|output_invalid_buf
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|output_invalid
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"(0x%x)"
argument_list|,
operator|(
name|unsigned
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
name|output_invalid_buf
return|;
block|}
end_function

begin_comment
comment|/* reg_string starts *before* REGISTER_PREFIX */
end_comment

begin_function
specifier|static
name|reg_entry
modifier|*
name|parse_register
parameter_list|(
name|reg_string
parameter_list|)
name|char
modifier|*
name|reg_string
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|reg_string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|reg_name_given
index|[
name|MAX_REG_NAME_SIZE
index|]
decl_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* skip REGISTER_PREFIX */
for|for
control|(
name|p
operator|=
name|reg_name_given
init|;
name|is_register_char
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|p
operator|++
operator|,
name|s
operator|++
control|)
block|{
operator|*
name|p
operator|=
name|register_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|reg_name_given
operator|+
name|MAX_REG_NAME_SIZE
condition|)
return|return
operator|(
name|reg_entry
operator|*
operator|)
literal|0
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name_given
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"kmVQ:"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"m"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'m'
case|:
name|flag_do_long_jump
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
comment|/* -k: Ignore for FreeBSD compatibility.  */
case|case
literal|'k'
case|:
break|break;
comment|/* -V: SVR4 argument to print version ID.  */
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section 	 should be emitted or not.  FIXME: Not implemented.  */
case|case
literal|'Q'
case|:
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ -m			do long jump\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_MAYBE_ELF
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_MAYBE_COFF
end_ifdef

begin_comment
comment|/* Pick the target format to use.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_target_format
parameter_list|()
block|{
switch|switch
condition|(
name|OUTPUT_FLAVOR
condition|)
block|{
case|case
name|bfd_target_coff_flavour
case|:
return|return
literal|"coff-i386"
return|;
case|case
name|bfd_target_elf_flavour
case|:
return|return
literal|"elf32-i386"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_MAYBE_COFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_MAYBE_ELF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|'G'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|name
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"GOT already in symbol table"
argument_list|)
expr_stmt|;
name|GOT_symbol
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
name|GOT_symbol
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_AOUT
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* For a.out, force the section size to be aligned.  If we don't do      this, BFD will align it for us, but it will not write out the      final bytes of the section.  This may be a bug in BFD, but it is      easier to fix it here since that is how the other a.out targets      work.  */
name|int
name|align
decl_stmt|;
name|align
operator|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|(
name|valueT
operator|)
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?  On the    i386, they're relative to the address of the offset, plus its    size. (??? Is this right?  FIXME-SOON!) */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|I386COFF
end_ifndef

begin_function
specifier|static
name|void
name|s_bss
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|void
name|i386_validate_fix
parameter_list|(
name|fixp
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|&&
name|fixp
operator|->
name|fx_subsy
operator|==
name|GOT_symbol
condition|)
block|{
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_386_GOTOFF
expr_stmt|;
name|fixp
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|F
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|)
value|(((SZ)<< 1) + (PCREL))
end_define

begin_define
define|#
directive|define
name|MAP
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|,
name|TYPE
parameter_list|)
value|case F(SZ,PCREL): code = (TYPE); break
end_define

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_386_PLT32
case|:
case|case
name|BFD_RELOC_386_GOT32
case|:
case|case
name|BFD_RELOC_386_GOTOFF
case|:
case|case
name|BFD_RELOC_386_GOTPC
case|:
case|case
name|BFD_RELOC_RVA
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|F
argument_list|(
name|fixp
operator|->
name|fx_size
argument_list|,
name|fixp
operator|->
name|fx_pcrel
argument_list|)
condition|)
block|{
name|MAP
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
default|default:
name|as_bad
argument_list|(
literal|"Can not do %d byte %srelocation"
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|,
name|fixp
operator|->
name|fx_pcrel
condition|?
literal|"pc-relative "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|MAP
undef|#
directive|undef
name|F
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_32
operator|&&
name|GOT_symbol
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|GOT_symbol
condition|)
name|code
operator|=
name|BFD_RELOC_386_GOTPC
expr_stmt|;
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|fixp
operator|->
name|fx_addsy
operator|->
name|bsym
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Cannot represent relocation type %s"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
operator|)
end_if

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
comment|/*    * In: length of relocation (or of address) in chars: 1, 2 or 4.    * Out: GNU LD relocation length code: 0, 1, or 2.    */
specifier|static
specifier|const
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|long
name|r_symbolnum
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT or OBJ_BOUT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I386COFF
argument_list|)
end_if

begin_function
name|short
name|tc_coff_fix2rtype
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|R_IMAGEBASE
condition|)
return|return
name|R_IMAGEBASE
return|;
return|return
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_PCRBYTE
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_PCRWORD
else|:
name|R_PCRLONG
operator|)
else|:
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_RELBYTE
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_RELWORD
else|:
name|R_DIR32
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tc_coff_sizemachdep
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
if|if
condition|(
name|frag
operator|->
name|fr_next
condition|)
return|return
operator|(
name|frag
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|frag
operator|->
name|fr_address
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I386COFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER? */
end_comment

begin_escape
end_escape

begin_comment
comment|/* end of tc-i386.c */
end_comment

end_unit

