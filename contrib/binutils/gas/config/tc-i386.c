begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-i386.c -- Assemble code for the Intel 80386    Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* Intel 80386 machine specific gas.    Written by Eliot Dresselhaus (eliot@mgm.mit.edu).    x86_64 support by Jan Hubicka (jh@suse.cz)    VIA PadLock support by Michal Ludvig (mludvig@suse.cz)    Bugs& suggestions are completely welcome.  This is free software.    Please help us make it better.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"dw2gencfi.h"
end_include

begin_include
include|#
directive|include
file|"elf/x86-64.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_WARNINGS
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_WARNINGS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INFER_ADDR_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|INFER_ADDR_PREFIX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SCALE1_WHEN_NO_INDEX
end_ifndef

begin_comment
comment|/* Specifying a scale factor besides 1 when there is no index is    futile.  eg. `mov (%ebx,2),%al' does exactly the same as    `mov (%ebx),%al'.  To slavishly follow what the programmer    specified, set SCALE1_WHEN_NO_INDEX to 0.  */
end_comment

begin_define
define|#
directive|define
name|SCALE1_WHEN_NO_INDEX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_ARCH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|"i386"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INLINE
end_ifndef

begin_if
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
end_if

begin_define
define|#
directive|define
name|INLINE
value|__inline__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|set_code_flag
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_16bit_gcc_code_flag
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_intel_syntax
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_cpu_arch
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_function_decl
specifier|static
name|void
name|pe_directive_secrel
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|signed_cons
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|output_invalid
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i386_operand
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i386_intel_operand
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|reg_entry
modifier|*
name|parse_register
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parse_insn
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parse_operands
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_operands
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_2_operands
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|optimize_imm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|optimize_disp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|match_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_string
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_suffix
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_byte_reg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_long_reg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_qword_reg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_word_reg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|finalize_imm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_operands
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|seg_entry
modifier|*
name|build_modrm_byte
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_insn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_imm
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|offsetT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_disp
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|offsetT
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|I386COFF
end_ifndef

begin_function_decl
specifier|static
name|void
name|s_bss
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|handle_large_common
parameter_list|(
name|int
name|small
name|ATTRIBUTE_UNUSED
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_arch
init|=
name|DEFAULT_ARCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'md_assemble ()' gathers together information and puts it into a    i386_insn.  */
end_comment

begin_union
union|union
name|i386_op
block|{
name|expressionS
modifier|*
name|disps
decl_stmt|;
name|expressionS
modifier|*
name|imms
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|regs
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|_i386_insn
block|{
comment|/* TM holds the template for the insn were currently assembling.  */
name|template
name|tm
decl_stmt|;
comment|/* SUFFIX holds the instruction mnemonic suffix if given.        (e.g. 'l' for 'movl')  */
name|char
name|suffix
decl_stmt|;
comment|/* OPERANDS gives the number of given operands.  */
name|unsigned
name|int
name|operands
decl_stmt|;
comment|/* REG_OPERANDS, DISP_OPERANDS, MEM_OPERANDS, IMM_OPERANDS give the number        of given register, displacement, memory operands and immediate        operands.  */
name|unsigned
name|int
name|reg_operands
decl_stmt|,
name|disp_operands
decl_stmt|,
name|mem_operands
decl_stmt|,
name|imm_operands
decl_stmt|;
comment|/* TYPES [i] is the type (see above #defines) which tells us how to        use OP[i] for the corresponding operand.  */
name|unsigned
name|int
name|types
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Displacement expression, immediate expression, or register for each        operand.  */
name|union
name|i386_op
name|op
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Flags for operands.  */
name|unsigned
name|int
name|flags
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
define|#
directive|define
name|Operand_PCrel
value|1
comment|/* Relocation type for operand */
name|enum
name|bfd_reloc_code_real
name|reloc
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* BASE_REG, INDEX_REG, and LOG2_SCALE_FACTOR are used to encode        the base index byte below.  */
specifier|const
name|reg_entry
modifier|*
name|base_reg
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|index_reg
decl_stmt|;
name|unsigned
name|int
name|log2_scale_factor
decl_stmt|;
comment|/* SEG gives the seg_entries of this insn.  They are zero unless        explicit segment overrides are given.  */
specifier|const
name|seg_entry
modifier|*
name|seg
index|[
literal|2
index|]
decl_stmt|;
comment|/* PREFIX holds all the given prefix opcodes (usually null).        PREFIXES is the number of prefix opcodes.  */
name|unsigned
name|int
name|prefixes
decl_stmt|;
name|unsigned
name|char
name|prefix
index|[
name|MAX_PREFIXES
index|]
decl_stmt|;
comment|/* RM and SIB are the modrm byte and the sib byte where the        addressing modes of this insn are encoded.  */
name|modrm_byte
name|rm
decl_stmt|;
name|rex_byte
name|rex
decl_stmt|;
name|sib_byte
name|sib
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|_i386_insn
name|i386_insn
typedef|;
end_typedef

begin_comment
comment|/* List of chars besides those in app.c:symbol_chars that can start an    operand.  Used to prevent the scrubber eating vital white-space.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|extra_symbol_chars
index|[]
init|=
literal|"*%-(["
ifdef|#
directive|ifdef
name|LEX_AT
literal|"@"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LEX_QM
literal|"?"
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|TE_I386AIX
argument_list|)
expr|\
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|TE_GNU
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|TE_NETWARE
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|TE_FreeBSD
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|)
operator|)
end_if

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  The option    --divide will remove '/' from this list.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|i386_comment_chars
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SVR4_COMMENT_CHARS
value|1
end_define

begin_define
define|#
directive|define
name|PREFIX_SEPARATOR
value|'\\'
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|i386_comment_chars
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PREFIX_SEPARATOR
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.    Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.    Also note that comments started like this one will always work if    '/' isn't otherwise defined.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point    nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant    As in 0f12.456    or    0d1.2345e12.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDxX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tables for lexical analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mnemonic_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|operand_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|identifier_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|digit_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lexical macros.  */
end_comment

begin_define
define|#
directive|define
name|is_mnemonic_char
parameter_list|(
name|x
parameter_list|)
value|(mnemonic_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_operand_char
parameter_list|(
name|x
parameter_list|)
value|(operand_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_register_char
parameter_list|(
name|x
parameter_list|)
value|(register_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_space_char
parameter_list|(
name|x
parameter_list|)
value|((x) == ' ')
end_define

begin_define
define|#
directive|define
name|is_identifier_char
parameter_list|(
name|x
parameter_list|)
value|(identifier_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_digit_char
parameter_list|(
name|x
parameter_list|)
value|(digit_chars[(unsigned char) x])
end_define

begin_comment
comment|/* All non-digit non-letter characters that may occur in an operand.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|operand_special_chars
index|[]
init|=
literal|"%$-+(,)*._~/<>|&^!:[@]"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* md_assemble() always leaves the strings it's passed unaltered.  To    effect this we maintain a stack of saved characters that we've smashed    with '\0's (indicating end of strings for various sub-fields of the    assembler instruction).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_stack
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_stack_p
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|END_STRING_AND_SAVE
parameter_list|(
name|s
parameter_list|)
define|\
value|do { *save_stack_p++ = *(s); *(s) = '\0'; } while (0)
end_define

begin_define
define|#
directive|define
name|RESTORE_END_STRING
parameter_list|(
name|s
parameter_list|)
define|\
value|do { *(s) = *--save_stack_p; } while (0)
end_define

begin_comment
comment|/* The instruction we're assembling.  */
end_comment

begin_decl_stmt
specifier|static
name|i386_insn
name|i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Possible templates for current insn.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|templates
modifier|*
name|current_templates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per instruction expressionS buffers: max displacements& immediates.  */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|disp_expressions
index|[
name|MAX_MEMORY_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|expressionS
name|im_expressions
index|[
name|MAX_IMMEDIATE_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current operand we are working on.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We support four different modes.  FLAG_CODE variable is used to distinguish    these.  */
end_comment

begin_enum
enum|enum
name|flag_code
block|{
name|CODE_32BIT
block|,
name|CODE_16BIT
block|,
name|CODE_64BIT
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|NUM_FLAG_CODE
value|((int) CODE_64BIT + 1)
end_define

begin_decl_stmt
specifier|static
name|enum
name|flag_code
name|flag_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|object_64bit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_rela_relocations
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The names used to print error messages.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|flag_code_names
index|[]
init|=
block|{
literal|"32"
block|,
literal|"16"
block|,
literal|"64"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 for intel syntax,    0 if att syntax.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|intel_syntax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if register prefix % not required.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allow_naked_reg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register prefix used for error message.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|register_prefix
init|=
literal|"%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in 16 bit gcc mode to add an l suffix to call, ret, enter,    leave, push, and pop instructions so that gcc has the same stack    frame as in 32 bit mode.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|stackop_size
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero to optimize code alignment.  */
end_comment

begin_decl_stmt
name|int
name|optimize_align_code
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero to quieten some warnings.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|quiet_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpu_arch_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpu_sub_arch_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU feature flags.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cpu_arch_flags
init|=
name|CpuUnknownFlags
operator||
name|CpuNo64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we have selected a cpu we are generating instructions for.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_arch_tune_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cpu we are generating instructions for.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|processor_type
name|cpu_arch_tune
init|=
name|PROCESSOR_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU feature flags of cpu we are generating instructions for.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cpu_arch_tune_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU instruction set architecture used.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|processor_type
name|cpu_arch_isa
init|=
name|PROCESSOR_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU feature flags of instruction set architecture used.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cpu_arch_isa_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If set, conditional jumps are not automatically promoted to handle    larger than a byte offset.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|no_cond_jump_promotion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The dwarf2 return column, adjusted for 32 or 64 bit.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|x86_dwarf2_return_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
end_comment

begin_decl_stmt
name|int
name|x86_cie_data_alignment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interface to relax_segment.    There are 3 major relax states for 386 jump insns because the    different types of jumps add different sizes to frags when we're    figuring out what sort of jump to choose to reach a given label.  */
end_comment

begin_comment
comment|/* Types.  */
end_comment

begin_define
define|#
directive|define
name|UNCOND_JUMP
value|0
end_define

begin_define
define|#
directive|define
name|COND_JUMP
value|1
end_define

begin_define
define|#
directive|define
name|COND_JUMP86
value|2
end_define

begin_comment
comment|/* Sizes.  */
end_comment

begin_define
define|#
directive|define
name|CODE16
value|1
end_define

begin_define
define|#
directive|define
name|SMALL
value|0
end_define

begin_define
define|#
directive|define
name|SMALL16
value|(SMALL | CODE16)
end_define

begin_define
define|#
directive|define
name|BIG
value|2
end_define

begin_define
define|#
directive|define
name|BIG16
value|(BIG | CODE16)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|INLINE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|INLINE
value|__inline__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ENCODE_RELAX_STATE
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|)
define|\
value|((relax_substateT) (((type)<< 2) | (size)))
end_define

begin_define
define|#
directive|define
name|TYPE_FROM_RELAX_STATE
parameter_list|(
name|s
parameter_list|)
define|\
value|((s)>> 2)
end_define

begin_define
define|#
directive|define
name|DISP_SIZE_FROM_RELAX_STATE
parameter_list|(
name|s
parameter_list|)
define|\
value|((((s)& 3) == BIG ? 4 : (((s)& 3) == BIG16 ? 2 : 1)))
end_define

begin_comment
comment|/* This table is used by relax_frag to promote short jumps to long    ones where necessary.  SMALL (short) jumps may be promoted to BIG    (32 bit long) ones, and SMALL16 jumps to BIG16 (16 bit long).  We    don't allow a short jump in a 32 bit code segment to be promoted to    a 16 bit offset jump because it's slower (requires data size    prefix), and doesn't work, unless the destination is in the bottom    64k of the code segment (The top 16 bits of eip are zeroed).  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The fields are:      1) most positive reach of this state,      2) most negative reach of this state,      3) how many bytes this mode will have in the variable part of the frag      4) which index into the table to try if we can't fit into this one.  */
comment|/* UNCOND_JUMP states.  */
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|BIG
argument_list|)
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|BIG16
argument_list|)
block|}
block|,
comment|/* dword jmp adds 4 bytes to frag:      0 extra opcode bytes, 4 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* word jmp adds 2 byte2 to frag:      0 extra opcode bytes, 2 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
comment|/* COND_JUMP states.  */
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|BIG
argument_list|)
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|BIG16
argument_list|)
block|}
block|,
comment|/* dword conditionals adds 5 bytes to frag:      1 extra opcode byte, 4 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* word conditionals add 3 bytes to frag:      1 extra opcode byte, 2 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
comment|/* COND_JUMP86 states.  */
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP86
argument_list|,
argument|BIG
argument_list|)
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|1
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP86
argument_list|,
argument|BIG16
argument_list|)
block|}
block|,
comment|/* dword conditionals adds 5 bytes to frag:      1 extra opcode byte, 4 displacement bytes.  */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* word conditionals add 4 bytes to frag:      1 displacement byte and a 3 byte long branch insn.  */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arch_entry
name|cpu_arch
index|[]
init|=
block|{
block|{
literal|"generic32"
block|,
name|PROCESSOR_GENERIC32
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
block|}
block|,
block|{
literal|"generic64"
block|,
name|PROCESSOR_GENERIC64
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
block|}
block|,
block|{
literal|"i8086"
block|,
name|PROCESSOR_UNKNOWN
block|,
literal|0
block|}
block|,
block|{
literal|"i186"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|Cpu186
block|}
block|,
block|{
literal|"i286"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|Cpu186
operator||
name|Cpu286
block|}
block|,
block|{
literal|"i386"
block|,
name|PROCESSOR_GENERIC32
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
block|}
block|,
block|{
literal|"i486"
block|,
name|PROCESSOR_I486
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
block|}
block|,
block|{
literal|"i586"
block|,
name|PROCESSOR_PENTIUM
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
block|}
block|,
block|{
literal|"i686"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
block|}
block|,
block|{
literal|"pentium"
block|,
name|PROCESSOR_PENTIUM
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
block|}
block|,
block|{
literal|"pentiumpro"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
block|}
block|,
block|{
literal|"pentiumii"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuMMX
block|}
block|,
block|{
literal|"pentiumiii"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
block|}
block|,
block|{
literal|"pentium4"
block|,
name|PROCESSOR_PENTIUM4
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
block|}
block|,
block|{
literal|"prescott"
block|,
name|PROCESSOR_NOCONA
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
block|}
block|,
block|{
literal|"nocona"
block|,
name|PROCESSOR_NOCONA
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
block|}
block|,
block|{
literal|"yonah"
block|,
name|PROCESSOR_CORE
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
block|}
block|,
block|{
literal|"core"
block|,
name|PROCESSOR_CORE
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
block|}
block|,
block|{
literal|"merom"
block|,
name|PROCESSOR_CORE2
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
operator||
name|CpuSSSE3
block|}
block|,
block|{
literal|"core2"
block|,
name|PROCESSOR_CORE2
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
operator||
name|CpuSSSE3
block|}
block|,
block|{
literal|"k6"
block|,
name|PROCESSOR_K6
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|CpuK6
operator||
name|CpuMMX
block|}
block|,
block|{
literal|"k6_2"
block|,
name|PROCESSOR_K6
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|CpuK6
operator||
name|CpuMMX
operator||
name|Cpu3dnow
block|}
block|,
block|{
literal|"athlon"
block|,
name|PROCESSOR_ATHLON
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuK6
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|Cpu3dnow
operator||
name|Cpu3dnowA
block|}
block|,
block|{
literal|"sledgehammer"
block|,
name|PROCESSOR_K8
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuK6
operator||
name|CpuSledgehammer
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|Cpu3dnow
operator||
name|Cpu3dnowA
operator||
name|CpuSSE
operator||
name|CpuSSE2
block|}
block|,
block|{
literal|"opteron"
block|,
name|PROCESSOR_K8
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuK6
operator||
name|CpuSledgehammer
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|Cpu3dnow
operator||
name|Cpu3dnowA
operator||
name|CpuSSE
operator||
name|CpuSSE2
block|}
block|,
block|{
literal|"k8"
block|,
name|PROCESSOR_K8
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuK6
operator||
name|CpuSledgehammer
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|Cpu3dnow
operator||
name|Cpu3dnowA
operator||
name|CpuSSE
operator||
name|CpuSSE2
block|}
block|,
block|{
literal|"amdfam10"
block|,
name|PROCESSOR_AMDFAM10
block|,
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuK6
operator||
name|CpuSledgehammer
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|Cpu3dnow
operator||
name|Cpu3dnowA
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
operator||
name|CpuSSE4a
operator||
name|CpuABM
block|}
block|,
block|{
literal|".mmx"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
block|}
block|,
block|{
literal|".sse"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
block|}
block|,
block|{
literal|".sse2"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
block|}
block|,
block|{
literal|".sse3"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
block|}
block|,
block|{
literal|".ssse3"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
operator||
name|CpuSSSE3
block|}
block|,
block|{
literal|".sse4.1"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
operator||
name|CpuSSSE3
operator||
name|CpuSSE4_1
block|}
block|,
block|{
literal|".sse4.2"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
operator||
name|CpuSSSE3
operator||
name|CpuSSE4
block|}
block|,
block|{
literal|".sse4"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
operator||
name|CpuSSSE3
operator||
name|CpuSSE4
block|}
block|,
block|{
literal|".3dnow"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|Cpu3dnow
block|}
block|,
block|{
literal|".3dnowa"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|Cpu3dnow
operator||
name|Cpu3dnowA
block|}
block|,
block|{
literal|".padlock"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuPadLock
block|}
block|,
block|{
literal|".pacifica"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuSVME
block|}
block|,
block|{
literal|".svme"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuSVME
block|}
block|,
block|{
literal|".sse4a"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
operator||
name|CpuSSE3
operator||
name|CpuSSE4a
block|}
block|,
block|{
literal|".abm"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuABM
block|}
block|,
block|{
literal|".xsave"
block|,
name|PROCESSOR_UNKNOWN
block|,
name|CpuXSAVE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_ALIGN_PTWO
argument_list|)
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"arch"
block|,
name|set_cpu_arch
block|,
literal|0
block|}
block|,
ifndef|#
directive|ifndef
name|I386COFF
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"tfloat"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"value"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"slong"
block|,
name|signed_cons
block|,
literal|4
block|}
block|,
block|{
literal|"noopt"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"code16gcc"
block|,
name|set_16bit_gcc_code_flag
block|,
name|CODE_16BIT
block|}
block|,
block|{
literal|"code16"
block|,
name|set_code_flag
block|,
name|CODE_16BIT
block|}
block|,
block|{
literal|"code32"
block|,
name|set_code_flag
block|,
name|CODE_32BIT
block|}
block|,
block|{
literal|"code64"
block|,
name|set_code_flag
block|,
name|CODE_64BIT
block|}
block|,
block|{
literal|"intel_syntax"
block|,
name|set_intel_syntax
block|,
literal|1
block|}
block|,
block|{
literal|"att_syntax"
block|,
name|set_intel_syntax
block|,
literal|0
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
block|{
literal|"largecomm"
block|,
name|handle_large_common
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"file"
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
block|{
literal|"loc_mark_labels"
block|,
name|dwarf2_directive_loc_mark_labels
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TE_PE
block|{
literal|"secrel32"
block|,
name|pe_directive_secrel
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For interface with expression ().  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table for instruction mnemonic lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table for register lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|i386_align_code
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|int
name|count
parameter_list|)
block|{
comment|/* Various efficient no-op patterns for aligning code labels.      Note: Don't try to assemble the instructions in the comments.      0L and 0w are not legal.  */
specifier|static
specifier|const
name|char
name|f32_1
index|[]
init|=
block|{
literal|0x90
block|}
decl_stmt|;
comment|/* nop			*/
specifier|static
specifier|const
name|char
name|f32_2
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x90
block|}
decl_stmt|;
comment|/* xchg %ax,%ax */
specifier|static
specifier|const
name|char
name|f32_3
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x76
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f32_4
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi,1),%esi	*/
specifier|static
specifier|const
name|char
name|f32_5
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0(%esi,1),%esi	*/
specifier|static
specifier|const
name|char
name|f32_6
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f32_7
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi,1),%esi */
specifier|static
specifier|const
name|char
name|f32_8
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%esi,1),%esi */
specifier|static
specifier|const
name|char
name|f32_9
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|,
comment|/* movl %esi,%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_10
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x76
block|,
literal|0x00
block|,
comment|/* leal 0(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_11
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x26
block|,
literal|0x00
block|,
comment|/* leal 0(%esi,1),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_12
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbf
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi),%edi	*/
specifier|static
specifier|const
name|char
name|f32_13
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi),%esi	*/
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_14
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* leal 0L(%esi,1),%esi */
literal|0x8d
block|,
literal|0xbc
block|,
literal|0x27
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* leal 0L(%edi,1),%edi */
specifier|static
specifier|const
name|char
name|f32_15
index|[]
init|=
block|{
literal|0xeb
block|,
literal|0x0d
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
comment|/* jmp .+15; lotsa nops	*/
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
name|f16_3
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0(%esi),%esi	*/
specifier|static
specifier|const
name|char
name|f16_4
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%si),%si	*/
specifier|static
specifier|const
name|char
name|f16_5
index|[]
init|=
block|{
literal|0x90
block|,
comment|/* nop			*/
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%si),%si	*/
specifier|static
specifier|const
name|char
name|f16_6
index|[]
init|=
block|{
literal|0x89
block|,
literal|0xf6
block|,
comment|/* mov %si,%si		*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
name|f16_7
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0x74
block|,
literal|0x00
block|,
comment|/* lea 0(%si),%si	*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
name|f16_8
index|[]
init|=
block|{
literal|0x8d
block|,
literal|0xb4
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* lea 0w(%si),%si	*/
literal|0x8d
block|,
literal|0xbd
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* lea 0w(%di),%di	*/
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|f32_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|f32_3
block|,
name|f32_4
block|,
name|f32_5
block|,
name|f32_6
block|,
name|f32_7
block|,
name|f32_8
block|,
name|f32_9
block|,
name|f32_10
block|,
name|f32_11
block|,
name|f32_12
block|,
name|f32_13
block|,
name|f32_14
block|,
name|f32_15
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|f16_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|f16_3
block|,
name|f16_4
block|,
name|f16_5
block|,
name|f16_6
block|,
name|f16_7
block|,
name|f16_8
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|,
name|f32_15
block|}
decl_stmt|;
comment|/* nopl (%[re]ax) */
specifier|static
specifier|const
name|char
name|alt_3
index|[]
init|=
block|{
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopl 0(%[re]ax) */
specifier|static
specifier|const
name|char
name|alt_4
index|[]
init|=
block|{
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x40
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopl 0(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_5
index|[]
init|=
block|{
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopw 0(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_6
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopl 0L(%[re]ax) */
specifier|static
specifier|const
name|char
name|alt_7
index|[]
init|=
block|{
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopl 0L(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_8
index|[]
init|=
block|{
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x84
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopw 0L(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_9
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x84
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopw %cs:0L(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_10
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x2e
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x84
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* data16      nopw %cs:0L(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_long_11
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x66
block|,
literal|0x2e
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x84
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* data16      data16      nopw %cs:0L(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_long_12
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x2e
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x84
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* data16      data16      data16      nopw %cs:0L(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_long_13
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x2e
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x84
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* data16      data16      data16      data16      nopw %cs:0L(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_long_14
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x2e
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x84
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* data16      data16      data16      data16      data16      nopw %cs:0L(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_long_15
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x2e
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x84
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopl 0(%[re]ax,%[re]ax,1)      nopw 0(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_short_11
index|[]
init|=
block|{
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x66
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopw 0(%[re]ax,%[re]ax,1)      nopw 0(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_short_12
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x66
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopw 0(%[re]ax,%[re]ax,1)      nopl 0L(%[re]ax) */
specifier|static
specifier|const
name|char
name|alt_short_13
index|[]
init|=
block|{
literal|0x66
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopl 0L(%[re]ax)      nopl 0L(%[re]ax) */
specifier|static
specifier|const
name|char
name|alt_short_14
index|[]
init|=
block|{
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* nopl 0L(%[re]ax)      nopl 0L(%[re]ax,%[re]ax,1) */
specifier|static
specifier|const
name|char
name|alt_short_15
index|[]
init|=
block|{
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x84
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|alt_short_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|alt_3
block|,
name|alt_4
block|,
name|alt_5
block|,
name|alt_6
block|,
name|alt_7
block|,
name|alt_8
block|,
name|alt_9
block|,
name|alt_10
block|,
name|alt_short_11
block|,
name|alt_short_12
block|,
name|alt_short_13
block|,
name|alt_short_14
block|,
name|alt_short_15
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|alt_long_patt
index|[]
init|=
block|{
name|f32_1
block|,
name|f32_2
block|,
name|alt_3
block|,
name|alt_4
block|,
name|alt_5
block|,
name|alt_6
block|,
name|alt_7
block|,
name|alt_8
block|,
name|alt_9
block|,
name|alt_10
block|,
name|alt_long_11
block|,
name|alt_long_12
block|,
name|alt_long_13
block|,
name|alt_long_14
block|,
name|alt_long_15
block|}
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|||
name|count
operator|>
literal|15
condition|)
return|return;
comment|/* We need to decide which NOP sequence to use for 32bit and      64bit. When -mtune= is used:       1. For PROCESSOR_I486, PROCESSOR_PENTIUM and PROCESSOR_GENERIC32,      f32_patt will be used.      2. For PROCESSOR_K8 and PROCESSOR_AMDFAM10 in 64bit, NOPs with      0x66 prefix will be used.      3. For PROCESSOR_CORE2, alt_long_patt will be used.      4. For PROCESSOR_PENTIUMPRO, PROCESSOR_PENTIUM4, PROCESSOR_NOCONA,      PROCESSOR_CORE, PROCESSOR_CORE2, PROCESSOR_K6, PROCESSOR_ATHLON      and PROCESSOR_GENERIC64, alt_short_patt will be used.       When -mtune= isn't used, alt_short_patt will be used if      cpu_arch_isa_flags has Cpu686. Otherwise, f32_patt will be used.       When -march= or .arch is used, we can't use anything beyond      cpu_arch_isa_flags.   */
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
condition|)
block|{
name|memcpy
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|f16_patt
index|[
name|count
operator|-
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|8
condition|)
comment|/* Adjust jump offset.  */
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
index|]
operator|=
name|count
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
name|cpu_arch_tune
operator|==
name|PROCESSOR_K8
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nnops
init|=
operator|(
name|count
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|int
name|len
init|=
name|count
operator|/
name|nnops
decl_stmt|;
name|int
name|remains
init|=
name|count
operator|-
name|nnops
operator|*
name|len
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|/* The recommended way to pad 64bit code is to use NOPs preceded 	 by maximally four 0x66 prefixes.  Balance the size of nops.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remains
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
name|pos
argument_list|,
literal|0x66
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
operator|+
name|pos
operator|+
name|len
index|]
operator|=
literal|0x90
expr_stmt|;
name|pos
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|nnops
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
name|pos
argument_list|,
literal|0x66
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
operator|+
name|pos
operator|+
name|len
operator|-
literal|1
index|]
operator|=
literal|0x90
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|patt
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cpu_arch_isa
operator|==
name|PROCESSOR_UNKNOWN
condition|)
block|{
comment|/* PROCESSOR_UNKNOWN means that all ISAs may be used.  */
switch|switch
condition|(
name|cpu_arch_tune
condition|)
block|{
case|case
name|PROCESSOR_UNKNOWN
case|:
comment|/* We use cpu_arch_isa_flags to check if we SHOULD 		 optimize for Cpu686.  */
if|if
condition|(
operator|(
name|cpu_arch_isa_flags
operator|&
name|Cpu686
operator|)
operator|!=
literal|0
condition|)
name|patt
operator|=
name|alt_short_patt
expr_stmt|;
else|else
name|patt
operator|=
name|f32_patt
expr_stmt|;
break|break;
case|case
name|PROCESSOR_CORE2
case|:
name|patt
operator|=
name|alt_long_patt
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
case|case
name|PROCESSOR_PENTIUM4
case|:
case|case
name|PROCESSOR_NOCONA
case|:
case|case
name|PROCESSOR_CORE
case|:
case|case
name|PROCESSOR_K6
case|:
case|case
name|PROCESSOR_ATHLON
case|:
case|case
name|PROCESSOR_K8
case|:
case|case
name|PROCESSOR_GENERIC64
case|:
case|case
name|PROCESSOR_AMDFAM10
case|:
name|patt
operator|=
name|alt_short_patt
expr_stmt|;
break|break;
case|case
name|PROCESSOR_I486
case|:
case|case
name|PROCESSOR_PENTIUM
case|:
case|case
name|PROCESSOR_GENERIC32
case|:
name|patt
operator|=
name|f32_patt
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|cpu_arch_tune
condition|)
block|{
case|case
name|PROCESSOR_UNKNOWN
case|:
comment|/* When cpu_arch_isa is net, cpu_arch_tune shouldn't be 		 PROCESSOR_UNKNOWN.  */
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|PROCESSOR_I486
case|:
case|case
name|PROCESSOR_PENTIUM
case|:
case|case
name|PROCESSOR_PENTIUMPRO
case|:
case|case
name|PROCESSOR_PENTIUM4
case|:
case|case
name|PROCESSOR_NOCONA
case|:
case|case
name|PROCESSOR_CORE
case|:
case|case
name|PROCESSOR_K6
case|:
case|case
name|PROCESSOR_ATHLON
case|:
case|case
name|PROCESSOR_K8
case|:
case|case
name|PROCESSOR_AMDFAM10
case|:
case|case
name|PROCESSOR_GENERIC32
case|:
comment|/* We use cpu_arch_isa_flags to check if we CAN optimize 		 for Cpu686.  */
if|if
condition|(
operator|(
name|cpu_arch_isa_flags
operator|&
name|Cpu686
operator|)
operator|!=
literal|0
condition|)
name|patt
operator|=
name|alt_short_patt
expr_stmt|;
else|else
name|patt
operator|=
name|f32_patt
expr_stmt|;
break|break;
case|case
name|PROCESSOR_CORE2
case|:
if|if
condition|(
operator|(
name|cpu_arch_isa_flags
operator|&
name|Cpu686
operator|)
operator|!=
literal|0
condition|)
name|patt
operator|=
name|alt_long_patt
expr_stmt|;
else|else
name|patt
operator|=
name|f32_patt
expr_stmt|;
break|break;
case|case
name|PROCESSOR_GENERIC64
case|:
name|patt
operator|=
name|alt_short_patt
expr_stmt|;
break|break;
block|}
block|}
name|memcpy
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|patt
index|[
name|count
operator|-
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_var
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|mode_from_disp_size
parameter_list|(
name|unsigned
name|int
name|t
parameter_list|)
block|{
return|return
operator|(
name|t
operator|&
name|Disp8
operator|)
condition|?
literal|1
else|:
operator|(
name|t
operator|&
operator|(
name|Disp16
operator||
name|Disp32
operator||
name|Disp32S
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_byte
parameter_list|(
name|offsetT
name|num
parameter_list|)
block|{
return|return
operator|(
name|num
operator|>=
operator|-
literal|128
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|127
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_byte
parameter_list|(
name|offsetT
name|num
parameter_list|)
block|{
return|return
operator|(
name|num
operator|&
literal|0xff
operator|)
operator|==
name|num
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_word
parameter_list|(
name|offsetT
name|num
parameter_list|)
block|{
return|return
operator|(
name|num
operator|&
literal|0xffff
operator|)
operator|==
name|num
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_word
parameter_list|(
name|offsetT
name|num
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|32768
operator|<=
name|num
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|32767
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_signed_long
parameter_list|(
name|offsetT
name|num
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BFD64
return|return
literal|1
return|;
else|#
directive|else
return|return
operator|(
operator|!
operator|(
operator|(
operator|(
name|offsetT
operator|)
operator|-
literal|1
operator|<<
literal|31
operator|)
operator|&
name|num
operator|)
operator|||
operator|(
operator|(
operator|(
name|offsetT
operator|)
operator|-
literal|1
operator|<<
literal|31
operator|)
operator|&
name|num
operator|)
operator|==
operator|(
operator|(
name|offsetT
operator|)
operator|-
literal|1
operator|<<
literal|31
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* fits_in_signed_long() */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fits_in_unsigned_long
parameter_list|(
name|offsetT
name|num
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BFD64
return|return
literal|1
return|;
else|#
directive|else
return|return
operator|(
name|num
operator|&
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|num
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* fits_in_unsigned_long() */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|smallest_imm_type
parameter_list|(
name|offsetT
name|num
parameter_list|)
block|{
if|if
condition|(
name|cpu_arch_flags
operator|!=
operator|(
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|CpuNo64
operator|)
condition|)
block|{
comment|/* This code is disabled on the 486 because all the Imm1 forms 	 in the opcode table are slower on the i486.  They're the 	 versions with the implicitly specified single-position 	 displacement, which has another syntax if you really want to 	 use that form.  */
if|if
condition|(
name|num
operator|==
literal|1
condition|)
return|return
name|Imm1
operator||
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
return|;
block|}
return|return
operator|(
name|fits_in_signed_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8S
operator||
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator|)
else|:
name|fits_in_unsigned_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator|)
else|:
operator|(
name|fits_in_signed_word
argument_list|(
name|num
argument_list|)
operator|||
name|fits_in_unsigned_word
argument_list|(
name|num
argument_list|)
operator|)
condition|?
operator|(
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator|)
else|:
name|fits_in_signed_long
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator|)
else|:
name|fits_in_unsigned_long
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm32
operator||
name|Imm64
operator|)
else|:
name|Imm64
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|offsetT
name|offset_in_range
parameter_list|(
name|offsetT
name|val
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|addressT
name|mask
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|mask
operator|=
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mask
operator|=
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mask
operator|=
operator|(
operator|(
name|addressT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BFD64
case|case
literal|8
case|:
name|mask
operator|=
operator|(
operator|(
name|addressT
operator|)
literal|2
operator|<<
literal|63
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If BFD64, sign extend val.  */
if|if
condition|(
operator|!
name|use_rela_relocations
condition|)
if|if
condition|(
operator|(
name|val
operator|&
operator|~
operator|(
operator|(
operator|(
name|addressT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
operator|(
name|val
operator|^
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|-
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|~
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|val
operator|&
operator|~
name|mask
operator|)
operator|!=
operator|~
name|mask
condition|)
block|{
name|char
name|buf1
index|[
literal|40
index|]
decl_stmt|,
name|buf2
index|[
literal|40
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sprint_value
argument_list|(
name|buf2
argument_list|,
name|val
operator|&
name|mask
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s shortened to %s"
argument_list|)
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
return|return
name|val
operator|&
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Returns 0 if attempting to add a prefix where one from the same    class already exists, 1 if non rep/repne added, 2 if rep/repne    added.  */
end_comment

begin_function
specifier|static
name|int
name|add_prefix
parameter_list|(
name|unsigned
name|int
name|prefix
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|q
decl_stmt|;
if|if
condition|(
name|prefix
operator|>=
name|REX_OPCODE
operator|&&
name|prefix
operator|<
name|REX_OPCODE
operator|+
literal|16
operator|&&
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
operator|&
name|prefix
operator|&
name|REX_W
operator|)
operator|||
operator|(
operator|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
operator|&
operator|(
name|REX_R
operator||
name|REX_X
operator||
name|REX_B
operator|)
operator|)
operator|&&
operator|(
name|prefix
operator|&
operator|(
name|REX_R
operator||
name|REX_X
operator||
name|REX_B
operator|)
operator|)
operator|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|REX_PREFIX
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|prefix
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|CS_PREFIX_OPCODE
case|:
case|case
name|DS_PREFIX_OPCODE
case|:
case|case
name|ES_PREFIX_OPCODE
case|:
case|case
name|FS_PREFIX_OPCODE
case|:
case|case
name|GS_PREFIX_OPCODE
case|:
case|case
name|SS_PREFIX_OPCODE
case|:
name|q
operator|=
name|SEG_PREFIX
expr_stmt|;
break|break;
case|case
name|REPNE_PREFIX_OPCODE
case|:
case|case
name|REPE_PREFIX_OPCODE
case|:
name|ret
operator|=
literal|2
expr_stmt|;
comment|/* fall thru */
case|case
name|LOCK_PREFIX_OPCODE
case|:
name|q
operator|=
name|LOCKREP_PREFIX
expr_stmt|;
break|break;
case|case
name|FWAIT_OPCODE
case|:
name|q
operator|=
name|WAIT_PREFIX
expr_stmt|;
break|break;
case|case
name|ADDR_PREFIX_OPCODE
case|:
name|q
operator|=
name|ADDR_PREFIX
expr_stmt|;
break|break;
case|case
name|DATA_PREFIX_OPCODE
case|:
name|q
operator|=
name|DATA_PREFIX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|q
index|]
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|prefix
index|[
name|q
index|]
condition|)
operator|++
name|i
operator|.
name|prefixes
expr_stmt|;
name|i
operator|.
name|prefix
index|[
name|q
index|]
operator||=
name|prefix
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"same type of prefix used twice"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_code_flag
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|flag_code
operator|=
name|value
expr_stmt|;
name|cpu_arch_flags
operator|&=
operator|~
operator|(
name|Cpu64
operator||
name|CpuNo64
operator|)
expr_stmt|;
name|cpu_arch_flags
operator||=
operator|(
name|flag_code
operator|==
name|CODE_64BIT
condition|?
name|Cpu64
else|:
name|CpuNo64
operator|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|CODE_64BIT
operator|&&
operator|!
operator|(
name|cpu_arch_flags
operator|&
name|CpuSledgehammer
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"64bit mode not supported on this CPU."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|CODE_32BIT
operator|&&
operator|!
operator|(
name|cpu_arch_flags
operator|&
name|Cpu386
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"32bit mode not supported on this CPU."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stackop_size
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_16bit_gcc_code_flag
parameter_list|(
name|int
name|new_code_flag
parameter_list|)
block|{
name|flag_code
operator|=
name|new_code_flag
expr_stmt|;
name|cpu_arch_flags
operator|&=
operator|~
operator|(
name|Cpu64
operator||
name|CpuNo64
operator|)
expr_stmt|;
name|cpu_arch_flags
operator||=
operator|(
name|flag_code
operator|==
name|CODE_64BIT
condition|?
name|Cpu64
else|:
name|CpuNo64
operator|)
expr_stmt|;
name|stackop_size
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_intel_syntax
parameter_list|(
name|int
name|syntax_flag
parameter_list|)
block|{
comment|/* Find out if register prefixing is specified.  */
name|int
name|ask_naked_reg
init|=
literal|0
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|char
modifier|*
name|string
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|e
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"prefix"
argument_list|)
operator|==
literal|0
condition|)
name|ask_naked_reg
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"noprefix"
argument_list|)
operator|==
literal|0
condition|)
name|ask_naked_reg
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad argument to syntax directive."
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|e
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|intel_syntax
operator|=
name|syntax_flag
expr_stmt|;
if|if
condition|(
name|ask_naked_reg
operator|==
literal|0
condition|)
name|allow_naked_reg
operator|=
operator|(
name|intel_syntax
operator|&&
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|stdoutput
argument_list|)
operator|!=
literal|'\0'
operator|)
operator|)
expr_stmt|;
else|else
name|allow_naked_reg
operator|=
operator|(
name|ask_naked_reg
operator|<
literal|0
operator|)
expr_stmt|;
name|identifier_chars
index|[
literal|'%'
index|]
operator|=
name|intel_syntax
operator|&&
name|allow_naked_reg
condition|?
literal|'%'
else|:
literal|0
expr_stmt|;
name|identifier_chars
index|[
literal|'$'
index|]
operator|=
name|intel_syntax
condition|?
literal|'$'
else|:
literal|0
expr_stmt|;
name|register_prefix
operator|=
name|allow_naked_reg
condition|?
literal|""
else|:
literal|"%"
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_cpu_arch
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|char
modifier|*
name|string
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|e
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cpu_arch
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|cpu_arch
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|!=
literal|'.'
condition|)
block|{
name|cpu_arch_name
operator|=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|cpu_sub_arch_name
operator|=
name|NULL
expr_stmt|;
name|cpu_arch_flags
operator|=
operator|(
name|cpu_arch
index|[
name|i
index|]
operator|.
name|flags
operator||
operator|(
name|flag_code
operator|==
name|CODE_64BIT
condition|?
name|Cpu64
else|:
name|CpuNo64
operator|)
operator|)
expr_stmt|;
name|cpu_arch_isa
operator|=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|cpu_arch_isa_flags
operator|=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
if|if
condition|(
operator|!
name|cpu_arch_tune_set
condition|)
block|{
name|cpu_arch_tune
operator|=
name|cpu_arch_isa
expr_stmt|;
name|cpu_arch_tune_flags
operator|=
name|cpu_arch_isa_flags
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|cpu_arch_flags
operator||
name|cpu_arch
index|[
name|i
index|]
operator|.
name|flags
operator|)
operator|!=
name|cpu_arch_flags
condition|)
block|{
name|cpu_sub_arch_name
operator|=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|cpu_arch_flags
operator||=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|e
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|ARRAY_SIZE
argument_list|(
name|cpu_arch
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such architecture: `%s'"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|e
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing cpu architecture"
argument_list|)
argument_list|)
expr_stmt|;
name|no_cond_jump_promotion
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
literal|1
index|]
index|]
condition|)
block|{
name|char
modifier|*
name|string
init|=
operator|++
name|input_line_pointer
decl_stmt|;
name|int
name|e
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"nojumps"
argument_list|)
operator|==
literal|0
condition|)
name|no_cond_jump_promotion
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"jumps"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such architecture modifier: `%s'"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|e
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|long
name|i386_mach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"x86_64"
argument_list|)
condition|)
return|return
name|bfd_mach_x86_64
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"i386"
argument_list|)
condition|)
return|return
name|bfd_mach_i386_i386
return|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown architecture"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|hash_err
decl_stmt|;
comment|/* Initialize op_hash hash table.  */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|const
name|template
modifier|*
name|optab
decl_stmt|;
name|templates
modifier|*
name|core_optab
decl_stmt|;
comment|/* Setup for loop.  */
name|optab
operator|=
name|i386_optab
expr_stmt|;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
name|optab
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|++
name|optab
expr_stmt|;
if|if
condition|(
name|optab
operator|->
name|name
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|optab
operator|->
name|name
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* different name --> ship out current template list; 	       add to hash table;& begin anew.  */
name|core_optab
operator|->
name|end
operator|=
name|optab
expr_stmt|;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|core_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optab
operator|->
name|name
operator|==
name|NULL
condition|)
break|break;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
name|optab
expr_stmt|;
block|}
block|}
block|}
comment|/* Initialize reg_hash hash table.  */
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|const
name|reg_entry
modifier|*
name|regtab
decl_stmt|;
name|unsigned
name|int
name|regtab_size
init|=
name|i386_regtab_size
decl_stmt|;
for|for
control|(
name|regtab
operator|=
name|i386_regtab
init|;
name|regtab_size
operator|--
condition|;
name|regtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|regtab
operator|->
name|reg_name
argument_list|,
operator|(
name|PTR
operator|)
name|regtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
name|regtab
operator|->
name|reg_name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fill in lexical tables:  mnemonic_chars, operand_chars.  */
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|digit_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISLOWER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|mnemonic_chars
index|[
name|c
index|]
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
operator|||
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|128
condition|)
block|{
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LEX_AT
name|identifier_chars
index|[
literal|'@'
index|]
operator|=
literal|'@'
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LEX_QM
name|identifier_chars
index|[
literal|'?'
index|]
operator|=
literal|'?'
expr_stmt|;
name|operand_chars
index|[
literal|'?'
index|]
operator|=
literal|'?'
expr_stmt|;
endif|#
directive|endif
name|digit_chars
index|[
literal|'-'
index|]
operator|=
literal|'-'
expr_stmt|;
name|mnemonic_chars
index|[
literal|'-'
index|]
operator|=
literal|'-'
expr_stmt|;
name|mnemonic_chars
index|[
literal|'.'
index|]
operator|=
literal|'.'
expr_stmt|;
name|identifier_chars
index|[
literal|'_'
index|]
operator|=
literal|'_'
expr_stmt|;
name|identifier_chars
index|[
literal|'.'
index|]
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|operand_special_chars
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
name|operand_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|IS_ELF
condition|)
block|{
name|record_alignment
argument_list|(
name|text_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|data_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
name|x86_dwarf2_return_column
operator|=
literal|16
expr_stmt|;
name|x86_cie_data_alignment
operator|=
operator|-
literal|8
expr_stmt|;
block|}
else|else
block|{
name|x86_dwarf2_return_column
operator|=
literal|8
expr_stmt|;
name|x86_cie_data_alignment
operator|=
operator|-
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i386_print_statistics
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"i386 opcode"
argument_list|,
name|op_hash
argument_list|)
expr_stmt|;
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"i386 register"
argument_list|,
name|reg_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG386
end_ifdef

begin_comment
comment|/* Debugging routines for md_assemble.  */
end_comment

begin_function_decl
specifier|static
name|void
name|pte
parameter_list|(
name|template
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pt
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pe
parameter_list|(
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps
parameter_list|(
name|symbolS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|pi
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|i386_insn
modifier|*
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: template "
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|pte
argument_list|(
operator|&
name|x
operator|->
name|tm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  address: base %s  index %s  scale %x\n"
argument_list|,
name|x
operator|->
name|base_reg
condition|?
name|x
operator|->
name|base_reg
operator|->
name|reg_name
else|:
literal|"none"
argument_list|,
name|x
operator|->
name|index_reg
condition|?
name|x
operator|->
name|index_reg
operator|->
name|reg_name
else|:
literal|"none"
argument_list|,
name|x
operator|->
name|log2_scale_factor
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  modrm:  mode %x  reg %x  reg/mem %x\n"
argument_list|,
name|x
operator|->
name|rm
operator|.
name|mode
argument_list|,
name|x
operator|->
name|rm
operator|.
name|reg
argument_list|,
name|x
operator|->
name|rm
operator|.
name|regmem
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  sib:  base %x  index %x  scale %x\n"
argument_list|,
name|x
operator|->
name|sib
operator|.
name|base
argument_list|,
name|x
operator|->
name|sib
operator|.
name|index
argument_list|,
name|x
operator|->
name|sib
operator|.
name|scale
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  rex: 64bit %x  extX %x  extY %x  extZ %x\n"
argument_list|,
operator|(
name|x
operator|->
name|rex
operator|&
name|REX_W
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|x
operator|->
name|rex
operator|&
name|REX_R
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|x
operator|->
name|rex
operator|&
name|REX_X
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|x
operator|->
name|rex
operator|&
name|REX_B
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d:  "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|x
operator|->
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|RegMMX
operator||
name|RegXMM
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|x
operator|->
name|op
index|[
name|i
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Imm
condition|)
name|pe
argument_list|(
name|x
operator|->
name|op
index|[
name|i
index|]
operator|.
name|imms
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Disp
condition|)
name|pe
argument_list|(
name|x
operator|->
name|op
index|[
name|i
index|]
operator|.
name|disps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pte
parameter_list|(
name|template
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" %d operands "
argument_list|,
name|t
operator|->
name|operands
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"opcode %x "
argument_list|,
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"ext %x "
argument_list|,
name|t
operator|->
name|extension_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|D
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"W"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d type "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|t
operator|->
name|operand_types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pe
parameter_list|(
name|expressionS
modifier|*
name|e
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    operation     %d\n"
argument_list|,
name|e
operator|->
name|X_op
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_number    %ld (%lx)\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|X_add_number
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_add_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|X_op_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    op_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ps
parameter_list|(
name|symbolS
modifier|*
name|s
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s type %s%s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|,
name|S_IS_EXTERNAL
argument_list|(
name|s
argument_list|)
condition|?
literal|"EXTERNAL "
else|:
literal|""
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|type_name
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
block|}
decl|const
name|type_names
index|[]
init|=
block|{
block|{
name|Reg8
block|,
literal|"r8"
block|}
block|,
block|{
name|Reg16
block|,
literal|"r16"
block|}
block|,
block|{
name|Reg32
block|,
literal|"r32"
block|}
block|,
block|{
name|Reg64
block|,
literal|"r64"
block|}
block|,
block|{
name|Imm8
block|,
literal|"i8"
block|}
block|,
block|{
name|Imm8S
block|,
literal|"i8s"
block|}
block|,
block|{
name|Imm16
block|,
literal|"i16"
block|}
block|,
block|{
name|Imm32
block|,
literal|"i32"
block|}
block|,
block|{
name|Imm32S
block|,
literal|"i32s"
block|}
block|,
block|{
name|Imm64
block|,
literal|"i64"
block|}
block|,
block|{
name|Imm1
block|,
literal|"i1"
block|}
block|,
block|{
name|BaseIndex
block|,
literal|"BaseIndex"
block|}
block|,
block|{
name|Disp8
block|,
literal|"d8"
block|}
block|,
block|{
name|Disp16
block|,
literal|"d16"
block|}
block|,
block|{
name|Disp32
block|,
literal|"d32"
block|}
block|,
block|{
name|Disp32S
block|,
literal|"d32s"
block|}
block|,
block|{
name|Disp64
block|,
literal|"d64"
block|}
block|,
block|{
name|InOutPortReg
block|,
literal|"InOutPortReg"
block|}
block|,
block|{
name|ShiftCount
block|,
literal|"ShiftCount"
block|}
block|,
block|{
name|Control
block|,
literal|"control reg"
block|}
block|,
block|{
name|Test
block|,
literal|"test reg"
block|}
block|,
block|{
name|Debug
block|,
literal|"debug reg"
block|}
block|,
block|{
name|FloatReg
block|,
literal|"FReg"
block|}
block|,
block|{
name|FloatAcc
block|,
literal|"FAcc"
block|}
block|,
block|{
name|SReg2
block|,
literal|"SReg2"
block|}
block|,
block|{
name|SReg3
block|,
literal|"SReg3"
block|}
block|,
block|{
name|Acc
block|,
literal|"Acc"
block|}
block|,
block|{
name|JumpAbsolute
block|,
literal|"Jump Absolute"
block|}
block|,
block|{
name|RegMMX
block|,
literal|"rMMX"
block|}
block|,
block|{
name|RegXMM
block|,
literal|"rXMM"
block|}
block|,
block|{
name|EsSeg
block|,
literal|"es"
block|}
block|,
block|{
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pt
parameter_list|(
name|t
parameter_list|)
name|unsigned
name|int
name|t
decl_stmt|;
block|{
specifier|const
name|struct
name|type_name
modifier|*
name|ty
decl_stmt|;
for|for
control|(
name|ty
operator|=
name|type_names
init|;
name|ty
operator|->
name|mask
condition|;
name|ty
operator|++
control|)
if|if
condition|(
name|t
operator|&
name|ty
operator|->
name|mask
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s, "
argument_list|,
name|ty
operator|->
name|tname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG386 */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|reloc
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|pcrel
parameter_list|,
name|int
name|sign
parameter_list|,
name|bfd_reloc_code_real_type
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|!=
name|NO_RELOC
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|8
condition|)
switch|switch
condition|(
name|other
condition|)
block|{
case|case
name|BFD_RELOC_X86_64_GOT32
case|:
return|return
name|BFD_RELOC_X86_64_GOT64
return|;
break|break;
case|case
name|BFD_RELOC_X86_64_PLTOFF64
case|:
return|return
name|BFD_RELOC_X86_64_PLTOFF64
return|;
break|break;
case|case
name|BFD_RELOC_X86_64_GOTPC32
case|:
name|other
operator|=
name|BFD_RELOC_X86_64_GOTPC64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_X86_64_GOTPCREL
case|:
name|other
operator|=
name|BFD_RELOC_X86_64_GOTPCREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_X86_64_TPOFF32
case|:
name|other
operator|=
name|BFD_RELOC_X86_64_TPOFF64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_X86_64_DTPOFF32
case|:
name|other
operator|=
name|BFD_RELOC_X86_64_DTPOFF64
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Sign-checking 4-byte relocations in 16-/32-bit code is pointless.  */
if|if
condition|(
name|size
operator|==
literal|4
operator|&&
name|flag_code
operator|!=
name|CODE_64BIT
condition|)
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|reloc
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|other
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown relocation (%u)"
argument_list|)
argument_list|,
name|other
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|!=
name|bfd_get_reloc_size
argument_list|(
name|reloc
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%u-byte relocation cannot be applied to %u-byte field"
argument_list|)
argument_list|,
name|bfd_get_reloc_size
argument_list|(
name|reloc
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pcrel
operator|&&
operator|!
name|reloc
operator|->
name|pc_relative
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"non-pc-relative relocation for pc-relative field"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|reloc
operator|->
name|complain_on_overflow
operator|==
name|complain_overflow_signed
operator|&&
operator|!
name|sign
operator|)
operator|||
operator|(
name|reloc
operator|->
name|complain_on_overflow
operator|==
name|complain_overflow_unsigned
operator|&&
name|sign
operator|>
literal|0
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"relocated field and relocation type differ in signedness"
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|other
return|;
return|return
name|NO_RELOC
return|;
block|}
if|if
condition|(
name|pcrel
condition|)
block|{
if|if
condition|(
operator|!
name|sign
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"there are no unsigned pc-relative relocations"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8_PCREL
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16_PCREL
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32_PCREL
return|;
case|case
literal|8
case|:
return|return
name|BFD_RELOC_64_PCREL
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot do %u byte pc-relative relocation"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sign
operator|>
literal|0
condition|)
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
return|return
name|BFD_RELOC_X86_64_32S
return|;
block|}
else|else
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32
return|;
case|case
literal|8
case|:
return|return
name|BFD_RELOC_64
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot do %s %u byte relocation"
argument_list|)
argument_list|,
name|sign
operator|>
literal|0
condition|?
literal|"signed"
else|:
literal|"unsigned"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_comment
comment|/* Here we decide which fixups can be adjusted to make them relative to    the beginning of the section instead of the symbol.  Basically we need    to make sure that the dynamic relocations are done correctly, so in    some cases we force the original symbol to be used.  */
end_comment

begin_function
name|int
name|tc_i386_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
operator|!
name|IS_ELF
condition|)
return|return
literal|1
return|;
comment|/* Don't adjust pc-relative references to merge sections in 64-bit      mode.  */
if|if
condition|(
name|use_rela_relocations
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|!=
literal|0
operator|&&
name|fixP
operator|->
name|fx_pcrel
condition|)
return|return
literal|0
return|;
comment|/* The x86_64 GOTPCREL are represented as 32bit PCrel relocations      and changed later by validate_fix.  */
if|if
condition|(
name|GOT_symbol
operator|&&
name|fixP
operator|->
name|fx_subsy
operator|==
name|GOT_symbol
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL
condition|)
return|return
literal|0
return|;
comment|/* adjust_reloc_syms doesn't know about the GOT.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_GOTOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_PLT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_GOT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_GD
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_LDM
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_LDO_32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_IE_32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_IE
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_GOTIE
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_LE_32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_LE
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_GOTDESC
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_386_TLS_DESC_CALL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_PLT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_GOT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_GOTPCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_TLSGD
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_TLSLD
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_DTPOFF32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_DTPOFF64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_GOTTPOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_TPOFF32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_TPOFF64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_GOTOFF64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_GOTPC32_TLSDESC
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_X86_64_TLSDESC_CALL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_float_operand
parameter_list|(
specifier|const
name|char
modifier|*
name|mnemonic
parameter_list|)
block|{
comment|/* Note that the value returned is meaningful only for opcodes with (memory)      operands, hence the code here is free to improperly handle opcodes that      have no operands (for better performance and smaller code). */
if|if
condition|(
name|mnemonic
index|[
literal|0
index|]
operator|!=
literal|'f'
condition|)
return|return
literal|0
return|;
comment|/* non-math */
switch|switch
condition|(
name|mnemonic
index|[
literal|1
index|]
condition|)
block|{
comment|/* fclex, fdecstp, fdisi, femms, feni, fincstp, finit, fsetpm, and        the fs segment override prefix not currently handled because no        call path can make opcodes without operands get here */
case|case
literal|'i'
case|:
return|return
literal|2
comment|/* integer op */
return|;
case|case
literal|'l'
case|:
if|if
condition|(
name|mnemonic
index|[
literal|2
index|]
operator|==
literal|'d'
operator|&&
operator|(
name|mnemonic
index|[
literal|3
index|]
operator|==
literal|'c'
operator|||
name|mnemonic
index|[
literal|3
index|]
operator|==
literal|'e'
operator|)
condition|)
return|return
literal|3
return|;
comment|/* fldcw/fldenv */
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|mnemonic
index|[
literal|2
index|]
operator|!=
literal|'o'
comment|/* fnop */
condition|)
return|return
literal|3
return|;
comment|/* non-waiting control op */
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|mnemonic
index|[
literal|2
index|]
operator|==
literal|'s'
condition|)
return|return
literal|3
return|;
comment|/* frstor/frstpm */
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|mnemonic
index|[
literal|2
index|]
operator|==
literal|'a'
condition|)
return|return
literal|3
return|;
comment|/* fsave */
if|if
condition|(
name|mnemonic
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
switch|switch
condition|(
name|mnemonic
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* fstcw */
case|case
literal|'d'
case|:
comment|/* fstdw */
case|case
literal|'e'
case|:
comment|/* fstenv */
case|case
literal|'s'
case|:
comment|/* fsts[gw] */
return|return
literal|3
return|;
block|}
block|}
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|mnemonic
index|[
literal|2
index|]
operator|==
literal|'r'
operator|||
name|mnemonic
index|[
literal|2
index|]
operator|==
literal|'s'
condition|)
return|return
literal|0
return|;
comment|/* fxsave/fxrstor are not really math ops */
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  LINE points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
name|char
name|mnemonic
index|[
name|MAX_MNEM_SIZE
index|]
decl_stmt|;
comment|/* Initialize globals.  */
name|memset
argument_list|(
operator|&
name|i
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_OPERANDS
condition|;
name|j
operator|++
control|)
name|i
operator|.
name|reloc
index|[
name|j
index|]
operator|=
name|NO_RELOC
expr_stmt|;
name|memset
argument_list|(
name|disp_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|disp_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|im_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|im_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|save_stack_p
operator|=
name|save_stack
expr_stmt|;
comment|/* First parse an instruction mnemonic& call i386_operand for the operands.      We assume that the scrubber has arranged it so that line[0] is the valid      start of a (possibly prefixed) mnemonic.  */
name|line
operator|=
name|parse_insn
argument_list|(
name|line
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return;
name|line
operator|=
name|parse_operands
argument_list|(
name|line
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return;
comment|/* The order of the immediates should be reversed      for 2 immediates extrq and insertq instructions */
if|if
condition|(
operator|(
name|i
operator|.
name|imm_operands
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|strcmp
argument_list|(
name|mnemonic
argument_list|,
literal|"extrq"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|mnemonic
argument_list|,
literal|"insertq"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|swap_2_operands
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* "extrq" and insertq" are the only two instructions whose operands 	 have to be reversed even though they have two immediate operands.       */
if|if
condition|(
name|intel_syntax
condition|)
name|swap_operands
argument_list|()
expr_stmt|;
block|}
comment|/* Now we've parsed the mnemonic into a set of templates, and have the      operands at hand.  */
comment|/* All intel opcodes have reversed operands except for "bound" and      "enter".  We also don't reverse intersegment "jmp" and "call"      instructions with 2 immediate operands so that the immediate segment      precedes the offset, as it does when in AT&T mode. */
if|if
condition|(
name|intel_syntax
operator|&&
name|i
operator|.
name|operands
operator|>
literal|1
operator|&&
operator|(
name|strcmp
argument_list|(
name|mnemonic
argument_list|,
literal|"bound"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|mnemonic
argument_list|,
literal|"invlpga"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Imm
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Imm
operator|)
operator|)
condition|)
name|swap_operands
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|imm_operands
condition|)
name|optimize_imm
argument_list|()
expr_stmt|;
comment|/* Don't optimize displacement for movabs since it only takes 64bit      displacement.  */
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|&&
operator|(
name|flag_code
operator|!=
name|CODE_64BIT
operator|||
name|strcmp
argument_list|(
name|mnemonic
argument_list|,
literal|"movabs"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|optimize_disp
argument_list|()
expr_stmt|;
comment|/* Next, we find a template that matches the given insn,      making sure the overlap of the given operands types is consistent      with the template operand types.  */
if|if
condition|(
operator|!
name|match_template
argument_list|()
condition|)
return|return;
if|if
condition|(
name|intel_syntax
condition|)
block|{
comment|/* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
if|if
condition|(
name|SYSV386_COMPAT
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xfffffde0
operator|)
operator|==
literal|0xdce0
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|^=
name|Opcode_FloatR
expr_stmt|;
comment|/* Zap movzx and movsx suffix.  The suffix may have been set from 	 "word ptr" or "byte ptr" on the source operand, but we'll use 	 the suffix later to choose the destination register.  */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
operator|~
literal|9
operator|)
operator|==
literal|0x0fb6
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|reg_operands
operator|<
literal|2
operator|&&
operator|!
name|i
operator|.
name|suffix
operator|&&
operator|(
operator|~
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|No_bSuf
operator||
name|No_wSuf
operator||
name|No_lSuf
operator||
name|No_sSuf
operator||
name|No_xSuf
operator||
name|No_qSuf
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ambiguous operand size for `%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
name|i
operator|.
name|suffix
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|FWait
condition|)
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|FWAIT_OPCODE
argument_list|)
condition|)
return|return;
comment|/* Check string instruction segment overrides.  */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|!=
literal|0
operator|&&
name|i
operator|.
name|mem_operands
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|check_string
argument_list|()
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|process_suffix
argument_list|()
condition|)
return|return;
comment|/* Make still unresolved immediate matches conform to size of immediate      given in i.suffix.  */
if|if
condition|(
operator|!
name|finalize_imm
argument_list|()
condition|)
return|return;
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Imm1
condition|)
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
comment|/* kludge for shift insns.  */
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ImmExt
condition|)
block|{
name|expressionS
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|cpu_flags
operator|&
operator|(
name|CpuSSE3
operator||
name|CpuSMAP
operator|)
operator|)
operator|&&
name|i
operator|.
name|operands
operator|>
literal|0
condition|)
block|{
comment|/* Streaming SIMD extensions 3 Instructions have the fixed 	     operands with an opcode suffix which is coded in the same 	     place as an 8-bit immediate field would be. Here we check 	     those operands and remove them afterwards.  */
name|unsigned
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|i
operator|.
name|operands
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|!=
name|x
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't use register '%s%s' as operand %d in '%s'."
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
name|i
operator|.
name|operands
operator|=
literal|0
expr_stmt|;
block|}
comment|/* These AMD 3DNow! and Intel Katmai New Instructions have an 	 opcode suffix which is coded in the same place as an 8-bit 	 immediate field would be.  Here we fake an 8-bit immediate 	 operand from the opcode suffix stored in tm.extension_opcode.  */
name|assert
argument_list|(
name|i
operator|.
name|imm_operands
operator|==
literal|0
operator|&&
name|i
operator|.
name|operands
operator|<=
literal|2
operator|&&
literal|2
operator|<
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|&
name|im_expressions
index|[
name|i
operator|.
name|imm_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|i
operator|.
name|operands
index|]
operator|.
name|imms
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|i
operator|.
name|operands
operator|++
index|]
operator|=
name|Imm8
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
name|i
operator|.
name|tm
operator|.
name|extension_opcode
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|=
name|None
expr_stmt|;
block|}
comment|/* For insns with operands there are more diddles to do to the opcode.  */
if|if
condition|(
name|i
operator|.
name|operands
condition|)
block|{
if|if
condition|(
operator|!
name|process_operands
argument_list|()
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|quiet_warnings
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Ugh
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating to `%sp'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Handle conversion of 'int $3' --> special int3 insn.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
name|INT_OPCODE
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|==
literal|3
condition|)
block|{
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|=
name|INT3_OPCODE
expr_stmt|;
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpByte
operator||
name|JumpDword
operator|)
operator|)
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Convert "jmp constant" (and "call constant") to a jump (call) to 	 the absolute address given by the constant.  Since ix86 jumps and 	 calls are pc relative, we need to generate a reloc.  */
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_add_symbol
operator|=
operator|&
name|abs_symbol
expr_stmt|;
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Rex64
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_W
expr_stmt|;
comment|/* For 8 bit registers we need an empty rex prefix.  Also if the      instruction already has a prefix, we need to convert old      registers to new ones.  */
if|if
condition|(
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex64
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex64
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|||
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|i
operator|.
name|rex
operator|!=
literal|0
operator|)
condition|)
block|{
name|int
name|x
decl_stmt|;
name|i
operator|.
name|rex
operator||=
name|REX_OPCODE
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|2
condition|;
name|x
operator|++
control|)
block|{
comment|/* Look for 8 bit operand that uses old registers.  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|x
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex64
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* In case it is "hi" register, give up.  */
if|if
condition|(
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|>
literal|3
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't encode register '%s%s' in an "
literal|"instruction requiring REX prefix."
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
comment|/* Otherwise it is equivalent to the extended register. 		 Since the encoding doesn't change this is merely 		 cosmetic cleanup for debug output.  */
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|=
name|i
operator|.
name|op
index|[
name|x
index|]
operator|.
name|regs
operator|+
literal|8
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|.
name|rex
operator|!=
literal|0
condition|)
name|add_prefix
argument_list|(
name|REX_OPCODE
operator||
name|i
operator|.
name|rex
argument_list|)
expr_stmt|;
comment|/* We are ready to output the insn.  */
name|output_insn
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_insn
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
name|mnemonic
parameter_list|)
block|{
name|char
modifier|*
name|l
init|=
name|line
decl_stmt|;
name|char
modifier|*
name|token_start
init|=
name|l
decl_stmt|;
name|char
modifier|*
name|mnem_p
decl_stmt|;
name|int
name|supported
decl_stmt|;
specifier|const
name|template
modifier|*
name|t
decl_stmt|;
comment|/* Non-zero if we found a prefix only acceptable with string insns.  */
specifier|const
name|char
modifier|*
name|expecting_string_instruction
init|=
name|NULL
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|mnem_p
operator|=
name|mnemonic
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|mnem_p
operator|=
name|mnemonic_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|l
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|mnem_p
operator|++
expr_stmt|;
if|if
condition|(
name|mnem_p
operator|>=
name|mnemonic
operator|+
name|MAX_MNEM_SIZE
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such instruction: `%s'"
argument_list|)
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
operator|&&
operator|(
name|intel_syntax
operator|||
operator|(
operator|*
name|l
operator|!=
name|PREFIX_SEPARATOR
operator|&&
operator|*
name|l
operator|!=
literal|','
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s in mnemonic"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|token_start
operator|==
name|l
condition|)
block|{
if|if
condition|(
operator|!
name|intel_syntax
operator|&&
operator|*
name|l
operator|==
name|PREFIX_SEPARATOR
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting prefix; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting mnemonic; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Look up instruction (or prefix) via hash table.  */
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
operator|&&
operator|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|||
name|l
index|[
literal|1
index|]
operator|!=
name|END_OF_INSN
operator|)
operator|&&
name|current_templates
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsPrefix
operator|)
condition|)
block|{
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|cpu_flags
operator|&
operator|(
name|flag_code
operator|!=
name|CODE_64BIT
condition|?
name|Cpu64
else|:
name|CpuNo64
operator|)
condition|)
block|{
name|as_bad
argument_list|(
operator|(
name|flag_code
operator|!=
name|CODE_64BIT
condition|?
name|_
argument_list|(
literal|"`%s' is only supported in 64-bit mode"
argument_list|)
else|:
name|_
argument_list|(
literal|"`%s' is not supported in 64-bit mode"
argument_list|)
operator|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* If we are in 16-bit mode, do not allow addr16 or data16. 	     Similarly, in 32-bit mode, do not allow addr32 or data32.  */
if|if
condition|(
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Size16
operator||
name|Size32
operator|)
operator|)
operator|&&
name|flag_code
operator|!=
name|CODE_64BIT
operator|&&
operator|(
operator|(
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|Size32
operator|)
operator|!=
literal|0
operator|)
operator|^
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"redundant %s prefix"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Add prefix, checking for repeated prefixes.  */
switch|switch
condition|(
name|add_prefix
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
name|NULL
return|;
case|case
literal|2
case|:
name|expecting_string_instruction
operator|=
name|current_templates
operator|->
name|start
operator|->
name|name
expr_stmt|;
break|break;
block|}
comment|/* Skip past PREFIX_SEPARATOR and reset token_start.  */
name|token_start
operator|=
operator|++
name|l
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
comment|/* See if we can get a match by trimming off a suffix.  */
switch|switch
condition|(
name|mnem_p
index|[
operator|-
literal|1
index|]
condition|)
block|{
case|case
name|WORD_MNEM_SUFFIX
case|:
if|if
condition|(
name|intel_syntax
operator|&&
operator|(
name|intel_float_operand
argument_list|(
name|mnemonic
argument_list|)
operator|&
literal|2
operator|)
condition|)
name|i
operator|.
name|suffix
operator|=
name|SHORT_MNEM_SUFFIX
expr_stmt|;
else|else
case|case
name|BYTE_MNEM_SUFFIX
case|:
case|case
name|QWORD_MNEM_SUFFIX
case|:
name|i
operator|.
name|suffix
operator|=
name|mnem_p
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|mnem_p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHORT_MNEM_SUFFIX
case|:
case|case
name|LONG_MNEM_SUFFIX
case|:
if|if
condition|(
operator|!
name|intel_syntax
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|mnem_p
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|mnem_p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Intel Syntax.  */
case|case
literal|'d'
case|:
if|if
condition|(
name|intel_syntax
condition|)
block|{
if|if
condition|(
name|intel_float_operand
argument_list|(
name|mnemonic
argument_list|)
operator|==
literal|1
condition|)
name|i
operator|.
name|suffix
operator|=
name|SHORT_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
name|mnem_p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such instruction: `%s'"
argument_list|)
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpByte
operator|)
condition|)
block|{
comment|/* Check for a branch hint.  We allow ",pt" and ",pn" for 	 predict taken and predict not taken respectively. 	 I'm not sure that branch hints actually do anything on loop 	 and jcxz insns (JumpByte) for current Pentium4 chips.  They 	 may work in the future and it doesn't hurt to accept them 	 now.  */
if|if
condition|(
name|l
index|[
literal|0
index|]
operator|==
literal|','
operator|&&
name|l
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|l
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|DS_PREFIX_OPCODE
argument_list|)
condition|)
return|return
name|NULL
return|;
name|l
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
index|[
literal|2
index|]
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|CS_PREFIX_OPCODE
argument_list|)
condition|)
return|return
name|NULL
return|;
name|l
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
comment|/* Any other comma loses.  */
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s in mnemonic"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Check if instruction is supported on specified architecture.  */
name|supported
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|t
operator|->
name|cpu_flags
operator|&
operator|~
operator|(
name|Cpu64
operator||
name|CpuNo64
operator|)
operator|)
operator|&
operator|~
operator|(
name|cpu_arch_flags
operator|&
operator|~
operator|(
name|Cpu64
operator||
name|CpuNo64
operator|)
operator|)
operator|)
condition|)
name|supported
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|cpu_flags
operator|&
operator|(
name|flag_code
operator|==
name|CODE_64BIT
condition|?
name|CpuNo64
else|:
name|Cpu64
operator|)
operator|)
condition|)
name|supported
operator||=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|supported
operator|&
literal|2
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|flag_code
operator|==
name|CODE_64BIT
condition|?
name|_
argument_list|(
literal|"`%s' is not supported in 64-bit mode"
argument_list|)
else|:
name|_
argument_list|(
literal|"`%s' is only supported in 64-bit mode"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|supported
operator|&
literal|1
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"`%s' is not supported on `%s%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|,
name|cpu_arch_name
argument_list|,
name|cpu_sub_arch_name
condition|?
name|cpu_sub_arch_name
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Cpu386
operator|&
operator|~
name|cpu_arch_flags
operator|)
operator|&&
operator|(
name|flag_code
operator|!=
name|CODE_16BIT
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"use .code16 to ensure correct addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for rep/repne without a string instruction.  */
if|if
condition|(
name|expecting_string_instruction
condition|)
block|{
specifier|static
name|templates
name|override
decl_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
operator|++
name|t
control|)
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|IsString
condition|)
break|break;
if|if
condition|(
name|t
operator|>=
name|current_templates
operator|->
name|end
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting string instruction after `%s'"
argument_list|)
argument_list|,
name|expecting_string_instruction
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|override
operator|.
name|start
operator|=
name|t
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
operator|++
name|t
control|)
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|IsString
operator|)
condition|)
break|break;
name|override
operator|.
name|end
operator|=
name|t
expr_stmt|;
name|current_templates
operator|=
operator|&
name|override
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_operands
parameter_list|(
name|char
modifier|*
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|mnemonic
parameter_list|)
block|{
name|char
modifier|*
name|token_start
decl_stmt|;
comment|/* 1 if operand is pending after ','.  */
name|unsigned
name|int
name|expecting_operand
init|=
literal|0
decl_stmt|;
comment|/* Non-zero if operand parens not balanced.  */
name|unsigned
name|int
name|paren_not_balanced
decl_stmt|;
while|while
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
comment|/* Skip optional white space before operand.  */
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
operator|++
name|l
expr_stmt|;
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s before operand %d"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|token_start
operator|=
name|l
expr_stmt|;
comment|/* after white space */
name|paren_not_balanced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|paren_not_balanced
operator|||
operator|*
name|l
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
name|paren_not_balanced
condition|)
block|{
if|if
condition|(
operator|!
name|intel_syntax
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unbalanced parenthesis in operand %d."
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unbalanced brackets in operand %d."
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
break|break;
comment|/* we are done */
block|}
elseif|else
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s in operand %d"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|intel_syntax
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
literal|'('
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|')'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|l
operator|==
literal|'['
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|']'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
block|}
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
name|token_start
condition|)
block|{
comment|/* Yes, we've read in another operand.  */
name|unsigned
name|int
name|operand_ok
decl_stmt|;
name|this_operand
operator|=
name|i
operator|.
name|operands
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|>
name|MAX_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"spurious operands; (%d operands/instruction max)"
argument_list|)
argument_list|,
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now parse operand adding info to 'i' as we go along.  */
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_syntax
condition|)
name|operand_ok
operator|=
name|i386_intel_operand
argument_list|(
name|token_start
argument_list|,
name|intel_float_operand
argument_list|(
name|mnemonic
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|operand_ok
operator|=
name|i386_operand
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand_ok
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
condition|)
block|{
name|expecting_operand_after_comma
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting operand after ','; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting operand before ','; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Now *l must be either ',' or END_OF_INSN.  */
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
comment|/* Just skip it, if it's \n complain.  */
goto|goto
name|expecting_operand_after_comma
goto|;
block|}
name|expecting_operand
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|l
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap_2_operands
parameter_list|(
name|int
name|xchg1
parameter_list|,
name|int
name|xchg2
parameter_list|)
block|{
name|union
name|i386_op
name|temp_op
decl_stmt|;
name|unsigned
name|int
name|temp_type
decl_stmt|;
name|enum
name|bfd_reloc_code_real
name|temp_reloc
decl_stmt|;
name|temp_type
operator|=
name|i
operator|.
name|types
index|[
name|xchg2
index|]
expr_stmt|;
name|i
operator|.
name|types
index|[
name|xchg2
index|]
operator|=
name|i
operator|.
name|types
index|[
name|xchg1
index|]
expr_stmt|;
name|i
operator|.
name|types
index|[
name|xchg1
index|]
operator|=
name|temp_type
expr_stmt|;
name|temp_op
operator|=
name|i
operator|.
name|op
index|[
name|xchg2
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|xchg2
index|]
operator|=
name|i
operator|.
name|op
index|[
name|xchg1
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|xchg1
index|]
operator|=
name|temp_op
expr_stmt|;
name|temp_reloc
operator|=
name|i
operator|.
name|reloc
index|[
name|xchg2
index|]
expr_stmt|;
name|i
operator|.
name|reloc
index|[
name|xchg2
index|]
operator|=
name|i
operator|.
name|reloc
index|[
name|xchg1
index|]
expr_stmt|;
name|i
operator|.
name|reloc
index|[
name|xchg1
index|]
operator|=
name|temp_reloc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap_operands
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|i
operator|.
name|operands
condition|)
block|{
case|case
literal|4
case|:
name|swap_2_operands
argument_list|(
literal|1
argument_list|,
name|i
operator|.
name|operands
operator|-
literal|2
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
case|case
literal|2
case|:
name|swap_2_operands
argument_list|(
literal|0
argument_list|,
name|i
operator|.
name|operands
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
specifier|const
name|seg_entry
modifier|*
name|temp_seg
decl_stmt|;
name|temp_seg
operator|=
name|i
operator|.
name|seg
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|seg
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|seg
index|[
literal|1
index|]
operator|=
name|temp_seg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to ensure constant immediates are represented in the smallest    opcode possible.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_imm
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|guess_suffix
init|=
literal|0
decl_stmt|;
name|int
name|op
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
name|guess_suffix
operator|=
name|i
operator|.
name|suffix
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
comment|/* Figure out a suffix from the last register operand specified. 	 We can't do this properly yet, ie. excluding InOutPortReg, 	 but the following works for instructions with immediates. 	 In any case, we can't set i.suffix yet.  */
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
condition|)
name|guess_suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
condition|)
name|guess_suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg32
condition|)
name|guess_suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg64
condition|)
name|guess_suffix
operator|=
name|QWORD_MNEM_SUFFIX
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
name|guess_suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Imm
condition|)
block|{
switch|switch
condition|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
comment|/* If a suffix is given, this operand may be shortened.  */
switch|switch
condition|(
name|guess_suffix
condition|)
block|{
case|case
name|LONG_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Imm32
operator||
name|Imm64
expr_stmt|;
break|break;
case|case
name|WORD_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Imm16
operator||
name|Imm32S
operator||
name|Imm32
operator||
name|Imm64
expr_stmt|;
break|break;
case|case
name|BYTE_MNEM_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Imm16
operator||
name|Imm8
operator||
name|Imm8S
operator||
name|Imm32S
operator||
name|Imm32
operator||
name|Imm64
expr_stmt|;
break|break;
block|}
comment|/* If this operand is at most 16 bits, convert it 	       to a signed 16 bit number before trying to see 	       whether it will fit in an even smaller size. 	       This allows a 16-bit operand such as $0xffe0 to 	       be recognised as within Imm8S range.  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Imm16
operator|)
operator|&&
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|&
operator|~
operator|(
name|offsetT
operator|)
literal|0xffff
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Imm32
operator|)
operator|&&
operator|(
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|&
operator|~
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|=
operator|(
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|^
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|-
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
expr_stmt|;
block|}
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|smallest_imm_type
argument_list|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|imms
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
comment|/* We must avoid matching of Imm32 templates when 64bit 	       only immediate is available.  */
if|if
condition|(
name|guess_suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Imm32
expr_stmt|;
break|break;
case|case
name|O_absent
case|:
case|case
name|O_register
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Symbols and expressions.  */
default|default:
comment|/* Convert symbolic operand to proper sizes for matching, but don't 	       prevent matching a set of insns that only supports sizes other 	       than those matching the insn suffix.  */
block|{
name|unsigned
name|int
name|mask
decl_stmt|,
name|allowed
init|=
literal|0
decl_stmt|;
specifier|const
name|template
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
operator|++
name|t
control|)
name|allowed
operator||=
name|t
operator|->
name|operand_types
index|[
name|op
index|]
expr_stmt|;
switch|switch
condition|(
name|guess_suffix
condition|)
block|{
case|case
name|QWORD_MNEM_SUFFIX
case|:
name|mask
operator|=
name|Imm64
operator||
name|Imm32S
expr_stmt|;
break|break;
case|case
name|LONG_MNEM_SUFFIX
case|:
name|mask
operator|=
name|Imm32
expr_stmt|;
break|break;
case|case
name|WORD_MNEM_SUFFIX
case|:
name|mask
operator|=
name|Imm16
expr_stmt|;
break|break;
case|case
name|BYTE_MNEM_SUFFIX
case|:
name|mask
operator|=
name|Imm8
expr_stmt|;
break|break;
default|default:
name|mask
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mask
operator|&
name|allowed
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
name|mask
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Try to use the smallest displacement type too.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_disp
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|offsetT
name|disp
init|=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp16
operator|)
operator|&&
operator|(
name|disp
operator|&
operator|~
operator|(
name|offsetT
operator|)
literal|0xffff
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If this operand is at most 16 bits, convert 		   to a signed 16 bit number and don't use 64bit 		   displacement.  */
name|disp
operator|=
operator|(
operator|(
operator|(
name|disp
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp64
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp32
operator|)
operator|&&
operator|(
name|disp
operator|&
operator|~
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If this operand is at most 32 bits, convert 		   to a signed 32 bit number and don't use 64bit 		   displacement.  */
name|disp
operator|&=
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|disp
operator|=
operator|(
name|disp
operator|^
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|-
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp64
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|disp
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|BaseIndex
operator|)
condition|)
block|{
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|=
literal|0
expr_stmt|;
name|i
operator|.
name|disp_operands
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
if|if
condition|(
name|fits_in_signed_long
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp64
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32S
expr_stmt|;
block|}
if|if
condition|(
name|fits_in_unsigned_long
argument_list|(
name|disp
argument_list|)
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
operator|(
name|Disp32
operator||
name|Disp32S
operator||
name|Disp16
operator|)
operator|)
operator|&&
name|fits_in_signed_byte
argument_list|(
name|disp
argument_list|)
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|reloc
index|[
name|op
index|]
operator|==
name|BFD_RELOC_386_TLS_DESC_CALL
operator|||
name|i
operator|.
name|reloc
index|[
name|op
index|]
operator|==
name|BFD_RELOC_X86_64_TLSDESC_CALL
condition|)
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_more
argument_list|(
literal|0
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
argument_list|,
literal|0
argument_list|,
name|i
operator|.
name|reloc
index|[
name|op
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
block|}
else|else
comment|/* We only support 64bit displacement on constants.  */
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp64
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|match_template
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Points to template once we've found it.  */
specifier|const
name|template
modifier|*
name|t
decl_stmt|;
name|unsigned
name|int
name|overlap0
decl_stmt|,
name|overlap1
decl_stmt|,
name|overlap2
decl_stmt|,
name|overlap3
decl_stmt|;
name|unsigned
name|int
name|found_reverse_match
decl_stmt|;
name|int
name|suffix_check
decl_stmt|;
name|unsigned
name|int
name|operand_types
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
name|int
name|addr_prefix_disp
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
if|#
directive|if
name|MAX_OPERANDS
operator|!=
literal|4
error|#
directive|error
literal|"MAX_OPERANDS must be 4."
endif|#
directive|endif
define|#
directive|define
name|MATCH
parameter_list|(
name|overlap
parameter_list|,
name|given
parameter_list|,
name|template
parameter_list|)
define|\
value|((overlap& ~JumpAbsolute)					\&& (((given)& (BaseIndex | JumpAbsolute))			\        == ((overlap)& (BaseIndex | JumpAbsolute))))
comment|/* If given types r0 and r1 are registers they must be of the same type      unless the expected operand type register overlap is null.      Note that Acc in a template matches every size of reg.  */
define|#
directive|define
name|CONSISTENT_REGISTER_MATCH
parameter_list|(
name|m0
parameter_list|,
name|g0
parameter_list|,
name|t0
parameter_list|,
name|m1
parameter_list|,
name|g1
parameter_list|,
name|t1
parameter_list|)
define|\
value|(((g0)& Reg) == 0 || ((g1)& Reg) == 0			\    || ((g0)& Reg) == ((g1)& Reg)				\    || ((((m0)& Acc) ? Reg : (t0))& (((m1)& Acc) ? Reg : (t1))& Reg) == 0 )
name|overlap0
operator|=
literal|0
expr_stmt|;
name|overlap1
operator|=
literal|0
expr_stmt|;
name|overlap2
operator|=
literal|0
expr_stmt|;
name|overlap3
operator|=
literal|0
expr_stmt|;
name|found_reverse_match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_OPERANDS
condition|;
name|j
operator|++
control|)
name|operand_types
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|addr_prefix_disp
operator|=
operator|-
literal|1
expr_stmt|;
name|suffix_check
operator|=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|?
name|No_bSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|?
name|No_wSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|SHORT_MNEM_SUFFIX
condition|?
name|No_sSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
condition|?
name|No_lSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|?
name|No_qSuf
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|LONG_DOUBLE_MNEM_SUFFIX
condition|?
name|No_xSuf
else|:
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
name|t
operator|++
control|)
block|{
name|addr_prefix_disp
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Must have right number of operands.  */
if|if
condition|(
name|i
operator|.
name|operands
operator|!=
name|t
operator|->
name|operands
condition|)
continue|continue;
comment|/* Check the suffix, except for some instructions in intel mode.  */
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|suffix_check
operator|)
operator|&&
operator|!
operator|(
name|intel_syntax
operator|&&
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|IgnoreSize
operator|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_OPERANDS
condition|;
name|j
operator|++
control|)
name|operand_types
index|[
name|j
index|]
operator|=
name|t
operator|->
name|operand_types
index|[
name|j
index|]
expr_stmt|;
comment|/* In general, don't allow 64-bit operands in 32-bit mode.  */
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
operator|&&
name|flag_code
operator|!=
name|CODE_64BIT
operator|&&
operator|(
name|intel_syntax
condition|?
operator|(
operator|!
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|IgnoreSize
operator|)
operator|&&
operator|!
name|intel_float_operand
argument_list|(
name|t
operator|->
name|name
argument_list|)
operator|)
else|:
name|intel_float_operand
argument_list|(
name|t
operator|->
name|name
argument_list|)
operator|!=
literal|2
operator|)
operator|&&
operator|(
operator|!
operator|(
name|operand_types
index|[
literal|0
index|]
operator|&
operator|(
name|RegMMX
operator||
name|RegXMM
operator|)
operator|)
operator|||
operator|!
operator|(
name|operand_types
index|[
name|t
operator|->
name|operands
operator|>
literal|1
index|]
operator|&
operator|(
name|RegMMX
operator||
name|RegXMM
operator|)
operator|)
operator|)
operator|&&
operator|(
name|t
operator|->
name|base_opcode
operator|!=
literal|0x0fc7
operator|||
name|t
operator|->
name|extension_opcode
operator|!=
literal|1
comment|/* cmpxchg8b */
operator|)
condition|)
continue|continue;
comment|/* Do not verify operands when there are none.  */
elseif|else
if|if
condition|(
operator|!
name|t
operator|->
name|operands
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|cpu_flags
operator|&
operator|~
name|cpu_arch_flags
condition|)
continue|continue;
comment|/* We've found a match; break out of loop.  */
break|break;
block|}
comment|/* Address size prefix will turn Disp64/Disp32/Disp16 operand 	 into Disp32/Disp16/Disp32 operand.  */
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|DispOn
init|=
literal|0
decl_stmt|,
name|DispOff
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|flag_code
condition|)
block|{
case|case
name|CODE_16BIT
case|:
name|DispOn
operator|=
name|Disp32
expr_stmt|;
name|DispOff
operator|=
name|Disp16
expr_stmt|;
break|break;
case|case
name|CODE_32BIT
case|:
name|DispOn
operator|=
name|Disp16
expr_stmt|;
name|DispOff
operator|=
name|Disp32
expr_stmt|;
break|break;
case|case
name|CODE_64BIT
case|:
name|DispOn
operator|=
name|Disp32
expr_stmt|;
name|DispOff
operator|=
name|Disp64
expr_stmt|;
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_OPERANDS
condition|;
name|j
operator|++
control|)
block|{
comment|/* There should be only one Disp operand.  */
if|if
condition|(
operator|(
name|operand_types
index|[
name|j
index|]
operator|&
name|DispOff
operator|)
condition|)
block|{
name|addr_prefix_disp
operator|=
name|j
expr_stmt|;
name|operand_types
index|[
name|j
index|]
operator||=
name|DispOn
expr_stmt|;
name|operand_types
index|[
name|j
index|]
operator|&=
operator|~
name|DispOff
expr_stmt|;
break|break;
block|}
block|}
block|}
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|operands
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|operand_types
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
break|break;
case|case
literal|2
case|:
comment|/* xchg %eax, %eax is a special case. It is an aliase for nop 	     only in 32bit mode and we can use opcode 0x90.  In 64bit 	     mode, we can't use 0x90 for xchg %eax, %eax since it should 	     zero-extend %eax to %rax.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
name|t
operator|->
name|base_opcode
operator|==
literal|0x90
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
operator|(
name|Acc
operator||
name|Reg32
operator|)
operator|&&
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
operator|(
name|Acc
operator||
name|Reg32
operator|)
condition|)
continue|continue;
case|case
literal|3
case|:
case|case
literal|4
case|:
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|operand_types
index|[
literal|1
index|]
argument_list|)
comment|/* monitor in SSE3 is a very special case.  The first 		 register and the second register may have different 		 sizes.  The same applies to crc32 in SSE4.2.  */
operator|||
operator|!
operator|(
operator|(
name|t
operator|->
name|base_opcode
operator|==
literal|0x0f01
operator|&&
name|t
operator|->
name|extension_opcode
operator|==
literal|0xc8
operator|)
operator|||
name|t
operator|->
name|base_opcode
operator|==
literal|0xf20f38f1
operator|||
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Check if other direction is valid ...  */
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|D
operator||
name|FloatD
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Try reversing direction of operands.  */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|operand_types
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Does not match either direction.  */
continue|continue;
block|}
comment|/* found_reverse_match holds which of D or FloatDR 		 we've found.  */
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|D
operator|)
condition|)
name|found_reverse_match
operator|=
name|Opcode_D
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|FloatD
operator|)
condition|)
name|found_reverse_match
operator|=
name|Opcode_FloatD
expr_stmt|;
else|else
name|found_reverse_match
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|FloatR
operator|)
condition|)
name|found_reverse_match
operator||=
name|Opcode_FloatR
expr_stmt|;
block|}
else|else
block|{
comment|/* Found a forward 2 operand match here.  */
switch|switch
condition|(
name|t
operator|->
name|operands
condition|)
block|{
case|case
literal|4
case|:
name|overlap3
operator|=
name|i
operator|.
name|types
index|[
literal|3
index|]
operator|&
name|operand_types
index|[
literal|3
index|]
expr_stmt|;
case|case
literal|3
case|:
name|overlap2
operator|=
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|&
name|operand_types
index|[
literal|2
index|]
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|t
operator|->
name|operands
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap3
argument_list|,
name|i
operator|.
name|types
index|[
literal|3
index|]
argument_list|,
name|operand_types
index|[
literal|3
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|,
name|operand_types
index|[
literal|2
index|]
argument_list|,
name|overlap3
argument_list|,
name|i
operator|.
name|types
index|[
literal|3
index|]
argument_list|,
name|operand_types
index|[
literal|3
index|]
argument_list|)
condition|)
continue|continue;
case|case
literal|3
case|:
comment|/* Here we make use of the fact that there are no 		     reverse match 3 operand instructions, and all 3 		     operand instructions only need to be checked for 		     register consistency between operands 2 and 3.  */
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|,
name|operand_types
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|,
name|operand_types
index|[
literal|2
index|]
argument_list|)
condition|)
continue|continue;
break|break;
block|}
block|}
comment|/* Found either forward/reverse 2, 3 or 4 operand match here: 	     slip through to break.  */
block|}
if|if
condition|(
name|t
operator|->
name|cpu_flags
operator|&
operator|~
name|cpu_arch_flags
condition|)
block|{
name|found_reverse_match
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* We've found a match; break out of loop.  */
break|break;
block|}
if|if
condition|(
name|t
operator|==
name|current_templates
operator|->
name|end
condition|)
block|{
comment|/* We found no match.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"suffix or operands invalid for `%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|quiet_warnings
condition|)
block|{
if|if
condition|(
operator|!
name|intel_syntax
operator|&&
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|JumpAbsolute
operator|)
operator|!=
operator|(
name|operand_types
index|[
literal|0
index|]
operator|&
name|JumpAbsolute
operator|)
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"indirect %s without `*'"
argument_list|)
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|IsPrefix
operator||
name|IgnoreSize
operator|)
operator|)
operator|==
operator|(
name|IsPrefix
operator||
name|IgnoreSize
operator|)
condition|)
block|{
comment|/* Warn them that a data or address size prefix doesn't 	     affect assembly of the next line of code.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"stand-alone `%s' prefix"
argument_list|)
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy the template we found.  */
name|i
operator|.
name|tm
operator|=
operator|*
name|t
expr_stmt|;
if|if
condition|(
name|addr_prefix_disp
operator|!=
operator|-
literal|1
condition|)
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|addr_prefix_disp
index|]
operator|=
name|operand_types
index|[
name|addr_prefix_disp
index|]
expr_stmt|;
if|if
condition|(
name|found_reverse_match
condition|)
block|{
comment|/* If we found a reverse match we must alter the opcode 	 direction bit.  found_reverse_match holds bits to change 	 (different for int& float insns).  */
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|^=
name|found_reverse_match
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|0
index|]
operator|=
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|1
index|]
operator|=
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_string
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mem_op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|AnyMem
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|mem_op
index|]
operator|&
name|EsSeg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|!=
operator|&
name|es
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' operand %d must use `%%es' segment"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|mem_op
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* There's only ever one segment override allowed per instruction. 	 This instruction possibly has a legal segment override on the 	 second operand, so copy the segment to where non-string 	 instructions store it, allowing common code.  */
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|seg
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|mem_op
operator|+
literal|1
index|]
operator|&
name|EsSeg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|seg
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|i
operator|.
name|seg
index|[
literal|1
index|]
operator|!=
operator|&
name|es
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' operand %d must use `%%es' segment"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|mem_op
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_suffix
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If matched instruction specifies an explicit instruction mnemonic      suffix, use it.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|Size16
operator||
name|Size32
operator||
name|Size64
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Size16
condition|)
name|i
operator|.
name|suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Size64
condition|)
name|i
operator|.
name|suffix
operator|=
name|QWORD_MNEM_SUFFIX
expr_stmt|;
else|else
name|i
operator|.
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
comment|/* If there's no instruction mnemonic suffix we try to invent one 	 based on register operands.  */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
comment|/* We take i.suffix from the last register operand specified, 	     Destination register type is more significant than source 	     register type.  crc32 in SSE4.2 prefers source register 	     type. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xf20f38f1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg
operator|)
condition|)
name|i
operator|.
name|suffix
operator|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg16
operator|)
condition|?
name|WORD_MNEM_SUFFIX
else|:
name|LONG_MNEM_SUFFIX
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xf20f38f0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg8
operator|)
condition|)
name|i
operator|.
name|suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
name|int
name|op
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xf20f38f1
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xf20f38f0
condition|)
block|{
comment|/* We have to know the operand size for crc32.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ambiguous memory operand size for `%s`"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg
operator|)
operator|&&
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
name|InOutPortReg
operator|)
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
condition|?
name|BYTE_MNEM_SUFFIX
else|:
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
operator|)
condition|?
name|WORD_MNEM_SUFFIX
else|:
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg64
operator|)
condition|?
name|QWORD_MNEM_SUFFIX
else|:
name|LONG_MNEM_SUFFIX
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|)
block|{
if|if
condition|(
operator|!
name|check_byte_reg
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
condition|)
block|{
if|if
condition|(
operator|!
name|check_long_reg
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|)
block|{
if|if
condition|(
operator|!
name|check_qword_reg
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|)
block|{
if|if
condition|(
operator|!
name|check_word_reg
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IgnoreSize
operator|)
condition|)
comment|/* Do nothing if the instruction is going to ignore the prefix.  */
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|DefaultSize
operator|)
operator|&&
operator|!
name|i
operator|.
name|suffix
comment|/* exclude fldenv/frstor/fsave/fstenv */
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|No_sSuf
operator|)
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|stackop_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intel_syntax
operator|&&
operator|!
name|i
operator|.
name|suffix
operator|&&
operator|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|0
index|]
operator|&
name|JumpAbsolute
operator|)
operator|||
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|JumpByte
operator||
name|JumpInterSegment
operator|)
operator|)
operator|||
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x0f01
comment|/* [ls][gi]dt */
operator|&&
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|<=
literal|3
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|flag_code
condition|)
block|{
case|case
name|CODE_64BIT
case|:
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|No_qSuf
operator|)
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
name|QWORD_MNEM_SUFFIX
expr_stmt|;
break|break;
block|}
case|case
name|CODE_32BIT
case|:
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|No_lSuf
operator|)
condition|)
name|i
operator|.
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
break|break;
case|case
name|CODE_16BIT
case|:
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|No_wSuf
operator|)
condition|)
name|i
operator|.
name|suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
if|if
condition|(
operator|!
name|intel_syntax
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|W
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no instruction mnemonic suffix given and "
literal|"no register operands; can't size instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|suffixes
init|=
operator|(
operator|~
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|No_bSuf
operator||
name|No_wSuf
operator||
name|No_lSuf
operator||
name|No_sSuf
operator||
name|No_xSuf
operator||
name|No_qSuf
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|W
operator|)
operator|||
operator|(
operator|(
name|suffixes
operator|&
operator|(
name|suffixes
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|DefaultSize
operator||
name|IgnoreSize
operator|)
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ambiguous operand size for `%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* Change the opcode based on the operand size given by i.suffix;      We don't need to change things for byte insns.  */
if|if
condition|(
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|suffix
operator|!=
name|BYTE_MNEM_SUFFIX
condition|)
block|{
comment|/* It's not a byte, select word/dword operation.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|W
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ShortForm
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
literal|8
expr_stmt|;
else|else
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
literal|1
expr_stmt|;
block|}
comment|/* Now select between word& dword operations via the operand 	 size prefix, except for instructions that will ignore this 	 prefix anyway.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x0f01
operator|&&
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|==
literal|0xc8
condition|)
block|{
comment|/* monitor in SSE3 is a very special case. The default size 	     of AX is the size of mode. The address size override 	     prefix will change the size of AX.  */
if|if
condition|(
name|i
operator|.
name|op
operator|->
name|regs
index|[
literal|0
index|]
operator|.
name|reg_type
operator|&
operator|(
name|flag_code
operator|==
name|CODE_32BIT
condition|?
name|Reg16
else|:
name|Reg32
operator|)
condition|)
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|ADDR_PREFIX_OPCODE
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|!=
name|QWORD_MNEM_SUFFIX
operator|&&
name|i
operator|.
name|suffix
operator|!=
name|LONG_DOUBLE_MNEM_SUFFIX
operator|&&
operator|!
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|IgnoreSize
operator||
name|FloatMF
operator|)
operator|)
operator|&&
operator|(
operator|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
operator|)
operator|==
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|||
operator|(
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpByte
operator|)
operator|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|prefix
init|=
name|DATA_PREFIX_OPCODE
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpByte
condition|)
comment|/* jcxz, loop */
name|prefix
operator|=
name|ADDR_PREFIX_OPCODE
expr_stmt|;
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|prefix
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Set mode64 for an operand.  */
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
operator|&&
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|NoRex64
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Special case for xchg %rax,%rax.  It is NOP and doesn't 	     need rex64.  */
if|if
condition|(
name|i
operator|.
name|operands
operator|!=
literal|2
operator|||
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|!=
operator|(
name|Acc
operator||
name|Reg64
operator|)
operator|||
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|!=
operator|(
name|Acc
operator||
name|Reg64
operator|)
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|!=
literal|0x90
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_W
expr_stmt|;
block|}
comment|/* Size floating point instruction.  */
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|LONG_MNEM_SUFFIX
condition|)
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|FloatMF
condition|)
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|^=
literal|4
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_byte_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* If this is an eight bit register, it's OK.  If it's the 16 or 	 32 bit version of an eight bit register, we will just use the 	 low portion, and that's OK too.  */
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
condition|)
continue|continue;
comment|/* movzx and movsx should not generate this warning.  */
if|if
condition|(
name|intel_syntax
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfb7
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfb6
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x63
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfbe
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xfbf
operator|)
condition|)
continue|continue;
comment|/* crc32 doesn't generate this warning.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0xf20f38f0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|WordReg
operator|)
operator|&&
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|<
literal|4
condition|)
block|{
comment|/* Prohibit these changes in the 64bit mode, since the 	     lowering is more complicated.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
name|InOutPortReg
operator|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%s%s' used with `%c' suffix"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|REGISTER_WARNINGS
if|if
condition|(
operator|!
name|quiet_warnings
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
name|InOutPortReg
operator|)
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using `%s%s' instead of `%s%s' due to `%c' suffix"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|+
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
condition|?
name|REGNAM_AL
operator|-
name|REGNAM_AX
else|:
name|REGNAM_AL
operator|-
name|REGNAM_EAX
operator|)
operator|)
operator|->
name|reg_name
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* Any other register is bad.  */
if|if
condition|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator||
name|FloatReg
operator||
name|FloatAcc
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_long_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
comment|/* Reject eight bit registers, except where the template requires        them. (eg. movzb)  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Warn if the e prefix on a general reg is missing.  */
elseif|else
if|if
condition|(
operator|(
operator|!
name|quiet_warnings
operator|||
name|flag_code
operator|==
name|CODE_64BIT
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Prohibit these changes in the 64bit mode, since the 	   lowering is more complicated.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%s%s' used with `%c' suffix"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|REGISTER_WARNINGS
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using `%s%s' instead of `%s%s' due to `%c' suffix"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|+
name|REGNAM_EAX
operator|-
name|REGNAM_AX
operator|)
operator|->
name|reg_name
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Warn if the r prefix on a general reg is missing.  */
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg64
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%s%s' used with `%c' suffix"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_qword_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
comment|/* Reject eight bit registers, except where the template requires        them. (eg. movzb)  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Warn if the e prefix on a general reg is missing.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg16
operator|)
operator|!=
literal|0
operator|||
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg32
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Prohibit these changes in the 64bit mode, since the 	   lowering is more complicated.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%s%s' used with `%c' suffix"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_word_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|i
operator|.
name|operands
init|;
operator|--
name|op
operator|>=
literal|0
condition|;
control|)
comment|/* Reject eight bit registers, except where the template requires        them. (eg. movzb)  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Reg32
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s%s' not allowed with `%s%c'"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Warn if the e prefix on a general reg is present.  */
elseif|else
if|if
condition|(
operator|(
operator|!
name|quiet_warnings
operator|||
name|flag_code
operator|==
name|CODE_64BIT
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Reg32
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|op
index|]
operator|&
operator|(
name|Reg16
operator||
name|Acc
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Prohibit these changes in the 64bit mode, since the 	   lowering is more complicated.  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect register `%s%s' used with `%c' suffix"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
if|#
directive|if
name|REGISTER_WARNINGS
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using `%s%s' instead of `%s%s' due to `%c' suffix"
argument_list|)
argument_list|,
name|register_prefix
argument_list|,
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|+
name|REGNAM_AX
operator|-
name|REGNAM_EAX
operator|)
operator|->
name|reg_name
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|finalize_imm
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|overlap0
decl_stmt|,
name|overlap1
decl_stmt|,
name|overlap2
decl_stmt|;
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|overlap0
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator|)
operator|)
operator|&&
name|overlap0
operator|!=
name|Imm8
operator|&&
name|overlap0
operator|!=
name|Imm8S
operator|&&
name|overlap0
operator|!=
name|Imm16
operator|&&
name|overlap0
operator|!=
name|Imm32S
operator|&&
name|overlap0
operator|!=
name|Imm32
operator|&&
name|overlap0
operator|!=
name|Imm64
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
name|overlap0
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|?
name|Imm8
operator||
name|Imm8S
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|?
name|Imm16
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|?
name|Imm64
operator||
name|Imm32S
else|:
name|Imm32
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overlap0
operator|==
operator|(
name|Imm16
operator||
name|Imm32S
operator||
name|Imm32
operator|)
operator|||
name|overlap0
operator|==
operator|(
name|Imm16
operator||
name|Imm32
operator|)
operator|||
name|overlap0
operator|==
operator|(
name|Imm16
operator||
name|Imm32S
operator|)
condition|)
block|{
name|overlap0
operator|=
operator|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|?
name|Imm16
else|:
name|Imm32S
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|overlap0
operator|!=
name|Imm8
operator|&&
name|overlap0
operator|!=
name|Imm8S
operator|&&
name|overlap0
operator|!=
name|Imm16
operator|&&
name|overlap0
operator|!=
name|Imm32S
operator|&&
name|overlap0
operator|!=
name|Imm32
operator|&&
name|overlap0
operator|!=
name|Imm64
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no instruction mnemonic suffix given; "
literal|"can't determine immediate size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|=
name|overlap0
expr_stmt|;
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|overlap1
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32S
operator||
name|Imm32
operator||
name|Imm64
operator|)
operator|)
operator|&&
name|overlap1
operator|!=
name|Imm8
operator|&&
name|overlap1
operator|!=
name|Imm8S
operator|&&
name|overlap1
operator|!=
name|Imm16
operator|&&
name|overlap1
operator|!=
name|Imm32S
operator|&&
name|overlap1
operator|!=
name|Imm32
operator|&&
name|overlap1
operator|!=
name|Imm64
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
name|overlap1
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_MNEM_SUFFIX
condition|?
name|Imm8
operator||
name|Imm8S
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
condition|?
name|Imm16
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
condition|?
name|Imm64
operator||
name|Imm32S
else|:
name|Imm32
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overlap1
operator|==
operator|(
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator|)
operator|||
name|overlap1
operator|==
operator|(
name|Imm16
operator||
name|Imm32
operator|)
operator|||
name|overlap1
operator|==
operator|(
name|Imm16
operator||
name|Imm32S
operator|)
condition|)
block|{
name|overlap1
operator|=
operator|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|?
name|Imm16
else|:
name|Imm32S
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|overlap1
operator|!=
name|Imm8
operator|&&
name|overlap1
operator|!=
name|Imm8S
operator|&&
name|overlap1
operator|!=
name|Imm16
operator|&&
name|overlap1
operator|!=
name|Imm32S
operator|&&
name|overlap1
operator|!=
name|Imm32
operator|&&
name|overlap1
operator|!=
name|Imm64
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no instruction mnemonic suffix given; "
literal|"can't determine immediate size %x %c"
argument_list|)
argument_list|,
name|overlap1
argument_list|,
name|i
operator|.
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|=
name|overlap1
expr_stmt|;
name|overlap2
operator|=
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|&
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|2
index|]
expr_stmt|;
name|assert
argument_list|(
operator|(
name|overlap2
operator|&
name|Imm
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|=
name|overlap2
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_operands
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Default segment register this instruction will use for memory      accesses.  0 means unknown.  This is only for optimizing out      unnecessary segment overrides.  */
specifier|const
name|seg_entry
modifier|*
name|default_seg
init|=
literal|0
decl_stmt|;
comment|/* The imul $imm, %reg instruction is converted into      imul $imm, %reg, %reg, and the clr %reg instruction      is converted into xor %reg, %reg.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|RegKludge
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|cpu_flags
operator|&
name|CpuSSE4_1
operator|)
condition|)
block|{
comment|/* The first operand in instruction blendvpd, blendvps and 	      pblendvb in SSE4.1 is implicit and must be xmm0.  */
name|assert
argument_list|(
name|i
operator|.
name|operands
operator|==
literal|3
operator|&&
name|i
operator|.
name|reg_operands
operator|>=
literal|2
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|RegXMM
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|intel_syntax
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"the last operand of `%s' must be `%sxmm0'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|register_prefix
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"the first operand of `%s' must be `%sxmm0'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|register_prefix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|op
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|=
name|i
operator|.
name|op
index|[
literal|2
index|]
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|=
name|i
operator|.
name|types
index|[
literal|2
index|]
expr_stmt|;
name|i
operator|.
name|operands
operator|--
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
comment|/* We need to adjust fields in i.tm since they are used by 	      build_modrm_byte.  */
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|1
index|]
operator|=
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
literal|2
index|]
expr_stmt|;
name|i
operator|.
name|tm
operator|.
name|operands
operator|--
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|first_reg_op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Pretend we saw the extra register operand.  */
name|assert
argument_list|(
name|i
operator|.
name|reg_operands
operator|==
literal|1
operator|&&
name|i
operator|.
name|op
index|[
name|first_reg_op
operator|+
literal|1
index|]
operator|.
name|regs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|i
operator|.
name|op
index|[
name|first_reg_op
operator|+
literal|1
index|]
operator|.
name|regs
operator|=
name|i
operator|.
name|op
index|[
name|first_reg_op
index|]
operator|.
name|regs
expr_stmt|;
name|i
operator|.
name|types
index|[
name|first_reg_op
operator|+
literal|1
index|]
operator|=
name|i
operator|.
name|types
index|[
name|first_reg_op
index|]
expr_stmt|;
name|i
operator|.
name|operands
operator|++
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|ShortForm
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
name|POP_SEG_SHORT
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|==
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"you can't `pop %%cs'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
operator|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_num
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_B
expr_stmt|;
block|}
else|else
block|{
comment|/* The register or float register operand is in operand 0 or 1.  */
name|unsigned
name|int
name|op
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|FloatReg
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Register goes in low 3 bits of opcode.  */
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator||=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_B
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_warnings
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Ugh
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Warn about some common errors, but press on regardless. 		 The first case can be generated by gcc (<= 2.8.1).  */
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|2
condition|)
block|{
comment|/* Reversed arguments on faddp, fsubp, etc.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating to `%s %s%s,%s%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Extraneous `l' suffix on fp insn.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating to `%s %s%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|,
name|register_prefix
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|regs
operator|->
name|reg_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
comment|/* The opcode is completed (modulo i.tm.extension_opcode which 	 must be put into the modrm byte).  Now, we make the modrm and 	 index base bytes based on all the info we've collected.  */
name|default_seg
operator|=
name|build_modrm_byte
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
operator|~
literal|0x3
operator|)
operator|==
name|MOV_AX_DISP32
condition|)
block|{
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* For the string instructions that allow a segment override 	 on one of their operands, the default segment is ds.  */
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x8d
comment|/* lea */
operator|||
operator|(
name|i
operator|.
name|tm
operator|.
name|cpu_flags
operator|&
name|CpuSVME
operator|)
operator|)
operator|&&
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|&&
operator|!
name|quiet_warnings
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"segment override on `%s' is ineffectual"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* If a segment was explicitly specified, and the specified segment      is not the default, use an opcode prefix to select it.  If we      never figured out what the default segment is, then default_seg      will be zero at this point, and the specified segment prefix will      always be used.  */
if|if
condition|(
operator|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|!=
name|default_seg
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|add_prefix
argument_list|(
name|i
operator|.
name|seg
index|[
literal|0
index|]
operator|->
name|seg_prefix
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|seg_entry
modifier|*
name|build_modrm_byte
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|seg_entry
modifier|*
name|default_seg
init|=
literal|0
decl_stmt|;
comment|/* i.reg_operands MUST be the number of real register operands;      implicit registers do not count.  */
if|if
condition|(
name|i
operator|.
name|reg_operands
operator|==
literal|2
condition|)
block|{
name|unsigned
name|int
name|source
decl_stmt|,
name|dest
decl_stmt|;
switch|switch
condition|(
name|i
operator|.
name|operands
condition|)
block|{
case|case
literal|2
case|:
name|source
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* When there are 3 operands, one of them may be immediate, 	     which may be the first or the last operand.  Otherwise, 	     the first operand must be shift count register (cl). */
name|assert
argument_list|(
name|i
operator|.
name|imm_operands
operator|==
literal|1
operator|||
operator|(
name|i
operator|.
name|imm_operands
operator|==
literal|0
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|ShiftCount
operator|)
operator|)
argument_list|)
expr_stmt|;
name|source
operator|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Imm
operator||
name|ShiftCount
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* When there are 4 operands, the first two must be immediate 	     operands. The source operand will be the 3rd one.  */
name|assert
argument_list|(
name|i
operator|.
name|imm_operands
operator|==
literal|2
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Imm
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Imm
operator|)
argument_list|)
expr_stmt|;
name|source
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|dest
operator|=
name|source
operator|+
literal|1
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
comment|/* One of the register operands will be encoded in the i.tm.reg 	 field, the other in the combined i.tm.mode and i.tm.regmem 	 fields.  If no form of this instruction supports a memory 	 destination operand, then we assume the source operand may 	 sometimes be a memory operand and so we need to store the 	 destination in the i.rm.reg field.  */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|operand_types
index|[
name|dest
index|]
operator|&
operator|(
name|AnyMem
operator||
name|RegMem
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_R
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_B
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
name|dest
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_B
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
name|source
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_R
expr_stmt|;
block|}
if|if
condition|(
name|flag_code
operator|!=
name|CODE_64BIT
operator|&&
operator|(
name|i
operator|.
name|rex
operator|&
operator|(
name|REX_R
operator||
name|REX_B
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator||
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|)
operator|&
name|Control
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|i
operator|.
name|rex
operator|&=
operator|~
operator|(
name|REX_R
operator||
name|REX_B
operator|)
expr_stmt|;
name|add_prefix
argument_list|(
name|LOCK_PREFIX_OPCODE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If it's not 2 reg operands...  */
if|if
condition|(
name|i
operator|.
name|mem_operands
condition|)
block|{
name|unsigned
name|int
name|fake_zero_displacement
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
literal|0
init|;
name|op
operator|<
name|i
operator|.
name|operands
condition|;
name|op
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|AnyMem
operator|)
condition|)
break|break;
name|assert
argument_list|(
name|op
operator|<
name|i
operator|.
name|operands
argument_list|)
expr_stmt|;
name|default_seg
operator|=
operator|&
name|ds
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|disp_operands
condition|)
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|index_reg
operator|==
literal|0
condition|)
block|{
comment|/* Operand is just<disp>  */
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
comment|/* 64bit mode overwrites the 32bit absolute 			 addressing by RIP relative addressing and 			 absolute addressing is encoded by one of the 			 redundant SIB forms.  */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|base
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
operator|(
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|==
literal|0
operator|)
condition|?
name|Disp32S
else|:
name|Disp32
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|NO_BASE_REGISTER_16
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
name|Disp16
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
name|Disp32
expr_stmt|;
block|}
block|}
else|else
comment|/* !i.base_reg&& i.index_reg  */
block|{
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|base
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
if|if
condition|(
name|flag_code
operator|!=
name|CODE_64BIT
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32
expr_stmt|;
comment|/* Must be 32 bit */
else|else
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32S
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_X
expr_stmt|;
block|}
block|}
comment|/* RIP addressing for 64bit mode.  */
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|==
name|BaseIndex
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp32S
expr_stmt|;
name|i
operator|.
name|flags
index|[
name|op
index|]
operator||=
name|Operand_PCrel
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|disp_operands
condition|)
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg16
condition|)
block|{
switch|switch
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_num
condition|)
block|{
case|case
literal|3
case|:
comment|/* (%bx)  */
if|if
condition|(
name|i
operator|.
name|index_reg
operator|==
literal|0
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
literal|7
expr_stmt|;
else|else
comment|/* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|-
literal|6
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* (%bp)  */
name|default_seg
operator|=
operator|&
name|ss
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|index_reg
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
literal|6
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* fake (%bp) into 0(%bp)  */
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|-
literal|6
operator|+
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* (%si) -> 4 or (%di) -> 5  */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|-
literal|6
operator|+
literal|4
expr_stmt|;
block|}
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* i.base_reg and 32/64 bit mode  */
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp
operator|)
condition|)
name|i
operator|.
name|types
index|[
name|op
index|]
operator|=
operator|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
name|Disp8
operator|)
operator||
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|==
literal|0
condition|?
name|Disp32S
else|:
name|Disp32
operator|)
operator|)
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_B
expr_stmt|;
name|i
operator|.
name|sib
operator|.
name|base
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
comment|/* x86-64 ignores REX prefix bit here to avoid decoder 		 complications.  */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|&
literal|7
operator|)
operator|==
name|EBP_REG_NUM
condition|)
block|{
name|default_seg
operator|=
operator|&
name|ss
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|==
literal|0
condition|)
block|{
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|types
index|[
name|op
index|]
operator||=
name|Disp8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|==
name|ESP_REG_NUM
condition|)
block|{
name|default_seg
operator|=
operator|&
name|ss
expr_stmt|;
block|}
name|i
operator|.
name|sib
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|index_reg
operator|==
literal|0
condition|)
block|{
comment|/*<disp>(%esp) becomes two byte modrm with no index 		     register.  We've already stored the code for esp 		     in i.rm.regmem ie. ESCAPE_TO_TWO_BYTE_ADDRESSING. 		     Any base register besides %esp will not use the 		     extra modrm byte.  */
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
if|#
directive|if
operator|!
name|SCALE1_WHEN_NO_INDEX
comment|/* Another case where we force the second modrm byte.  */
if|if
condition|(
name|i
operator|.
name|log2_scale_factor
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|i
operator|.
name|sib
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_X
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|&&
operator|(
name|i
operator|.
name|reloc
index|[
name|op
index|]
operator|==
name|BFD_RELOC_386_TLS_DESC_CALL
operator|||
name|i
operator|.
name|reloc
index|[
name|op
index|]
operator|==
name|BFD_RELOC_X86_64_TLSDESC_CALL
operator|)
condition|)
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|op
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fake_zero_displacement
condition|)
block|{
comment|/* Fakes a zero displacement assuming that i.types[op] 		 holds the correct displacement size.  */
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|assert
argument_list|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|==
literal|0
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|disps
operator|=
name|exp
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* Fill in i.rm.reg or i.rm.regmem field with register operand 	 (if any) based on i.tm.extension_opcode.  Again, we must be 	 careful to make sure that segment/control/debug/test/MMX 	 registers are coded into the i.rm.reg field.  */
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
name|unsigned
name|int
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
literal|0
init|;
name|op
operator|<
name|i
operator|.
name|operands
condition|;
name|op
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|op
index|]
operator|&
operator|(
name|Reg
operator||
name|RegMMX
operator||
name|RegXMM
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|)
break|break;
name|assert
argument_list|(
name|op
operator|<
name|i
operator|.
name|operands
argument_list|)
expr_stmt|;
comment|/* If there is an extension opcode to put here, the register 	     number must be put into the regmem field.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|!=
name|None
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_B
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|op
index|[
name|op
index|]
operator|.
name|regs
operator|->
name|reg_flags
operator|&
name|RegRex
operator|)
operator|!=
literal|0
condition|)
name|i
operator|.
name|rex
operator||=
name|REX_R
expr_stmt|;
block|}
comment|/* Now, if no memory operand has set i.rm.mode = 0, 1, 2 we 	     must set it to 3 to indicate this is a register operand 	     in the regmem field.  */
if|if
condition|(
operator|!
name|i
operator|.
name|mem_operands
condition|)
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Fill in i.rm.reg field with extension opcode (if any).  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|tm
operator|.
name|extension_opcode
expr_stmt|;
block|}
return|return
name|default_seg
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_branch
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|code16
decl_stmt|;
name|int
name|prefix
decl_stmt|;
name|relax_substateT
name|subtype
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|off
decl_stmt|;
name|code16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
condition|)
name|code16
operator|=
name|CODE16
expr_stmt|;
name|prefix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
condition|)
block|{
name|prefix
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
name|code16
operator|^=
name|CODE16
expr_stmt|;
block|}
comment|/* Pentium4 branch hints.  */
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|CS_PREFIX_OPCODE
comment|/* not taken */
operator|||
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|DS_PREFIX_OPCODE
comment|/* taken */
condition|)
block|{
name|prefix
operator|++
expr_stmt|;
name|i
operator|.
name|prefixes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
operator|!=
literal|0
condition|)
block|{
name|prefix
operator|++
expr_stmt|;
name|i
operator|.
name|prefixes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefixes
operator|!=
literal|0
operator|&&
operator|!
name|intel_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping prefixes on this instruction"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It's always a symbol;  End frag& setup for relax.      Make sure there is enough room in this frag for the largest      instruction we may generate in md_convert_frag.  This is 2      bytes for the opcode and room for the prefix and largest      displacement.  */
name|frag_grow
argument_list|(
name|prefix
operator|+
literal|2
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Prefix and 1 opcode byte go in fr_fix.  */
name|p
operator|=
name|frag_more
argument_list|(
name|prefix
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|DATA_PREFIX_OPCODE
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|CS_PREFIX_OPCODE
operator|||
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|DS_PREFIX_OPCODE
condition|)
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
expr_stmt|;
operator|*
name|p
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|==
name|JUMP_PC_RELATIVE
condition|)
name|subtype
operator|=
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|SMALL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cpu_arch_flags
operator|&
name|Cpu386
operator|)
operator|!=
literal|0
condition|)
name|subtype
operator|=
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|SMALL
argument_list|)
expr_stmt|;
else|else
name|subtype
operator|=
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP86
argument_list|,
name|SMALL
argument_list|)
expr_stmt|;
name|subtype
operator||=
name|code16
expr_stmt|;
name|sym
operator|=
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
comment|/* Handle complex expressions.  */
name|sym
operator|=
name|make_expr_symbol
argument_list|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 1 possible extra opcode + 4 byte displacement go in var part.      Pass reloc in fr_var.  */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|5
argument_list|,
name|i
operator|.
name|reloc
index|[
literal|0
index|]
argument_list|,
name|subtype
argument_list|,
name|sym
argument_list|,
name|off
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_jump
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpByte
condition|)
block|{
comment|/* This is a loop or jecxz type instruction.  */
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|ADDR_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* Pentium4 branch hints.  */
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|CS_PREFIX_OPCODE
comment|/* not taken */
operator|||
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
operator|==
name|DS_PREFIX_OPCODE
comment|/* taken */
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
operator|.
name|prefix
index|[
name|SEG_PREFIX
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|code16
decl_stmt|;
name|code16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
condition|)
name|code16
operator|=
name|CODE16
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|DATA_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
name|code16
operator|^=
name|CODE16
expr_stmt|;
block|}
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|code16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
operator|!=
literal|0
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefixes
operator|!=
literal|0
operator|&&
operator|!
name|intel_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping prefixes on this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|disps
argument_list|,
literal|1
argument_list|,
name|reloc
argument_list|(
name|size
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|i
operator|.
name|reloc
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All jumps handled here are signed, but don't use a signed limit      check for 32 and 16 bit jumps as we want to allow wrap around at      4G and 64k respectively.  */
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|fixP
operator|->
name|fx_signed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_interseg_jump
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|prefix
decl_stmt|;
name|int
name|code16
decl_stmt|;
name|code16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
condition|)
name|code16
operator|=
name|CODE16
expr_stmt|;
name|prefix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
condition|)
block|{
name|prefix
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
name|code16
operator|^=
name|CODE16
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
operator|!=
literal|0
condition|)
block|{
name|prefix
operator|++
expr_stmt|;
name|i
operator|.
name|prefixes
operator|-=
literal|1
expr_stmt|;
block|}
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|code16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefixes
operator|!=
literal|0
operator|&&
operator|!
name|intel_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping prefixes on this instruction"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1 opcode; 2 segment; offset  */
name|p
operator|=
name|frag_more
argument_list|(
name|prefix
operator|+
literal|1
operator|+
literal|2
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|DATA_PREFIX_OPCODE
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|prefix
index|[
name|REX_PREFIX
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|offsetT
name|n
init|=
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|imms
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|2
operator|&&
operator|!
name|fits_in_unsigned_word
argument_list|(
name|n
argument_list|)
operator|&&
operator|!
name|fits_in_signed_word
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"16-bit jump out of range"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
literal|1
index|]
operator|.
name|imms
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|i
operator|.
name|reloc
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|imms
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't handle non absolute segment in `%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|tm
operator|.
name|name
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
name|size
argument_list|,
operator|(
name|valueT
operator|)
name|i
operator|.
name|op
index|[
literal|0
index|]
operator|.
name|imms
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|fragS
modifier|*
name|insn_start_frag
decl_stmt|;
name|offsetT
name|insn_start_off
decl_stmt|;
comment|/* Tie dwarf2 debug info to the address at the start of the insn.      We can't do this after the insn has been output as the current      frag may have been closed off.  eg. by frag_var.  */
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|insn_start_frag
operator|=
name|frag_now
expr_stmt|;
name|insn_start_off
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
comment|/* Output jumps.  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Jump
condition|)
name|output_branch
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
operator|(
name|JumpByte
operator||
name|JumpDword
operator|)
condition|)
name|output_jump
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|JumpInterSegment
condition|)
name|output_interseg_jump
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* Output normal instructions here.  */
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
name|unsigned
name|int
name|prefix
decl_stmt|;
comment|/* All opcodes on i386 have either 1 or 2 bytes.  SSSE3 and 	 SSE4 instructions have 3 bytes.  We may use one more higher 	 byte to specify a prefix the instruction requires.  Exclude 	 instructions which are in both SSE4 and ABM.  */
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|cpu_flags
operator|&
operator|(
name|CpuSSSE3
operator||
name|CpuSSE4
operator||
name|CpuAES
operator||
name|CpuPCLMUL
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|cpu_flags
operator|&
name|CpuABM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff000000
condition|)
block|{
name|prefix
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
goto|goto
name|check_prefix
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x660f3880
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x660f3881
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x660f3882
condition|)
block|{
comment|/* invept and invvpid are 3 byte instructions with a 	     mandatory prefix. */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff000000
condition|)
block|{
name|prefix
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|add_prefix
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff0000
operator|)
operator|!=
literal|0
condition|)
block|{
name|prefix
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|cpu_flags
operator|&
name|CpuPadLock
operator|)
operator|!=
literal|0
condition|)
block|{
name|check_prefix
label|:
if|if
condition|(
name|prefix
operator|!=
name|REPE_PREFIX_OPCODE
operator|||
name|i
operator|.
name|prefix
index|[
name|LOCKREP_PREFIX
index|]
operator|!=
name|REPE_PREFIX_OPCODE
condition|)
name|add_prefix
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
else|else
name|add_prefix
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
comment|/* The prefix bytes.  */
for|for
control|(
name|q
operator|=
name|i
operator|.
name|prefix
init|;
name|q
operator|<
name|i
operator|.
name|prefix
operator|+
sizeof|sizeof
argument_list|(
name|i
operator|.
name|prefix
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|i
operator|.
name|prefix
index|[
literal|0
index|]
argument_list|)
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
operator|*
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now the opcode; be careful about word order here!  */
if|if
condition|(
name|fits_in_unsigned_byte
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|i
operator|.
name|tm
operator|.
name|cpu_flags
operator|&
operator|(
name|CpuSSSE3
operator||
name|CpuSSE4
operator||
name|CpuAES
operator||
name|CpuPCLMUL
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|cpu_flags
operator|&
name|CpuABM
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x660f3880
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x660f3881
operator|||
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|==
literal|0x660f3882
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Put out high byte first: can't use md_number_to_chars!  */
operator|*
name|p
operator|++
operator|=
operator|(
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
name|i
operator|.
name|tm
operator|.
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* Now the modrm byte and sib byte (if present).  */
if|if
condition|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|<<
literal|0
operator||
name|i
operator|.
name|rm
operator|.
name|reg
operator|<<
literal|3
operator||
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|6
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If i.rm.regmem == ESP (4)&& i.rm.mode != (Register mode)&& not 16 bit 	     ==> need second modrm byte.  */
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|==
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
operator|&&
name|i
operator|.
name|rm
operator|.
name|mode
operator|!=
literal|3
operator|&&
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg16
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|i
operator|.
name|sib
operator|.
name|base
operator|<<
literal|0
operator||
name|i
operator|.
name|sib
operator|.
name|index
operator|<<
literal|3
operator||
name|i
operator|.
name|sib
operator|.
name|scale
operator|<<
literal|6
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|disp_operands
condition|)
name|output_disp
argument_list|(
name|insn_start_frag
argument_list|,
name|insn_start_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|imm_operands
condition|)
name|output_imm
argument_list|(
name|insn_start_frag
argument_list|,
name|insn_start_off
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG386
if|if
condition|(
name|flag_debug
condition|)
block|{
name|pi
argument_list|(
literal|""
comment|/*line*/
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG386  */
block|}
end_function

begin_comment
comment|/* Return the size of the displacement operand N.  */
end_comment

begin_function
specifier|static
name|int
name|disp_size
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|int
name|size
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp8
operator||
name|Disp16
operator||
name|Disp64
operator|)
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp8
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp64
condition|)
name|size
operator|=
literal|8
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the immediate operand N.  */
end_comment

begin_function
specifier|static
name|int
name|imm_size
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|int
name|size
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm64
operator|)
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm64
condition|)
name|size
operator|=
literal|8
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_disp
parameter_list|(
name|fragS
modifier|*
name|insn_start_frag
parameter_list|,
name|offsetT
name|insn_start_off
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|size
init|=
name|disp_size
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|val
operator|=
name|offset_in_range
argument_list|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|bfd_reloc_code_real
name|reloc_type
decl_stmt|;
name|int
name|size
init|=
name|disp_size
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|int
name|sign
init|=
operator|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp32S
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|pcrel
init|=
operator|(
name|i
operator|.
name|flags
index|[
name|n
index|]
operator|&
name|Operand_PCrel
operator|)
operator|!=
literal|0
decl_stmt|;
comment|/* We can't have 8 bit displacement here.  */
name|assert
argument_list|(
operator|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Disp8
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* The PC relative address is computed relative 		 to the instruction boundary, so in case immediate 		 fields follows, we need to adjust the value.  */
if|if
condition|(
name|pcrel
operator|&&
name|i
operator|.
name|imm_operands
condition|)
block|{
name|unsigned
name|int
name|n1
decl_stmt|;
name|int
name|sz
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n1
operator|=
literal|0
init|;
name|n1
operator|<
name|i
operator|.
name|operands
condition|;
name|n1
operator|++
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n1
index|]
operator|&
name|Imm
condition|)
block|{
comment|/* Only one immediate is allowed for PC 			   relative address.  */
name|assert
argument_list|(
name|sz
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sz
operator|=
name|imm_size
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_add_number
operator|-=
name|sz
expr_stmt|;
block|}
comment|/* We should find the immediate.  */
name|assert
argument_list|(
name|sz
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|reloc
argument_list|(
name|size
argument_list|,
name|pcrel
argument_list|,
name|sign
argument_list|,
name|i
operator|.
name|reloc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GOT_symbol
operator|&&
name|GOT_symbol
operator|==
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_add_symbol
operator|&&
operator|(
operator|(
operator|(
name|reloc_type
operator|==
name|BFD_RELOC_32
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_X86_64_32S
operator|||
operator|(
name|reloc_type
operator|==
name|BFD_RELOC_64
operator|&&
name|object_64bit
operator|)
operator|)
operator|&&
operator|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
operator|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_op
operator|==
name|O_add
operator|&&
operator|(
operator|(
name|symbol_get_value_expression
argument_list|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
operator|->
name|X_op_symbol
argument_list|)
operator|->
name|X_op
operator|)
operator|==
name|O_subtract
operator|)
operator|)
operator|)
operator|)
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_32_PCREL
operator|)
condition|)
block|{
name|offsetT
name|add
decl_stmt|;
if|if
condition|(
name|insn_start_frag
operator|==
name|frag_now
condition|)
name|add
operator|=
operator|(
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|-
name|insn_start_off
expr_stmt|;
else|else
block|{
name|fragS
modifier|*
name|fr
decl_stmt|;
name|add
operator|=
name|insn_start_frag
operator|->
name|fr_fix
operator|-
name|insn_start_off
expr_stmt|;
for|for
control|(
name|fr
operator|=
name|insn_start_frag
operator|->
name|fr_next
init|;
name|fr
operator|&&
name|fr
operator|!=
name|frag_now
condition|;
name|fr
operator|=
name|fr
operator|->
name|fr_next
control|)
name|add
operator|+=
name|fr
operator|->
name|fr_fix
expr_stmt|;
name|add
operator|+=
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|object_64bit
condition|)
block|{
name|reloc_type
operator|=
name|BFD_RELOC_386_GOTPC
expr_stmt|;
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|+=
name|add
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reloc_type
operator|==
name|BFD_RELOC_64
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_X86_64_GOTPC64
expr_stmt|;
else|else
comment|/* Don't do the adjustment for x86-64, as there 		       the pcrel addressing is relative to the _next_ 		       insn, and that is taken care of in other code.  */
name|reloc_type
operator|=
name|BFD_RELOC_X86_64_GOTPC32
expr_stmt|;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|disps
argument_list|,
name|pcrel
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_imm
parameter_list|(
name|fragS
modifier|*
name|insn_start_frag
parameter_list|,
name|offsetT
name|insn_start_off
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|size
init|=
name|imm_size
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|val
operator|=
name|offset_in_range
argument_list|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not absolute_section. 		 Need a 32-bit fixup (don't support 8bit 		 non-absolute imms).  Try to support other 		 sizes ...  */
name|enum
name|bfd_reloc_code_real
name|reloc_type
decl_stmt|;
name|int
name|size
init|=
name|imm_size
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|int
name|sign
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm32S
operator|)
operator|)
operator|&&
operator|(
name|i
operator|.
name|suffix
operator|==
name|QWORD_MNEM_SUFFIX
operator|||
operator|(
operator|!
name|i
operator|.
name|suffix
operator|&&
operator|(
name|i
operator|.
name|tm
operator|.
name|opcode_modifier
operator|&
name|No_lSuf
operator|)
operator|)
operator|)
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
else|else
name|sign
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|reloc
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|sign
argument_list|,
name|i
operator|.
name|reloc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
comment|/*   This is tough to explain.  We end up with this one if we 	       * have operands that look like 	       * "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal here is to 	       * obtain the absolute address of the GOT, and it is strongly 	       * preferable from a performance point of view to avoid using 	       * a runtime relocation for this.  The actual sequence of 	       * instructions often look something like: 	       * 	       *	call	.L66 	       * .L66: 	       *	popl	%ebx 	       *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx 	       * 	       *   The call and pop essentially return the absolute address 	       * of the label .L66 and store it in %ebx.  The linker itself 	       * will ultimately change the first operand of the addl so 	       * that %ebx points to the GOT, but to keep things simple, the 	       * .o file must have this operand set so that it generates not 	       * the absolute address of .L66, but the absolute address of 	       * itself.  This allows the linker itself simply treat a GOTPC 	       * relocation as asking for a pcrel offset to the GOT to be 	       * added in, and the addend of the relocation is stored in the 	       * operand field for the instruction itself. 	       * 	       *   Our job here is to fix the operand so that it would add 	       * the correct offset so that %ebx would point to itself.  The 	       * thing that is tricky is that .-.L66 will point to the 	       * beginning of the instruction, so we need to further modify 	       * the operand so that it will point to itself.  There are 	       * other cases where you have something like: 	       * 	       *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66] 	       * 	       * and here no correction would be required.  Internally in 	       * the assembler we treat operands of this form as not being 	       * pcrel since the '.' is explicitly mentioned, and I wonder 	       * whether it would simplify matters to do it this way.  Who 	       * knows.  In earlier versions of the PIC patches, the 	       * pcrel_adjust field was used to store the correction, but 	       * since the expression is not pcrel, I felt it would be 	       * confusing to do it this way.  */
if|if
condition|(
operator|(
name|reloc_type
operator|==
name|BFD_RELOC_32
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_X86_64_32S
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_64
operator|)
operator|&&
name|GOT_symbol
operator|&&
name|GOT_symbol
operator|==
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_symbol
operator|&&
operator|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
operator|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op
operator|==
name|O_add
operator|&&
operator|(
operator|(
name|symbol_get_value_expression
argument_list|(
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_op_symbol
argument_list|)
operator|->
name|X_op
operator|)
operator|==
name|O_subtract
operator|)
operator|)
operator|)
condition|)
block|{
name|offsetT
name|add
decl_stmt|;
if|if
condition|(
name|insn_start_frag
operator|==
name|frag_now
condition|)
name|add
operator|=
operator|(
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|-
name|insn_start_off
expr_stmt|;
else|else
block|{
name|fragS
modifier|*
name|fr
decl_stmt|;
name|add
operator|=
name|insn_start_frag
operator|->
name|fr_fix
operator|-
name|insn_start_off
expr_stmt|;
for|for
control|(
name|fr
operator|=
name|insn_start_frag
operator|->
name|fr_next
init|;
name|fr
operator|&&
name|fr
operator|!=
name|frag_now
condition|;
name|fr
operator|=
name|fr
operator|->
name|fr_next
control|)
name|add
operator|+=
name|fr
operator|->
name|fr_fix
expr_stmt|;
name|add
operator|+=
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|object_64bit
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_386_GOTPC
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_X86_64_GOTPC32
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_X86_64_GOTPC64
expr_stmt|;
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
operator|->
name|X_add_number
operator|+=
name|add
expr_stmt|;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|op
index|[
name|n
index|]
operator|.
name|imms
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* x86_cons_fix_new is called via the expression parsing code when a    reloc is needed.  We use this hook to get the correct .got reloc.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|bfd_reloc_code_real
name|got_reloc
init|=
name|NO_RELOC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cons_sign
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|x86_cons_fix_new
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|unsigned
name|int
name|off
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|enum
name|bfd_reloc_code_real
name|r
init|=
name|reloc
argument_list|(
name|len
argument_list|,
literal|0
argument_list|,
name|cons_sign
argument_list|,
name|got_reloc
argument_list|)
decl_stmt|;
name|got_reloc
operator|=
name|NO_RELOC
expr_stmt|;
ifdef|#
directive|ifdef
name|TE_PE
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_secrel
condition|)
block|{
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|r
operator|=
name|BFD_RELOC_32_SECREL
expr_stmt|;
block|}
endif|#
directive|endif
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|LEX_AT
argument_list|)
end_if

begin_define
define|#
directive|define
name|lex_got
parameter_list|(
name|reloc
parameter_list|,
name|adjust
parameter_list|,
name|types
parameter_list|)
value|NULL
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Parse operands of the form<symbol>@GOTOFF+<nnn>    and similar .plt or .got references.     If we find one, set up the correct relocation in RELOC and copy the    input string, minus the `@GOTOFF' into a malloc'd buffer for    parsing by the calling routine.  Return this buffer, and if ADJUST    is non-null set it to the length of the string we removed from the    input line.  Otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lex_got
parameter_list|(
name|enum
name|bfd_reloc_code_real
modifier|*
name|reloc
parameter_list|,
name|int
modifier|*
name|adjust
parameter_list|,
name|unsigned
name|int
modifier|*
name|types
parameter_list|)
block|{
comment|/* Some of the relocations depend on the size of what field is to      be relocated.  But in our callers i386_immediate and i386_displacement      we don't yet know the operand size (this will be set by insn      matching).  Hence we record the word32 relocation here,      and adjust the reloc according to the real size in reloc().  */
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|enum
name|bfd_reloc_code_real
name|rel
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|unsigned
name|int
name|types64
decl_stmt|;
block|}
name|gotrel
index|[]
init|=
block|{
block|{
literal|"PLTOFF"
block|,
block|{
literal|0
block|,
name|BFD_RELOC_X86_64_PLTOFF64
block|}
block|,
name|Imm64
block|}
block|,
block|{
literal|"PLT"
block|,
block|{
name|BFD_RELOC_386_PLT32
block|,
name|BFD_RELOC_X86_64_PLT32
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Disp32
block|}
block|,
block|{
literal|"GOTPLT"
block|,
block|{
literal|0
block|,
name|BFD_RELOC_X86_64_GOTPLT64
block|}
block|,
name|Imm64
operator||
name|Disp64
block|}
block|,
block|{
literal|"GOTOFF"
block|,
block|{
name|BFD_RELOC_386_GOTOFF
block|,
name|BFD_RELOC_X86_64_GOTOFF64
block|}
block|,
name|Imm64
operator||
name|Disp64
block|}
block|,
block|{
literal|"GOTPCREL"
block|,
block|{
literal|0
block|,
name|BFD_RELOC_X86_64_GOTPCREL
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Disp32
block|}
block|,
block|{
literal|"TLSGD"
block|,
block|{
name|BFD_RELOC_386_TLS_GD
block|,
name|BFD_RELOC_X86_64_TLSGD
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Disp32
block|}
block|,
block|{
literal|"TLSLDM"
block|,
block|{
name|BFD_RELOC_386_TLS_LDM
block|,
literal|0
block|}
block|,
literal|0
block|}
block|,
block|{
literal|"TLSLD"
block|,
block|{
literal|0
block|,
name|BFD_RELOC_X86_64_TLSLD
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Disp32
block|}
block|,
block|{
literal|"GOTTPOFF"
block|,
block|{
name|BFD_RELOC_386_TLS_IE_32
block|,
name|BFD_RELOC_X86_64_GOTTPOFF
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Disp32
block|}
block|,
block|{
literal|"TPOFF"
block|,
block|{
name|BFD_RELOC_386_TLS_LE_32
block|,
name|BFD_RELOC_X86_64_TPOFF32
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator||
name|Disp32
operator||
name|Disp64
block|}
block|,
block|{
literal|"NTPOFF"
block|,
block|{
name|BFD_RELOC_386_TLS_LE
block|,
literal|0
block|}
block|,
literal|0
block|}
block|,
block|{
literal|"DTPOFF"
block|,
block|{
name|BFD_RELOC_386_TLS_LDO_32
block|,
name|BFD_RELOC_X86_64_DTPOFF32
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
operator||
name|Disp32
operator||
name|Disp64
block|}
block|,
block|{
literal|"GOTNTPOFF"
block|,
block|{
name|BFD_RELOC_386_TLS_GOTIE
block|,
literal|0
block|}
block|,
literal|0
block|}
block|,
block|{
literal|"INDNTPOFF"
block|,
block|{
name|BFD_RELOC_386_TLS_IE
block|,
literal|0
block|}
block|,
literal|0
block|}
block|,
block|{
literal|"GOT"
block|,
block|{
name|BFD_RELOC_386_GOT32
block|,
name|BFD_RELOC_X86_64_GOT32
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Disp32
operator||
name|Imm64
block|}
block|,
block|{
literal|"TLSDESC"
block|,
block|{
name|BFD_RELOC_386_TLS_GOTDESC
block|,
name|BFD_RELOC_X86_64_GOTPC32_TLSDESC
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Disp32
block|}
block|,
block|{
literal|"TLSCALL"
block|,
block|{
name|BFD_RELOC_386_TLS_DESC_CALL
block|,
name|BFD_RELOC_X86_64_TLSDESC_CALL
block|}
block|,
name|Imm32
operator||
name|Imm32S
operator||
name|Disp32
block|}
block|}
struct|;
name|char
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|IS_ELF
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|cp
operator|=
name|input_line_pointer
init|;
operator|*
name|cp
operator|!=
literal|'@'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
index|]
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|gotrel
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|gotrel
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|gotrel
index|[
name|j
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|gotrel
index|[
name|j
index|]
operator|.
name|str
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gotrel
index|[
name|j
index|]
operator|.
name|rel
index|[
name|object_64bit
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|first
decl_stmt|,
name|second
decl_stmt|;
name|char
modifier|*
name|tmpbuf
decl_stmt|,
modifier|*
name|past_reloc
decl_stmt|;
operator|*
name|reloc
operator|=
name|gotrel
index|[
name|j
index|]
operator|.
name|rel
index|[
name|object_64bit
index|]
expr_stmt|;
if|if
condition|(
name|adjust
condition|)
operator|*
name|adjust
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|types
condition|)
block|{
if|if
condition|(
name|flag_code
operator|!=
name|CODE_64BIT
condition|)
operator|*
name|types
operator|=
name|Imm32
operator||
name|Disp32
expr_stmt|;
else|else
operator|*
name|types
operator|=
name|gotrel
index|[
name|j
index|]
operator|.
name|types64
expr_stmt|;
block|}
if|if
condition|(
name|GOT_symbol
operator|==
name|NULL
condition|)
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
expr_stmt|;
comment|/* The length of the first part of our input line.  */
name|first
operator|=
name|cp
operator|-
name|input_line_pointer
expr_stmt|;
comment|/* The second part goes from after the reloc token until 		 (and including) an end_of_line char.  Don't use strlen 		 here as the end_of_line char may not be a NUL.  */
name|past_reloc
operator|=
name|cp
operator|+
literal|1
operator|+
name|len
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|past_reloc
init|;
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
operator|++
index|]
condition|;
control|)
empty_stmt|;
name|second
operator|=
name|cp
operator|-
name|past_reloc
expr_stmt|;
comment|/* Allocate and copy string.  The trailing NUL shouldn't 		 be necessary, but be safe.  */
name|tmpbuf
operator|=
name|xmalloc
argument_list|(
name|first
operator|+
name|second
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|second
operator|!=
literal|0
operator|&&
operator|*
name|past_reloc
operator|!=
literal|' '
condition|)
comment|/* Replace the relocation token with ' ', so that 		   errors like foo@GOTOFF1 will be detected.  */
name|tmpbuf
index|[
name|first
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuf
operator|+
name|first
argument_list|,
name|past_reloc
argument_list|,
name|second
argument_list|)
expr_stmt|;
name|tmpbuf
index|[
name|first
operator|+
name|second
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|tmpbuf
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"@%s reloc is not supported with %d-bit output format"
argument_list|)
argument_list|,
name|gotrel
index|[
name|j
index|]
operator|.
name|str
argument_list|,
literal|1
operator|<<
operator|(
literal|5
operator|+
name|object_64bit
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Might be a symbol version string.  Don't as_bad here.  */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|x86_cons
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|4
operator|||
operator|(
name|object_64bit
operator|&&
name|size
operator|==
literal|8
operator|)
condition|)
block|{
comment|/* Handle @GOTOFF and the like in an expression.  */
name|char
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
name|gotfree_input_line
decl_stmt|;
name|int
name|adjust
decl_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|gotfree_input_line
operator|=
name|lex_got
argument_list|(
operator|&
name|got_reloc
argument_list|,
operator|&
name|adjust
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
name|input_line_pointer
operator|=
name|gotfree_input_line
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
block|{
comment|/* expression () has merrily parsed up to the end of line, 	     or a comma - in the wrong buffer.  Transfer how far 	     input_line_pointer has moved to the right buffer.  */
name|input_line_pointer
operator|=
operator|(
name|save
operator|+
operator|(
name|input_line_pointer
operator|-
name|gotfree_input_line
operator|)
operator|+
name|adjust
operator|)
expr_stmt|;
name|free
argument_list|(
name|gotfree_input_line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|signed_cons
parameter_list|(
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|cons_sign
operator|=
literal|1
expr_stmt|;
name|cons
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|cons_sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_function
specifier|static
name|void
name|pe_directive_secrel
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
name|exp
operator|.
name|X_op
operator|=
name|O_secrel
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|i386_immediate
parameter_list|(
name|char
modifier|*
name|imm_start
parameter_list|)
block|{
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|char
modifier|*
name|gotfree_input_line
decl_stmt|;
name|segT
name|exp_seg
init|=
literal|0
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|types
init|=
operator|~
literal|0U
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|imm_operands
operator|==
name|MAX_IMMEDIATE_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"at most %d immediate operands are allowed"
argument_list|)
argument_list|,
name|MAX_IMMEDIATE_OPERANDS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|exp
operator|=
operator|&
name|im_expressions
index|[
name|i
operator|.
name|imm_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
name|exp
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|imm_start
argument_list|)
condition|)
operator|++
name|imm_start
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|imm_start
expr_stmt|;
name|gotfree_input_line
operator|=
name|lex_got
argument_list|(
operator|&
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
name|input_line_pointer
operator|=
name|gotfree_input_line
expr_stmt|;
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk `%s' after expression"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
name|free
argument_list|(
name|gotfree_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* Missing or bad expr becomes absolute 0.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing or invalid immediate expression `%s' taken as 0"
argument_list|)
argument_list|,
name|imm_start
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Size it properly later.  */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm64
expr_stmt|;
comment|/* If BFD64, sign extend val.  */
if|if
condition|(
operator|!
name|use_rela_relocations
operator|&&
operator|(
name|exp
operator|->
name|X_add_number
operator|&
operator|~
operator|(
operator|(
operator|(
name|addressT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|exp
operator|->
name|X_add_number
operator|=
operator|(
name|exp
operator|->
name|X_add_number
operator|^
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|-
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
elseif|else
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
operator|&&
name|exp_seg
operator|!=
name|absolute_section
operator|&&
name|exp_seg
operator|!=
name|text_section
operator|&&
name|exp_seg
operator|!=
name|data_section
operator|&&
name|exp_seg
operator|!=
name|bss_section
operator|&&
name|exp_seg
operator|!=
name|undefined_section
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|exp_seg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment %s in operand"
argument_list|)
argument_list|,
name|exp_seg
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|!
name|intel_syntax
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal immediate register operand %s"
argument_list|)
argument_list|,
name|imm_start
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* This is an address.  The size of the address will be 	 determined later, depending on destination register, 	 suffix, or the default for the section.  */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator||
name|Imm32S
operator||
name|Imm64
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&=
name|types
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|i386_scale
parameter_list|(
name|char
modifier|*
name|scale
parameter_list|)
block|{
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
name|scale
expr_stmt|;
name|val
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|1
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
block|{
name|char
name|sep
init|=
operator|*
name|input_line_pointer
decl_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting scale factor of 1, 2, 4, or 8: got `%s'"
argument_list|)
argument_list|,
name|scale
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|sep
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|log2_scale_factor
operator|!=
literal|0
operator|&&
name|i
operator|.
name|index_reg
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"scale factor of %d without an index register"
argument_list|)
argument_list|,
literal|1
operator|<<
name|i
operator|.
name|log2_scale_factor
argument_list|)
expr_stmt|;
if|#
directive|if
name|SCALE1_WHEN_NO_INDEX
name|i
operator|.
name|log2_scale_factor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|scale
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|scale
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i386_displacement
parameter_list|(
name|char
modifier|*
name|disp_start
parameter_list|,
name|char
modifier|*
name|disp_end
parameter_list|)
block|{
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|segT
name|exp_seg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|char
modifier|*
name|gotfree_input_line
decl_stmt|;
name|int
name|bigdisp
decl_stmt|,
name|override
decl_stmt|;
name|unsigned
name|int
name|types
init|=
name|Disp
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|==
name|MAX_MEMORY_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"at most %d displacement operands are allowed"
argument_list|)
argument_list|,
name|MAX_MEMORY_OPERANDS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|JumpAbsolute
operator|)
operator|||
operator|!
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpDword
operator|)
operator|)
condition|)
block|{
name|bigdisp
operator|=
name|Disp32
expr_stmt|;
name|override
operator|=
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For PC-relative branches, the width of the displacement 	 is dependent upon data size, not address size.  */
name|bigdisp
operator|=
literal|0
expr_stmt|;
name|override
operator|=
operator|(
name|i
operator|.
name|prefix
index|[
name|DATA_PREFIX
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
if|if
condition|(
operator|!
name|bigdisp
condition|)
name|bigdisp
operator|=
operator|(
operator|(
name|override
operator|||
name|i
operator|.
name|suffix
operator|==
name|WORD_MNEM_SUFFIX
operator|)
condition|?
name|Disp16
else|:
name|Disp32S
operator||
name|Disp32
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|override
condition|)
name|bigdisp
operator|=
name|Disp64
operator||
name|Disp32S
operator||
name|Disp32
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bigdisp
condition|)
block|{
if|if
condition|(
operator|!
name|override
condition|)
name|override
operator|=
operator|(
name|i
operator|.
name|suffix
operator|==
operator|(
name|flag_code
operator|!=
name|CODE_16BIT
condition|?
name|WORD_MNEM_SUFFIX
else|:
name|LONG_MNEM_SUFFIX
operator|)
operator|)
expr_stmt|;
name|bigdisp
operator|=
name|Disp32
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
name|override
condition|)
name|bigdisp
operator|=
name|Disp16
expr_stmt|;
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|bigdisp
expr_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
index|]
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|disp_operands
operator|++
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|disp_start
expr_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|disp_end
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|GCC_ASM_O_HACK
define|#
directive|define
name|GCC_ASM_O_HACK
value|0
endif|#
directive|endif
if|#
directive|if
name|GCC_ASM_O_HACK
name|END_STRING_AND_SAVE
argument_list|(
name|disp_end
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|BaseIndex
operator|)
operator|!=
literal|0
operator|&&
name|displacement_string_end
index|[
operator|-
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
comment|/* This hack is to avoid a warning when using the "o" 	 constraint within gcc asm statements. 	 For instance:  	 #define _set_tssldt_desc(n,addr,limit,type) \ 	 __asm__ __volatile__ ( \ 	 "movw %w2,%0\n\t" \ 	 "movw %w1,2+%0\n\t" \ 	 "rorl $16,%1\n\t" \ 	 "movb %b1,4+%0\n\t" \ 	 "movb %4,5+%0\n\t" \ 	 "movb $0,6+%0\n\t" \ 	 "movb %h1,7+%0\n\t" \ 	 "rorl $16,%1" \ 	 : "=o"(*(n)) : "q" (addr), "ri"(limit), "i"(type))  	 This works great except that the output assembler ends 	 up looking a bit weird if it turns out that there is 	 no offset.  You end up producing code that looks like:  	 #APP 	 movw $235,(%eax) 	 movw %dx,2+(%eax) 	 rorl $16,%edx 	 movb %dl,4+(%eax) 	 movb $137,5+(%eax) 	 movb $0,6+(%eax) 	 movb %dh,7+(%eax) 	 rorl $16,%edx 	 #NO_APP  	 So here we provide the missing zero.  */
operator|*
name|displacement_string_end
operator|=
literal|'0'
expr_stmt|;
block|}
endif|#
directive|endif
name|gotfree_input_line
operator|=
name|lex_got
argument_list|(
operator|&
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
name|input_line_pointer
operator|=
name|gotfree_input_line
expr_stmt|;
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk `%s' after expression"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
if|#
directive|if
name|GCC_ASM_O_HACK
name|RESTORE_END_STRING
argument_list|(
name|disp_end
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RESTORE_END_STRING
argument_list|(
name|disp_end
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|gotfree_input_line
condition|)
name|free
argument_list|(
name|gotfree_input_line
argument_list|)
expr_stmt|;
comment|/* We do this to make sure that the section symbol is in      the symbol table.  We will ultimately change the relocation      to be relative to the beginning of the section.  */
if|if
condition|(
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_386_GOTOFF
operator|||
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_X86_64_GOTPCREL
operator|||
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_X86_64_GOTOFF64
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad expression used with @%s"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_X86_64_GOTPCREL
condition|?
literal|"GOTPCREL"
else|:
literal|"GOTOFF"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|S_IS_LOCAL
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|undefined_section
condition|)
name|section_symbol
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
name|GOT_symbol
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_X86_64_GOTPCREL
condition|)
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|==
name|BFD_RELOC_X86_64_GOTOFF64
condition|)
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_64
expr_stmt|;
else|else
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|=
name|BFD_RELOC_32
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* Missing or bad expr becomes absolute 0.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing or invalid displacement expression `%s' taken as 0"
argument_list|)
argument_list|,
name|disp_start
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
operator|&&
name|exp_seg
operator|!=
name|absolute_section
operator|&&
name|exp_seg
operator|!=
name|text_section
operator|&&
name|exp_seg
operator|!=
name|data_section
operator|&&
name|exp_seg
operator|!=
name|bss_section
operator|&&
name|exp_seg
operator|!=
name|undefined_section
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|exp_seg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment %s in operand"
argument_list|)
argument_list|,
name|exp_seg
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
operator|~
name|Disp
operator|)
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&=
name|types
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Make sure the memory operand we've been dealt is valid.    Return 1 on success, 0 on a failure.  */
end_comment

begin_function
specifier|static
name|int
name|i386_index_check
parameter_list|(
specifier|const
name|char
modifier|*
name|operand_string
parameter_list|)
block|{
name|int
name|ok
decl_stmt|;
if|#
directive|if
name|INFER_ADDR_PREFIX
name|int
name|fudged
init|=
literal|0
decl_stmt|;
name|tryprefix
label|:
endif|#
directive|endif
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|current_templates
operator|->
name|start
operator|->
name|cpu_flags
operator|&
name|CpuSVME
operator|)
operator|&&
name|current_templates
operator|->
name|end
index|[
operator|-
literal|1
index|]
operator|.
name|operand_types
index|[
literal|0
index|]
operator|==
name|AnyMem
condition|)
block|{
comment|/* Memory operands of SVME insns are special in that they only allow 	 rAX as their memory address and ignore any segment override.  */
name|unsigned
name|RegXX
decl_stmt|;
comment|/* SKINIT is even more restrictive: it always requires EAX.  */
if|if
condition|(
name|strcmp
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|,
literal|"skinit"
argument_list|)
operator|==
literal|0
condition|)
name|RegXX
operator|=
name|Reg32
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
name|RegXX
operator|=
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|==
literal|0
condition|?
name|Reg64
else|:
name|Reg32
expr_stmt|;
else|else
name|RegXX
operator|=
operator|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|?
name|Reg16
else|:
name|Reg32
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|base_reg
operator|||
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Acc
operator|)
operator|||
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|RegXX
operator|)
operator|||
name|i
operator|.
name|index_reg
operator|||
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Disp
operator|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
name|unsigned
name|RegXX
init|=
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|==
literal|0
condition|?
name|Reg64
else|:
name|Reg32
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|RegXX
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|!=
name|BaseIndex
operator|||
name|i
operator|.
name|index_reg
operator|)
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
operator|(
name|RegXX
operator||
name|BaseIndex
operator|)
operator|)
operator|!=
operator|(
name|RegXX
operator||
name|BaseIndex
operator|)
operator|)
operator|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flag_code
operator|==
name|CODE_16BIT
operator|)
operator|^
operator|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 16bit checks.  */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg16
operator||
name|BaseIndex
operator||
name|RegRex
operator|)
operator|)
operator|!=
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
operator|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|!=
operator|(
name|Reg16
operator||
name|BaseIndex
operator|)
operator|)
operator|||
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|<
literal|6
operator|&&
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|>=
literal|6
operator|&&
name|i
operator|.
name|log2_scale_factor
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 32bit checks.  */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg32
operator||
name|RegRex
operator|)
operator|)
operator|!=
name|Reg32
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
operator|(
name|Reg32
operator||
name|BaseIndex
operator||
name|RegRex
operator|)
operator|)
operator|!=
operator|(
name|Reg32
operator||
name|BaseIndex
operator|)
operator|)
operator|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|#
directive|if
name|INFER_ADDR_PREFIX
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|prefix
index|[
name|ADDR_PREFIX
index|]
operator|=
name|ADDR_PREFIX_OPCODE
expr_stmt|;
name|i
operator|.
name|prefixes
operator|+=
literal|1
expr_stmt|;
comment|/* Change the size of any displacement too.  At most one of 	     Disp16 or Disp32 is set. 	     FIXME.  There doesn't seem to be any real need for separate 	     Disp16 and Disp32 flags.  The same goes for Imm16 and Imm32. 	     Removing them would probably clean up the code quite a lot.  */
if|if
condition|(
name|flag_code
operator|!=
name|CODE_64BIT
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
operator|(
name|Disp16
operator||
name|Disp32
operator|)
operator|)
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|^=
operator|(
name|Disp16
operator||
name|Disp32
operator|)
expr_stmt|;
name|fudged
operator|=
literal|1
expr_stmt|;
goto|goto
name|tryprefix
goto|;
block|}
if|if
condition|(
name|fudged
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is not a valid base/index expression"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is not a valid %s bit base/index expression"
argument_list|)
argument_list|,
name|operand_string
argument_list|,
name|flag_code_names
index|[
name|flag_code
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero    on error.  */
end_comment

begin_function
specifier|static
name|int
name|i386_operand
parameter_list|(
name|char
modifier|*
name|operand_string
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|end_op
decl_stmt|;
name|char
modifier|*
name|op_string
init|=
name|operand_string
decl_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
comment|/* We check for an absolute prefix (differentiating,      for example, 'jmp pc_relative_label' from 'jmp *absolute_label'.  */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
comment|/* Check if operand is a register.  */
if|if
condition|(
operator|(
name|r
operator|=
name|parse_register
argument_list|(
name|op_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Check for a segment override by searching for ':' after a 	 segment register.  */
name|op_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
operator|*
name|op_string
operator|==
literal|':'
operator|&&
operator|(
name|r
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|reg_num
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|gs
expr_stmt|;
break|break;
block|}
comment|/* Skip the ':' and whitespace.  */
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
operator|!
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|!
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|*
name|op_string
operator|!=
literal|'('
operator|&&
operator|*
name|op_string
operator|!=
name|ABSOLUTE_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad memory operand `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Handle case of %es:*foo.  */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
goto|goto
name|do_memory_reference
goto|;
block|}
if|if
condition|(
operator|*
name|op_string
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk `%s' after register"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|r
operator|->
name|reg_type
operator|&
operator|~
name|BaseIndex
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|regs
operator|=
name|r
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|IMMEDIATE_PREFIX
condition|)
block|{
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|JumpAbsolute
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate operand illegal with absolute jump"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|i386_immediate
argument_list|(
name|op_string
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
operator|*
name|op_string
operator|==
literal|'('
condition|)
block|{
comment|/* This is a memory reference of some sort.  */
name|char
modifier|*
name|base_string
decl_stmt|;
comment|/* Start and end of displacement string expression (if found).  */
name|char
modifier|*
name|displacement_string_start
decl_stmt|;
name|char
modifier|*
name|displacement_string_end
decl_stmt|;
name|do_memory_reference
label|:
if|if
condition|(
operator|(
name|i
operator|.
name|mem_operands
operator|==
literal|1
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|==
literal|0
operator|)
operator|||
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many memory references for `%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for base index form.  We detect the base index form by 	 looking for an ')' at the end of the operand, searching 	 for the '(' matching it, and finding a REGISTER_PREFIX or ',' 	 after the '('.  */
name|base_string
operator|=
name|op_string
operator|+
name|strlen
argument_list|(
name|op_string
argument_list|)
expr_stmt|;
operator|--
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|--
name|base_string
expr_stmt|;
comment|/* If we only have a displacement, set-up for it to be parsed later.  */
name|displacement_string_start
operator|=
name|op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|base_string
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
block|{
name|char
modifier|*
name|temp_string
decl_stmt|;
name|unsigned
name|int
name|parens_balanced
init|=
literal|1
decl_stmt|;
comment|/* We've already checked that the number of left& right ()'s are 	     equal, so this loop will not be infinite.  */
do|do
block|{
name|base_string
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
name|parens_balanced
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|'('
condition|)
name|parens_balanced
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|parens_balanced
condition|)
do|;
name|temp_string
operator|=
name|base_string
expr_stmt|;
comment|/* Skip past '(' and whitespace.  */
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
operator|||
operator|(
operator|(
name|i
operator|.
name|base_reg
operator|=
name|parse_register
argument_list|(
name|base_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|displacement_string_end
operator|=
name|temp_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
condition|)
block|{
name|base_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
block|}
comment|/* There may be an index reg or scale factor here.  */
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
condition|)
block|{
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|.
name|index_reg
operator|=
name|parse_register
argument_list|(
name|base_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|base_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
condition|)
block|{
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting `,' or `)' "
literal|"after index register in `%s'"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|base_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for scale factor.  */
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|char
modifier|*
name|end_scale
init|=
name|i386_scale
argument_list|(
name|base_string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|end_scale
condition|)
return|return
literal|0
return|;
name|base_string
operator|=
name|end_scale
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|++
name|base_string
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting `)' "
literal|"after scale factor in `%s'"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting index register or scale factor "
literal|"after `,'; got '%c'"
argument_list|)
argument_list|,
operator|*
name|base_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting `,' or `)' "
literal|"after base register in `%s'"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name `%s'"
argument_list|)
argument_list|,
name|base_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If there's an expression beginning the operand, parse it, 	 assuming displacement_string_start and 	 displacement_string_end are meaningful.  */
if|if
condition|(
name|displacement_string_start
operator|!=
name|displacement_string_end
condition|)
block|{
if|if
condition|(
operator|!
name|i386_displacement
argument_list|(
name|displacement_string_start
argument_list|,
name|displacement_string_end
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Special case for (%dx) while doing input/output op.  */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|==
operator|(
name|Reg16
operator||
name|InOutPortReg
operator|)
operator|&&
name|i
operator|.
name|index_reg
operator|==
literal|0
operator|&&
name|i
operator|.
name|log2_scale_factor
operator|==
literal|0
operator|&&
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|==
literal|0
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|&
name|Disp
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|InOutPortReg
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|i386_index_check
argument_list|(
name|operand_string
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* It's not a memory operand; argh!  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid char %s beginning operand %d `%s'"
argument_list|)
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|op_string
argument_list|)
argument_list|,
name|this_operand
operator|+
literal|1
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* Normal return.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* md_estimate_size_before_relax()     Called just before relax() for rs_machine_dependent frags.  The x86    assembler uses these frags to handle variable size jump    instructions.     Any symbol that is now undefined will not become defined.    Return the correct fr_subtype in the frag.    Return the initial "guess for variable size of frag" to caller.    The guess is actually the growth beyond the fixed part.  Whatever    we do to grow the fixed or variable part contributes to our    returned value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
comment|/* We've already got fragP->fr_subtype right;  all we have to do is      check for un-relaxable symbols.  On an ELF system, we can't relax      an externally visible symbol, because it may be overridden by a      shared library.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|||
operator|(
name|IS_ELF
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* Symbol is undefined in this segment, or we need to keep a 	 reloc so that weak symbols can be overridden.  */
name|int
name|size
init|=
operator|(
name|fragP
operator|->
name|fr_subtype
operator|&
name|CODE16
operator|)
condition|?
literal|2
else|:
literal|4
decl_stmt|;
name|enum
name|bfd_reloc_code_real
name|reloc_type
decl_stmt|;
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
name|int
name|old_fr_fix
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_var
operator|!=
name|NO_RELOC
condition|)
name|reloc_type
operator|=
name|fragP
operator|->
name|fr_var
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
else|else
name|reloc_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
switch|switch
condition|(
name|TYPE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
case|case
name|UNCOND_JUMP
case|:
comment|/* Make jmp (0xeb) a (d)word displacement jump.  */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|size
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
argument_list|,
name|size
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_JUMP86
case|:
if|if
condition|(
name|size
operator|==
literal|2
operator|&&
operator|(
operator|!
name|no_cond_jump_promotion
operator|||
name|fragP
operator|->
name|fr_var
operator|!=
name|NO_RELOC
operator|)
condition|)
block|{
comment|/* Negate the condition, and branch past an 		 unconditional jump.  */
name|opcode
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
name|opcode
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* Insert an unconditional jump.  */
name|opcode
index|[
literal|2
index|]
operator|=
literal|0xe9
expr_stmt|;
comment|/* We added two extra opcode bytes, and have a two byte 		 offset.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
operator|+
literal|2
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|COND_JUMP
case|:
if|if
condition|(
name|no_cond_jump_promotion
operator|&&
name|fragP
operator|->
name|fr_var
operator|==
name|NO_RELOC
condition|)
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_signed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* This changes the byte-displacement jump 0x7N 	     to the (d)word-displacement jump 0x0f,0x8N.  */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
comment|/* We've added an opcode byte.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
name|size
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
name|size
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
return|return
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
return|;
block|}
comment|/* Guess size depending on current relax state.  Initially the relax      state will correspond to a short jump and we return 1, because      the variable part of the frag (the branch offset) is one byte      long.  However, we can relax a section more than once and in that      case we must either set fr_subtype back to the unrelaxed state,      or return the value for the appropriate branch.  */
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_comment
comment|/* Called after relax() is finished.     In:	Address of frag. 	fr_type == rs_machine_dependent. 	fr_subtype is what the address relaxed to.     Out:	Any fixSs and constants are set up. 	Caller will turn frag into a ".space 0".  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|char
modifier|*
name|where_to_put_displacement
init|=
name|NULL
decl_stmt|;
name|offsetT
name|target_address
decl_stmt|;
name|offsetT
name|opcode_address
decl_stmt|;
name|unsigned
name|int
name|extension
init|=
literal|0
decl_stmt|;
name|offsetT
name|displacement_from_opcode_start
decl_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* Address we want to reach in file space.  */
name|target_address
operator|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
comment|/* Address opcode resides at in file space.  */
name|opcode_address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* Displacement from opcode start to fill into instruction.  */
name|displacement_from_opcode_start
operator|=
name|target_address
operator|-
name|opcode_address
expr_stmt|;
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_subtype
operator|&
name|BIG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't have to change opcode.  */
name|extension
operator|=
literal|1
expr_stmt|;
comment|/* 1 opcode + 1 displacement  */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|no_cond_jump_promotion
operator|&&
name|TYPE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|!=
name|UNCOND_JUMP
condition|)
name|as_warn_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"long jump required"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BIG
argument_list|)
case|:
name|extension
operator|=
literal|4
expr_stmt|;
comment|/* 1 opcode + 4 displacement  */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BIG16
argument_list|)
case|:
name|extension
operator|=
literal|2
expr_stmt|;
comment|/* 1 opcode + 2 displacement  */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BIG
argument_list|)
case|:
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP86
argument_list|,
name|BIG
argument_list|)
case|:
name|extension
operator|=
literal|5
expr_stmt|;
comment|/* 2 opcode + 4 displacement  */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BIG16
argument_list|)
case|:
name|extension
operator|=
literal|3
expr_stmt|;
comment|/* 2 opcode + 2 displacement  */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP86
argument_list|,
name|BIG16
argument_list|)
case|:
name|extension
operator|=
literal|4
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
name|opcode
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|opcode
index|[
literal|2
index|]
operator|=
literal|0xe9
expr_stmt|;
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|3
index|]
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If size if less then four we are sure that the operand fits,      but if it's 4, then it could be that the displacement is larger      then -/+ 2GB.  */
if|if
condition|(
name|DISP_SIZE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|==
literal|4
operator|&&
name|object_64bit
operator|&&
operator|(
call|(
name|addressT
call|)
argument_list|(
name|displacement_from_opcode_start
operator|-
name|extension
operator|+
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
literal|31
operator|)
argument_list|)
operator|>
operator|(
operator|(
operator|(
name|addressT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"jump target out of range"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make us emit 0.  */
name|displacement_from_opcode_start
operator|=
name|extension
expr_stmt|;
block|}
comment|/* Now put displacement after opcode.  */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|where_to_put_displacement
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|displacement_from_opcode_start
operator|-
name|extension
argument_list|)
argument_list|,
name|DISP_SIZE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Size of byte displacement jmp.  */
end_comment

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of dword displacement jmp.  */
end_comment

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|offsetT
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* Opcode for byte-disp jump.  */
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xeb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|offsetT
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|5
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Apply a fixup (fixS) to segment data, once it has been determined    by our caller that we have all the info we need to fix it up.     On the 386, immediates, displacements, and data pointers are all in    the same (little-endian) format, so we don't need to care about which    we are handling.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
comment|/* The fix we're to put in.  */
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Pointer to the value of the bits.  */
name|valueT
modifier|*
name|valP
decl_stmt|;
comment|/* Segment fix is from.  */
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valP
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TE_Mach
argument_list|)
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
default|default:
break|break;
case|case
name|BFD_RELOC_64
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_X86_64_32S
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_64_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_8_PCREL
operator|)
operator|&&
operator|!
name|use_rela_relocations
condition|)
block|{
comment|/* This is a hack.  There should be a better way to handle this. 	 This covers for the fact that bfd_install_relocation will 	 subtract the current location (for partial_inplace, PC relative 	 relocations); see more below.  */
ifndef|#
directive|ifndef
name|OBJ_AOUT
if|if
condition|(
name|IS_ELF
ifdef|#
directive|ifdef
name|TE_PE
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_coff_flavour
endif|#
directive|endif
condition|)
name|value
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|IS_ELF
condition|)
block|{
name|segT
name|sym_seg
init|=
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sym_seg
operator|==
name|seg
operator|||
operator|(
name|symbol_section_p
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|sym_seg
operator|!=
name|absolute_section
operator|)
operator|)
operator|&&
operator|!
name|generic_force_reloc
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
comment|/* Yes, we add the values in twice.  This is because 		 bfd_install_relocation subtracts them out again.  I think 		 bfd_install_relocation is broken, but I don't dare change 		 it.  FIXME.  */
name|value
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|&&
name|defined
argument_list|(
name|TE_PE
argument_list|)
comment|/* For some reason, the PE format does not store a 	 section address offset for a PC relative symbol.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
operator|||
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Fix a few things - the dynamic linker expects certain values here,      and we must not disappoint it.  */
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|IS_ELF
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_386_PLT32
case|:
case|case
name|BFD_RELOC_X86_64_PLT32
case|:
comment|/* Make the jump instruction point to the address of the operand.  At 	   runtime we merely add the offset to the actual PLT entry.  */
name|value
operator|=
operator|-
literal|4
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_386_TLS_GD
case|:
case|case
name|BFD_RELOC_386_TLS_LDM
case|:
case|case
name|BFD_RELOC_386_TLS_IE_32
case|:
case|case
name|BFD_RELOC_386_TLS_IE
case|:
case|case
name|BFD_RELOC_386_TLS_GOTIE
case|:
case|case
name|BFD_RELOC_386_TLS_GOTDESC
case|:
case|case
name|BFD_RELOC_X86_64_TLSGD
case|:
case|case
name|BFD_RELOC_X86_64_TLSLD
case|:
case|case
name|BFD_RELOC_X86_64_GOTTPOFF
case|:
case|case
name|BFD_RELOC_X86_64_GOTPC32_TLSDESC
case|:
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Fully resolved at runtime.  No addend.  */
comment|/* Fallthrough */
case|case
name|BFD_RELOC_386_TLS_LE
case|:
case|case
name|BFD_RELOC_386_TLS_LDO_32
case|:
case|case
name|BFD_RELOC_386_TLS_LE_32
case|:
case|case
name|BFD_RELOC_X86_64_DTPOFF32
case|:
case|case
name|BFD_RELOC_X86_64_DTPOFF64
case|:
case|case
name|BFD_RELOC_X86_64_TPOFF32
case|:
case|case
name|BFD_RELOC_X86_64_TPOFF64
case|:
name|S_SET_THREAD_LOCAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_386_TLS_DESC_CALL
case|:
case|case
name|BFD_RELOC_X86_64_TLSDESC_CALL
case|:
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Fully resolved at runtime.  No addend.  */
name|S_SET_THREAD_LOCAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_386_GOT32
case|:
case|case
name|BFD_RELOC_X86_64_GOT32
case|:
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Fully resolved at runtime.  No addend.  */
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)  */
operator|*
name|valP
operator|=
name|value
expr_stmt|;
endif|#
directive|endif
comment|/* !defined (TE_Mach)  */
comment|/* Are we finished with this relocation now?  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|use_rela_relocations
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
comment|/* Remember value for tc_gen_reloc.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn the string pointed to by litP into a floating point constant    of type TYPE, and emit the appropriate bytes.  The number of    LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof ()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loops outputs the LITTLENUMs in REVERSE order; in accord with      the bigendian 386.  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|char
name|output_invalid_buf
index|[
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
literal|2
operator|+
literal|6
expr|]
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|char
modifier|*
name|output_invalid
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|snprintf
argument_list|(
name|output_invalid_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|output_invalid_buf
argument_list|)
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|output_invalid_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|output_invalid_buf
argument_list|)
argument_list|,
literal|"(0x%x)"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
name|output_invalid_buf
return|;
block|}
end_function

begin_comment
comment|/* REG_STRING starts *before* REGISTER_PREFIX.  */
end_comment

begin_function
specifier|static
specifier|const
name|reg_entry
modifier|*
name|parse_real_register
parameter_list|(
name|char
modifier|*
name|reg_string
parameter_list|,
name|char
modifier|*
modifier|*
name|end_op
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|reg_string
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|reg_name_given
index|[
name|MAX_REG_NAME_SIZE
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
comment|/* Skip possible REGISTER_PREFIX and possible whitespace.  */
if|if
condition|(
operator|*
name|s
operator|==
name|REGISTER_PREFIX
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|p
operator|=
name|reg_name_given
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|register_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|reg_name_given
operator|+
name|MAX_REG_NAME_SIZE
condition|)
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
name|s
operator|++
expr_stmt|;
block|}
comment|/* For naked regs, make sure that we are not dealing with an identifier.      This prevents confusing an identifier like `eax_var' with register      `eax'.  */
if|if
condition|(
name|allow_naked_reg
operator|&&
name|identifier_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
condition|)
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
operator|*
name|end_op
operator|=
name|s
expr_stmt|;
name|r
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name_given
argument_list|)
expr_stmt|;
comment|/* Handle floating point regs, allowing spaces in the (i) part.  */
if|if
condition|(
name|r
operator|==
name|i386_regtab
comment|/* %st is first entry of table  */
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
condition|)
block|{
name|int
name|fpr
init|=
operator|*
name|s
operator|-
literal|'0'
decl_stmt|;
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
block|{
operator|*
name|end_op
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|r
operator|=
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
literal|"st(0)"
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
operator|+
name|fpr
return|;
block|}
block|}
comment|/* We have "%st(" then garbage.  */
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|r
operator|->
name|reg_flags
operator|&
operator|(
name|RegRex64
operator||
name|RegRex
operator|)
operator|)
operator||
operator|(
name|r
operator|->
name|reg_type
operator|&
name|Reg64
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|r
operator|->
name|reg_type
operator|!=
name|Control
operator|||
operator|!
operator|(
name|cpu_arch_flags
operator|&
name|CpuSledgehammer
operator|)
operator|)
operator|&&
name|flag_code
operator|!=
name|CODE_64BIT
condition|)
return|return
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|NULL
return|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* REG_STRING starts *before* REGISTER_PREFIX.  */
end_comment

begin_function
specifier|static
specifier|const
name|reg_entry
modifier|*
name|parse_register
parameter_list|(
name|char
modifier|*
name|reg_string
parameter_list|,
name|char
modifier|*
modifier|*
name|end_op
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|*
name|reg_string
operator|==
name|REGISTER_PREFIX
operator|||
name|allow_naked_reg
condition|)
name|r
operator|=
name|parse_real_register
argument_list|(
name|reg_string
argument_list|,
name|end_op
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|input_line_pointer
operator|=
name|reg_string
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|reg_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|reg_section
condition|)
block|{
specifier|const
name|expressionS
modifier|*
name|e
init|=
name|symbol_get_value_expression
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
name|know
argument_list|(
name|e
operator|->
name|X_op
operator|==
name|O_register
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|e
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|valueT
operator|)
name|e
operator|->
name|X_add_number
operator|<
name|i386_regtab_size
argument_list|)
expr_stmt|;
name|r
operator|=
name|i386_regtab
operator|+
name|e
operator|->
name|X_add_number
expr_stmt|;
operator|*
name|end_op
operator|=
name|input_line_pointer
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|i386_parse_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|expressionS
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|nextcharP
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|input_line_pointer
decl_stmt|;
operator|*
name|end
operator|=
operator|*
name|nextcharP
expr_stmt|;
name|r
operator|=
name|parse_register
argument_list|(
name|name
argument_list|,
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|end
operator|<=
name|input_line_pointer
condition|)
block|{
operator|*
name|nextcharP
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|r
operator|-
name|i386_regtab
expr_stmt|;
return|return
literal|1
return|;
block|}
name|input_line_pointer
operator|=
name|end
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|r
init|=
name|parse_real_register
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|r
operator|-
name|i386_regtab
expr_stmt|;
name|input_line_pointer
operator|=
name|end
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"kVQ:sqn"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"qn"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OPTION_32
value|(OPTION_MD_BASE + 0)
end_define

begin_define
define|#
directive|define
name|OPTION_64
value|(OPTION_MD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_DIVIDE
value|(OPTION_MD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|OPTION_MARCH
value|(OPTION_MD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|OPTION_MTUNE
value|(OPTION_MD_BASE + 4)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_32
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_PEP
argument_list|)
block|{
literal|"64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_64
block|}
block|,
endif|#
directive|endif
block|{
literal|"divide"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DIVIDE
block|}
block|,
block|{
literal|"march"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MARCH
block|}
block|,
block|{
literal|"mtune"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MTUNE
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|optimize_align_code
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet_warnings
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section 	 should be emitted or not.  FIXME: Not implemented.  */
case|case
literal|'Q'
case|:
break|break;
comment|/* -V: SVR4 argument to print version ID.  */
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
comment|/* -k: Ignore for FreeBSD compatibility.  */
case|case
literal|'k'
case|:
break|break;
case|case
literal|'s'
case|:
comment|/* -s: On i386 Solaris, this tells the native assembler to use 	 .stab instead of .stab.excl.  We always use .stab anyhow.  */
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_PEP
argument_list|)
case|case
name|OPTION_64
case|:
block|{
specifier|const
name|char
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
modifier|*
name|l
decl_stmt|;
name|list
operator|=
name|bfd_target_list
argument_list|()
expr_stmt|;
for|for
control|(
name|l
operator|=
name|list
init|;
operator|*
name|l
operator|!=
name|NULL
condition|;
name|l
operator|++
control|)
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-x86-64"
argument_list|)
operator|||
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"coff-x86-64"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"pe-x86-64"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"pei-x86-64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|default_arch
operator|=
literal|"x86_64"
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|l
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"No compiled in support for x86_64"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|OPTION_32
case|:
name|default_arch
operator|=
literal|"i386"
expr_stmt|;
break|break;
case|case
name|OPTION_DIVIDE
case|:
ifdef|#
directive|ifdef
name|SVR4_COMMENT_CHARS
block|{
name|char
modifier|*
name|n
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|i386_comment_chars
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|n
expr_stmt|;
for|for
control|(
name|s
operator|=
name|i386_comment_chars
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|!=
literal|'/'
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|i386_comment_chars
operator|=
name|n
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|OPTION_MARCH
case|:
if|if
condition|(
operator|*
name|arg
operator|==
literal|'.'
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Invalid -march= option: `%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cpu_arch
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
name|cpu_arch
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_arch_isa
operator|=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|cpu_arch_isa_flags
operator|=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
if|if
condition|(
operator|!
name|cpu_arch_tune_set
condition|)
block|{
name|cpu_arch_tune
operator|=
name|cpu_arch_isa
expr_stmt|;
name|cpu_arch_tune_flags
operator|=
name|cpu_arch_isa_flags
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|ARRAY_SIZE
argument_list|(
name|cpu_arch
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Invalid -march= option: `%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_MTUNE
case|:
if|if
condition|(
operator|*
name|arg
operator|==
literal|'.'
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Invalid -mtune= option: `%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cpu_arch
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
name|cpu_arch
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_arch_tune_set
operator|=
literal|1
expr_stmt|;
name|cpu_arch_tune
operator|=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|cpu_arch_tune_flags
operator|=
name|cpu_arch
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|ARRAY_SIZE
argument_list|(
name|cpu_arch
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Invalid -mtune= option: `%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -Q                      ignored\n\   -V                      print assembler version number\n\   -k                      ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -n                      Do not optimize code alignment\n\   -q                      quieten some warnings\n"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -s                      ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_PEP
argument_list|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --32/--64               generate 32bit/64bit code\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SVR4_COMMENT_CHARS
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --divide                do not treat `/' as a comment character\n"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --divide                ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -march=CPU/-mtune=CPU   generate code/optimize for CPU, where CPU is one of:\n\                            i386, i486, pentium, pentiumpro, pentium4, nocona,\n\                            core, core2, k6, athlon, k8, generic32, generic64\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TE_PEP
argument_list|)
end_if

begin_function
specifier|const
name|char
modifier|*
name|x86_64_target_format
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"x86_64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set_code_flag
argument_list|(
name|CODE_64BIT
argument_list|)
expr_stmt|;
return|return
name|COFF_TARGET_FORMAT
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"i386"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set_code_flag
argument_list|(
name|CODE_32BIT
argument_list|)
expr_stmt|;
return|return
literal|"coff-i386"
return|;
block|}
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown architecture"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
operator|(
name|defined
argument_list|(
name|OBJ_MAYBE_COFF
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
expr|\
operator|||
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
end_if

begin_comment
comment|/* Pick the target format to use.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_target_format
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"x86_64"
argument_list|)
condition|)
block|{
name|set_code_flag
argument_list|(
name|CODE_64BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_arch_isa_flags
operator|==
literal|0
condition|)
name|cpu_arch_isa_flags
operator|=
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
expr_stmt|;
if|if
condition|(
name|cpu_arch_tune_flags
operator|==
literal|0
condition|)
name|cpu_arch_tune_flags
operator|=
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
operator||
name|Cpu486
operator||
name|Cpu586
operator||
name|Cpu686
operator||
name|CpuP4
operator||
name|CpuMMX
operator||
name|CpuMMX2
operator||
name|CpuSSE
operator||
name|CpuSSE2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"i386"
argument_list|)
condition|)
block|{
name|set_code_flag
argument_list|(
name|CODE_32BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_arch_isa_flags
operator|==
literal|0
condition|)
name|cpu_arch_isa_flags
operator|=
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
expr_stmt|;
if|if
condition|(
name|cpu_arch_tune_flags
operator|==
literal|0
condition|)
name|cpu_arch_tune_flags
operator|=
name|Cpu186
operator||
name|Cpu286
operator||
name|Cpu386
expr_stmt|;
block|}
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown architecture"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OUTPUT_FLAVOR
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_MAYBE_AOUT
case|case
name|bfd_target_aout_flavour
case|:
return|return
name|AOUT_TARGET_FORMAT
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_MAYBE_COFF
case|case
name|bfd_target_coff_flavour
case|:
return|return
literal|"coff-i386"
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
case|case
name|bfd_target_elf_flavour
case|:
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
name|object_64bit
operator|=
literal|1
expr_stmt|;
name|use_rela_relocations
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|flag_code
operator|==
name|CODE_64BIT
condition|?
name|ELF_TARGET_FORMAT64
else|:
name|ELF_TARGET_FORMAT
return|;
block|}
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_MAYBE_ more than one  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
operator|)
end_if

begin_function
name|void
name|i386_elf_emit_arch_note
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|IS_ELF
operator|&&
name|cpu_arch_name
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|subseg
init|=
name|now_subseg
decl_stmt|;
name|Elf_Internal_Note
name|i_note
decl_stmt|;
name|Elf_External_Note
name|e_note
decl_stmt|;
name|asection
modifier|*
name|note_secp
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Create the .note section.  */
name|note_secp
operator|=
name|subseg_new
argument_list|(
literal|".note"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|note_secp
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
comment|/* Process the arch string.  */
name|len
operator|=
name|strlen
argument_list|(
name|cpu_arch_name
argument_list|)
expr_stmt|;
name|i_note
operator|.
name|namesz
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|i_note
operator|.
name|descsz
operator|=
literal|0
expr_stmt|;
name|i_note
operator|.
name|type
operator|=
name|NT_ARCH
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|namesz
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|namesz
argument_list|,
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|namesz
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|descsz
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|descsz
argument_list|,
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|descsz
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|cpu_arch_name
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|GLOBAL_OFFSET_TABLE_NAME
index|[
literal|0
index|]
operator|&&
name|name
index|[
literal|1
index|]
operator|==
name|GLOBAL_OFFSET_TABLE_NAME
index|[
literal|1
index|]
operator|&&
name|name
index|[
literal|2
index|]
operator|==
name|GLOBAL_OFFSET_TABLE_NAME
index|[
literal|2
index|]
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|name
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"GOT already in symbol table"
argument_list|)
argument_list|)
expr_stmt|;
name|GOT_symbol
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
name|GOT_symbol
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
condition|)
block|{
comment|/* For a.out, force the section size to be aligned.  If we don't do 	 this, BFD will align it for us, but it will not write out the 	 final bytes of the section.  This may be a bug in BFD, but it is 	 easier to fix it here since that is how the other a.out targets 	 work.  */
name|int
name|align
decl_stmt|;
name|align
operator|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|(
name|valueT
operator|)
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* On the i386, PC-relative offsets are relative to the start of the    next instruction.  That is, the address of the offset, plus its    size, since the offset is always the last part of the insn.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|I386COFF
end_ifndef

begin_function
specifier|static
name|void
name|s_bss
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|IS_ELF
condition|)
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|i386_validate_fix
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|&&
name|fixp
operator|->
name|fx_subsy
operator|==
name|GOT_symbol
condition|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL
condition|)
block|{
if|if
condition|(
operator|!
name|object_64bit
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_X86_64_GOTPCREL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|object_64bit
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_386_GOTOFF
expr_stmt|;
else|else
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_X86_64_GOTOFF64
expr_stmt|;
block|}
name|fixp
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_X86_64_PLT32
case|:
case|case
name|BFD_RELOC_X86_64_GOT32
case|:
case|case
name|BFD_RELOC_X86_64_GOTPCREL
case|:
case|case
name|BFD_RELOC_386_PLT32
case|:
case|case
name|BFD_RELOC_386_GOT32
case|:
case|case
name|BFD_RELOC_386_GOTOFF
case|:
case|case
name|BFD_RELOC_386_GOTPC
case|:
case|case
name|BFD_RELOC_386_TLS_GD
case|:
case|case
name|BFD_RELOC_386_TLS_LDM
case|:
case|case
name|BFD_RELOC_386_TLS_LDO_32
case|:
case|case
name|BFD_RELOC_386_TLS_IE_32
case|:
case|case
name|BFD_RELOC_386_TLS_IE
case|:
case|case
name|BFD_RELOC_386_TLS_GOTIE
case|:
case|case
name|BFD_RELOC_386_TLS_LE_32
case|:
case|case
name|BFD_RELOC_386_TLS_LE
case|:
case|case
name|BFD_RELOC_386_TLS_GOTDESC
case|:
case|case
name|BFD_RELOC_386_TLS_DESC_CALL
case|:
case|case
name|BFD_RELOC_X86_64_TLSGD
case|:
case|case
name|BFD_RELOC_X86_64_TLSLD
case|:
case|case
name|BFD_RELOC_X86_64_DTPOFF32
case|:
case|case
name|BFD_RELOC_X86_64_DTPOFF64
case|:
case|case
name|BFD_RELOC_X86_64_GOTTPOFF
case|:
case|case
name|BFD_RELOC_X86_64_TPOFF32
case|:
case|case
name|BFD_RELOC_X86_64_TPOFF64
case|:
case|case
name|BFD_RELOC_X86_64_GOTOFF64
case|:
case|case
name|BFD_RELOC_X86_64_GOTPC32
case|:
case|case
name|BFD_RELOC_X86_64_GOT64
case|:
case|case
name|BFD_RELOC_X86_64_GOTPCREL64
case|:
case|case
name|BFD_RELOC_X86_64_GOTPC64
case|:
case|case
name|BFD_RELOC_X86_64_GOTPLT64
case|:
case|case
name|BFD_RELOC_X86_64_PLTOFF64
case|:
case|case
name|BFD_RELOC_X86_64_GOTPC32_TLSDESC
case|:
case|case
name|BFD_RELOC_X86_64_TLSDESC_CALL
case|:
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
ifdef|#
directive|ifdef
name|TE_PE
case|case
name|BFD_RELOC_32_SECREL
case|:
endif|#
directive|endif
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_X86_64_32S
case|:
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
comment|/* Don't turn BFD_RELOC_X86_64_32S into BFD_RELOC_32.  */
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
block|}
default|default:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_size
condition|)
block|{
default|default:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can not do %d byte pc-relative relocation"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BFD64
case|case
literal|8
case|:
name|code
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_size
condition|)
block|{
default|default:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can not do %d byte relocation"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BFD64
case|case
literal|8
case|:
name|code
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|code
operator|==
name|BFD_RELOC_32
operator|||
name|code
operator|==
name|BFD_RELOC_32_PCREL
operator|||
name|code
operator|==
name|BFD_RELOC_X86_64_32S
operator|)
operator|&&
name|GOT_symbol
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|GOT_symbol
condition|)
block|{
if|if
condition|(
operator|!
name|object_64bit
condition|)
name|code
operator|=
name|BFD_RELOC_386_GOTPC
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_X86_64_GOTPC32
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|==
name|BFD_RELOC_64
operator|||
name|code
operator|==
name|BFD_RELOC_64_PCREL
operator|)
operator|&&
name|GOT_symbol
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|GOT_symbol
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_X86_64_GOTPC64
expr_stmt|;
block|}
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
operator|!
name|use_rela_relocations
condition|)
block|{
comment|/* HACK: Since i386 ELF uses Rel instead of Rela, encode the 	 vtable entry to be used in the relocation's section offset.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Use the rela in 64bit mode.  */
else|else
block|{
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_pcrel
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
else|else
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_X86_64_PLT32
case|:
case|case
name|BFD_RELOC_X86_64_GOT32
case|:
case|case
name|BFD_RELOC_X86_64_GOTPCREL
case|:
case|case
name|BFD_RELOC_X86_64_TLSGD
case|:
case|case
name|BFD_RELOC_X86_64_TLSLD
case|:
case|case
name|BFD_RELOC_X86_64_GOTTPOFF
case|:
case|case
name|BFD_RELOC_X86_64_GOTPC32_TLSDESC
case|:
case|case
name|BFD_RELOC_X86_64_TLSDESC_CALL
case|:
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
operator|-
name|fixp
operator|->
name|fx_size
expr_stmt|;
break|break;
default|default:
name|rel
operator|->
name|addend
operator|=
operator|(
name|section
operator|->
name|vma
operator|-
name|fixp
operator|->
name|fx_size
operator|+
name|fixp
operator|->
name|fx_addnumber
operator|+
name|md_pcrel_from
argument_list|(
name|fixp
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent relocation type %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse operands using Intel syntax. This implements a recursive descent    parser based on the BNF grammar published in Appendix B of the MASM 6.1    Programmer's Guide.     FIXME: We do not recognize the full operand grammar defined in the MASM 	  documentation.  In particular, all the structure/union and 	  high-level macro operands are missing.     Uppercase words are terminals, lower case words are non-terminals.    Objects surrounded by double brackets '[[' ']]' are optional. Vertical    bars '|' denote choices. Most grammar productions are implemented in    functions called 'intel_<production>'.     Initial production is 'expr'.      addOp		+ | -      alpha		[a-zA-Z]      binOp& | AND | \| | OR | ^ | XOR      byteRegister	AL | AH | BL | BH | CL | CH | DL | DH      constant		digits [[ radixOverride ]]      dataType		BYTE | WORD | DWORD | FWORD | QWORD | TBYTE | OWORD | XMMWORD      digits		decdigit 			| digits decdigit 			| digits hexdigit      decdigit		[0-9]      e04			e04 addOp e05 			| e05      e05			e05 binOp e06 			| e06      e06			e06 mulOp e09 			| e09      e09			OFFSET e10 			| SHORT e10 			| + e10 			| - e10 			| ~ e10 			| NOT e10 			| e09 PTR e10 			| e09 : e10 			| e10      e10			e10 [ expr ] 			| e11      e11			( expr ) 			| [ expr ] 			| constant 			| dataType 			| id 			| $ 			| register   => expr		expr cmpOp e04 			| e04      gpRegister		AX | EAX | BX | EBX | CX | ECX | DX | EDX 			| BP | EBP | SP | ESP | DI | EDI | SI | ESI      hexdigit		a | b | c | d | e | f 			| A | B | C | D | E | F      id			alpha 			| id alpha 			| id decdigit      mulOp		* | / | % | MOD |<< | SHL |>> | SHR      quote		" | '      register		specialRegister 			| gpRegister 			| byteRegister      segmentRegister	CS | DS | ES | FS | GS | SS      specialRegister	CR0 | CR2 | CR3 | CR4 			| DR0 | DR1 | DR2 | DR3 | DR6 | DR7 			| TR3 | TR4 | TR5 | TR6 | TR7      We simplify the grammar in obvious places (e.g., register parsing is     done by calling parse_register) and eliminate immediate left recursion     to implement a recursive-descent parser.      expr	e04 expr'      expr'	cmpOp e04 expr' 		| Empty      e04		e05 e04'      e04'	addOp e05 e04' 		| Empty      e05		e06 e05'      e05'	binOp e06 e05' 		| Empty      e06		e09 e06'      e06'	mulOp e09 e06' 		| Empty      e09		OFFSET e10 e09' 		| SHORT e10' 		| + e10' 		| - e10' 		| ~ e10' 		| NOT e10' 		| e10 e09'      e09'	PTR e10 e09' 		| : e10 e09' 		| Empty      e10		e11 e10'      e10'	[ expr ] e10' 		| Empty      e11		( expr ) 		| [ expr ] 		| BYTE 		| WORD 		| DWORD 		| FWORD 		| QWORD 		| TBYTE 		| OWORD 		| XMMWORD 		| . 		| $ 		| register 		| id 		| constant  */
end_comment

begin_comment
comment|/* Parsing structure for the intel syntax parser. Used to implement the    semantic actions for the operand grammar.  */
end_comment

begin_struct
struct|struct
name|intel_parser_s
block|{
name|char
modifier|*
name|op_string
decl_stmt|;
comment|/* The string being parsed.  */
name|int
name|got_a_float
decl_stmt|;
comment|/* Whether the operand is a float.  */
name|int
name|op_modifier
decl_stmt|;
comment|/* Operand modifier.  */
name|int
name|is_mem
decl_stmt|;
comment|/* 1 if operand is memory reference.  */
name|int
name|in_offset
decl_stmt|;
comment|/*>=1 if parsing operand of offset.  */
name|int
name|in_bracket
decl_stmt|;
comment|/*>=1 if parsing operand in brackets.  */
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
comment|/* Last register reference found.  */
name|char
modifier|*
name|disp
decl_stmt|;
comment|/* Displacement string being built.  */
name|char
modifier|*
name|next_operand
decl_stmt|;
comment|/* Resume point when splitting operands.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|intel_parser_s
name|intel_parser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Token structure for parsing intel syntax.  */
end_comment

begin_struct
struct|struct
name|intel_token
block|{
name|int
name|code
decl_stmt|;
comment|/* Token code.  */
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
comment|/* Register entry for register tokens.  */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* String representation.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|intel_token
name|cur_token
decl_stmt|,
name|prev_token
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Token codes for the intel parser. Since T_SHORT is already used    by COFF, undefine it first to prevent a warning.  */
end_comment

begin_define
define|#
directive|define
name|T_NIL
value|-1
end_define

begin_define
define|#
directive|define
name|T_CONST
value|1
end_define

begin_define
define|#
directive|define
name|T_REG
value|2
end_define

begin_define
define|#
directive|define
name|T_BYTE
value|3
end_define

begin_define
define|#
directive|define
name|T_WORD
value|4
end_define

begin_define
define|#
directive|define
name|T_DWORD
value|5
end_define

begin_define
define|#
directive|define
name|T_FWORD
value|6
end_define

begin_define
define|#
directive|define
name|T_QWORD
value|7
end_define

begin_define
define|#
directive|define
name|T_TBYTE
value|8
end_define

begin_define
define|#
directive|define
name|T_XMMWORD
value|9
end_define

begin_undef
undef|#
directive|undef
name|T_SHORT
end_undef

begin_define
define|#
directive|define
name|T_SHORT
value|10
end_define

begin_define
define|#
directive|define
name|T_OFFSET
value|11
end_define

begin_define
define|#
directive|define
name|T_PTR
value|12
end_define

begin_define
define|#
directive|define
name|T_ID
value|13
end_define

begin_define
define|#
directive|define
name|T_SHL
value|14
end_define

begin_define
define|#
directive|define
name|T_SHR
value|15
end_define

begin_comment
comment|/* Prototypes for intel parser functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|intel_match_token
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_putback_token
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_get_token
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_expr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_e04
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_e05
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_e06
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_e09
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_e10
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_e11
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|i386_intel_operand
parameter_list|(
name|char
modifier|*
name|operand_string
parameter_list|,
name|int
name|got_a_float
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|intel_parser
operator|.
name|op_string
operator|=
name|xstrdup
argument_list|(
name|operand_string
argument_list|)
expr_stmt|;
name|intel_parser
operator|.
name|disp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|operand_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Initialize token holders.  */
name|cur_token
operator|.
name|code
operator|=
name|prev_token
operator|.
name|code
operator|=
name|T_NIL
expr_stmt|;
name|cur_token
operator|.
name|reg
operator|=
name|prev_token
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|cur_token
operator|.
name|str
operator|=
name|prev_token
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize parser structure.  */
name|intel_parser
operator|.
name|got_a_float
operator|=
name|got_a_float
expr_stmt|;
name|intel_parser
operator|.
name|op_modifier
operator|=
literal|0
expr_stmt|;
name|intel_parser
operator|.
name|is_mem
operator|=
literal|0
expr_stmt|;
name|intel_parser
operator|.
name|in_offset
operator|=
literal|0
expr_stmt|;
name|intel_parser
operator|.
name|in_bracket
operator|=
literal|0
expr_stmt|;
name|intel_parser
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|intel_parser
operator|.
name|disp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|intel_parser
operator|.
name|next_operand
operator|=
name|NULL
expr_stmt|;
comment|/* Read the first token and start the parser.  */
name|intel_get_token
argument_list|()
expr_stmt|;
name|ret
operator|=
name|intel_expr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
break|break;
if|if
condition|(
name|cur_token
operator|.
name|code
operator|!=
name|T_NIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand for '%s' ('%s' unexpected)"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we found a memory reference, hand it over to i386_displacement 	 to fill in the rest of the operand fields.  */
elseif|else
if|if
condition|(
name|intel_parser
operator|.
name|is_mem
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|.
name|mem_operands
operator|==
literal|1
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
name|IsString
operator|)
operator|==
literal|0
operator|)
operator|||
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many memory references for '%s'"
argument_list|)
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|s
init|=
name|intel_parser
operator|.
name|disp
decl_stmt|;
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_warnings
operator|&&
name|intel_parser
operator|.
name|is_mem
operator|<
literal|0
condition|)
comment|/* See the comments in intel_bracket_expr.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Treating `%s' as memory reference"
argument_list|)
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
comment|/* Add the displacement expression.  */
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|ret
operator|=
name|i386_displacement
argument_list|(
name|s
argument_list|,
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Swap base and index in 16-bit memory operands like 		     [si+bx]. Since i386_index_check is also used in AT&T 		     mode we have to do that here.  */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|index_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg16
operator|)
operator|&&
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
name|Reg16
operator|)
operator|&&
name|i
operator|.
name|base_reg
operator|->
name|reg_num
operator|>=
literal|6
operator|&&
name|i
operator|.
name|index_reg
operator|->
name|reg_num
operator|<
literal|6
condition|)
block|{
specifier|const
name|reg_entry
modifier|*
name|base
init|=
name|i
operator|.
name|index_reg
decl_stmt|;
name|i
operator|.
name|index_reg
operator|=
name|i
operator|.
name|base_reg
expr_stmt|;
name|i
operator|.
name|base_reg
operator|=
name|base
expr_stmt|;
block|}
name|ret
operator|=
name|i386_index_check
argument_list|(
name|operand_string
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Constant and OFFSET expressions are handled by i386_immediate.  */
elseif|else
if|if
condition|(
operator|(
name|intel_parser
operator|.
name|op_modifier
operator|&
operator|(
literal|1
operator|<<
name|T_OFFSET
operator|)
operator|)
operator|||
name|intel_parser
operator|.
name|reg
operator|==
name|NULL
condition|)
name|ret
operator|=
name|i386_immediate
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_parser
operator|.
name|next_operand
operator|&&
name|this_operand
operator|>=
name|MAX_OPERANDS
operator|-
literal|1
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|||
operator|!
name|intel_parser
operator|.
name|next_operand
condition|)
break|break;
name|intel_parser
operator|.
name|op_string
operator|=
name|intel_parser
operator|.
name|next_operand
expr_stmt|;
name|this_operand
operator|=
name|i
operator|.
name|operands
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NUM_ADDRESS_REGS
value|(!!i.base_reg + !!i.index_reg)
end_define

begin_comment
comment|/* expr	e04 expr'     expr'  cmpOp e04 expr' 	| Empty  */
end_comment

begin_function
specifier|static
name|int
name|intel_expr
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* XXX Implement the comparison operators.  */
return|return
name|intel_e04
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* e04	e05 e04'     e04'	addOp e05 e04' 	| Empty  */
end_comment

begin_function
specifier|static
name|int
name|intel_e04
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nregs
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|intel_e05
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|nregs
operator|>=
literal|0
operator|&&
name|NUM_ADDRESS_REGS
operator|>
name|nregs
condition|)
name|i
operator|.
name|base_reg
operator|=
name|i386_regtab
operator|+
name|REGNAM_AL
expr_stmt|;
comment|/* al is invalid as base */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'+'
condition|)
name|nregs
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'-'
condition|)
name|nregs
operator|=
name|NUM_ADDRESS_REGS
expr_stmt|;
else|else
return|return
literal|1
return|;
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* e05	e06 e05'     e05'	binOp e06 e05' 	| Empty  */
end_comment

begin_function
specifier|static
name|int
name|intel_e05
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nregs
init|=
operator|~
name|NUM_ADDRESS_REGS
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|intel_e06
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'&'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'|'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'^'
condition|)
block|{
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|cur_token
operator|.
name|code
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|nregs
operator|<
literal|0
condition|)
name|nregs
operator|=
operator|~
name|nregs
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|>=
literal|0
operator|&&
name|NUM_ADDRESS_REGS
operator|>
name|nregs
condition|)
name|i
operator|.
name|base_reg
operator|=
name|i386_regtab
operator|+
name|REGNAM_AL
operator|+
literal|1
expr_stmt|;
comment|/* cl is invalid as base */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* e06	e09 e06'     e06'	mulOp e09 e06' 	| Empty  */
end_comment

begin_function
specifier|static
name|int
name|intel_e06
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nregs
init|=
operator|~
name|NUM_ADDRESS_REGS
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|intel_e09
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'*'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'/'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'%'
condition|)
block|{
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|cur_token
operator|.
name|code
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_SHL
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"<<"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_SHR
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|">>"
argument_list|)
expr_stmt|;
else|else
break|break;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|nregs
operator|<
literal|0
condition|)
name|nregs
operator|=
operator|~
name|nregs
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|>=
literal|0
operator|&&
name|NUM_ADDRESS_REGS
operator|>
name|nregs
condition|)
name|i
operator|.
name|base_reg
operator|=
name|i386_regtab
operator|+
name|REGNAM_AL
operator|+
literal|2
expr_stmt|;
comment|/* dl is invalid as base */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* e09	OFFSET e09 	| SHORT e09 	| + e09 	| - e09 	| ~ e09 	| NOT e09 	| e10 e09'     e09'	PTR e10 e09' 	| : e10 e09' 	| Empty */
end_comment

begin_function
specifier|static
name|int
name|intel_e09
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nregs
init|=
operator|~
name|NUM_ADDRESS_REGS
decl_stmt|;
name|int
name|in_offset
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Don't consume constants here.  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'+'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'-'
condition|)
block|{
comment|/* Need to look one token ahead - if the next token 	     is a constant, the current token is its sign.  */
name|int
name|next_code
decl_stmt|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
name|next_code
operator|=
name|cur_token
operator|.
name|code
expr_stmt|;
name|intel_putback_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|next_code
operator|==
name|T_CONST
condition|)
break|break;
block|}
comment|/* e09  OFFSET e09  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_OFFSET
condition|)
block|{
if|if
condition|(
operator|!
name|in_offset
operator|++
condition|)
operator|++
name|intel_parser
operator|.
name|in_offset
expr_stmt|;
block|}
comment|/* e09  SHORT e09  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_SHORT
condition|)
name|intel_parser
operator|.
name|op_modifier
operator||=
literal|1
operator|<<
name|T_SHORT
expr_stmt|;
comment|/* e09  + e09  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'+'
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
comment|/* e09  - e09 	      | ~ e09 	      | NOT e09  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'-'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'~'
condition|)
block|{
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|nregs
operator|<
literal|0
condition|)
name|nregs
operator|=
operator|~
name|nregs
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|cur_token
operator|.
name|code
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* e09  e10 e09'  */
else|else
break|break;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|intel_e10
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* e09'  PTR e10 e09' */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_PTR
condition|)
block|{
name|char
name|suffix
decl_stmt|;
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_BYTE
condition|)
name|suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_WORD
condition|)
block|{
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|current_templates
operator|->
name|start
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'s'
operator|&&
name|current_templates
operator|->
name|start
operator|->
name|name
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
comment|/* so it will cause an error */
elseif|else
if|if
condition|(
name|intel_parser
operator|.
name|got_a_float
operator|==
literal|2
condition|)
comment|/* "fi..." */
name|suffix
operator|=
name|SHORT_MNEM_SUFFIX
expr_stmt|;
else|else
name|suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_DWORD
condition|)
block|{
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|current_templates
operator|->
name|start
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'s'
operator|&&
name|current_templates
operator|->
name|start
operator|->
name|name
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|suffix
operator|=
name|WORD_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
operator|&&
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpDword
operator|)
operator|)
condition|)
name|suffix
operator|=
name|LONG_DOUBLE_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
name|intel_parser
operator|.
name|got_a_float
operator|==
literal|1
condition|)
comment|/* "f..." */
name|suffix
operator|=
name|SHORT_MNEM_SUFFIX
expr_stmt|;
else|else
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_FWORD
condition|)
block|{
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|current_templates
operator|->
name|start
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'s'
operator|&&
name|current_templates
operator|->
name|start
operator|->
name|name
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|got_a_float
condition|)
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_16BIT
condition|)
name|add_prefix
argument_list|(
name|DATA_PREFIX_OPCODE
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|LONG_DOUBLE_MNEM_SUFFIX
expr_stmt|;
block|}
else|else
name|suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
comment|/* so it will cause an error */
block|}
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_QWORD
condition|)
block|{
if|if
condition|(
name|intel_parser
operator|.
name|got_a_float
operator|==
literal|1
condition|)
comment|/* "f..." */
name|suffix
operator|=
name|LONG_MNEM_SUFFIX
expr_stmt|;
else|else
name|suffix
operator|=
name|QWORD_MNEM_SUFFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_TBYTE
condition|)
block|{
if|if
condition|(
name|intel_parser
operator|.
name|got_a_float
operator|==
literal|1
condition|)
name|suffix
operator|=
name|LONG_DOUBLE_MNEM_SUFFIX
expr_stmt|;
else|else
name|suffix
operator|=
name|BYTE_MNEM_SUFFIX
expr_stmt|;
comment|/* so it will cause an error */
block|}
elseif|else
if|if
condition|(
name|prev_token
operator|.
name|code
operator|==
name|T_XMMWORD
condition|)
block|{
comment|/* XXX ignored for now, but accepted since gcc uses it */
name|suffix
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown operand modifier `%s'"
argument_list|)
argument_list|,
name|prev_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Operands for jump/call using 'ptr' notation denote absolute 	     addresses.  */
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpDword
operator|)
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
operator|==
literal|0x8d
comment|/* lea */
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
name|i
operator|.
name|suffix
operator|=
name|suffix
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|suffix
operator|!=
name|suffix
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Conflicting operand modifiers"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* e09'  : e10 e09'  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|prev_token
operator|.
name|code
operator|!=
name|T_REG
condition|)
block|{
comment|/* While {call,jmp} SSSS:OOOO is MASM syntax only when SSSS is a 		 segment/group identifier (which we don't have), using comma 		 as the operand separator there is even less consistent, since 		 there all branches only have a single operand.  */
if|if
condition|(
name|this_operand
operator|!=
literal|0
operator|||
name|intel_parser
operator|.
name|in_offset
operator|||
name|intel_parser
operator|.
name|in_bracket
operator|||
operator|(
operator|!
operator|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpDword
operator||
name|JumpInterSegment
operator|)
operator|)
operator|&&
operator|!
operator|(
name|current_templates
operator|->
name|start
operator|->
name|operand_types
index|[
literal|0
index|]
operator|&
name|JumpAbsolute
operator|)
operator|)
condition|)
return|return
name|intel_match_token
argument_list|(
name|T_NIL
argument_list|)
return|;
comment|/* Remember the start of the 2nd operand and terminate 1st 		 operand here. 		 XXX This isn't right, yet (when SSSS:OOOO is right operand of 		 another expression), but it gets at least the simplest case 		 (a plain number or symbol on the left side) right.  */
name|intel_parser
operator|.
name|next_operand
operator|=
name|intel_parser
operator|.
name|op_string
expr_stmt|;
operator|*
operator|--
name|intel_parser
operator|.
name|op_string
operator|=
literal|'\0'
expr_stmt|;
return|return
name|intel_match_token
argument_list|(
literal|':'
argument_list|)
return|;
block|}
block|}
comment|/* e09'  Empty  */
else|else
break|break;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_offset
condition|)
block|{
operator|--
name|intel_parser
operator|.
name|in_offset
expr_stmt|;
if|if
condition|(
name|nregs
operator|<
literal|0
condition|)
name|nregs
operator|=
operator|~
name|nregs
expr_stmt|;
if|if
condition|(
name|NUM_ADDRESS_REGS
operator|>
name|nregs
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid operand to `OFFSET'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|intel_parser
operator|.
name|op_modifier
operator||=
literal|1
operator|<<
name|T_OFFSET
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|>=
literal|0
operator|&&
name|NUM_ADDRESS_REGS
operator|>
name|nregs
condition|)
name|i
operator|.
name|base_reg
operator|=
name|i386_regtab
operator|+
name|REGNAM_AL
operator|+
literal|3
expr_stmt|;
comment|/* bl is invalid as base */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_bracket_expr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|was_offset
init|=
name|intel_parser
operator|.
name|op_modifier
operator|&
operator|(
literal|1
operator|<<
name|T_OFFSET
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|intel_parser
operator|.
name|op_string
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|regs
condition|)
return|return
name|intel_match_token
argument_list|(
name|T_NIL
argument_list|)
return|;
name|intel_match_token
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
comment|/* Mark as a memory operand only if it's not already known to be an      offset expression.  If it's an offset expression, we need to keep      the brace in.  */
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|in_offset
condition|)
block|{
operator|++
name|intel_parser
operator|.
name|in_bracket
expr_stmt|;
comment|/* Operands for jump/call inside brackets denote absolute addresses.  */
if|if
condition|(
name|current_templates
operator|->
name|start
operator|->
name|opcode_modifier
operator|&
operator|(
name|Jump
operator||
name|JumpDword
operator|)
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
comment|/* Unfortunately gas always diverged from MASM in a respect that can't 	 be easily fixed without risking to break code sequences likely to be 	 encountered (the testsuite even check for this): MASM doesn't consider 	 an expression inside brackets unconditionally as a memory reference. 	 When that is e.g. a constant, an offset expression, or the sum of the 	 two, this is still taken as a constant load. gas, however, always 	 treated these as memory references. As a compromise, we'll try to make 	 offset expressions inside brackets work the MASM way (since that's 	 less likely to be found in real world code), but make constants alone 	 continue to work the traditional gas way. In either case, issue a 	 warning.  */
name|intel_parser
operator|.
name|op_modifier
operator|&=
operator|~
name|was_offset
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
comment|/* Add a '+' to the displacement string if necessary.  */
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|disp
operator|!=
literal|'\0'
operator|&&
operator|*
operator|(
name|intel_parser
operator|.
name|disp
operator|+
name|strlen
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|)
operator|-
literal|1
operator|)
operator|!=
literal|'+'
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_expr
argument_list|()
operator|&&
operator|(
name|len
operator|=
name|intel_parser
operator|.
name|op_string
operator|-
name|start
operator|-
literal|1
operator|,
name|intel_match_token
argument_list|(
literal|']'
argument_list|)
operator|)
condition|)
block|{
comment|/* Preserve brackets when the operand is an offset expression.  */
if|if
condition|(
name|intel_parser
operator|.
name|in_offset
condition|)
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
else|else
block|{
operator|--
name|intel_parser
operator|.
name|in_bracket
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
operator|||
name|i
operator|.
name|index_reg
condition|)
name|intel_parser
operator|.
name|is_mem
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|is_mem
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|intel_parser
operator|.
name|op_modifier
operator|&
operator|(
literal|1
operator|<<
name|T_OFFSET
operator|)
operator|)
condition|)
comment|/* Defer the warning until all of the operand was parsed.  */
name|intel_parser
operator|.
name|is_mem
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|quiet_warnings
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"`[%.*s]' taken to mean just `%.*s'"
argument_list|)
argument_list|,
name|len
argument_list|,
name|start
argument_list|,
name|len
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
block|}
name|intel_parser
operator|.
name|op_modifier
operator||=
name|was_offset
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* e10	e11 e10'     e10'	[ expr ] e10' 	| Empty  */
end_comment

begin_function
specifier|static
name|int
name|intel_e10
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|intel_e11
argument_list|()
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
operator|!
name|intel_bracket_expr
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* e11	( expr ) 	| [ expr ] 	| BYTE 	| WORD 	| DWORD 	| FWORD 	| QWORD 	| TBYTE 	| OWORD 	| XMMWORD 	| $ 	| . 	| register 	| id 	| constant  */
end_comment

begin_function
specifier|static
name|int
name|intel_e11
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|cur_token
operator|.
name|code
condition|)
block|{
comment|/* e11  ( expr ) */
case|case
literal|'('
case|:
name|intel_match_token
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|intel_expr
argument_list|()
operator|&&
name|intel_match_token
argument_list|(
literal|')'
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* e11  [ expr ] */
case|case
literal|'['
case|:
return|return
name|intel_bracket_expr
argument_list|()
return|;
comment|/* e11  $ 	    | .  */
case|case
literal|'.'
case|:
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
comment|/* Mark as a memory operand only if it's not already known to be an 	 offset expression.  */
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|in_offset
condition|)
name|intel_parser
operator|.
name|is_mem
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
comment|/* e11  register  */
case|case
name|T_REG
case|:
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
init|=
name|intel_parser
operator|.
name|reg
operator|=
name|cur_token
operator|.
name|reg
decl_stmt|;
name|intel_match_token
argument_list|(
name|T_REG
argument_list|)
expr_stmt|;
comment|/* Check for segment change.  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|reg
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is not a valid segment register"
argument_list|)
argument_list|,
name|reg
operator|->
name|reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Extra segment override ignored"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|in_offset
condition|)
name|intel_parser
operator|.
name|is_mem
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|reg
operator|->
name|reg_num
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|i
operator|.
name|seg
index|[
name|i
operator|.
name|mem_operands
index|]
operator|=
operator|&
name|gs
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Not a segment register. Check for register scaling.  */
elseif|else
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|in_bracket
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Register scaling only allowed in memory operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|reg
operator|->
name|reg_type
operator|&
name|Reg16
condition|)
comment|/* Disallow things like [si*1]. */
name|reg
operator|=
name|i386_regtab
operator|+
name|REGNAM_AX
operator|+
literal|4
expr_stmt|;
comment|/* sp is invalid as index */
elseif|else
if|if
condition|(
name|i
operator|.
name|index_reg
condition|)
name|reg
operator|=
name|i386_regtab
operator|+
name|REGNAM_EAX
operator|+
literal|4
expr_stmt|;
comment|/* esp is invalid as index */
comment|/* What follows must be a valid scale.  */
name|intel_match_token
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|i
operator|.
name|index_reg
operator|=
name|reg
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
comment|/* Set the scale after setting the register (otherwise, 	       i386_scale will complain)  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'+'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'-'
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|,
name|sign
init|=
name|cur_token
operator|.
name|code
decl_stmt|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_token
operator|.
name|code
operator|!=
name|T_CONST
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Syntax error: Expecting a constant, got `%s'"
argument_list|)
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|sign
expr_stmt|;
if|if
condition|(
operator|!
name|i386_scale
argument_list|(
name|str
argument_list|)
condition|)
return|return
literal|0
return|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|i386_scale
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
condition|)
return|return
literal|0
return|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* No scaling. If this is a memory operand, the register is either a 	   base register (first occurrence) or an index register (second 	   occurrence).  */
elseif|else
if|if
condition|(
name|intel_parser
operator|.
name|in_bracket
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|base_reg
condition|)
name|i
operator|.
name|base_reg
operator|=
name|reg
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
condition|)
name|i
operator|.
name|index_reg
operator|=
name|reg
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Too many register references in memory operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
block|}
comment|/* It's neither base nor index.  */
elseif|else
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|in_offset
operator|&&
operator|!
name|intel_parser
operator|.
name|is_mem
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|reg
operator|->
name|reg_type
operator|&
operator|~
name|BaseIndex
expr_stmt|;
name|i
operator|.
name|op
index|[
name|this_operand
index|]
operator|.
name|regs
operator|=
name|reg
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid use of register"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Since registers are not part of the displacement string (except 	   when we're parsing offset operands), we may need to remove any 	   preceding '+' from the displacement string.  */
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|disp
operator|!=
literal|'\0'
operator|&&
operator|!
name|intel_parser
operator|.
name|in_offset
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|intel_parser
operator|.
name|disp
decl_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* e11  BYTE 	    | WORD 	    | DWORD 	    | FWORD 	    | QWORD 	    | TBYTE 	    | OWORD 	    | XMMWORD  */
case|case
name|T_BYTE
case|:
case|case
name|T_WORD
case|:
case|case
name|T_DWORD
case|:
case|case
name|T_FWORD
case|:
case|case
name|T_QWORD
case|:
case|case
name|T_TBYTE
case|:
case|case
name|T_XMMWORD
case|:
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|T_PTR
condition|)
return|return
literal|1
return|;
comment|/* It must have been an identifier.  */
name|intel_putback_token
argument_list|()
expr_stmt|;
name|cur_token
operator|.
name|code
operator|=
name|T_ID
expr_stmt|;
comment|/* FALLTHRU */
comment|/* e11  id 	    | constant  */
case|case
name|T_ID
case|:
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|in_offset
operator|&&
name|intel_parser
operator|.
name|is_mem
operator|<=
literal|0
condition|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* The identifier represents a memory reference only if it's not 	     preceded by an offset modifier and if it's not an equate.  */
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolP
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|absolute_section
condition|)
name|intel_parser
operator|.
name|is_mem
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHRU */
case|case
name|T_CONST
case|:
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
block|{
name|char
modifier|*
name|save_str
decl_stmt|,
name|sign
init|=
literal|0
decl_stmt|;
comment|/* Allow constants that start with `+' or `-'.  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'-'
operator|||
name|cur_token
operator|.
name|code
operator|==
literal|'+'
condition|)
block|{
name|sign
operator|=
name|cur_token
operator|.
name|code
expr_stmt|;
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_token
operator|.
name|code
operator|!=
name|T_CONST
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Syntax error: Expecting a constant, got `%s'"
argument_list|)
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|save_str
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|save_str
operator|+
operator|!
operator|!
name|sign
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
operator|*
name|save_str
operator|=
name|sign
expr_stmt|;
comment|/* Get the next token to check for register scaling.  */
name|intel_match_token
argument_list|(
name|cur_token
operator|.
name|code
argument_list|)
expr_stmt|;
comment|/* Check if this constant is a scaling factor for an 	   index register.  */
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|intel_match_token
argument_list|(
literal|'*'
argument_list|)
operator|&&
name|cur_token
operator|.
name|code
operator|==
name|T_REG
condition|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
init|=
name|cur_token
operator|.
name|reg
decl_stmt|;
if|if
condition|(
operator|!
name|intel_parser
operator|.
name|in_bracket
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Register scaling only allowed "
literal|"in memory operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Disallow things like [1*si]. 		    sp and esp are invalid as index.  */
if|if
condition|(
name|reg
operator|->
name|reg_type
operator|&
name|Reg16
condition|)
name|reg
operator|=
name|i386_regtab
operator|+
name|REGNAM_AX
operator|+
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|index_reg
condition|)
name|reg
operator|=
name|i386_regtab
operator|+
name|REGNAM_EAX
operator|+
literal|4
expr_stmt|;
comment|/* The constant is followed by `* reg', so it must be 		   a valid scale.  */
name|i
operator|.
name|index_reg
operator|=
name|reg
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
comment|/* Set the scale after setting the register (otherwise, 		   i386_scale will complain)  */
if|if
condition|(
operator|!
name|i386_scale
argument_list|(
name|save_str
argument_list|)
condition|)
return|return
literal|0
return|;
name|intel_match_token
argument_list|(
name|T_REG
argument_list|)
expr_stmt|;
comment|/* Since registers are not part of the displacement 		   string, we may need to remove any preceding '+' from 		   the displacement string.  */
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|disp
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|intel_parser
operator|.
name|disp
decl_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
name|free
argument_list|(
name|save_str
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* The constant was not used for register scaling. Since we have 	       already consumed the token following `*' we now need to put it 	       back in the stream.  */
name|intel_putback_token
argument_list|()
expr_stmt|;
block|}
comment|/* Add the constant to the displacement string.  */
name|strcat
argument_list|(
name|intel_parser
operator|.
name|disp
argument_list|,
name|save_str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_str
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized token '%s'"
argument_list|)
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Match the given token against cur_token. If they match, read the next    token from the operand string.  */
end_comment

begin_function
specifier|static
name|int
name|intel_match_token
parameter_list|(
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|cur_token
operator|.
name|code
operator|==
name|code
condition|)
block|{
name|intel_get_token
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unexpected token `%s'"
argument_list|)
argument_list|,
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read a new token from intel_parser.op_string and store it in cur_token.  */
end_comment

begin_function
specifier|static
name|void
name|intel_get_token
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|end_op
decl_stmt|;
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|struct
name|intel_token
name|new_token
decl_stmt|;
name|new_token
operator|.
name|code
operator|=
name|T_NIL
expr_stmt|;
name|new_token
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|new_token
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
comment|/* Free the memory allocated to the previous token and move      cur_token to prev_token.  */
if|if
condition|(
name|prev_token
operator|.
name|str
condition|)
name|free
argument_list|(
name|prev_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|prev_token
operator|=
name|cur_token
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|is_space_char
argument_list|(
operator|*
name|intel_parser
operator|.
name|op_string
argument_list|)
condition|)
name|intel_parser
operator|.
name|op_string
operator|++
expr_stmt|;
comment|/* Return an empty token if we find nothing else on the line.  */
if|if
condition|(
operator|*
name|intel_parser
operator|.
name|op_string
operator|==
literal|'\0'
condition|)
block|{
name|cur_token
operator|=
name|new_token
expr_stmt|;
return|return;
block|}
comment|/* The new token cannot be larger than the remainder of the operand      string.  */
name|new_token
operator|.
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|intel_parser
operator|.
name|op_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"0123456789"
argument_list|,
operator|*
name|intel_parser
operator|.
name|op_string
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|new_token
operator|.
name|str
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|intel_parser
operator|.
name|op_string
decl_stmt|;
name|new_token
operator|.
name|code
operator|=
name|T_CONST
expr_stmt|;
comment|/* Allow any kind of identifier char to encompass floating point and 	 hexadecimal numbers.  */
while|while
condition|(
name|is_identifier_char
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Recognize special symbol names [0-9][bf].  */
if|if
condition|(
name|strlen
argument_list|(
name|intel_parser
operator|.
name|op_string
argument_list|)
operator|==
literal|2
operator|&&
operator|(
name|intel_parser
operator|.
name|op_string
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|intel_parser
operator|.
name|op_string
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_ID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|reg
operator|=
name|parse_register
argument_list|(
name|intel_parser
operator|.
name|op_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
init|=
name|end_op
operator|-
name|intel_parser
operator|.
name|op_string
decl_stmt|;
name|new_token
operator|.
name|code
operator|=
name|T_REG
expr_stmt|;
name|new_token
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|memcpy
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
name|intel_parser
operator|.
name|op_string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new_token
operator|.
name|str
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_identifier_char
argument_list|(
operator|*
name|intel_parser
operator|.
name|op_string
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|new_token
operator|.
name|str
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|intel_parser
operator|.
name|op_string
decl_stmt|;
comment|/* A '.' or '$' followed by an identifier char is an identifier. 	 Otherwise, it's operator '.' followed by an expression.  */
if|if
condition|(
operator|(
operator|*
name|q
operator|==
literal|'.'
operator|||
operator|*
name|q
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|is_identifier_char
argument_list|(
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|new_token
operator|.
name|code
operator|=
literal|'.'
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|is_identifier_char
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'@'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"NOT"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
literal|'~'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"MOD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
literal|'%'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"AND"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
literal|'&'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"OR"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
literal|'|'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"XOR"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
literal|'^'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"SHL"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_SHL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"SHR"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_SHR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"BYTE"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_BYTE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"WORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_WORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"DWORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_DWORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"FWORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_FWORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"QWORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_QWORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"TBYTE"
argument_list|)
operator|==
literal|0
comment|/* XXX remove (gcc still uses it) */
operator|||
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"XWORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_TBYTE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"XMMWORD"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"OWORD"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_XMMWORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"PTR"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_PTR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"SHORT"
argument_list|)
operator|==
literal|0
condition|)
name|new_token
operator|.
name|code
operator|=
name|T_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"OFFSET"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new_token
operator|.
name|code
operator|=
name|T_OFFSET
expr_stmt|;
comment|/* ??? This is not mentioned in the MASM grammar but gcc 		     makes use of it with -mintel-syntax.  OFFSET may be 		     followed by FLAT:  */
if|if
condition|(
name|strncasecmp
argument_list|(
name|q
argument_list|,
literal|" FLAT:"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|" FLAT:"
argument_list|)
expr_stmt|;
block|}
comment|/* ??? This is not mentioned in the MASM grammar.  */
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|"FLAT"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new_token
operator|.
name|code
operator|=
name|T_OFFSET
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|':'
condition|)
name|strcat
argument_list|(
name|new_token
operator|.
name|str
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`:' expected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|new_token
operator|.
name|code
operator|=
name|T_ID
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"+-/*%|&^:[]()~"
argument_list|,
operator|*
name|intel_parser
operator|.
name|op_string
argument_list|)
condition|)
block|{
name|new_token
operator|.
name|code
operator|=
operator|*
name|intel_parser
operator|.
name|op_string
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|0
index|]
operator|=
operator|*
name|intel_parser
operator|.
name|op_string
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"<>"
argument_list|,
operator|*
name|intel_parser
operator|.
name|op_string
argument_list|)
operator|&&
operator|*
name|intel_parser
operator|.
name|op_string
operator|==
operator|*
operator|(
name|intel_parser
operator|.
name|op_string
operator|+
literal|1
operator|)
condition|)
block|{
name|new_token
operator|.
name|code
operator|=
operator|*
name|intel_parser
operator|.
name|op_string
operator|==
literal|'<'
condition|?
name|T_SHL
else|:
name|T_SHR
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|0
index|]
operator|=
operator|*
name|intel_parser
operator|.
name|op_string
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|1
index|]
operator|=
operator|*
name|intel_parser
operator|.
name|op_string
expr_stmt|;
name|new_token
operator|.
name|str
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized token `%s'"
argument_list|)
argument_list|,
name|intel_parser
operator|.
name|op_string
argument_list|)
expr_stmt|;
name|intel_parser
operator|.
name|op_string
operator|+=
name|strlen
argument_list|(
name|new_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|cur_token
operator|=
name|new_token
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put cur_token back into the token stream and make cur_token point to    prev_token.  */
end_comment

begin_function
specifier|static
name|void
name|intel_putback_token
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cur_token
operator|.
name|code
operator|!=
name|T_NIL
condition|)
block|{
name|intel_parser
operator|.
name|op_string
operator|-=
name|strlen
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur_token
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
name|cur_token
operator|=
name|prev_token
expr_stmt|;
comment|/* Forget prev_token.  */
name|prev_token
operator|.
name|code
operator|=
name|T_NIL
expr_stmt|;
name|prev_token
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|prev_token
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tc_x86_regname_to_dw2regnum
parameter_list|(
name|char
modifier|*
name|regname
parameter_list|)
block|{
name|unsigned
name|int
name|regnum
decl_stmt|;
name|unsigned
name|int
name|regnames_count
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|regnames_32
index|[]
init|=
block|{
literal|"eax"
block|,
literal|"ecx"
block|,
literal|"edx"
block|,
literal|"ebx"
block|,
literal|"esp"
block|,
literal|"ebp"
block|,
literal|"esi"
block|,
literal|"edi"
block|,
literal|"eip"
block|,
literal|"eflags"
block|,
name|NULL
block|,
literal|"st0"
block|,
literal|"st1"
block|,
literal|"st2"
block|,
literal|"st3"
block|,
literal|"st4"
block|,
literal|"st5"
block|,
literal|"st6"
block|,
literal|"st7"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"xmm0"
block|,
literal|"xmm1"
block|,
literal|"xmm2"
block|,
literal|"xmm3"
block|,
literal|"xmm4"
block|,
literal|"xmm5"
block|,
literal|"xmm6"
block|,
literal|"xmm7"
block|,
literal|"mm0"
block|,
literal|"mm1"
block|,
literal|"mm2"
block|,
literal|"mm3"
block|,
literal|"mm4"
block|,
literal|"mm5"
block|,
literal|"mm6"
block|,
literal|"mm7"
block|,
literal|"fcw"
block|,
literal|"fsw"
block|,
literal|"mxcsr"
block|,
literal|"es"
block|,
literal|"cs"
block|,
literal|"ss"
block|,
literal|"ds"
block|,
literal|"fs"
block|,
literal|"gs"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"tr"
block|,
literal|"ldtr"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|regnames_64
index|[]
init|=
block|{
literal|"rax"
block|,
literal|"rdx"
block|,
literal|"rcx"
block|,
literal|"rbx"
block|,
literal|"rsi"
block|,
literal|"rdi"
block|,
literal|"rbp"
block|,
literal|"rsp"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"rip"
block|,
literal|"xmm0"
block|,
literal|"xmm1"
block|,
literal|"xmm2"
block|,
literal|"xmm3"
block|,
literal|"xmm4"
block|,
literal|"xmm5"
block|,
literal|"xmm6"
block|,
literal|"xmm7"
block|,
literal|"xmm8"
block|,
literal|"xmm9"
block|,
literal|"xmm10"
block|,
literal|"xmm11"
block|,
literal|"xmm12"
block|,
literal|"xmm13"
block|,
literal|"xmm14"
block|,
literal|"xmm15"
block|,
literal|"st0"
block|,
literal|"st1"
block|,
literal|"st2"
block|,
literal|"st3"
block|,
literal|"st4"
block|,
literal|"st5"
block|,
literal|"st6"
block|,
literal|"st7"
block|,
literal|"mm0"
block|,
literal|"mm1"
block|,
literal|"mm2"
block|,
literal|"mm3"
block|,
literal|"mm4"
block|,
literal|"mm5"
block|,
literal|"mm6"
block|,
literal|"mm7"
block|,
literal|"rflags"
block|,
literal|"es"
block|,
literal|"cs"
block|,
literal|"ss"
block|,
literal|"ds"
block|,
literal|"fs"
block|,
literal|"gs"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"fs.base"
block|,
literal|"gs.base"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"tr"
block|,
literal|"ldtr"
block|,
literal|"mxcsr"
block|,
literal|"fcw"
block|,
literal|"fsw"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|regnames
decl_stmt|;
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
name|regnames
operator|=
name|regnames_64
expr_stmt|;
name|regnames_count
operator|=
name|ARRAY_SIZE
argument_list|(
name|regnames_64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regnames
operator|=
name|regnames_32
expr_stmt|;
name|regnames_count
operator|=
name|ARRAY_SIZE
argument_list|(
name|regnames_32
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|regnames_count
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
name|regnames
index|[
name|regnum
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|regname
argument_list|,
name|regnames
index|[
name|regnum
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|regnum
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|tc_x86_frame_initial_instructions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
name|sp_regno
decl_stmt|;
if|if
condition|(
operator|!
name|sp_regno
condition|)
name|sp_regno
operator|=
name|tc_x86_regname_to_dw2regnum
argument_list|(
name|flag_code
operator|==
name|CODE_64BIT
condition|?
literal|"rsp"
else|:
literal|"esp"
argument_list|)
expr_stmt|;
name|cfi_add_CFA_def_cfa
argument_list|(
name|sp_regno
argument_list|,
operator|-
name|x86_cie_data_alignment
argument_list|)
expr_stmt|;
name|cfi_add_CFA_offset
argument_list|(
name|x86_dwarf2_return_column
argument_list|,
name|x86_cie_data_alignment
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i386_elf_section_type
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|"unwind"
argument_list|)
operator|-
literal|1
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"unwind"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SHT_X86_64_UNWIND
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_function
name|void
name|tc_pe_dwarf2_emit_offset
parameter_list|(
name|symbolS
modifier|*
name|symbol
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|expressionS
name|expr
decl_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_secrel
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|symbol
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_comment
comment|/* For ELF on x86-64, add support for SHF_X86_64_LARGE.  */
end_comment

begin_function
name|int
name|x86_64_section_letter
parameter_list|(
name|int
name|letter
parameter_list|,
name|char
modifier|*
modifier|*
name|ptr_msg
parameter_list|)
block|{
if|if
condition|(
name|flag_code
operator|==
name|CODE_64BIT
condition|)
block|{
if|if
condition|(
name|letter
operator|==
literal|'l'
condition|)
return|return
name|SHF_X86_64_LARGE
return|;
operator|*
name|ptr_msg
operator|=
name|_
argument_list|(
literal|"Bad .section directive: want a,l,w,x,M,S,G,T in string"
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|ptr_msg
operator|=
name|_
argument_list|(
literal|"Bad .section directive: want a,w,x,M,S,G,T in string"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|x86_64_section_word
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|5
operator|&&
name|flag_code
operator|==
name|CODE_64BIT
operator|&&
name|CONST_STRNEQ
argument_list|(
name|str
argument_list|,
literal|"large"
argument_list|)
condition|)
return|return
name|SHF_X86_64_LARGE
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_large_common
parameter_list|(
name|int
name|small
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|flag_code
operator|!=
name|CODE_64BIT
condition|)
block|{
name|s_comm_internal
argument_list|(
literal|0
argument_list|,
name|elf_common_parse
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".largecomm supported only in 64bit mode, producing .comm"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|segT
name|lbss_section
decl_stmt|;
name|asection
modifier|*
name|saved_com_section_ptr
init|=
name|elf_com_section_ptr
decl_stmt|;
name|asection
modifier|*
name|saved_bss_section
init|=
name|bss_section
decl_stmt|;
if|if
condition|(
name|lbss_section
operator|==
name|NULL
condition|)
block|{
name|flagword
name|applicable
decl_stmt|;
name|segT
name|seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|subseg
init|=
name|now_subseg
decl_stmt|;
comment|/* The .lbss section is for local .largecomm symbols.  */
name|lbss_section
operator|=
name|subseg_new
argument_list|(
literal|".lbss"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|lbss_section
argument_list|,
name|applicable
operator|&
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|lbss_section
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
name|elf_com_section_ptr
operator|=
operator|&
name|_bfd_elf_large_com_section
expr_stmt|;
name|bss_section
operator|=
name|lbss_section
expr_stmt|;
name|s_comm_internal
argument_list|(
literal|0
argument_list|,
name|elf_common_parse
argument_list|)
expr_stmt|;
name|elf_com_section_ptr
operator|=
name|saved_com_section_ptr
expr_stmt|;
name|bss_section
operator|=
name|saved_bss_section
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF || OBJ_MAYBE_ELF */
end_comment

end_unit

