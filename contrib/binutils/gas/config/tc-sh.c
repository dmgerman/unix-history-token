begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-sh.c -- Assemble code for the Hitachi Super-H    Copyright (C) 1993, 94, 95, 96, 1997 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*    Written By Steve Chamberlain    sac@cygnus.com  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_include
include|#
directive|include
file|"opcodes/sh-opc.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"!#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_uses
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sh_count_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|segT
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sh_frob_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|segT
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:    pseudo-op name without dot    function to call to execute this pseudo-op    Integer arg to pass to the function  */
end_comment

begin_function_decl
name|void
name|cons
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|s_align_bytes
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|shl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|little
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|shl
operator|=
literal|1
expr_stmt|;
name|target_big_endian
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"int"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"form"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
block|{
literal|"little"
block|,
name|little
block|,
literal|0
block|}
block|,
block|{
literal|"heading"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
block|{
literal|"import"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"page"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
block|{
literal|"program"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"uses"
block|,
name|s_uses
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*int md_reloc_size; */
end_comment

begin_decl_stmt
name|int
name|sh_relax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if -relax seen */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ENCODE_RELAX(a,b)
end_define

begin_define
define|#
directive|define
name|JREG
value|14
end_define

begin_comment
comment|/* Register used as a temp when relaxing */
end_comment

begin_define
define|#
directive|define
name|ENCODE_RELAX
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< 4) + (length))
end_define

begin_define
define|#
directive|define
name|GET_WHAT
parameter_list|(
name|x
parameter_list|)
value|((x>>4))
end_define

begin_comment
comment|/* These are the two types of relaxable instrction */
end_comment

begin_define
define|#
directive|define
name|COND_JUMP
value|1
end_define

begin_define
define|#
directive|define
name|UNCOND_JUMP
value|2
end_define

begin_define
define|#
directive|define
name|UNDEF_DISP
value|0
end_define

begin_define
define|#
directive|define
name|COND8
value|1
end_define

begin_define
define|#
directive|define
name|COND12
value|2
end_define

begin_define
define|#
directive|define
name|COND32
value|3
end_define

begin_define
define|#
directive|define
name|UNCOND12
value|1
end_define

begin_define
define|#
directive|define
name|UNCOND32
value|2
end_define

begin_define
define|#
directive|define
name|UNDEF_WORD_DISP
value|4
end_define

begin_define
define|#
directive|define
name|END
value|5
end_define

begin_define
define|#
directive|define
name|UNCOND12
value|1
end_define

begin_define
define|#
directive|define
name|UNCOND32
value|2
end_define

begin_comment
comment|/* Branch displacements are from the address of the branch plus    four, thus all minimum and maximum values have 4 added to them.  */
end_comment

begin_define
define|#
directive|define
name|COND8_F
value|258
end_define

begin_define
define|#
directive|define
name|COND8_M
value|-252
end_define

begin_define
define|#
directive|define
name|COND8_LENGTH
value|2
end_define

begin_comment
comment|/* There is one extra instruction before the branch, so we must add    two more bytes to account for it.  */
end_comment

begin_define
define|#
directive|define
name|COND12_F
value|4100
end_define

begin_define
define|#
directive|define
name|COND12_M
value|-4090
end_define

begin_define
define|#
directive|define
name|COND12_LENGTH
value|6
end_define

begin_comment
comment|/* ??? The minimum and maximum values are wrong, but this does not matter    since this relocation type is not supported yet.  */
end_comment

begin_define
define|#
directive|define
name|COND32_F
value|(1<<30)
end_define

begin_define
define|#
directive|define
name|COND32_M
value|-(1<<30)
end_define

begin_define
define|#
directive|define
name|COND32_LENGTH
value|14
end_define

begin_define
define|#
directive|define
name|UNCOND12_F
value|4098
end_define

begin_define
define|#
directive|define
name|UNCOND12_M
value|-4092
end_define

begin_define
define|#
directive|define
name|UNCOND12_LENGTH
value|2
end_define

begin_comment
comment|/* ??? The minimum and maximum values are wrong, but this does not matter    since this relocation type is not supported yet.  */
end_comment

begin_define
define|#
directive|define
name|UNCOND32_F
value|(1<<30)
end_define

begin_define
define|#
directive|define
name|UNCOND32_M
value|-(1<<30)
end_define

begin_define
define|#
directive|define
name|UNCOND32_LENGTH
value|14
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[
name|C
argument_list|(
name|END
argument_list|,
literal|0
argument_list|)
index|]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
comment|/* C (COND_JUMP, COND8) */
block|{
name|COND8_F
block|,
name|COND8_M
block|,
name|COND8_LENGTH
block|,
name|C
argument_list|(
argument|COND_JUMP
argument_list|,
argument|COND12
argument_list|)
block|}
block|,
comment|/* C (COND_JUMP, COND12) */
block|{
name|COND12_F
block|,
name|COND12_M
block|,
name|COND12_LENGTH
block|,
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND32
argument_list|)
block|, }
block|,
comment|/* C (COND_JUMP, COND32) */
block|{
name|COND32_F
block|,
name|COND32_M
block|,
name|COND32_LENGTH
block|,
literal|0
block|, }
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
comment|/* C (UNCOND_JUMP, UNCOND12) */
block|{
name|UNCOND12_F
block|,
name|UNCOND12_M
block|,
name|UNCOND12_LENGTH
block|,
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND32
argument_list|)
block|, }
block|,
comment|/* C (UNCOND_JUMP, UNCOND32) */
block|{
name|UNCOND32_F
block|,
name|UNCOND32_M
block|,
name|UNCOND32_LENGTH
block|,
literal|0
block|, }
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|opcode_hash_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode mnemonics */
end_comment

begin_comment
comment|/*    This function is called once, at assembler startup time.  This should    set up all the tables, etc that the MD part of the assembler needs  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|shl
condition|)
name|target_big_endian
operator|=
literal|1
expr_stmt|;
name|opcode_hash_control
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert unique names into hash table */
for|for
control|(
name|opcode
operator|=
name|sh_table
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
condition|)
block|{
name|prev_name
operator|=
name|opcode
operator|->
name|name
expr_stmt|;
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make all the opcodes with the same name point to the same 	     string */
name|opcode
operator|->
name|name
operator|=
name|prev_name
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|reg_m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|expressionS
name|immediate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* absolute expression */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|sh_arg_type
name|type
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|}
name|sh_operand_info
typedef|;
end_typedef

begin_comment
comment|/* try and parse a reg name, returns number of chars consumed */
end_comment

begin_function
specifier|static
name|int
name|parse_reg
parameter_list|(
name|src
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|int
modifier|*
name|mode
decl_stmt|;
name|int
modifier|*
name|reg
decl_stmt|;
block|{
comment|/* We use !isalnum for the next character after the register name, to      make sure that we won't accidentally recognize a symbol name such as      'sram' as being a reference to the register 'sr'.  */
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|1
index|]
operator|<=
literal|'7'
operator|&&
name|strncmp
argument_list|(
operator|&
name|src
index|[
literal|2
index|]
argument_list|,
literal|"_bank"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|7
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_B
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|7
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'5'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|+
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'r'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_SSR
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'c'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_SPC
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_SR
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|15
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'p'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_PR
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'p'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_DISP_PC
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'g'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'b'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'r'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_GBR
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'v'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'b'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'r'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_VBR
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'c'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|==
literal|'l'
condition|)
block|{
operator|*
name|mode
operator|=
name|A_MACL
expr_stmt|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|==
literal|'h'
condition|)
block|{
operator|*
name|mode
operator|=
name|A_MACH
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'5'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|F_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|F_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'u'
operator|&&
name|src
index|[
literal|3
index|]
operator|==
literal|'l'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|FPUL_N
expr_stmt|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'s'
operator|&&
name|src
index|[
literal|3
index|]
operator|==
literal|'c'
operator|&&
name|src
index|[
literal|4
index|]
operator|==
literal|'r'
operator|&&
operator|!
name|isalnum
argument_list|(
name|src
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|FPSCR_N
expr_stmt|;
return|return
literal|5
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|dot
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|fake
decl_stmt|;
comment|/* JF: '.' is pseudo symbol with value of current location      in current segment.  */
name|fake
operator|=
name|FAKE_LABEL_NAME
expr_stmt|;
return|return
name|symbol_new
argument_list|(
name|fake
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_exp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
operator|&
name|immediate
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediate
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
literal|"missing operand"
argument_list|)
expr_stmt|;
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* The many forms of operand:     Rn                   Register direct    @Rn                  Register indirect    @Rn+                 Autoincrement    @-Rn                 Autodecrement    @(disp:4,Rn)    @(disp:8,GBR)    @(disp:8,PC)     @(R0,Rn)    @(R0,GBR)     disp:8    disp:12    #imm8    pr, gbr, vbr, macl, mach   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_at
parameter_list|(
name|src
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|sh_operand_info
modifier|*
name|op
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* Must be predecrement */
name|src
operator|++
expr_stmt|;
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|A_REG_N
condition|)
name|as_bad
argument_list|(
literal|"illegal register after @-"
argument_list|)
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|A_DEC_N
expr_stmt|;
name|src
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* Could be @(disp, rn), @(disp, gbr), @(disp, pc),  @(r0, gbr) or          @(r0, rn) */
name|src
operator|++
expr_stmt|;
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|mode
operator|==
name|A_REG_N
condition|)
block|{
name|src
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|reg
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"must be @(r0,...)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|src
operator|++
expr_stmt|;
comment|/* Now can be rn or gbr */
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|A_GBR
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_R0_GBR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|A_REG_N
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_IND_R0_REG_N
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"syntax error in @(r0,...)"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Must be an @(disp,.. thing) */
name|src
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|src
operator|++
expr_stmt|;
comment|/* Now can be rn, gbr or pc */
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|op
operator|->
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|A_REG_N
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_DISP_REG_N
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|A_GBR
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_DISP_GBR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|A_DISP_PC
condition|)
block|{
comment|/* Turn a plain @(4,pc) into @(.+4,pc) */
if|if
condition|(
name|immediate
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|immediate
operator|.
name|X_add_symbol
operator|=
name|dot
argument_list|()
expr_stmt|;
name|immediate
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
name|op
operator|->
name|type
operator|=
name|A_DISP_PC
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"syntax error in @(disp,[Rn, gbr, pc])"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"syntax error in @(disp,[Rn, gbr, pc])"
argument_list|)
expr_stmt|;
block|}
block|}
name|src
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|!=
literal|')'
condition|)
name|as_bad
argument_list|(
literal|"expecting )"
argument_list|)
expr_stmt|;
else|else
name|src
operator|++
expr_stmt|;
block|}
else|else
block|{
name|src
operator|+=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|A_REG_N
condition|)
block|{
name|as_bad
argument_list|(
literal|"illegal register after @"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_INC_N
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
else|else
block|{
name|op
operator|->
name|type
operator|=
name|A_IND_N
expr_stmt|;
block|}
block|}
return|return
name|src
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_operand
parameter_list|(
name|ptr
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|sh_operand_info
modifier|*
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|mode
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|src
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|A_IMM
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
operator|*
name|ptr
operator|=
name|parse_at
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
operator|*
name|ptr
operator|=
name|src
operator|+
name|len
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|mode
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Not a reg, the only thing left is a displacement */
operator|*
name|ptr
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|A_DISP_PC
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_operands
parameter_list|(
name|info
parameter_list|,
name|args
parameter_list|,
name|operand
parameter_list|)
name|sh_opcode_info
modifier|*
name|info
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|sh_operand_info
modifier|*
name|operand
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
init|=
name|args
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|arg
index|[
literal|0
index|]
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|arg
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
block|}
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|arg
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
block|}
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operand
index|[
literal|2
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|operand
index|[
literal|1
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|2
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|operand
index|[
literal|0
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|1
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|2
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Passed a pointer to a list of opcodes which use different    addressing modes, return the opcode which matches the opcodes    provided  */
end_comment

begin_function
specifier|static
name|sh_opcode_info
modifier|*
name|get_specific
parameter_list|(
name|opcode
parameter_list|,
name|operands
parameter_list|)
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|sh_operand_info
modifier|*
name|operands
decl_stmt|;
block|{
name|sh_opcode_info
modifier|*
name|this_try
init|=
name|opcode
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|opcode
operator|->
name|name
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|opcode
operator|->
name|name
condition|)
block|{
name|this_try
operator|=
name|opcode
operator|++
expr_stmt|;
if|if
condition|(
name|this_try
operator|->
name|name
operator|!=
name|name
condition|)
block|{
comment|/* We've looked so far down the table that we've run out of 	     opcodes with the same name */
return|return
literal|0
return|;
block|}
comment|/* look at both operands needed by the opcodes and provided by          the user - since an arg test will often fail on the same arg          again and again, we'll try and test the last failing arg the          first on each opcode try */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|this_try
operator|->
name|arg
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
name|sh_operand_info
modifier|*
name|user
init|=
name|operands
operator|+
name|n
decl_stmt|;
name|sh_arg_type
name|arg
init|=
name|this_try
operator|->
name|arg
index|[
name|n
index|]
decl_stmt|;
switch|switch
condition|(
name|arg
condition|)
block|{
case|case
name|A_IMM
case|:
case|case
name|A_BDISP12
case|:
case|case
name|A_BDISP8
case|:
case|case
name|A_DISP_GBR
case|:
case|case
name|A_DISP_PC
case|:
case|case
name|A_MACH
case|:
case|case
name|A_PR
case|:
case|case
name|A_MACL
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_R0
case|:
comment|/* opcode needs r0 */
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|A_REG_N
operator|||
name|user
operator|->
name|reg
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_R0_GBR
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|A_R0_GBR
operator|||
name|user
operator|->
name|reg
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|F_FR0
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|F_REG_N
operator|||
name|user
operator|->
name|reg
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_REG_N
case|:
case|case
name|A_INC_N
case|:
case|case
name|A_DEC_N
case|:
case|case
name|A_IND_N
case|:
case|case
name|A_IND_R0_REG_N
case|:
case|case
name|A_DISP_REG_N
case|:
case|case
name|F_REG_N
case|:
case|case
name|FPUL_N
case|:
case|case
name|FPSCR_N
case|:
comment|/* Opcode needs rn */
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
condition|)
goto|goto
name|fail
goto|;
name|reg_n
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
case|case
name|A_GBR
case|:
case|case
name|A_SR
case|:
case|case
name|A_VBR
case|:
case|case
name|A_SSR
case|:
case|case
name|A_SPC
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_REG_B
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
condition|)
goto|goto
name|fail
goto|;
name|reg_b
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
case|case
name|A_REG_M
case|:
case|case
name|A_INC_M
case|:
case|case
name|A_DEC_M
case|:
case|case
name|A_IND_M
case|:
case|case
name|A_IND_R0_REG_M
case|:
case|case
name|A_DISP_REG_M
case|:
comment|/* Opcode needs rn */
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
operator|-
name|A_REG_M
operator|+
name|A_REG_N
condition|)
goto|goto
name|fail
goto|;
name|reg_m
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
case|case
name|F_REG_M
case|:
case|case
name|FPUL_M
case|:
case|case
name|FPSCR_M
case|:
comment|/* Opcode needs rn */
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
operator|-
name|F_REG_M
operator|+
name|F_REG_N
condition|)
goto|goto
name|fail
goto|;
name|reg_m
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unhandled %d\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
name|this_try
return|;
name|fail
label|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|check
parameter_list|(
name|operand
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
name|expressionS
modifier|*
name|operand
decl_stmt|;
name|int
name|low
decl_stmt|;
name|int
name|high
decl_stmt|;
block|{
if|if
condition|(
name|operand
operator|->
name|X_op
operator|!=
name|O_constant
operator|||
name|operand
operator|->
name|X_add_number
operator|<
name|low
operator|||
name|operand
operator|->
name|X_add_number
operator|>
name|high
condition|)
block|{
name|as_bad
argument_list|(
literal|"operand must be absolute in range %d..%d"
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
return|return
name|operand
operator|->
name|X_add_number
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert
parameter_list|(
name|where
parameter_list|,
name|how
parameter_list|,
name|pcrel
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|int
name|how
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|immediate
argument_list|,
name|pcrel
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_relax
parameter_list|(
name|opcode
parameter_list|)
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
block|{
name|int
name|high_byte
init|=
name|target_big_endian
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|==
name|A_BDISP8
condition|)
block|{
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND32
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND8
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|COND_JUMP
argument_list|,
literal|0
argument_list|)
argument_list|,
name|immediate
operator|.
name|X_add_symbol
argument_list|,
name|immediate
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
index|[
name|high_byte
index|]
operator|=
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|==
name|A_BDISP12
condition|)
block|{
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND32
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
literal|0
argument_list|)
argument_list|,
name|immediate
operator|.
name|X_add_symbol
argument_list|,
name|immediate
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
index|[
name|high_byte
index|]
operator|=
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Now we know what sort of opcodes it is, lets build the bytes -  */
end_comment

begin_function
specifier|static
name|void
name|build_Mytes
parameter_list|(
name|opcode
parameter_list|,
name|operand
parameter_list|)
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|sh_operand_info
modifier|*
name|operand
decl_stmt|;
block|{
name|int
name|index
decl_stmt|;
name|char
name|nbuf
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|frag_more
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|int
name|low_byte
init|=
name|target_big_endian
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|nbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|nbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|nbuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|nbuf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|4
condition|;
name|index
operator|++
control|)
block|{
name|sh_nibble_type
name|i
init|=
name|opcode
operator|->
name|nibbles
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|16
condition|)
block|{
name|nbuf
index|[
name|index
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|REG_N
case|:
name|nbuf
index|[
name|index
index|]
operator|=
name|reg_n
expr_stmt|;
break|break;
case|case
name|REG_M
case|:
name|nbuf
index|[
name|index
index|]
operator|=
name|reg_m
expr_stmt|;
break|break;
case|case
name|REG_B
case|:
name|nbuf
index|[
name|index
index|]
operator|=
name|reg_b
operator||
literal|0x08
expr_stmt|;
break|break;
case|case
name|DISP_4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM_4BY4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4BY4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM_4BY2
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4BY2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM_4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM_8BY4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM8BY4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM_8BY2
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM8BY2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM_8
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCRELIMM_8BY4
case|:
name|insert
argument_list|(
name|output
argument_list|,
name|BFD_RELOC_SH_PCRELIMM8BY4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCRELIMM_8BY2
case|:
name|insert
argument_list|(
name|output
argument_list|,
name|BFD_RELOC_SH_PCRELIMM8BY2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"failed for %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|output
index|[
literal|1
index|]
operator|=
operator|(
name|nbuf
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
operator|(
name|nbuf
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|3
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|output
index|[
literal|0
index|]
operator|=
operator|(
name|nbuf
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
operator|(
name|nbuf
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|3
index|]
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|op_start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op_end
decl_stmt|;
name|sh_operand_info
name|operand
index|[
literal|3
index|]
decl_stmt|;
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
name|int
name|nlen
init|=
literal|0
decl_stmt|;
comment|/* Drop leading whitespace */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* find the op code end */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|str
operator|)
init|;
operator|*
name|op_end
operator|&&
name|nlen
operator|<
literal|20
operator|&&
operator|!
name|is_end_of_line
index|[
operator|*
name|op_end
index|]
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
condition|;
name|op_end
operator|++
control|)
block|{
name|name
index|[
name|nlen
index|]
operator|=
name|op_start
index|[
name|nlen
index|]
expr_stmt|;
name|nlen
operator|++
expr_stmt|;
block|}
name|name
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't find opcode "
argument_list|)
expr_stmt|;
block|}
name|opcode
operator|=
operator|(
name|sh_opcode_info
operator|*
operator|)
name|hash_find
argument_list|(
name|opcode_hash_control
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"unknown opcode"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sh_relax
operator|&&
operator|!
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
condition|)
block|{
comment|/* Output a CODE reloc to tell the linker that the following          bytes are instructions, not data.  */
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|2
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_CODE
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|==
name|A_BDISP12
operator|||
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|==
name|A_BDISP8
condition|)
block|{
name|parse_exp
argument_list|(
name|op_end
operator|+
literal|1
argument_list|)
expr_stmt|;
name|build_relax
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|!=
name|A_END
condition|)
block|{
name|get_operands
argument_list|(
name|opcode
argument_list|,
name|op_end
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
name|opcode
operator|=
name|get_specific
argument_list|(
name|opcode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
comment|/* Couldn't find an opcode which matched the operands */
name|char
modifier|*
name|where
init|=
name|frag_more
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|where
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|as_bad
argument_list|(
literal|"invalid operands for opcode"
argument_list|)
expr_stmt|;
return|return;
block|}
name|build_Mytes
argument_list|(
name|opcode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is called each time a label definition is seen.  It    emits a BFD_RELOC_SH_LABEL reloc if necessary.  */
end_comment

begin_function
name|void
name|sh_frob_label
parameter_list|()
block|{
specifier|static
name|fragS
modifier|*
name|last_label_frag
decl_stmt|;
specifier|static
name|int
name|last_label_offset
decl_stmt|;
if|if
condition|(
name|sh_relax
operator|&&
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
if|if
condition|(
name|frag_now
operator|!=
name|last_label_frag
operator|||
name|offset
operator|!=
name|last_label_offset
condition|)
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|offset
argument_list|,
literal|2
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_LABEL
argument_list|)
expr_stmt|;
name|last_label_frag
operator|=
name|frag_now
expr_stmt|;
name|last_label_offset
operator|=
name|offset
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This routine is called when the assembler is about to output some    data.  It emits a BFD_RELOC_SH_DATA reloc if necessary.  */
end_comment

begin_function
name|void
name|sh_flush_pending_output
parameter_list|()
block|{
if|if
condition|(
name|sh_relax
operator|&&
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
condition|)
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|2
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_DATA
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|symbolS
modifier|*
name|DEFUN
argument_list|(
name|md_undefined_symbol
argument_list|,
operator|(
name|name
operator|)
argument_list|,
name|char
operator|*
name|name
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|tc_crawl_symbol_chain
argument_list|,
operator|(
name|headers
operator|)
argument_list|,
name|object_headers
operator|*
name|headers
argument_list|)
block|{
name|printf
argument_list|(
literal|"call to tc_crawl_symbol_chain \n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|tc_headers_hook
argument_list|,
operator|(
name|headers
operator|)
argument_list|,
name|object_headers
operator|*
name|headers
argument_list|)
block|{
name|printf
argument_list|(
literal|"call to tc_headers_hook \n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Various routines to kill one day */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"bad call to md_atof"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Handle the .uses pseudo-op.  This pseudo-op is used just before a    call instruction.  It refers to a label of the instruction which    loads the register which the call uses.  We use it to generate a    special reloc for the linker.  */
end_comment

begin_function
specifier|static
name|void
name|s_uses
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|expressionS
name|ex
decl_stmt|;
if|if
condition|(
operator|!
name|sh_relax
condition|)
name|as_warn
argument_list|(
literal|".uses pseudo-op seen when not relaxing"
argument_list|)
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad .uses format"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|2
argument_list|,
operator|&
name|ex
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_USES
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_RELAX
value|(OPTION_MD_BASE)
define|#
directive|define
name|OPTION_LITTLE
value|(OPTION_MD_BASE+1)
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
block|{
literal|"little"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LITTLE
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_RELAX
case|:
name|sh_relax
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_LITTLE
case|:
name|shl
operator|=
literal|1
expr_stmt|;
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ SH options:\n\ -little			generate little endian code\n\ -relax			alter jump instructions for long displacements\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|md_short_jump_size
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|tc_Nout_fix_to_chars
parameter_list|()
block|{
name|printf
argument_list|(
literal|"call to tc_Nout_fix_to_chars \n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_Nddr
parameter_list|,
name|to_Nddr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_Nddr
decl_stmt|;
name|addressT
name|to_Nddr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_Nddr
parameter_list|,
name|to_Nddr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_Nddr
decl_stmt|,
name|to_Nddr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This struct is used to pass arguments to sh_count_relocs through    bfd_map_over_sections.  */
end_comment

begin_struct
struct|struct
name|sh_count_relocs
block|{
comment|/* Symbol we are looking for.  */
name|symbolS
modifier|*
name|sym
decl_stmt|;
comment|/* Count of relocs found.  */
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Count the number of fixups in a section which refer to a particular    symbol.  When using BFD_ASSEMBLER, this is called via    bfd_map_over_sections.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|sh_count_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|sh_count_relocs
modifier|*
name|info
init|=
operator|(
expr|struct
name|sh_count_relocs
operator|*
operator|)
name|data
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
name|sym
operator|=
name|info
operator|->
name|sym
expr_stmt|;
for|for
control|(
name|fix
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fix
operator|!=
name|NULL
condition|;
name|fix
operator|=
name|fix
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
name|fix
operator|->
name|fx_addsy
operator|==
name|sym
condition|)
block|{
operator|++
name|info
operator|->
name|count
expr_stmt|;
name|fix
operator|->
name|fx_tcbit
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle the count relocs for a particular section.  When using    BFD_ASSEMBLER, this is called via bfd_map_over_sections.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|sh_frob_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|PTR
name|ignore
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|fix
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fix
operator|!=
name|NULL
condition|;
name|fix
operator|=
name|fix
operator|->
name|fx_next
control|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|fixS
modifier|*
name|fscan
decl_stmt|;
name|struct
name|sh_count_relocs
name|info
decl_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_USES
condition|)
continue|continue;
comment|/* The BFD_RELOC_SH_USES reloc should refer to a defined local 	 symbol in the same section.  */
name|sym
operator|=
name|fix
operator|->
name|fx_addsy
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
operator|||
name|fix
operator|->
name|fx_subsy
operator|!=
name|NULL
operator|||
name|fix
operator|->
name|fx_addnumber
operator|!=
literal|0
operator|||
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|!=
name|sec
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_EXT
endif|#
directive|endif
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_warn_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
literal|".uses does not refer to a local symbol in the same section"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Look through the fixups again, this time looking for one 	 at the same location as sym.  */
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
for|for
control|(
name|fscan
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fscan
operator|!=
name|NULL
condition|;
name|fscan
operator|=
name|fscan
operator|->
name|fx_next
control|)
if|if
condition|(
name|val
operator|==
name|fscan
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fscan
operator|->
name|fx_where
operator|&&
name|fscan
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_ALIGN
operator|&&
name|fscan
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_CODE
operator|&&
name|fscan
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_DATA
operator|&&
name|fscan
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_LABEL
condition|)
break|break;
if|if
condition|(
name|fscan
operator|==
name|NULL
condition|)
block|{
name|as_warn_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
literal|"can't find fixup pointed to by .uses"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fscan
operator|->
name|fx_tcbit
condition|)
block|{
comment|/* We've already done this one.  */
continue|continue;
block|}
comment|/* fscan should also be a fixup to a local symbol in the same 	 section.  */
name|sym
operator|=
name|fscan
operator|->
name|fx_addsy
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
operator|||
name|fscan
operator|->
name|fx_subsy
operator|!=
name|NULL
operator|||
name|fscan
operator|->
name|fx_addnumber
operator|!=
literal|0
operator|||
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|!=
name|sec
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_EXT
endif|#
directive|endif
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_warn_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
literal|".uses target does not refer to a local symbol in the same section"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now we look through all the fixups of all the sections, 	 counting the number of times we find a reference to sym.  */
name|info
operator|.
name|sym
operator|=
name|sym
expr_stmt|;
name|info
operator|.
name|count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|sh_count_relocs
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|iscan
decl_stmt|;
for|for
control|(
name|iscan
operator|=
name|SEG_E0
init|;
name|iscan
operator|<
name|SEG_UNKNOWN
condition|;
name|iscan
operator|++
control|)
name|sh_count_relocs
argument_list|(
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
name|iscan
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|info
operator|.
name|count
operator|<
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Generate a BFD_RELOC_SH_COUNT fixup at the location of sym. 	 We have already adjusted the value of sym to include the 	 fragment address, so we undo that adjustment here.  */
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|sym
operator|->
name|sy_frag
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|-
name|sym
operator|->
name|sy_frag
operator|->
name|fr_address
argument_list|,
literal|4
argument_list|,
operator|&
name|abs_symbol
argument_list|,
name|info
operator|.
name|count
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_COUNT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called after the symbol table has been completed,    but before the relocs or section contents have been written out.    If we have seen any .uses pseudo-ops, they point to an instruction    which loads a register with the address of a function.  We look    through the fixups to find where the function address is being    loaded from.  We then generate a COUNT reloc giving the number of    times that function address is referred to.  The linker uses this    information when doing relaxing, to decide when it can eliminate    the stored function address entirely.  */
end_comment

begin_function
name|void
name|sh_frob_file
parameter_list|()
block|{
if|if
condition|(
operator|!
name|sh_relax
condition|)
return|return;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|sh_frob_section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|iseg
decl_stmt|;
for|for
control|(
name|iseg
operator|=
name|SEG_E0
init|;
name|iseg
operator|<
name|SEG_UNKNOWN
condition|;
name|iseg
operator|++
control|)
name|sh_frob_section
argument_list|(
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
name|iseg
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called after relaxing.  Set the correct sizes of the fragments, and    create relocs so that md_apply_fix will fill in the correct values.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|seg
parameter_list|,
name|fragP
parameter_list|)
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd
modifier|*
name|headers
decl_stmt|;
else|#
directive|else
name|object_headers
modifier|*
name|headers
decl_stmt|;
endif|#
directive|endif
name|segT
name|seg
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|int
name|donerelax
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND8
argument_list|)
case|:
name|subseg_change
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_PCDISP8BY2
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
case|:
name|subseg_change
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_PCDISP12BY2
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
literal|"at 0x%lx, displacement overflows 12-bit field"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fragP
operator|->
name|fr_address
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"at 0x%lx, displacement to %sdefined symbol %s overflows 12-bit field"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fragP
operator|->
name|fr_address
argument_list|,
name|S_IS_DEFINED
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|?
literal|""
else|:
literal|"un"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code works, but generates poor code and the compiler 				   should never produce a sequence that requires it to be used.  */
comment|/* A jump wont fit in 12 bits, make code which looks like 	 bra foo 	 mov.w @(0, PC), r14 	 .long disp 	 foo: bra @r14 	 */
block|int t = buffer[0]& 0x10;        buffer[highbyte] = 0xa0;
comment|/* branch over move and disp */
block|buffer[lowbyte] = 3;       buffer[highbyte+2] = 0xd0 | JREG;
comment|/* Build mov insn */
block|buffer[lowbyte+2] = 0x00;        buffer[highbyte+4] = 0;
comment|/* space for 32 bit jump disp */
block|buffer[lowbyte+4] = 0;       buffer[highbyte+6] = 0;       buffer[lowbyte+6] = 0;        buffer[highbyte+8] = 0x40 | JREG;
comment|/* Build jmp @JREG */
block|buffer[lowbyte+8] = t ? 0xb : 0x2b;        buffer[highbyte+10] = 0x20;
comment|/* build nop */
block|buffer[lowbyte+10] = 0x0b;
comment|/* Make reloc for the long disp */
block|fix_new (fragP, 	       fragP->fr_fix + 4, 	       4, 	       fragP->fr_symbol, 	       fragP->fr_offset, 	       0, 	       BFD_RELOC_32);       fragP->fr_fix += UNCOND32_LENGTH;       fragP->fr_var = 0;       donerelax = 1;
endif|#
directive|endif
break|break;
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND12
argument_list|)
case|:
comment|/* A bcond won't fit, so turn it into a b!cond; bra disp; nop */
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
operator|)
decl_stmt|;
name|int
name|highbyte
init|=
name|target_big_endian
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|int
name|lowbyte
init|=
name|target_big_endian
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|/* Toggle the true/false bit of the bcond.  */
name|buffer
index|[
name|highbyte
index|]
operator|^=
literal|0x2
expr_stmt|;
comment|/* Build a relocation to six bytes farther on.  */
name|subseg_change
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|section_symbol
argument_list|(
name|seg
argument_list|)
argument_list|,
else|#
directive|else
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|dot
argument_list|,
endif|#
directive|endif
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
literal|6
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_PCDISP8BY2
argument_list|)
expr_stmt|;
comment|/* Set up a jump instruction.  */
name|buffer
index|[
name|highbyte
operator|+
literal|2
index|]
operator|=
literal|0xa0
expr_stmt|;
name|buffer
index|[
name|lowbyte
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_PCDISP12BY2
argument_list|)
expr_stmt|;
comment|/* Fill in a NOP instruction.  */
name|buffer
index|[
name|highbyte
operator|+
literal|4
index|]
operator|=
literal|0x0
expr_stmt|;
name|buffer
index|[
name|lowbyte
operator|+
literal|4
index|]
operator|=
literal|0x9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|donerelax
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
literal|"at 0x%lx, displacement overflows 8-bit field"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fragP
operator|->
name|fr_address
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"at 0x%lx, displacement to %sdefined symbol %s overflows 8-bit field "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fragP
operator|->
name|fr_address
argument_list|,
name|S_IS_DEFINED
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|?
literal|""
else|:
literal|"un"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code works, but generates poor code, and the compiler 				   should never produce a sequence that requires it to be used.  */
comment|/* A bcond won't fit and it won't go into a 12 bit 	 displacement either, the code sequence looks like: 	 b!cond foop 	 mov.w @(n, PC), r14 	 jmp  @r14 	 nop 	 .long where 	 foop: 	 */
block|buffer[0] ^= 0x2;
comment|/* Toggle T/F bit */
define|#
directive|define
name|JREG
value|14
block|buffer[1] = 5;
comment|/* branch over mov, jump, nop and ptr */
block|buffer[2] = 0xd0 | JREG;
comment|/* Build mov insn */
block|buffer[3] = 0x2;       buffer[4] = 0x40 | JREG;
comment|/* Build jmp @JREG */
block|buffer[5] = 0x0b;       buffer[6] = 0x20;
comment|/* build nop */
block|buffer[7] = 0x0b;       buffer[8] = 0;
comment|/* space for 32 bit jump disp */
block|buffer[9] = 0;       buffer[10] = 0;       buffer[11] = 0;       buffer[12] = 0;       buffer[13] = 0;
comment|/* Make reloc for the long disp */
block|fix_new (fragP, 	       fragP->fr_fix + 8, 	       4, 	       fragP->fr_symbol, 	       fragP->fr_offset, 	       0, 	       BFD_RELOC_32);       fragP->fr_fix += COND32_LENGTH;       fragP->fr_var = 0;       donerelax = 1;
endif|#
directive|endif
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|donerelax
operator|&&
operator|!
name|sh_relax
condition|)
name|as_warn_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
literal|"overflow in branch to %s; converted into longer instruction sequence"
argument_list|,
operator|(
name|fragP
operator|->
name|fr_symbol
operator|!=
name|NULL
condition|?
name|S_GET_NAME
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|valueT
name|DEFUN
argument_list|(
name|md_section_align
argument_list|,
operator|(
name|seg
operator|,
name|size
operator|)
argument_list|,
name|segT
name|seg
name|AND
name|valueT
name|size
argument_list|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
ifdef|#
directive|ifdef
name|OBJ_ELF
return|return
name|size
return|;
else|#
directive|else
comment|/* ! OBJ_ELF */
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* ! OBJ_ELF */
else|#
directive|else
comment|/* ! BFD_ASSEMBLER */
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* ! BFD_ASSEMBLER */
block|}
end_decl_stmt

begin_comment
comment|/* When relaxing, we need to output a reloc for any .align directive    that requests alignment to a four byte boundary or larger.  */
end_comment

begin_function
name|void
name|sh_handle_align
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
if|if
condition|(
name|sh_relax
operator|&&
name|frag
operator|->
name|fr_type
operator|==
name|rs_align
operator|&&
name|frag
operator|->
name|fr_address
operator|+
name|frag
operator|->
name|fr_fix
operator|>
literal|0
operator|&&
name|frag
operator|->
name|fr_offset
operator|>
literal|1
operator|&&
name|now_seg
operator|!=
name|bss_section
condition|)
name|fix_new
argument_list|(
name|frag
argument_list|,
name|frag
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
operator|&
name|abs_symbol
argument_list|,
name|frag
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_ALIGN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This macro decides whether a particular reloc is an entry in a    switch table.  It is used when relaxing, because the linker needs    to know about all such entries so that it can adjust them if    necessary.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_define
define|#
directive|define
name|SWITCH_TABLE_CONS
parameter_list|(
name|fix
parameter_list|)
value|(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SWITCH_TABLE_CONS
parameter_list|(
name|fix
parameter_list|)
define|\
value|((fix)->fx_r_type == 0				\&& ((fix)->fx_size == 2				\        || (fix)->fx_size == 4))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SWITCH_TABLE
parameter_list|(
name|fix
parameter_list|)
define|\
value|((fix)->fx_addsy != NULL				\&& (fix)->fx_subsy != NULL				\&& S_GET_SEGMENT ((fix)->fx_addsy) == text_section	\&& S_GET_SEGMENT ((fix)->fx_subsy) == text_section	\&& ((fix)->fx_r_type == BFD_RELOC_32			\        || (fix)->fx_r_type == BFD_RELOC_16		\        || SWITCH_TABLE_CONS (fix)))
end_define

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|sh_force_relocation
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sh_relax
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|fix
operator|->
name|fx_pcrel
operator|||
name|SWITCH_TABLE
argument_list|(
name|fix
argument_list|)
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_COUNT
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_ALIGN
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_CODE
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_DATA
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_LABEL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|int
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|valp
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valp
decl_stmt|;
else|#
directive|else
function|void md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|val
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|long
name|val
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|int
name|lowbyte
init|=
name|target_big_endian
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|highbyte
init|=
name|target_big_endian
condition|?
literal|0
else|:
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|long
name|val
init|=
operator|*
name|valp
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_16
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_SH_IMM8
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_SH_IMM4
case|:
operator|*
name|buf
operator|=
operator|(
operator|*
name|buf
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|val
operator|&
literal|0xf
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM4BY2
case|:
operator|*
name|buf
operator|=
operator|(
operator|*
name|buf
operator|&
literal|0xf0
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|1
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM4BY4
case|:
operator|*
name|buf
operator|=
operator|(
operator|*
name|buf
operator|&
literal|0xf0
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|2
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM8BY2
case|:
operator|*
name|buf
operator|=
name|val
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM8BY4
case|:
operator|*
name|buf
operator|=
name|val
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
case|case
name|BFD_RELOC_SH_IMM8
case|:
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PCRELIMM8BY4
case|:
comment|/* The lower two bits of the PC are cleared before the          displacement is added in.  We can assume that the destination          is on a 4 byte bounday.  If this instruction is also on a 4          byte boundary, then we want 	   (target - here) / 4 	 and target - here is a multiple of 4. 	 Otherwise, we are on a 2 byte boundary, and we want 	   (target - (here - 2)) / 4 	 and target - here is not a multiple of 4.  Computing 	   (target - (here - 2)) / 4 == (target - here + 2) / 4 	 works for both cases, since in the first case the addition of 	 2 will be removed by the division.  target - here is in the 	 variable val.  */
name|val
operator|=
operator|(
name|val
operator|+
literal|2
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|~
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"pcrel too far"
argument_list|)
expr_stmt|;
name|buf
index|[
name|lowbyte
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PCRELIMM8BY2
case|:
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|~
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"pcrel too far"
argument_list|)
expr_stmt|;
name|buf
index|[
name|lowbyte
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PCDISP8BY2
case|:
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|<
operator|-
literal|0x80
operator|||
name|val
operator|>
literal|0x7f
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"pcrel too far"
argument_list|)
expr_stmt|;
name|buf
index|[
name|lowbyte
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PCDISP12BY2
case|:
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|<
operator|-
literal|0x800
operator|||
name|val
operator|>=
literal|0x7ff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"pcrel too far"
argument_list|)
expr_stmt|;
name|buf
index|[
name|lowbyte
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
name|highbyte
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xf
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_SH_USES
case|:
comment|/* Pass the value into sh_coff_reloc_mangle.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_COUNT
case|:
case|case
name|BFD_RELOC_SH_ALIGN
case|:
case|case
name|BFD_RELOC_SH_CODE
case|:
case|case
name|BFD_RELOC_SH_DATA
case|:
case|case
name|BFD_RELOC_SH_LABEL
case|:
comment|/* Nothing to do here.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|int
name|md_long_jump_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called just before address relaxation.  Return the length    by which a fragment must grow to reach it's destination.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment_type
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|segment_type
decl_stmt|;
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNDEF_DISP
argument_list|)
case|:
comment|/* used to be a branch to somewhere which was unknown */
if|if
condition|(
operator|!
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
index|]
operator|.
name|rlx_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
index|]
operator|.
name|rlx_length
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND32
argument_list|)
index|]
operator|.
name|rlx_length
expr_stmt|;
return|return
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND32
argument_list|)
index|]
operator|.
name|rlx_length
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_DISP
argument_list|)
case|:
comment|/* used to be a branch to somewhere which was unknown */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
comment|/* Got a symbol and it's defined in this segment, become byte 	     sized - maybe it will fix up */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND8
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND8
argument_list|)
index|]
operator|.
name|rlx_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
comment|/* Its got a segment, but its not ours, so it will always be long */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND32
argument_list|)
index|]
operator|.
name|rlx_length
expr_stmt|;
return|return
name|md_relax_table
index|[
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND32
argument_list|)
index|]
operator|.
name|rlx_length
return|;
block|}
else|else
block|{
comment|/* We know the abs value */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND8
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND8
argument_list|)
index|]
operator|.
name|rlx_length
expr_stmt|;
block|}
break|break;
block|}
return|return
name|fragP
operator|->
name|fr_var
return|;
block|}
end_function

begin_comment
comment|/* Put number into target byte order */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|ptr
parameter_list|,
name|use
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|valueT
name|use
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|number_to_chars_littleendian
argument_list|(
name|ptr
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_bigendian
argument_list|(
name|ptr
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
literal|2
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_function
name|int
name|tc_coff_sizemachdep
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
return|return
name|md_relax_table
index|[
name|frag
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_comment
comment|/* When we align the .text section, insert the correct NOP pattern.  */
end_comment

begin_function
name|int
name|sh_do_align
parameter_list|(
name|n
parameter_list|,
name|fill
parameter_list|,
name|len
parameter_list|,
name|max
parameter_list|)
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|fill
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
if|if
condition|(
name|fill
operator|==
name|NULL
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
operator|&&
operator|(
name|now_seg
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
else|#
directive|else
operator|&&
name|now_seg
operator|!=
name|data_section
operator|&&
name|now_seg
operator|!=
name|bss_section
endif|#
directive|endif
operator|&&
name|n
operator|>
literal|1
condition|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|big_nop_pattern
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x09
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|little_nop_pattern
index|[]
init|=
block|{
literal|0x09
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* First align to a 2 byte boundary, in case there is an odd          .byte.  */
name|frag_align
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|frag_align_pattern
argument_list|(
name|n
argument_list|,
name|big_nop_pattern
argument_list|,
sizeof|sizeof
name|big_nop_pattern
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|frag_align_pattern
argument_list|(
name|n
argument_list|,
name|little_nop_pattern
argument_list|,
sizeof|sizeof
name|little_nop_pattern
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_comment
comment|/* Map BFD relocs to SH COFF relocs.  */
end_comment

begin_struct
struct|struct
name|reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc
decl_stmt|;
name|int
name|sh_reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reloc_map
name|coff_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_32
block|,
name|R_SH_IMM32
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_SH_IMM16
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_SH_IMM8
block|}
block|,
block|{
name|BFD_RELOC_SH_PCDISP8BY2
block|,
name|R_SH_PCDISP8BY2
block|}
block|,
block|{
name|BFD_RELOC_SH_PCDISP12BY2
block|,
name|R_SH_PCDISP
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM4
block|,
name|R_SH_IMM4
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM4BY2
block|,
name|R_SH_IMM4BY2
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM4BY4
block|,
name|R_SH_IMM4BY4
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM8
block|,
name|R_SH_IMM8
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM8BY2
block|,
name|R_SH_IMM8BY2
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM8BY4
block|,
name|R_SH_IMM8BY4
block|}
block|,
block|{
name|BFD_RELOC_SH_PCRELIMM8BY2
block|,
name|R_SH_PCRELIMM8BY2
block|}
block|,
block|{
name|BFD_RELOC_SH_PCRELIMM8BY4
block|,
name|R_SH_PCRELIMM8BY4
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH16
block|,
name|R_SH_SWITCH16
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH32
block|,
name|R_SH_SWITCH32
block|}
block|,
block|{
name|BFD_RELOC_SH_USES
block|,
name|R_SH_USES
block|}
block|,
block|{
name|BFD_RELOC_SH_COUNT
block|,
name|R_SH_COUNT
block|}
block|,
block|{
name|BFD_RELOC_SH_ALIGN
block|,
name|R_SH_ALIGN
block|}
block|,
block|{
name|BFD_RELOC_SH_CODE
block|,
name|R_SH_CODE
block|}
block|,
block|{
name|BFD_RELOC_SH_DATA
block|,
name|R_SH_DATA
block|}
block|,
block|{
name|BFD_RELOC_SH_LABEL
block|,
name|R_SH_LABEL
block|}
block|,
block|{
name|BFD_RELOC_UNUSED
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjust a reloc for the SH.  This is similar to the generic code,    but does some minor tweaking.  */
end_comment

begin_function
name|void
name|sh_coff_reloc_mangle
parameter_list|(
name|seg
parameter_list|,
name|fix
parameter_list|,
name|intr
parameter_list|,
name|paddr
parameter_list|)
name|segment_info_type
modifier|*
name|seg
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|intr
decl_stmt|;
name|unsigned
name|int
name|paddr
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbol_ptr
init|=
name|fix
operator|->
name|fx_addsy
decl_stmt|;
name|symbolS
modifier|*
name|dot
decl_stmt|;
name|intr
operator|->
name|r_vaddr
operator|=
name|paddr
operator|+
name|fix
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fix
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
operator|!
name|SWITCH_TABLE
argument_list|(
name|fix
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|reloc_map
modifier|*
name|rm
decl_stmt|;
for|for
control|(
name|rm
operator|=
name|coff_reloc_map
init|;
name|rm
operator|->
name|bfd_reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|;
name|rm
operator|++
control|)
if|if
condition|(
name|rm
operator|->
name|bfd_reloc
operator|==
operator|(
name|bfd_reloc_code_real_type
operator|)
name|fix
operator|->
name|fx_r_type
condition|)
break|break;
if|if
condition|(
name|rm
operator|->
name|bfd_reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
literal|"Can not represent %s relocation in this object file format"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fix
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
name|intr
operator|->
name|r_type
operator|=
name|rm
operator|->
name|sh_reloc
expr_stmt|;
name|intr
operator|->
name|r_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|sh_relax
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16
condition|)
name|intr
operator|->
name|r_type
operator|=
name|R_SH_SWITCH16
expr_stmt|;
elseif|else
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32
condition|)
name|intr
operator|->
name|r_type
operator|=
name|R_SH_SWITCH32
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* For a switch reloc, we set r_offset to the difference between          the reloc address and the subtrahend.  When the linker is          doing relaxing, it can use the determine the starting and          ending points of the switch difference expression.  */
name|intr
operator|->
name|r_offset
operator|=
name|intr
operator|->
name|r_vaddr
operator|-
name|S_GET_VALUE
argument_list|(
name|fix
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
block|}
comment|/* PC relative relocs are always against the current section.  */
if|if
condition|(
name|symbol_ptr
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_SH_PCRELIMM8BY2
case|:
case|case
name|BFD_RELOC_SH_PCRELIMM8BY4
case|:
case|case
name|BFD_RELOC_SH_PCDISP8BY2
case|:
case|case
name|BFD_RELOC_SH_PCDISP12BY2
case|:
case|case
name|BFD_RELOC_SH_USES
case|:
name|symbol_ptr
operator|=
name|seg
operator|->
name|dot
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_USES
condition|)
block|{
comment|/* We can't store the offset in the object file, since this 	 reloc does not take up any space, so we store it in r_offset. 	 The fx_addnumber field was set in md_apply_fix.  */
name|intr
operator|->
name|r_offset
operator|=
name|fix
operator|->
name|fx_addnumber
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_COUNT
condition|)
block|{
comment|/* We can't store the count in the object file, since this reloc          does not take up any space, so we store it in r_offset.  The          fx_offset field was set when the fixup was created in          sh_coff_frob_file.  */
name|intr
operator|->
name|r_offset
operator|=
name|fix
operator|->
name|fx_offset
expr_stmt|;
comment|/* This reloc is always absolute.  */
name|symbol_ptr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_ALIGN
condition|)
block|{
comment|/* Store the alignment in the r_offset field.  */
name|intr
operator|->
name|r_offset
operator|=
name|fix
operator|->
name|fx_offset
expr_stmt|;
comment|/* This reloc is always absolute.  */
name|symbol_ptr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_CODE
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_DATA
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_LABEL
condition|)
block|{
comment|/* These relocs are always absolute.  */
name|symbol_ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Turn the segment of the symbol into an offset.  */
if|if
condition|(
name|symbol_ptr
operator|!=
name|NULL
condition|)
block|{
name|dot
operator|=
name|segment_info
index|[
name|S_GET_SEGMENT
argument_list|(
name|symbol_ptr
argument_list|)
index|]
operator|.
name|dot
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
name|intr
operator|->
name|r_symndx
operator|=
name|dot
operator|->
name|sy_number
expr_stmt|;
else|else
name|intr
operator|->
name|r_symndx
operator|=
name|symbol_ptr
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
name|intr
operator|->
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_comment
comment|/* Create a reloc.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|fixp
operator|->
name|fx_addsy
operator|->
name|bsym
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|r_type
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|SWITCH_TABLE
argument_list|(
name|fixp
argument_list|)
condition|)
block|{
name|rel
operator|->
name|addend
operator|=
name|rel
operator|->
name|address
operator|-
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_16
condition|)
name|r_type
operator|=
name|BFD_RELOC_SH_SWITCH16
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_32
condition|)
name|r_type
operator|=
name|BFD_RELOC_SH_SWITCH32
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_SH_USES
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_SH_COUNT
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_SH_ALIGN
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Cannot represent relocation type %s"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|r_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

end_unit

