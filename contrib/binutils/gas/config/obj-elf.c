begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF object file format    Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2,    or (at your option) any later version.     GAS is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See    the GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|OBJ_HEADER
value|"obj-elf.h"
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ECOFF_DEBUGGING
end_ifndef

begin_define
define|#
directive|define
name|ECOFF_DEBUGGING
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NEED_ECOFF_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"ecoff.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TC_ALPHA
end_ifdef

begin_include
include|#
directive|include
file|"elf/alpha.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TC_MIPS
end_ifdef

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TC_PPC
end_ifdef

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TC_I370
end_ifdef

begin_include
include|#
directive|include
file|"elf/i370.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bfd_vma
name|elf_s_get_size
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_s_set_size
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|elf_s_get_align
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_s_set_align
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_s_set_other
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_sec_sym_ok_for_reloc
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_stab_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_group_lists
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_separate_stab_sections
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_init_stab_section
name|PARAMS
argument_list|(
operator|(
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|boolean
name|elf_get_extr
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_set_index
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|obj_elf_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|obj_elf_version
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_size
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_ident
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_weak
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_local
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_visibility
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_change_section
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|obj_elf_parse_section_letters
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|obj_elf_section_word
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|obj_elf_section_name
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|obj_elf_section_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_symver
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_subsection
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_elf_popsection
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|elf_pseudo_table
index|[]
init|=
block|{
block|{
literal|"comm"
block|,
name|obj_elf_common
block|,
literal|0
block|}
block|,
block|{
literal|"common"
block|,
name|obj_elf_common
block|,
literal|1
block|}
block|,
block|{
literal|"ident"
block|,
name|obj_elf_ident
block|,
literal|0
block|}
block|,
block|{
literal|"local"
block|,
name|obj_elf_local
block|,
literal|0
block|}
block|,
block|{
literal|"previous"
block|,
name|obj_elf_previous
block|,
literal|0
block|}
block|,
block|{
literal|"section"
block|,
name|obj_elf_section
block|,
literal|0
block|}
block|,
block|{
literal|"section.s"
block|,
name|obj_elf_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|obj_elf_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect.s"
block|,
name|obj_elf_section
block|,
literal|0
block|}
block|,
block|{
literal|"pushsection"
block|,
name|obj_elf_section
block|,
literal|1
block|}
block|,
block|{
literal|"popsection"
block|,
name|obj_elf_popsection
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
name|obj_elf_size
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
name|obj_elf_type
block|,
literal|0
block|}
block|,
block|{
literal|"version"
block|,
name|obj_elf_version
block|,
literal|0
block|}
block|,
block|{
literal|"weak"
block|,
name|obj_elf_weak
block|,
literal|0
block|}
block|,
comment|/* These define symbol visibility.  */
block|{
literal|"internal"
block|,
name|obj_elf_visibility
block|,
name|STV_INTERNAL
block|}
block|,
block|{
literal|"hidden"
block|,
name|obj_elf_visibility
block|,
name|STV_HIDDEN
block|}
block|,
block|{
literal|"protected"
block|,
name|obj_elf_visibility
block|,
name|STV_PROTECTED
block|}
block|,
comment|/* These are used for stabs-in-elf configurations.  */
block|{
literal|"line"
block|,
name|obj_elf_line
block|,
literal|0
block|}
block|,
comment|/* This is a GNU extension to handle symbol versions.  */
block|{
literal|"symver"
block|,
name|obj_elf_symver
block|,
literal|0
block|}
block|,
comment|/* A GNU extension to change subsection only.  */
block|{
literal|"subsection"
block|,
name|obj_elf_subsection
block|,
literal|0
block|}
block|,
comment|/* These are GNU extensions to aid in garbage collecting C++ vtables.  */
block|{
literal|"vtable_inherit"
block|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
operator|&
name|obj_elf_vtable_inherit
block|,
literal|0
block|}
block|,
block|{
literal|"vtable_entry"
block|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
operator|&
name|obj_elf_vtable_entry
block|,
literal|0
block|}
block|,
comment|/* These are used for dwarf.  */
block|{
literal|"2byte"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"4byte"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"8byte"
block|,
name|cons
block|,
literal|8
block|}
block|,
comment|/* We need to trap the section changing calls to handle .previous.  */
block|{
literal|"data"
block|,
name|obj_elf_data
block|,
literal|0
block|}
block|,
block|{
literal|"text"
block|,
name|obj_elf_text
block|,
literal|0
block|}
block|,
comment|/* End sentinel.  */
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|ecoff_debug_pseudo_table
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
comment|/* COFF style debugging information for ECOFF. .ln is not used; .loc      is used instead.  */
block|{
literal|"def"
block|,
name|ecoff_directive_def
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|ecoff_directive_dim
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|ecoff_directive_endef
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|ecoff_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"scl"
block|,
name|ecoff_directive_scl
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|ecoff_directive_tag
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|ecoff_directive_val
block|,
literal|0
block|}
block|,
comment|/* COFF debugging requires pseudo-ops .size and .type, but ELF      already has meanings for those.  We use .esize and .etype      instead.  These are only generated by gcc anyhow.  */
block|{
literal|"esize"
block|,
name|ecoff_directive_size
block|,
literal|0
block|}
block|,
block|{
literal|"etype"
block|,
name|ecoff_directive_type
block|,
literal|0
block|}
block|,
comment|/* ECOFF specific debugging information.  */
block|{
literal|"begin"
block|,
name|ecoff_directive_begin
block|,
literal|0
block|}
block|,
block|{
literal|"bend"
block|,
name|ecoff_directive_bend
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|ecoff_directive_end
block|,
literal|0
block|}
block|,
block|{
literal|"ent"
block|,
name|ecoff_directive_ent
block|,
literal|0
block|}
block|,
block|{
literal|"fmask"
block|,
name|ecoff_directive_fmask
block|,
literal|0
block|}
block|,
block|{
literal|"frame"
block|,
name|ecoff_directive_frame
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|ecoff_directive_loc
block|,
literal|0
block|}
block|,
block|{
literal|"mask"
block|,
name|ecoff_directive_mask
block|,
literal|0
block|}
block|,
comment|/* Other ECOFF directives.  */
block|{
literal|"extern"
block|,
name|ecoff_directive_extern
block|,
literal|0
block|}
block|,
comment|/* These are used on Irix.  I don't know how to implement them.  */
block|{
literal|"alias"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"bgnb"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"endb"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"lab"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"noalias"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"verstamp"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"vreg"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
comment|/* end sentinel */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|NO_RELOC
end_undef

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_comment
comment|/* This is called when the assembler starts.  */
end_comment

begin_function
name|void
name|elf_begin
parameter_list|()
block|{
comment|/* Add symbols for the known sections to the symbol table.  */
name|symbol_table_insert
argument_list|(
name|section_symbol
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|TEXT_SECTION_NAME
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|section_symbol
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|DATA_SECTION_NAME
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|section_symbol
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|BSS_SECTION_NAME
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_pop_insert
parameter_list|()
block|{
name|pop_insert
argument_list|(
name|elf_pseudo_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
name|pop_insert
argument_list|(
name|ecoff_debug_pseudo_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|elf_s_get_size
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|S_GET_SIZE
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_s_set_size
parameter_list|(
name|sym
parameter_list|,
name|sz
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|sz
decl_stmt|;
block|{
name|S_SET_SIZE
argument_list|(
name|sym
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|elf_s_get_align
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|S_GET_ALIGN
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_s_set_align
parameter_list|(
name|sym
parameter_list|,
name|align
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|align
decl_stmt|;
block|{
name|S_SET_ALIGN
argument_list|(
name|sym
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|elf_s_get_other
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|elf_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_other
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_s_set_other
parameter_list|(
name|sym
parameter_list|,
name|other
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|other
decl_stmt|;
block|{
name|S_SET_OTHER
argument_list|(
name|sym
argument_list|,
name|other
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_sec_sym_ok_for_reloc
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
return|return
name|obj_sec_sym_ok_for_reloc
argument_list|(
name|sec
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|elf_file_symbol
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbol_new
argument_list|(
name|s
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|frag
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FILE
expr_stmt|;
if|if
condition|(
name|symbol_rootP
operator|!=
name|sym
condition|)
block|{
name|symbol_remove
argument_list|(
name|sym
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|sym
argument_list|,
name|symbol_rootP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|verify_symbol_chain
argument_list|(
name|symbol_rootP
argument_list|,
name|symbol_lastP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
name|ecoff_new_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|obj_elf_common
parameter_list|(
name|is_common
parameter_list|)
name|int
name|is_common
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|temp
decl_stmt|,
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|have_align
decl_stmt|;
if|if
condition|(
name|flag_mri
operator|&&
name|is_common
condition|)
block|{
name|s_mri_common
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after symbol-name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".COMMon length (%d.)<0! Ignored."
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|temp
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
operator|(
name|valueT
operator|)
name|size
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"length of .comm \"%s\" is already %ld; not changed to %d"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|have_align
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|have_align
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_align
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|!
name|have_align
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"common alignment negative; 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbol_get_obj
argument_list|(
name|symbolP
argument_list|)
operator|->
name|local
condition|)
block|{
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|char
modifier|*
name|pfrag
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* allocate_bss: */
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* convert to a power of 2 alignment */
for|for
control|(
name|align
operator|=
literal|0
init|;
operator|(
name|temp
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|temp
operator|>>=
literal|1
operator|,
operator|++
name|align
control|)
empty_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"common alignment not a power of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
name|align
operator|=
literal|0
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
condition|)
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
operator|(
name|offsetT
operator|)
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_common
label|:
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|size
argument_list|)
expr_stmt|;
name|S_SET_ALIGN
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bfd_com_section_ptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* @@ Some use the dot, some don't.  Can we get some consistency??  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'.'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* @@ Some say data, some say bss.  */
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"bss\""
argument_list|,
literal|4
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"data\""
argument_list|,
literal|5
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
operator|--
name|input_line_pointer
operator|!=
literal|'"'
condition|)
empty_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
goto|goto
name|bad_common_segment
goto|;
block|}
while|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|'"'
condition|)
empty_stmt|;
goto|goto
name|allocate_common
goto|;
block|}
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|{
name|bad_common_segment
label|:
name|p
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad .common segment %s"
argument_list|)
argument_list|,
name|input_line_pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|obj_elf_local
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|symbolP
argument_list|)
operator|->
name|local
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_elf_weak
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_SET_WEAK
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|symbolP
argument_list|)
operator|->
name|local
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_elf_visibility
parameter_list|(
name|visibility
parameter_list|)
name|int
name|visibility
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|asymbol
modifier|*
name|bfdsym
decl_stmt|;
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|bfdsym
operator|=
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|elfsym
operator|=
name|elf_symbol_from
argument_list|(
name|bfd_asymbol_bfd
argument_list|(
name|bfdsym
argument_list|)
argument_list|,
name|bfdsym
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|elfsym
argument_list|)
expr_stmt|;
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_other
operator|=
name|visibility
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|segT
name|previous_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|previous_subsection
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|section_stack
block|{
name|struct
name|section_stack
modifier|*
name|next
decl_stmt|;
name|segT
name|seg
decl_stmt|,
name|prev_seg
decl_stmt|;
name|int
name|subseg
decl_stmt|,
name|prev_subseg
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|section_stack
modifier|*
name|section_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the .section pseudo-op.  This code supports two different    syntaxes.     The first is found on Solaris, and looks like        .section ".sec1",#alloc,#execinstr,#write    Here the names after '#' are the SHF_* flags to turn on for the    section.  I'm not sure how it determines the SHT_* type (BFD    doesn't really give us control over the type, anyhow).     The second format is found on UnixWare, and probably most SVR4    machines, and looks like        .section .sec1,"a",@progbits    The quoted string may contain any combination of a, w, x, and    represents the SHF_* flags to turn on for the section.  The string    beginning with '@' can be progbits or nobits.  There should be    other possibilities, but I don't know what they are.  In any case,    BFD doesn't really let us set the section type.  */
end_comment

begin_comment
comment|/* Certain named sections have particular defined types, listed on p.    4-19 of the ABI.  */
end_comment

begin_struct
struct|struct
name|special_section
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|attributes
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|special_section
specifier|const
name|special_sections
index|[]
init|=
block|{
block|{
literal|".bss"
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".comment"
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".data"
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".data1"
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".debug"
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".fini"
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".init"
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".line"
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".note"
block|,
name|SHT_NOTE
block|,
literal|0
block|}
block|,
block|{
literal|".rodata"
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".rodata1"
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".text"
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
ifdef|#
directive|ifdef
name|ELF_TC_SPECIAL_SECTIONS
name|ELF_TC_SPECIAL_SECTIONS
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* The following section names are special, but they can not      reasonably appear in assembler code.  Some of the attributes are      processor dependent.  */
expr|{ ".dynamic",	SHT_DYNAMIC,	SHF_ALLOC
comment|/* + SHF_WRITE */
expr|},   { ".dynstr",	SHT_STRTAB,	SHF_ALLOC			},   { ".dynsym",	SHT_DYNSYM,	SHF_ALLOC			},   { ".got",	SHT_PROGBITS,	0				},   { ".hash",	SHT_HASH,	SHF_ALLOC			},   { ".interp",	SHT_PROGBITS,
comment|/* SHF_ALLOC */
expr|},   { ".plt",	SHT_PROGBITS,	0				},   { ".shstrtab",SHT_STRTAB,	0				},   { ".strtab",	SHT_STRTAB,
comment|/* SHF_ALLOC */
expr|},   { ".symtab",	SHT_SYMTAB,
comment|/* SHF_ALLOC */
expr|},
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|obj_elf_change_section
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|attr
parameter_list|,
name|entsize
parameter_list|,
name|group_name
parameter_list|,
name|push
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|attr
decl_stmt|;
name|int
name|entsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|group_name
decl_stmt|;
name|int
name|push
decl_stmt|;
block|{
name|asection
modifier|*
name|old_sec
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Switch to the section, creating it if necessary.  */
if|if
condition|(
name|push
condition|)
block|{
name|struct
name|section_stack
modifier|*
name|elt
decl_stmt|;
name|elt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_stack
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|->
name|next
operator|=
name|section_stack
expr_stmt|;
name|elt
operator|->
name|seg
operator|=
name|now_seg
expr_stmt|;
name|elt
operator|->
name|prev_seg
operator|=
name|previous_section
expr_stmt|;
name|elt
operator|->
name|subseg
operator|=
name|now_subseg
expr_stmt|;
name|elt
operator|->
name|prev_subseg
operator|=
name|previous_subsection
expr_stmt|;
name|section_stack
operator|=
name|elt
expr_stmt|;
block|}
name|previous_section
operator|=
name|now_seg
expr_stmt|;
name|previous_subsection
operator|=
name|now_subseg
expr_stmt|;
name|old_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sec
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* See if this is one of the special sections.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|special_sections
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|special_sections
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|SHT_NULL
condition|)
name|type
operator|=
name|special_sections
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|special_sections
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|old_sec
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"setting incorrect section type for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring incorrect section type for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|special_sections
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|attr
operator|&
operator|~
name|special_sections
index|[
name|i
index|]
operator|.
name|attributes
operator|)
operator|!=
literal|0
operator|&&
name|old_sec
operator|==
name|NULL
condition|)
block|{
comment|/* As a GNU extension, we permit a .note section to be 	       allocatable.  If the linker sees an allocateable .note 	       section, it will create a PT_NOTE segment in the output 	       file.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".note"
argument_list|)
operator|!=
literal|0
operator|||
name|attr
operator|!=
name|SHF_ALLOC
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"setting incorrect section attributes for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|attr
operator||=
name|special_sections
index|[
name|i
index|]
operator|.
name|attributes
expr_stmt|;
break|break;
block|}
comment|/* Convert ELF type and flags to BFD flags.  */
name|flags
operator|=
operator|(
name|SEC_RELOC
operator||
operator|(
operator|(
name|attr
operator|&
name|SHF_WRITE
operator|)
condition|?
literal|0
else|:
name|SEC_READONLY
operator|)
operator||
operator|(
operator|(
name|attr
operator|&
name|SHF_ALLOC
operator|)
condition|?
name|SEC_ALLOC
else|:
literal|0
operator|)
operator||
operator|(
operator|(
operator|(
name|attr
operator|&
name|SHF_ALLOC
operator|)
operator|&&
name|type
operator|!=
name|SHT_NOBITS
operator|)
condition|?
name|SEC_LOAD
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|attr
operator|&
name|SHF_EXECINSTR
operator|)
condition|?
name|SEC_CODE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|attr
operator|&
name|SHF_MERGE
operator|)
condition|?
name|SEC_MERGE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|attr
operator|&
name|SHF_STRINGS
operator|)
condition|?
name|SEC_STRINGS
else|:
literal|0
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_elf_section_flags
name|flags
operator|=
name|md_elf_section_flags
argument_list|(
name|flags
argument_list|,
name|attr
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|old_sec
operator|==
name|NULL
condition|)
block|{
name|symbolS
modifier|*
name|secsym
decl_stmt|;
comment|/* Prevent SEC_HAS_CONTENTS from being inadvertently set.  */
if|if
condition|(
name|type
operator|==
name|SHT_NOBITS
condition|)
name|seg_info
argument_list|(
name|sec
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_MERGE
condition|)
name|sec
operator|->
name|entsize
operator|=
name|entsize
expr_stmt|;
name|elf_group_name
argument_list|(
name|sec
argument_list|)
operator|=
name|group_name
expr_stmt|;
comment|/* Add a symbol for this section to the symbol table.  */
name|secsym
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|secsym
operator|!=
name|NULL
condition|)
name|symbol_set_bfdsym
argument_list|(
name|secsym
argument_list|,
name|sec
operator|->
name|symbol
argument_list|)
expr_stmt|;
else|else
name|symbol_table_insert
argument_list|(
name|section_symbol
argument_list|(
name|sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|!=
literal|0
condition|)
block|{
comment|/* If section attributes are specified the second time we see a 	 particular section, then check that they are the same as we 	 saw the first time.  */
if|if
condition|(
operator|(
name|old_sec
operator|->
name|flags
operator|^
name|flags
operator|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_EXCLUDE
operator||
name|SEC_SORT_ENTRIES
operator||
name|SEC_MERGE
operator||
name|SEC_STRINGS
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring changed section attributes for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|old_sec
operator|->
name|entsize
operator|!=
operator|(
name|unsigned
operator|)
name|entsize
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring changed section entity size for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|attr
operator|&
name|SHF_GROUP
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|elf_group_name
argument_list|(
name|old_sec
argument_list|)
argument_list|,
name|group_name
argument_list|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring new section group for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|md_elf_section_change_hook
name|md_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|obj_elf_parse_section_letters
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|int
name|attr
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'a'
case|:
name|attr
operator||=
name|SHF_ALLOC
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|attr
operator||=
name|SHF_WRITE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|attr
operator||=
name|SHF_EXECINSTR
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|attr
operator||=
name|SHF_MERGE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|attr
operator||=
name|SHF_STRINGS
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|attr
operator||=
name|SHF_GROUP
expr_stmt|;
break|break;
comment|/* Compatibility.  */
case|case
literal|'m'
case|:
if|if
condition|(
operator|*
operator|(
name|str
operator|-
literal|1
operator|)
operator|==
literal|'a'
condition|)
block|{
name|attr
operator||=
name|SHF_MERGE
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|str
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
name|attr
operator||=
name|SHF_STRINGS
expr_stmt|;
name|str
operator|++
operator|,
name|len
operator|--
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|char
modifier|*
name|bad_msg
init|=
name|_
argument_list|(
literal|"unrecognized .section attribute: want a,w,x,M,S,G"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|md_elf_section_letter
name|int
name|md_attr
init|=
name|md_elf_section_letter
argument_list|(
operator|*
name|str
argument_list|,
operator|&
name|bad_msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|md_attr
operator|>=
literal|0
condition|)
name|attr
operator||=
name|md_attr
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|as_warn
argument_list|(
literal|"%s"
argument_list|,
name|bad_msg
argument_list|)
expr_stmt|;
name|attr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
block|}
name|str
operator|++
operator|,
name|len
operator|--
expr_stmt|;
block|}
return|return
name|attr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_elf_section_word
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|5
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"write"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SHF_WRITE
return|;
if|if
condition|(
name|len
operator|==
literal|5
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"alloc"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SHF_ALLOC
return|;
if|if
condition|(
name|len
operator|==
literal|9
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"execinstr"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SHF_EXECINSTR
return|;
ifdef|#
directive|ifdef
name|md_elf_section_word
block|{
name|int
name|md_attr
init|=
name|md_elf_section_word
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|md_attr
operator|>=
literal|0
condition|)
return|return
name|md_attr
return|;
block|}
endif|#
directive|endif
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unrecognized section attribute"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_elf_section_type
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|8
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"progbits"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SHT_PROGBITS
return|;
if|if
condition|(
name|len
operator|==
literal|6
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"nobits"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SHT_NOBITS
return|;
ifdef|#
directive|ifdef
name|md_elf_section_type
block|{
name|int
name|md_type
init|=
name|md_elf_section_type
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|md_type
operator|>=
literal|0
condition|)
return|return
name|md_type
return|;
block|}
endif|#
directive|endif
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unrecognized section type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get name of section.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|obj_elf_section_name
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|int
name|dummy
decl_stmt|;
name|name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|end
init|=
name|input_line_pointer
decl_stmt|;
while|while
condition|(
literal|0
operator|==
name|strchr
argument_list|(
literal|"\n\t,; "
argument_list|,
operator|*
name|end
argument_list|)
condition|)
name|end
operator|++
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|input_line_pointer
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|name
operator|=
name|xmalloc
argument_list|(
name|end
operator|-
name|input_line_pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|input_line_pointer
argument_list|,
name|end
operator|-
name|input_line_pointer
argument_list|)
expr_stmt|;
name|name
index|[
name|end
operator|-
name|input_line_pointer
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_line_pointer
operator|=
name|end
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_function
name|void
name|obj_elf_section
parameter_list|(
name|push
parameter_list|)
name|int
name|push
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|group_name
decl_stmt|,
modifier|*
name|beg
decl_stmt|;
name|int
name|type
decl_stmt|,
name|attr
decl_stmt|,
name|dummy
decl_stmt|;
name|int
name|entsize
decl_stmt|;
ifndef|#
directive|ifndef
name|TC_I370
if|if
condition|(
name|flag_mri
condition|)
block|{
name|char
name|mri_type
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|previous_section
operator|=
name|now_seg
expr_stmt|;
name|previous_subsection
operator|=
name|now_subseg
expr_stmt|;
name|s_mri_sect
argument_list|(
operator|&
name|mri_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_elf_section_change_hook
name|md_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
endif|#
directive|endif
comment|/* ! defined (TC_I370) */
name|name
operator|=
name|obj_elf_section_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return;
name|type
operator|=
name|SHT_NULL
expr_stmt|;
name|attr
operator|=
literal|0
expr_stmt|;
name|group_name
operator|=
name|NULL
expr_stmt|;
name|entsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
comment|/* Skip the comma.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|beg
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|beg
operator|==
name|NULL
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|attr
operator||=
name|obj_elf_parse_section_letters
argument_list|(
name|beg
argument_list|,
name|strlen
argument_list|(
name|beg
argument_list|)
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|beg
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|beg
operator|==
name|NULL
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|type
operator|=
name|obj_elf_section_type
argument_list|(
name|beg
argument_list|,
name|strlen
argument_list|(
name|beg
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'@'
operator|||
name|c
operator|==
literal|'%'
condition|)
block|{
name|beg
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|type
operator|=
name|obj_elf_section_type
argument_list|(
name|beg
argument_list|,
name|input_line_pointer
operator|-
name|beg
argument_list|)
expr_stmt|;
block|}
else|else
name|input_line_pointer
operator|=
name|save
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|attr
operator|&
name|SHF_MERGE
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|entsize
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|entsize
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"invalid merge entity size"
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|&=
operator|~
name|SHF_MERGE
expr_stmt|;
name|entsize
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|attr
operator|&
name|SHF_MERGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"entity size for SHF_MERGE not specified"
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|&=
operator|~
name|SHF_MERGE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|attr
operator|&
name|SHF_GROUP
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|group_name
operator|=
name|obj_elf_section_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|group_name
operator|==
name|NULL
condition|)
name|attr
operator|&=
operator|~
name|SHF_GROUP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|attr
operator|&
name|SHF_GROUP
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"group name for SHF_GROUP not specified"
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|&=
operator|~
name|SHF_GROUP
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
block|{
name|char
name|c
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'#'
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"character following name is not '#'"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|beg
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|attr
operator||=
name|obj_elf_section_word
argument_list|(
name|beg
argument_list|,
name|input_line_pointer
operator|-
name|beg
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
operator|--
name|input_line_pointer
expr_stmt|;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|obj_elf_change_section
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|attr
argument_list|,
name|entsize
argument_list|,
name|group_name
argument_list|,
name|push
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change to the .data section.  */
end_comment

begin_function
name|void
name|obj_elf_data
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|previous_section
operator|=
name|now_seg
expr_stmt|;
name|previous_subsection
operator|=
name|now_subseg
expr_stmt|;
name|s_data
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_elf_section_change_hook
name|md_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Change to the .text section.  */
end_comment

begin_function
name|void
name|obj_elf_text
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|previous_section
operator|=
name|now_seg
expr_stmt|;
name|previous_subsection
operator|=
name|now_subseg
expr_stmt|;
name|s_text
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_elf_section_change_hook
name|md_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|obj_elf_subsection
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|previous_section
operator|=
name|now_seg
expr_stmt|;
name|previous_subsection
operator|=
name|now_subseg
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|now_seg
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_elf_section_change_hook
name|md_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This can be called from the processor backends if they change    sections.  */
end_comment

begin_function
name|void
name|obj_elf_section_change_hook
parameter_list|()
block|{
name|previous_section
operator|=
name|now_seg
expr_stmt|;
name|previous_subsection
operator|=
name|now_subseg
expr_stmt|;
block|}
end_function

begin_function
name|void
name|obj_elf_previous
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|segT
name|new_section
decl_stmt|;
name|int
name|new_subsection
decl_stmt|;
if|if
condition|(
name|previous_section
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".previous without corresponding .section; ignored"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|new_section
operator|=
name|previous_section
expr_stmt|;
name|new_subsection
operator|=
name|previous_subsection
expr_stmt|;
name|previous_section
operator|=
name|now_seg
expr_stmt|;
name|previous_subsection
operator|=
name|now_subseg
expr_stmt|;
name|subseg_set
argument_list|(
name|new_section
argument_list|,
name|new_subsection
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_elf_section_change_hook
name|md_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|obj_elf_popsection
parameter_list|(
name|xxx
parameter_list|)
name|int
name|xxx
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|section_stack
modifier|*
name|top
init|=
name|section_stack
decl_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".popsection without corresponding .pushsection; ignored"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|section_stack
operator|=
name|top
operator|->
name|next
expr_stmt|;
name|previous_section
operator|=
name|top
operator|->
name|prev_seg
expr_stmt|;
name|previous_subsection
operator|=
name|top
operator|->
name|prev_subseg
expr_stmt|;
name|subseg_set
argument_list|(
name|top
operator|->
name|seg
argument_list|,
name|top
operator|->
name|subseg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|top
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_elf_section_change_hook
name|md_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|obj_elf_line
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Assume delimiter is part of expression.  BSD4.2 as fails with      delightful bug, so we are not being incompatible here.  */
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
call|(
name|int
call|)
argument_list|(
name|get_absolute_expression
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This handles the .symver pseudo-op, which is used to specify a    symbol version.  The syntax is ``.symver NAME,SYMVERNAME''.    SYMVERNAME may contain ELF_VER_CHR ('@') characters.  This    pseudo-op causes the assembler to emit a symbol named SYMVERNAME    with the same value as the symbol NAME.  */
end_comment

begin_function
specifier|static
name|void
name|obj_elf_symver
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|old_lexat
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after name in .symver"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Temporarily include '@' in symbol names.  */
name|old_lexat
operator|=
name|lex_type
index|[
operator|(
name|unsigned
name|char
operator|)
literal|'@'
index|]
expr_stmt|;
name|lex_type
index|[
operator|(
name|unsigned
name|char
operator|)
literal|'@'
index|]
operator||=
name|LEX_NAME
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|lex_type
index|[
operator|(
name|unsigned
name|char
operator|)
literal|'@'
index|]
operator|=
name|old_lexat
expr_stmt|;
if|if
condition|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|versioned_name
operator|==
name|NULL
condition|)
block|{
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|versioned_name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|versioned_name
argument_list|,
name|ELF_VER_CHR
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing version name in `%s' for symbol `%s'"
argument_list|)
argument_list|,
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|versioned_name
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|versioned_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple versions [`%s'|`%s'] for symbol `%s'"
argument_list|)
argument_list|,
name|name
argument_list|,
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|versioned_name
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This handles the .vtable_inherit pseudo-op, which is used to indicate    to the linker the hierarchy in which a particular table resides.  The    syntax is ".vtable_inherit CHILDNAME, PARENTNAME".  */
end_comment

begin_function
name|struct
name|fix
modifier|*
name|obj_elf_vtable_inherit
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|cname
decl_stmt|,
modifier|*
name|pname
decl_stmt|;
name|symbolS
modifier|*
name|csym
decl_stmt|,
modifier|*
name|psym
decl_stmt|;
name|char
name|c
decl_stmt|,
name|bad
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|cname
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|csym
operator|=
name|symbol_find
argument_list|(
name|cname
argument_list|)
expr_stmt|;
comment|/* GCFIXME: should check that we don't have two .vtable_inherits for      the same child symbol.  Also, we can currently only do this if the      child symbol is already exists and is placed in a fragment.  */
if|if
condition|(
name|csym
operator|==
name|NULL
operator|||
name|symbol_get_frag
argument_list|(
name|csym
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected `%s' to have already been set for .vtable_inherit"
argument_list|,
name|cname
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after name in .vtable_inherit"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|ISSPACE
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|psym
operator|=
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|pname
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|psym
operator|=
name|symbol_find_or_make
argument_list|(
name|pname
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|bad
condition|)
return|return
name|NULL
return|;
name|assert
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|csym
argument_list|)
operator|->
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
return|return
name|fix_new
argument_list|(
name|symbol_get_frag
argument_list|(
name|csym
argument_list|)
argument_list|,
name|symbol_get_value_expression
argument_list|(
name|csym
argument_list|)
operator|->
name|X_add_number
argument_list|,
literal|0
argument_list|,
name|psym
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_VTABLE_INHERIT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This handles the .vtable_entry pseudo-op, which is used to indicate    to the linker that a vtable slot was used.  The syntax is    ".vtable_entry tablename, offset".  */
end_comment

begin_function
name|struct
name|fix
modifier|*
name|obj_elf_vtable_entry
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after name in .vtable_entry"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|0
argument_list|,
name|sym
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_VTABLE_ENTRY
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|elf_obj_read_begin_hook
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
name|ecoff_read_begin_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|elf_obj_symbol_new_hook
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|struct
name|elf_obj_sy
modifier|*
name|sy_obj
decl_stmt|;
name|sy_obj
operator|=
name|symbol_get_obj
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|sy_obj
operator|->
name|size
operator|=
name|NULL
expr_stmt|;
name|sy_obj
operator|->
name|versioned_name
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
name|ecoff_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* When setting one symbol equal to another, by default we probably    want them to have the same "size", whatever it means in the current    context.  */
end_comment

begin_function
name|void
name|elf_copy_symbol_attributes
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|symbolS
modifier|*
name|dest
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|elf_obj_sy
modifier|*
name|srcelf
init|=
name|symbol_get_obj
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|struct
name|elf_obj_sy
modifier|*
name|destelf
init|=
name|symbol_get_obj
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcelf
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|destelf
operator|->
name|size
operator|==
name|NULL
condition|)
name|destelf
operator|->
name|size
operator|=
operator|(
name|expressionS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|destelf
operator|->
name|size
operator|=
operator|*
name|srcelf
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|destelf
operator|->
name|size
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|destelf
operator|->
name|size
argument_list|)
expr_stmt|;
name|destelf
operator|->
name|size
operator|=
name|NULL
expr_stmt|;
block|}
name|S_SET_SIZE
argument_list|(
name|dest
argument_list|,
name|S_GET_SIZE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_OTHER
argument_list|(
name|dest
argument_list|,
name|S_GET_OTHER
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|obj_elf_version
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|subseg
init|=
name|now_subseg
decl_stmt|;
name|Elf_Internal_Note
name|i_note
decl_stmt|;
name|Elf_External_Note
name|e_note
decl_stmt|;
name|asection
modifier|*
name|note_secp
init|=
operator|(
name|asection
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* -> 1st char of string.  */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
empty_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
operator|*
operator|(
name|input_line_pointer
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* create the .note section */
name|note_secp
operator|=
name|subseg_new
argument_list|(
literal|".note"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|note_secp
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
comment|/* process the version string */
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|i_note
operator|.
name|namesz
operator|=
operator|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* round this to word boundary */
name|i_note
operator|.
name|descsz
operator|=
literal|0
expr_stmt|;
comment|/* no description */
name|i_note
operator|.
name|type
operator|=
name|NT_VERSION
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|namesz
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|namesz
argument_list|,
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|namesz
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|descsz
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|descsz
argument_list|,
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|descsz
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|e_note
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected quoted string"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_elf_size
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after name `%s' in .size directive"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing expression in .size directive"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|S_SET_SIZE
argument_list|(
name|sym
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
condition|)
block|{
name|xfree
argument_list|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|=
operator|(
name|expressionS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|=
name|exp
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the ELF .type pseudo-op.  This sets the type of a symbol.    There are five syntaxes:     The first (used on Solaris) is        .type SYM,#function    The second (used on UnixWare) is        .type SYM,@function    The third (reportedly to be used on Irix 6.0) is        .type SYM STT_FUNC    The fourth (used on NetBSD/Arm and Linux/ARM) is        .type SYM,%function    The fifth (used on SVR4/860) is        .type SYM,"function"    */
end_comment

begin_function
specifier|static
name|void
name|obj_elf_type
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|elfsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'@'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'"'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'%'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|typename
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|typename
argument_list|,
literal|"function"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|typename
argument_list|,
literal|"STT_FUNC"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|BSF_FUNCTION
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|typename
argument_list|,
literal|"object"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|typename
argument_list|,
literal|"STT_OBJECT"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|BSF_OBJECT
expr_stmt|;
ifdef|#
directive|ifdef
name|md_elf_symbol_type
elseif|else
if|if
condition|(
operator|(
name|type
operator|=
name|md_elf_symbol_type
argument_list|(
name|typename
argument_list|,
name|sym
argument_list|,
name|elfsym
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
endif|#
directive|endif
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unrecognized symbol type \"%s\""
argument_list|)
argument_list|,
name|typename
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|elfsym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|type
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_elf_ident
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|static
name|segT
name|comment_section
decl_stmt|;
name|segT
name|old_section
init|=
name|now_seg
decl_stmt|;
name|int
name|old_subsection
init|=
name|now_subseg
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|comment_section
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|comment_section
operator|=
name|subseg_new
argument_list|(
literal|".comment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|comment_section
argument_list|,
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|subseg_set
argument_list|(
name|comment_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stringer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|old_section
argument_list|,
name|old_subsection
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INIT_STAB_SECTION
end_ifdef

begin_comment
comment|/* The first entry in a .stabs section is special.  */
end_comment

begin_function
name|void
name|obj_elf_init_stab_section
parameter_list|(
name|seg
parameter_list|)
name|segT
name|seg
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|stabstr_name
decl_stmt|;
name|unsigned
name|int
name|stroff
decl_stmt|;
comment|/* Force the section to align to a longword boundary.  Without this,      UnixWare ar crashes.  */
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Make space for this first symbol.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|12
argument_list|)
expr_stmt|;
comment|/* Zero it out.  */
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|stabstr_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stabstr_name
argument_list|,
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stabstr_name
argument_list|,
literal|"str"
argument_list|)
expr_stmt|;
name|stroff
operator|=
name|get_stab_string_offset
argument_list|(
name|file
argument_list|,
name|stabstr_name
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|stroff
operator|==
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|stroff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|stabu
operator|.
name|p
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fill in the counts in the first entry in a .stabs section.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_stab_sections
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|xxx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|xxx
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|strsec
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|strsz
decl_stmt|,
name|nsyms
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|".stab"
argument_list|,
name|sec
operator|->
name|name
argument_list|,
literal|5
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"str"
argument_list|,
name|sec
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
operator|-
literal|3
argument_list|)
condition|)
return|return;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"str"
argument_list|)
expr_stmt|;
name|strsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strsec
condition|)
name|strsz
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|strsec
argument_list|)
expr_stmt|;
else|else
name|strsz
operator|=
literal|0
expr_stmt|;
name|nsyms
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|/
literal|12
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
operator|->
name|stabu
operator|.
name|p
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nsyms
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|strsz
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
end_ifdef

begin_comment
comment|/* This function is called by the ECOFF code.  It is supposed to    record the external symbol information so that the backend can    write it out correctly.  The ELF backend doesn't actually handle    this at the moment, so we do it ourselves.  We save the information    in the symbol.  */
end_comment

begin_function
name|void
name|elf_ecoff_set_ext
parameter_list|(
name|sym
parameter_list|,
name|ext
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|struct
name|ecoff_extr
modifier|*
name|ext
decl_stmt|;
block|{
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|udata
operator|.
name|p
operator|=
operator|(
name|PTR
operator|)
name|ext
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called by bfd_ecoff_debug_externals.  It is    supposed to *EXT to the external symbol information, and return    whether the symbol should be used at all.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_get_extr
parameter_list|(
name|sym
parameter_list|,
name|ext
parameter_list|)
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|EXTR
modifier|*
name|ext
decl_stmt|;
block|{
if|if
condition|(
name|sym
operator|->
name|udata
operator|.
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|*
name|ext
operator|=
operator|*
operator|(
name|EXTR
operator|*
operator|)
name|sym
operator|->
name|udata
operator|.
name|p
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function is called by bfd_ecoff_debug_externals.  It has    nothing to do for ELF.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|elf_set_index
parameter_list|(
name|sym
parameter_list|,
name|indx
parameter_list|)
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_size_type
name|indx
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEED_ECOFF_DEBUG */
end_comment

begin_function
name|void
name|elf_frob_symbol
parameter_list|(
name|symp
parameter_list|,
name|puntp
parameter_list|)
name|symbolS
modifier|*
name|symp
decl_stmt|;
name|int
modifier|*
name|puntp
decl_stmt|;
block|{
name|struct
name|elf_obj_sy
modifier|*
name|sy_obj
decl_stmt|;
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
name|ecoff_frob_symbol
argument_list|(
name|symp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sy_obj
operator|=
name|symbol_get_obj
argument_list|(
name|symp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sy_obj
operator|->
name|size
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|sy_obj
operator|->
name|size
operator|->
name|X_op
condition|)
block|{
case|case
name|O_subtract
case|:
name|S_SET_SIZE
argument_list|(
name|symp
argument_list|,
operator|(
name|S_GET_VALUE
argument_list|(
name|sy_obj
operator|->
name|size
operator|->
name|X_add_symbol
argument_list|)
operator|+
name|sy_obj
operator|->
name|size
operator|->
name|X_add_number
operator|-
name|S_GET_VALUE
argument_list|(
name|sy_obj
operator|->
name|size
operator|->
name|X_op_symbol
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
name|S_SET_SIZE
argument_list|(
name|symp
argument_list|,
operator|(
name|S_GET_VALUE
argument_list|(
name|sy_obj
operator|->
name|size
operator|->
name|X_add_symbol
argument_list|)
operator|+
name|sy_obj
operator|->
name|size
operator|->
name|X_add_number
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".size expression too complicated to fix up"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|sy_obj
operator|->
name|size
argument_list|)
expr_stmt|;
name|sy_obj
operator|->
name|size
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sy_obj
operator|->
name|versioned_name
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|sy_obj
operator|->
name|versioned_name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* This symbol was given a new name with the .symver directive.           If this is an external reference, just rename the symbol to          include the version string.  This will make the relocs be          against the correct versioned symbol.  	 If this is a definition, add an alias.  FIXME: Using an alias 	 will permit the debugging information to refer to the right 	 symbol.  However, it's not clear whether it is the best 	 approach.  */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
condition|)
block|{
comment|/* Verify that the name isn't using the @@ syntax--this is              reserved for definitions of the default version to link              against.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|ELF_VER_CHR
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid attempt to declare external version name as default in symbol `%s'"
argument_list|)
argument_list|,
name|sy_obj
operator|->
name|versioned_name
argument_list|)
expr_stmt|;
operator|*
name|puntp
operator|=
name|true
expr_stmt|;
block|}
name|S_SET_NAME
argument_list|(
name|symp
argument_list|,
name|sy_obj
operator|->
name|versioned_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|ELF_VER_CHR
operator|&&
name|p
index|[
literal|2
index|]
operator|==
name|ELF_VER_CHR
condition|)
block|{
name|size_t
name|l
decl_stmt|;
comment|/* The @@@ syntax is a special case. It renames the 		 symbol name to versioned_name with one `@' removed.  */
name|l
operator|=
name|strlen
argument_list|(
operator|&
name|p
index|[
literal|3
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
operator|&
name|p
index|[
literal|3
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symp
argument_list|,
name|sy_obj
operator|->
name|versioned_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symbolS
modifier|*
name|symp2
decl_stmt|;
comment|/* FIXME: Creating a new symbol here is risky.  We're 		 in the final loop over the symbol table.  We can 		 get away with it only because the symbol goes to 		 the end of the list, where the loop will still see 		 it.  It would probably be better to do this in 		 obj_frob_file_before_adjust.  */
name|symp2
operator|=
name|symbol_find_or_make
argument_list|(
name|sy_obj
operator|->
name|versioned_name
argument_list|)
expr_stmt|;
comment|/* Now we act as though we saw symp2 = sym.  */
name|S_SET_SEGMENT
argument_list|(
name|symp2
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Subtracting out the frag address here is a hack 		 because we are in the middle of the final loop.  */
name|S_SET_VALUE
argument_list|(
name|symp2
argument_list|,
operator|(
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
operator|-
name|symbol_get_frag
argument_list|(
name|symp
argument_list|)
operator|->
name|fr_address
operator|)
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symp2
argument_list|,
name|symbol_get_frag
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This will copy over the size information.  */
name|copy_symbol_attributes
argument_list|(
name|symp2
argument_list|,
name|symp
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|symp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
condition|)
name|S_SET_EXTERNAL
argument_list|(
name|symp2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Double check weak symbols.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|symp
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' can not be both weak and common"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TC_MIPS
comment|/* The Irix 5 and 6 assemblers set the type of any common symbol and      any undefined non-function symbol to STT_OBJECT.  We try to be      compatible, since newer Irix 5 and 6 linkers care.  However, we      only set undefined symbols to be STT_OBJECT if we are on Irix,      because that is the only time gcc will generate the necessary      .global directives to mark functions.  */
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|symp
argument_list|)
condition|)
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|TARGET_OS
argument_list|,
literal|"irix"
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|==
literal|0
condition|)
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* TC_PPC */
comment|/* If TC_PPC is defined, we used to force the type of a symbol to be      BSF_OBJECT if it was otherwise unset.  This was required by some      version of VxWorks.  Thomas de Lellis<tdel@windriver.com> says      that this is no longer needed, so it is now commented out.  */
block|if ((symbol_get_bfdsym (symp)->flags& (BSF_FUNCTION | BSF_FILE | BSF_SECTION_SYM)) == 0&& S_IS_DEFINED (symp))     symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;
endif|#
directive|endif
block|}
end_function

begin_struct
struct|struct
name|group_list
block|{
name|asection
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* Section lists.  */
name|unsigned
name|int
modifier|*
name|elt_count
decl_stmt|;
comment|/* Number of sections in each list.  */
name|unsigned
name|int
name|num_group
decl_stmt|;
comment|/* Number of lists.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Called via bfd_map_over_sections.  If SEC is a member of a group,    add it to a list of sections belonging to the group.  INF is a    pointer to a struct group_list, which is where we store the head of    each list.  */
end_comment

begin_function
specifier|static
name|void
name|build_group_lists
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|inf
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|group_list
modifier|*
name|list
init|=
operator|(
expr|struct
name|group_list
operator|*
operator|)
name|inf
decl_stmt|;
specifier|const
name|char
modifier|*
name|group_name
init|=
name|elf_group_name
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|group_name
operator|==
name|NULL
condition|)
return|return;
comment|/* If this group already has a list, add the section to the head of      the list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|num_group
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|group_name
argument_list|,
name|elf_group_name
argument_list|(
name|list
operator|->
name|head
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|elf_next_in_group
argument_list|(
name|sec
argument_list|)
operator|=
name|list
operator|->
name|head
index|[
name|i
index|]
expr_stmt|;
name|list
operator|->
name|head
index|[
name|i
index|]
operator|=
name|sec
expr_stmt|;
name|list
operator|->
name|elt_count
index|[
name|i
index|]
operator|+=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* New group.  Make the arrays bigger in chunks to minimize calls to      realloc.  */
name|i
operator|=
name|list
operator|->
name|num_group
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|127
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|newsize
init|=
name|i
operator|+
literal|128
decl_stmt|;
name|list
operator|->
name|head
operator|=
name|xrealloc
argument_list|(
name|list
operator|->
name|head
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|list
operator|->
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|elt_count
operator|=
name|xrealloc
argument_list|(
name|list
operator|->
name|elt_count
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|list
operator|->
name|elt_count
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list
operator|->
name|head
index|[
name|i
index|]
operator|=
name|sec
expr_stmt|;
name|list
operator|->
name|elt_count
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|list
operator|->
name|num_group
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_frob_file
parameter_list|()
block|{
name|struct
name|group_list
name|list
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|adjust_stab_sections
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Go find section groups.  */
name|list
operator|.
name|num_group
operator|=
literal|0
expr_stmt|;
name|list
operator|.
name|head
operator|=
name|NULL
expr_stmt|;
name|list
operator|.
name|elt_count
operator|=
name|NULL
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|build_group_lists
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|list
argument_list|)
expr_stmt|;
comment|/* Make the SHT_GROUP sections that describe each section group.  We      can't set up the section contents here yet, because elf section      indices have yet to be calculated.  elf.c:set_group_contents does      the rest of the work.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|num_group
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|group_name
init|=
name|elf_group_name
argument_list|(
name|list
operator|.
name|head
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|s
operator|=
name|subseg_force_new
argument_list|(
name|group_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_GROUP
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"can't create group: %s"
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Pass a pointer to the first section in this group.  */
name|elf_next_in_group
argument_list|(
name|s
argument_list|)
operator|=
name|list
operator|.
name|head
index|[
name|i
index|]
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
literal|4
operator|*
operator|(
name|list
operator|.
name|elt_count
index|[
name|i
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|frag_more
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_fix
operator|=
name|frag_now_fix_octets
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|elf_tc_final_processing
name|elf_tc_final_processing
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* It removes any unneeded versioned symbols from the symbol table.  */
end_comment

begin_function
name|void
name|elf_frob_file_before_adjust
parameter_list|()
block|{
if|if
condition|(
name|symbol_rootP
condition|)
block|{
name|symbolS
modifier|*
name|symp
decl_stmt|;
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
condition|;
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol_get_obj
argument_list|(
name|symp
argument_list|)
operator|->
name|versioned_name
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* The @@@ syntax is a special case. If the symbol is 		   not defined, 2 `@'s will be removed from the 		   versioned_name.  */
name|p
operator|=
name|strchr
argument_list|(
name|symbol_get_obj
argument_list|(
name|symp
argument_list|)
operator|->
name|versioned_name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|ELF_VER_CHR
operator|&&
name|p
index|[
literal|2
index|]
operator|==
name|ELF_VER_CHR
condition|)
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
operator|&
name|p
index|[
literal|3
index|]
argument_list|)
operator|+
literal|1
decl_stmt|;
name|memmove
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|,
operator|&
name|p
index|[
literal|3
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbol_used_p
argument_list|(
name|symp
argument_list|)
operator|==
literal|0
operator|&&
name|symbol_used_in_reloc_p
argument_list|(
name|symp
argument_list|)
operator|==
literal|0
condition|)
name|symbol_remove
argument_list|(
name|symp
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
comment|/* If there was .weak foo, but foo was neither defined nor 	       used anywhere, remove it.  */
elseif|else
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
operator|&&
name|symbol_used_p
argument_list|(
name|symp
argument_list|)
operator|==
literal|0
operator|&&
name|symbol_used_in_reloc_p
argument_list|(
name|symp
argument_list|)
operator|==
literal|0
condition|)
name|symbol_remove
argument_list|(
name|symp
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* It is required that we let write_relocs have the opportunity to    optimize away fixups before output has begun, since it is possible    to eliminate all fixups for a section and thus we never should    have generated the relocation section.  */
end_comment

begin_function
name|void
name|elf_frob_file_after_relocs
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
comment|/* Generate the ECOFF debugging information.  */
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|debug_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
name|debug
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|debug_swap
operator|=
name|get_elf_backend_data
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|know
argument_list|(
name|debug_swap
operator|!=
operator|(
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ecoff_build_debug
argument_list|(
operator|&
name|debug
operator|.
name|symbolic_header
argument_list|,
operator|&
name|buf
argument_list|,
name|debug_swap
argument_list|)
expr_stmt|;
comment|/* Set up the pointers in debug.  */
define|#
directive|define
name|SET
parameter_list|(
name|ptr
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
define|\
value|debug.ptr = (type) (buf + debug.symbolic_header.offset)
name|SET
argument_list|(
argument|line
argument_list|,
argument|cbLineOffset
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|SET
argument_list|(
name|external_dnr
argument_list|,
name|cbDnOffset
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_pdr
argument_list|,
name|cbPdOffset
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_sym
argument_list|,
name|cbSymOffset
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_opt
argument_list|,
name|cbOptOffset
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_aux
argument_list|,
name|cbAuxOffset
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ss
argument_list|,
name|cbSsOffset
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_fdr
argument_list|,
name|cbFdOffset
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_rfd
argument_list|,
name|cbRfdOffset
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
comment|/* ssext and external_ext are set up just below.  */
undef|#
directive|undef
name|SET
comment|/* Set up the external symbols.  */
name|debug
operator|.
name|ssext
operator|=
name|debug
operator|.
name|ssext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_ext
operator|=
name|debug
operator|.
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_externals
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|debug
argument_list|,
name|debug_swap
argument_list|,
name|true
argument_list|,
name|elf_get_extr
argument_list|,
name|elf_set_index
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed to set up debugging information: %s"
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
literal|".mdebug"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|stdoutput
operator|->
name|output_has_begun
operator|==
name|false
argument_list|)
expr_stmt|;
comment|/* We set the size of the section, call bfd_set_section_contents 	 to force the ELF backend to allocate a file position, and then 	 write out the data.  FIXME: Is this really the best way to do 	 this?  */
name|sec
operator|->
name|_raw_size
operator|=
name|bfd_ecoff_debug_size
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|debug
argument_list|,
name|debug_swap
argument_list|)
expr_stmt|;
comment|/* Pass BUF to bfd_set_section_contents because this will          eventually become a call to fwrite, and ISO C prohibits          passing a NULL pointer to a stdio function even if the          pointer will not be used.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|0
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"can't start writing .mdebug section: %s"
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|stdoutput
operator|->
name|output_has_begun
operator|==
name|true
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|sec
operator|->
name|filepos
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_write_debug
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|debug
argument_list|,
name|debug_swap
argument_list|,
name|sec
operator|->
name|filepos
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"could not write .mdebug section: %s"
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NEED_ECOFF_DEBUG */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCO_ELF
end_ifdef

begin_comment
comment|/* Heavily plagarized from obj_elf_version.  The idea is to emit the    SCO specific identifier in the .notes section to satisfy the SCO    linker.     This looks more complicated than it really is.  As opposed to the    "obvious" solution, this should handle the cross dev cases    correctly.  (i.e, hosting on a 64 bit big endian processor, but    generating SCO Elf code) Efficiency isn't a concern, as there    should be exactly one of these sections per object module.     SCO OpenServer 5 identifies it's ELF modules with a standard ELF    .note section.     int_32 namesz  = 4 ;  Name size    int_32 descsz  = 12 ; Descriptive information    int_32 type    = 1 ;    char   name[4] = "SCO" ; Originator name ALWAYS SCO + NULL    int_32 version = (major ver #<< 16)  | version of tools ;    int_32 source  = (tool_id<< 16 ) | 1 ;    int_32 info    = 0 ;    These are set by the SCO tools, but we                            don't know enough about the source 			   environment to set them.  SCO ld currently 			   ignores them, and recommends we set them 			   to zero.  */
end_comment

begin_define
define|#
directive|define
name|SCO_MAJOR_VERSION
value|0x1
end_define

begin_define
define|#
directive|define
name|SCO_MINOR_VERSION
value|0x1
end_define

begin_function
name|void
name|sco_id
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|subseg
init|=
name|now_subseg
decl_stmt|;
name|Elf_Internal_Note
name|i_note
decl_stmt|;
name|Elf_External_Note
name|e_note
decl_stmt|;
name|asection
modifier|*
name|note_secp
init|=
operator|(
name|asection
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
comment|/* create the .note section */
name|note_secp
operator|=
name|subseg_new
argument_list|(
literal|".note"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|note_secp
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
comment|/* process the version string */
name|i_note
operator|.
name|namesz
operator|=
literal|4
expr_stmt|;
name|i_note
operator|.
name|descsz
operator|=
literal|12
expr_stmt|;
comment|/* 12 descriptive bytes */
name|i_note
operator|.
name|type
operator|=
name|NT_VERSION
expr_stmt|;
comment|/* Contains a version string */
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|i_note
operator|.
name|namesz
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|namesz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|i_note
operator|.
name|descsz
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|descsz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|i_note
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|i_note
operator|.
name|type
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"SCO"
argument_list|)
expr_stmt|;
comment|/* Note: this is the version number of the ELF we're representing */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|SCO_MAJOR_VERSION
operator|<<
literal|16
operator|)
operator||
operator|(
name|SCO_MINOR_VERSION
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Here, we pick a magic number for ourselves (yes, I "registered"      it with SCO.  The bottom bit shows that we are compat with the      SCO ABI.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
literal|0x4c520000
operator||
literal|0x0001
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If we knew (or cared) what the source language options were, we'd      fill them in here.  SCO has given us permission to ignore these      and just set them to zero.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
literal|0x0000
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We probably can't restore the current segment, for there likely      isn't one yet...  */
if|if
condition|(
name|seg
operator|&&
name|subseg
condition|)
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCO_ELF */
end_comment

begin_function
specifier|static
name|int
name|elf_separate_stab_sections
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
return|return
operator|(
operator|!
name|ECOFF_DEBUGGING
operator|)
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|elf_init_stab_section
parameter_list|(
name|seg
parameter_list|)
name|segT
name|seg
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
if|if
condition|(
operator|!
name|ECOFF_DEBUGGING
condition|)
endif|#
directive|endif
name|obj_elf_init_stab_section
argument_list|(
name|seg
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|format_ops
name|elf_format_ops
init|=
block|{
name|bfd_target_elf_flavour
block|,
literal|0
block|,
comment|/* dfl_leading_underscore */
literal|1
block|,
comment|/* emit_section_symbols */
name|elf_begin
block|,
name|elf_file_symbol
block|,
name|elf_frob_symbol
block|,
name|elf_frob_file
block|,
name|elf_frob_file_before_adjust
block|,
name|elf_frob_file_after_relocs
block|,
name|elf_s_get_size
block|,
name|elf_s_set_size
block|,
name|elf_s_get_align
block|,
name|elf_s_set_align
block|,
name|elf_s_get_other
block|,
name|elf_s_set_other
block|,
literal|0
block|,
comment|/* s_get_desc */
literal|0
block|,
comment|/* s_set_desc */
literal|0
block|,
comment|/* s_get_type */
literal|0
block|,
comment|/* s_set_type */
name|elf_copy_symbol_attributes
block|,
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
name|ecoff_generate_asm_lineno
block|,
name|ecoff_stab
block|,
else|#
directive|else
literal|0
block|,
comment|/* generate_asm_lineno */
literal|0
block|,
comment|/* process_stab */
endif|#
directive|endif
name|elf_separate_stab_sections
block|,
name|elf_init_stab_section
block|,
name|elf_sec_sym_ok_for_reloc
block|,
name|elf_pop_insert
block|,
ifdef|#
directive|ifdef
name|NEED_ECOFF_DEBUG
name|elf_ecoff_set_ext
block|,
else|#
directive|else
literal|0
block|,
comment|/* ecoff_set_ext */
endif|#
directive|endif
name|elf_obj_read_begin_hook
block|,
name|elf_obj_symbol_new_hook
block|}
decl_stmt|;
end_decl_stmt

end_unit

