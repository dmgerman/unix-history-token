begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-ia64.c -- Assembler for the HP/Intel IA-64 architecture.    Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by David Mosberger-Tang<davidm@hpl.hp.com>     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*   TODO:    - optional operands   - directives: 	.alias 	.eb 	.estate 	.lb 	.popsection 	.previous 	.psr 	.pushsection   - labels are wrong if automatic alignment is introduced     (e.g., checkout the second real10 definition in test-data.s)   - DV-related stuff:<reg>.safe_across_calls and any other DV-related directives I don't 	  have documentation for. 	verify mod-sched-brs reads/writes are checked/marked (and other 	notes)   */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/ia64.h"
end_include

begin_include
include|#
directive|include
file|"elf/ia64.h"
end_include

begin_define
define|#
directive|define
name|NELEMS
parameter_list|(
name|a
parameter_list|)
value|((int) (sizeof (a)/sizeof ((a)[0])))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|NUM_SLOTS
value|4
end_define

begin_define
define|#
directive|define
name|PREV_SLOT
value|md.slot[(md.curr_slot + NUM_SLOTS - 1) % NUM_SLOTS]
end_define

begin_define
define|#
directive|define
name|CURR_SLOT
value|md.slot[md.curr_slot]
end_define

begin_define
define|#
directive|define
name|O_pseudo_fixup
value|(O_max + 1)
end_define

begin_enum
enum|enum
name|special_section
block|{
comment|/* IA-64 ABI section pseudo-ops.  */
name|SPECIAL_SECTION_BSS
init|=
literal|0
block|,
name|SPECIAL_SECTION_SBSS
block|,
name|SPECIAL_SECTION_SDATA
block|,
name|SPECIAL_SECTION_RODATA
block|,
name|SPECIAL_SECTION_COMMENT
block|,
name|SPECIAL_SECTION_UNWIND
block|,
name|SPECIAL_SECTION_UNWIND_INFO
block|,
comment|/* HPUX specific section pseudo-ops.  */
name|SPECIAL_SECTION_INIT_ARRAY
block|,
name|SPECIAL_SECTION_FINI_ARRAY
block|,   }
enum|;
end_enum

begin_enum
enum|enum
name|reloc_func
block|{
name|FUNC_FPTR_RELATIVE
block|,
name|FUNC_GP_RELATIVE
block|,
name|FUNC_LT_RELATIVE
block|,
name|FUNC_PC_RELATIVE
block|,
name|FUNC_PLT_RELATIVE
block|,
name|FUNC_SEC_RELATIVE
block|,
name|FUNC_SEG_RELATIVE
block|,
name|FUNC_LTV_RELATIVE
block|,
name|FUNC_LT_FPTR_RELATIVE
block|,
name|FUNC_IPLT_RELOC
block|,   }
enum|;
end_enum

begin_enum
enum|enum
name|reg_symbol
block|{
name|REG_GR
init|=
literal|0
block|,
name|REG_FR
init|=
operator|(
name|REG_GR
operator|+
literal|128
operator|)
block|,
name|REG_AR
init|=
operator|(
name|REG_FR
operator|+
literal|128
operator|)
block|,
name|REG_CR
init|=
operator|(
name|REG_AR
operator|+
literal|128
operator|)
block|,
name|REG_P
init|=
operator|(
name|REG_CR
operator|+
literal|128
operator|)
block|,
name|REG_BR
init|=
operator|(
name|REG_P
operator|+
literal|64
operator|)
block|,
name|REG_IP
init|=
operator|(
name|REG_BR
operator|+
literal|8
operator|)
block|,
name|REG_CFM
block|,
name|REG_PR
block|,
name|REG_PR_ROT
block|,
name|REG_PSR
block|,
name|REG_PSR_L
block|,
name|REG_PSR_UM
block|,
comment|/* The following are pseudo-registers for use by gas only.  */
name|IND_CPUID
block|,
name|IND_DBR
block|,
name|IND_DTR
block|,
name|IND_ITR
block|,
name|IND_IBR
block|,
name|IND_MEM
block|,
name|IND_MSR
block|,
name|IND_PKR
block|,
name|IND_PMC
block|,
name|IND_PMD
block|,
name|IND_RR
block|,
comment|/* The following pseudo-registers are used for unwind directives only:  */
name|REG_PSP
block|,
name|REG_PRIUNAT
block|,
name|REG_NUM
block|}
enum|;
end_enum

begin_enum
enum|enum
name|dynreg_type
block|{
name|DYNREG_GR
init|=
literal|0
block|,
comment|/* dynamic general purpose register */
name|DYNREG_FR
block|,
comment|/* dynamic floating point register */
name|DYNREG_PR
block|,
comment|/* dynamic predicate register */
name|DYNREG_NUM_TYPES
block|}
enum|;
end_enum

begin_enum
enum|enum
name|operand_match_result
block|{
name|OPERAND_MATCH
block|,
name|OPERAND_OUT_OF_RANGE
block|,
name|OPERAND_MISMATCH
block|}
enum|;
end_enum

begin_comment
comment|/* On the ia64, we can't know the address of a text label until the    instructions are packed into a bundle.  To handle this, we keep    track of the list of labels that appear in front of each    instruction.  */
end_comment

begin_struct
struct|struct
name|label_fix
block|{
name|struct
name|label_fix
modifier|*
name|next
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a    single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0d1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ia64-specific option processing:  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:N:x::"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_MCONSTANT_GP
value|(OPTION_MD_BASE + 1)
block|{
literal|"mconstant-gp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MCONSTANT_GP
block|}
block|,
define|#
directive|define
name|OPTION_MAUTO_PIC
value|(OPTION_MD_BASE + 2)
block|{
literal|"mauto-pic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MAUTO_PIC
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|hash_control
modifier|*
name|pseudo_hash
decl_stmt|;
comment|/* pseudo opcode hash table */
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
comment|/* register name hash table */
name|struct
name|hash_control
modifier|*
name|dynreg_hash
decl_stmt|;
comment|/* dynamic register hash table */
name|struct
name|hash_control
modifier|*
name|const_hash
decl_stmt|;
comment|/* constant hash table */
name|struct
name|hash_control
modifier|*
name|entry_hash
decl_stmt|;
comment|/* code entry hint hash table */
name|symbolS
modifier|*
name|regsym
index|[
name|REG_NUM
index|]
decl_stmt|;
comment|/* If X_op is != O_absent, the registername for the instruction's        qualifying predicate.  If NULL, p0 is assumed for instructions        that are predicatable.  */
name|expressionS
name|qp
decl_stmt|;
name|unsigned
name|int
name|manual_bundling
range|:
literal|1
decl_stmt|,
name|debug_dv
range|:
literal|1
decl_stmt|,
name|detect_dv
range|:
literal|1
decl_stmt|,
name|explicit_mode
range|:
literal|1
decl_stmt|,
comment|/* which mode we're in */
name|default_explicit_mode
range|:
literal|1
decl_stmt|,
comment|/* which mode is the default */
name|mode_explicitly_set
range|:
literal|1
decl_stmt|,
comment|/* was the current mode explicitly set? */
name|auto_align
range|:
literal|1
decl_stmt|,
name|keep_pending_output
range|:
literal|1
decl_stmt|;
comment|/* Each bundle consists of up to three instructions.  We keep        track of four most recent instructions so we can correctly set        the end_of_insn_group for the last instruction in a bundle.  */
name|int
name|curr_slot
decl_stmt|;
name|int
name|num_slots_in_use
decl_stmt|;
struct|struct
name|slot
block|{
name|unsigned
name|int
name|end_of_insn_group
range|:
literal|1
decl_stmt|,
name|manual_bundling_on
range|:
literal|1
decl_stmt|,
name|manual_bundling_off
range|:
literal|1
decl_stmt|;
name|signed
name|char
name|user_template
decl_stmt|;
comment|/* user-selected template, if any */
name|unsigned
name|char
name|qp_regno
decl_stmt|;
comment|/* qualifying predicate */
comment|/* This duplicates a good fraction of "struct fix" but we 	   can't use a "struct fix" instead since we can't call 	   fix_new_exp() until we know the address of the instruction.  */
name|int
name|num_fixups
decl_stmt|;
struct|struct
name|insn_fix
block|{
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|enum
name|ia64_opnd
name|opnd
decl_stmt|;
comment|/* type of operand in need of fix */
name|unsigned
name|int
name|is_pcrel
range|:
literal|1
decl_stmt|;
comment|/* is operand pc-relative? */
name|expressionS
name|expr
decl_stmt|;
comment|/* the value to be inserted */
block|}
name|fixup
index|[
literal|2
index|]
struct|;
comment|/* at most two fixups per insn */
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|struct
name|label_fix
modifier|*
name|label_fixups
decl_stmt|;
name|struct
name|label_fix
modifier|*
name|tag_fixups
decl_stmt|;
name|struct
name|unw_rec_list
modifier|*
name|unwind_record
decl_stmt|;
comment|/* Unwind directive.  */
name|expressionS
name|opnd
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|src_file
decl_stmt|;
name|unsigned
name|int
name|src_line
decl_stmt|;
name|struct
name|dwarf2_line_info
name|debug_line
decl_stmt|;
block|}
name|slot
index|[
name|NUM_SLOTS
index|]
struct|;
name|segT
name|last_text_seg
decl_stmt|;
struct|struct
name|dynreg
block|{
name|struct
name|dynreg
modifier|*
name|next
decl_stmt|;
comment|/* next dynamic register */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|short
name|base
decl_stmt|;
comment|/* the base register number */
name|unsigned
name|short
name|num_regs
decl_stmt|;
comment|/* # of registers in this set */
block|}
modifier|*
name|dynreg
index|[
name|DYNREG_NUM_TYPES
index|]
struct|,
name|in
struct|,
name|loc
struct|,
name|out
struct|,
name|rot
struct|;
name|flagword
name|flags
decl_stmt|;
comment|/* ELF-header flags */
struct|struct
name|mem_offset
block|{
name|unsigned
name|hint
range|:
literal|1
decl_stmt|;
comment|/* is this hint currently valid? */
name|bfd_vma
name|offset
decl_stmt|;
comment|/* mem.offset offset */
name|bfd_vma
name|base
decl_stmt|;
comment|/* mem.offset base */
block|}
name|mem_offset
struct|;
name|int
name|path
decl_stmt|;
comment|/* number of alt. entry points seen */
specifier|const
name|char
modifier|*
modifier|*
name|entry_labels
decl_stmt|;
comment|/* labels of all alternate paths in 				       the current DV-checking block.  */
name|int
name|maxpaths
decl_stmt|;
comment|/* size currently allocated for 				       entry_labels */
comment|/* Support for hardware errata workarounds.  */
comment|/* Record data about the last three insn groups.  */
struct|struct
name|group
block|{
comment|/* B-step workaround. 	 For each predicate register, this is set if the corresponding insn 	 group conditionally sets this register with one of the affected 	 instructions.  */
name|int
name|p_reg_set
index|[
literal|64
index|]
decl_stmt|;
comment|/* B-step workaround. 	 For each general register, this is set if the corresponding insn 	 a) is conditional one one of the predicate registers for which 	    P_REG_SET is 1 in the corresponding entry of the previous group, 	 b) sets this general register with one of the affected 	    instructions.  */
name|int
name|g_reg_set_conditionally
index|[
literal|128
index|]
decl_stmt|;
block|}
name|last_groups
index|[
literal|3
index|]
struct|;
name|int
name|group_idx
decl_stmt|;
name|int
name|pointer_size
decl_stmt|;
comment|/* size in bytes of a pointer */
name|int
name|pointer_size_shift
decl_stmt|;
comment|/* shift size of a pointer for alignment */
block|}
name|md
struct|;
end_struct

begin_comment
comment|/* application registers:  */
end_comment

begin_define
define|#
directive|define
name|AR_K0
value|0
end_define

begin_define
define|#
directive|define
name|AR_K7
value|7
end_define

begin_define
define|#
directive|define
name|AR_RSC
value|16
end_define

begin_define
define|#
directive|define
name|AR_BSP
value|17
end_define

begin_define
define|#
directive|define
name|AR_BSPSTORE
value|18
end_define

begin_define
define|#
directive|define
name|AR_RNAT
value|19
end_define

begin_define
define|#
directive|define
name|AR_UNAT
value|36
end_define

begin_define
define|#
directive|define
name|AR_FPSR
value|40
end_define

begin_define
define|#
directive|define
name|AR_ITC
value|44
end_define

begin_define
define|#
directive|define
name|AR_PFS
value|64
end_define

begin_define
define|#
directive|define
name|AR_LC
value|65
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|}
name|ar
index|[]
init|=
block|{
block|{
literal|"ar.k0"
block|,
literal|0
block|}
block|,
block|{
literal|"ar.k1"
block|,
literal|1
block|}
block|,
block|{
literal|"ar.k2"
block|,
literal|2
block|}
block|,
block|{
literal|"ar.k3"
block|,
literal|3
block|}
block|,
block|{
literal|"ar.k4"
block|,
literal|4
block|}
block|,
block|{
literal|"ar.k5"
block|,
literal|5
block|}
block|,
block|{
literal|"ar.k6"
block|,
literal|6
block|}
block|,
block|{
literal|"ar.k7"
block|,
literal|7
block|}
block|,
block|{
literal|"ar.rsc"
block|,
literal|16
block|}
block|,
block|{
literal|"ar.bsp"
block|,
literal|17
block|}
block|,
block|{
literal|"ar.bspstore"
block|,
literal|18
block|}
block|,
block|{
literal|"ar.rnat"
block|,
literal|19
block|}
block|,
block|{
literal|"ar.fcr"
block|,
literal|21
block|}
block|,
block|{
literal|"ar.eflag"
block|,
literal|24
block|}
block|,
block|{
literal|"ar.csd"
block|,
literal|25
block|}
block|,
block|{
literal|"ar.ssd"
block|,
literal|26
block|}
block|,
block|{
literal|"ar.cflg"
block|,
literal|27
block|}
block|,
block|{
literal|"ar.fsr"
block|,
literal|28
block|}
block|,
block|{
literal|"ar.fir"
block|,
literal|29
block|}
block|,
block|{
literal|"ar.fdr"
block|,
literal|30
block|}
block|,
block|{
literal|"ar.ccv"
block|,
literal|32
block|}
block|,
block|{
literal|"ar.unat"
block|,
literal|36
block|}
block|,
block|{
literal|"ar.fpsr"
block|,
literal|40
block|}
block|,
block|{
literal|"ar.itc"
block|,
literal|44
block|}
block|,
block|{
literal|"ar.pfs"
block|,
literal|64
block|}
block|,
block|{
literal|"ar.lc"
block|,
literal|65
block|}
block|,
block|{
literal|"ar.ec"
block|,
literal|66
block|}
block|,   }
struct|;
end_struct

begin_define
define|#
directive|define
name|CR_IPSR
value|16
end_define

begin_define
define|#
directive|define
name|CR_ISR
value|17
end_define

begin_define
define|#
directive|define
name|CR_IIP
value|19
end_define

begin_define
define|#
directive|define
name|CR_IFA
value|20
end_define

begin_define
define|#
directive|define
name|CR_ITIR
value|21
end_define

begin_define
define|#
directive|define
name|CR_IIPA
value|22
end_define

begin_define
define|#
directive|define
name|CR_IFS
value|23
end_define

begin_define
define|#
directive|define
name|CR_IIM
value|24
end_define

begin_define
define|#
directive|define
name|CR_IHA
value|25
end_define

begin_define
define|#
directive|define
name|CR_IVR
value|65
end_define

begin_define
define|#
directive|define
name|CR_TPR
value|66
end_define

begin_define
define|#
directive|define
name|CR_EOI
value|67
end_define

begin_define
define|#
directive|define
name|CR_IRR0
value|68
end_define

begin_define
define|#
directive|define
name|CR_IRR3
value|71
end_define

begin_define
define|#
directive|define
name|CR_LRR0
value|80
end_define

begin_define
define|#
directive|define
name|CR_LRR1
value|81
end_define

begin_comment
comment|/* control registers:  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|}
name|cr
index|[]
init|=
block|{
block|{
literal|"cr.dcr"
block|,
literal|0
block|}
block|,
block|{
literal|"cr.itm"
block|,
literal|1
block|}
block|,
block|{
literal|"cr.iva"
block|,
literal|2
block|}
block|,
block|{
literal|"cr.pta"
block|,
literal|8
block|}
block|,
block|{
literal|"cr.gpta"
block|,
literal|9
block|}
block|,
block|{
literal|"cr.ipsr"
block|,
literal|16
block|}
block|,
block|{
literal|"cr.isr"
block|,
literal|17
block|}
block|,
block|{
literal|"cr.iip"
block|,
literal|19
block|}
block|,
block|{
literal|"cr.ifa"
block|,
literal|20
block|}
block|,
block|{
literal|"cr.itir"
block|,
literal|21
block|}
block|,
block|{
literal|"cr.iipa"
block|,
literal|22
block|}
block|,
block|{
literal|"cr.ifs"
block|,
literal|23
block|}
block|,
block|{
literal|"cr.iim"
block|,
literal|24
block|}
block|,
block|{
literal|"cr.iha"
block|,
literal|25
block|}
block|,
block|{
literal|"cr.lid"
block|,
literal|64
block|}
block|,
block|{
literal|"cr.ivr"
block|,
literal|65
block|}
block|,
block|{
literal|"cr.tpr"
block|,
literal|66
block|}
block|,
block|{
literal|"cr.eoi"
block|,
literal|67
block|}
block|,
block|{
literal|"cr.irr0"
block|,
literal|68
block|}
block|,
block|{
literal|"cr.irr1"
block|,
literal|69
block|}
block|,
block|{
literal|"cr.irr2"
block|,
literal|70
block|}
block|,
block|{
literal|"cr.irr3"
block|,
literal|71
block|}
block|,
block|{
literal|"cr.itv"
block|,
literal|72
block|}
block|,
block|{
literal|"cr.pmv"
block|,
literal|73
block|}
block|,
block|{
literal|"cr.cmcv"
block|,
literal|74
block|}
block|,
block|{
literal|"cr.lrr0"
block|,
literal|80
block|}
block|,
block|{
literal|"cr.lrr1"
block|,
literal|81
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PSR_MFL
value|4
end_define

begin_define
define|#
directive|define
name|PSR_IC
value|13
end_define

begin_define
define|#
directive|define
name|PSR_DFL
value|18
end_define

begin_define
define|#
directive|define
name|PSR_CPL
value|32
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|const_desc
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|valueT
name|value
decl_stmt|;
block|}
name|const_bits
index|[]
init|=
block|{
comment|/* PSR constant masks:  */
comment|/* 0: reserved */
block|{
literal|"psr.be"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|1
block|}
block|,
block|{
literal|"psr.up"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|2
block|}
block|,
block|{
literal|"psr.ac"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|3
block|}
block|,
block|{
literal|"psr.mfl"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|4
block|}
block|,
block|{
literal|"psr.mfh"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|5
block|}
block|,
comment|/* 6-12: reserved */
block|{
literal|"psr.ic"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|13
block|}
block|,
block|{
literal|"psr.i"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|14
block|}
block|,
block|{
literal|"psr.pk"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|15
block|}
block|,
comment|/* 16: reserved */
block|{
literal|"psr.dt"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|17
block|}
block|,
block|{
literal|"psr.dfl"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|18
block|}
block|,
block|{
literal|"psr.dfh"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|19
block|}
block|,
block|{
literal|"psr.sp"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|20
block|}
block|,
block|{
literal|"psr.pp"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|21
block|}
block|,
block|{
literal|"psr.di"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|22
block|}
block|,
block|{
literal|"psr.si"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|23
block|}
block|,
block|{
literal|"psr.db"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|24
block|}
block|,
block|{
literal|"psr.lp"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|25
block|}
block|,
block|{
literal|"psr.tb"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|26
block|}
block|,
block|{
literal|"psr.rt"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|27
block|}
block|,
comment|/* 28-31: reserved */
comment|/* 32-33: cpl (current privilege level) */
block|{
literal|"psr.is"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|34
block|}
block|,
block|{
literal|"psr.mc"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|35
block|}
block|,
block|{
literal|"psr.it"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|36
block|}
block|,
block|{
literal|"psr.id"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|37
block|}
block|,
block|{
literal|"psr.da"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|38
block|}
block|,
block|{
literal|"psr.dd"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|39
block|}
block|,
block|{
literal|"psr.ss"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|40
block|}
block|,
comment|/* 41-42: ri (restart instruction) */
block|{
literal|"psr.ed"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|43
block|}
block|,
block|{
literal|"psr.bn"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|44
block|}
block|,   }
struct|;
end_struct

begin_comment
comment|/* indirect register-sets/memory:  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|}
name|indirect_reg
index|[]
init|=
block|{
block|{
literal|"CPUID"
block|,
name|IND_CPUID
block|}
block|,
block|{
literal|"cpuid"
block|,
name|IND_CPUID
block|}
block|,
block|{
literal|"dbr"
block|,
name|IND_DBR
block|}
block|,
block|{
literal|"dtr"
block|,
name|IND_DTR
block|}
block|,
block|{
literal|"itr"
block|,
name|IND_ITR
block|}
block|,
block|{
literal|"ibr"
block|,
name|IND_IBR
block|}
block|,
block|{
literal|"msr"
block|,
name|IND_MSR
block|}
block|,
block|{
literal|"pkr"
block|,
name|IND_PKR
block|}
block|,
block|{
literal|"pmc"
block|,
name|IND_PMC
block|}
block|,
block|{
literal|"pmd"
block|,
name|IND_PMD
block|}
block|,
block|{
literal|"rr"
block|,
name|IND_RR
block|}
block|,   }
struct|;
end_struct

begin_comment
comment|/* Pseudo functions used to indicate relocation types (these functions    start with an at sign (@).  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
enum|enum
name|pseudo_type
block|{
name|PSEUDO_FUNC_NONE
block|,
name|PSEUDO_FUNC_RELOC
block|,
name|PSEUDO_FUNC_CONST
block|,
name|PSEUDO_FUNC_REG
block|,
name|PSEUDO_FUNC_FLOAT
block|}
name|type
enum|;
union|union
block|{
name|unsigned
name|long
name|ival
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|}
name|u
union|;
block|}
name|pseudo_func
index|[]
init|=
block|{
comment|/* reloc pseudo functions (these must come first!):  */
block|{
literal|"fptr"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"gprel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"ltoff"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"pcrel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"pltoff"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"secrel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"segrel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"ltv"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
block|,
comment|/* placeholder for FUNC_LT_FPTR_RELATIVE */
block|{
literal|"iplt"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
comment|/* mbtype4 constants:  */
block|{
literal|"alt"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0xa
block|}
block|}
block|,
block|{
literal|"brcst"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x0
block|}
block|}
block|,
block|{
literal|"mix"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x8
block|}
block|}
block|,
block|{
literal|"rev"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0xb
block|}
block|}
block|,
block|{
literal|"shuf"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x9
block|}
block|}
block|,
comment|/* fclass constants:  */
block|{
literal|"nat"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x100
block|}
block|}
block|,
block|{
literal|"qnan"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x080
block|}
block|}
block|,
block|{
literal|"snan"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x040
block|}
block|}
block|,
block|{
literal|"pos"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x001
block|}
block|}
block|,
block|{
literal|"neg"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x002
block|}
block|}
block|,
block|{
literal|"zero"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x004
block|}
block|}
block|,
block|{
literal|"unorm"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x008
block|}
block|}
block|,
block|{
literal|"norm"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x010
block|}
block|}
block|,
block|{
literal|"inf"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x020
block|}
block|}
block|,
block|{
literal|"natval"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x100
block|}
block|}
block|,
comment|/* old usage */
comment|/* unwind-related constants:  */
block|{
literal|"svr4"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"hpux"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|1
block|}
block|}
block|,
block|{
literal|"nt"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|2
block|}
block|}
block|,
comment|/* unwind-related registers:  */
block|{
literal|"priunat"
block|,
name|PSEUDO_FUNC_REG
block|,
block|{
name|REG_PRIUNAT
block|}
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* 41-bit nop opcodes (one per unit):  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|nop
index|[
name|IA64_NUM_UNITS
index|]
init|=
block|{
literal|0x0000000000LL
block|,
comment|/* NIL => break 0 */
literal|0x0008000000LL
block|,
comment|/* I-unit nop */
literal|0x0008000000LL
block|,
comment|/* M-unit nop */
literal|0x4000000000LL
block|,
comment|/* B-unit nop */
literal|0x0008000000LL
block|,
comment|/* F-unit nop */
literal|0x0008000000LL
block|,
comment|/* L-"unit" nop */
literal|0x0008000000LL
block|,
comment|/* X-unit nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Can't be `const' as it's passed to input routines (which have the    habit of setting temporary sentinels.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|special_section_name
index|[]
index|[
literal|20
index|]
init|=
block|{
block|{
literal|".bss"
block|}
block|,
block|{
literal|".sbss"
block|}
block|,
block|{
literal|".sdata"
block|}
block|,
block|{
literal|".rodata"
block|}
block|,
block|{
literal|".comment"
block|}
block|,
block|{
literal|".IA_64.unwind"
block|}
block|,
block|{
literal|".IA_64.unwind_info"
block|}
block|,
block|{
literal|".init_array"
block|}
block|,
block|{
literal|".fini_array"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|special_linkonce_name
index|[]
init|=
block|{
literal|".gnu.linkonce.ia64unw."
block|,
literal|".gnu.linkonce.ia64unwi."
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The best template for a particular sequence of up to three    instructions:  */
end_comment

begin_define
define|#
directive|define
name|N
value|IA64_NUM_TYPES
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|best_template
index|[
name|N
index|]
index|[
name|N
index|]
index|[
name|N
index|]
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|N
end_undef

begin_comment
comment|/* Resource dependencies currently in effect */
end_comment

begin_struct
specifier|static
struct|struct
name|rsrc
block|{
name|int
name|depind
decl_stmt|;
comment|/* dependency index */
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dependency
decl_stmt|;
comment|/* actual dependency */
name|unsigned
name|specific
range|:
literal|1
decl_stmt|,
comment|/* is this a specific bit/regno? */
name|link_to_qp_branch
range|:
literal|1
decl_stmt|;
comment|/* will a branch on the same QP clear it?*/
name|int
name|index
decl_stmt|;
comment|/* specific regno/bit within dependency */
name|int
name|note
decl_stmt|;
comment|/* optional qualifying note (0 if none) */
define|#
directive|define
name|STATE_NONE
value|0
define|#
directive|define
name|STATE_STOP
value|1
define|#
directive|define
name|STATE_SRLZ
value|2
name|int
name|insn_srlz
decl_stmt|;
comment|/* current insn serialization state */
name|int
name|data_srlz
decl_stmt|;
comment|/* current data serialization state */
name|int
name|qp_regno
decl_stmt|;
comment|/* qualifying predicate for this usage */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* what file marked this dependency */
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* what line marked this dependency */
name|struct
name|mem_offset
name|mem_offset
decl_stmt|;
comment|/* optional memory offset hint */
enum|enum
block|{
name|CMP_NONE
block|,
name|CMP_OR
block|,
name|CMP_AND
block|}
name|cmp_type
enum|;
comment|/* OR or AND compare? */
name|int
name|path
decl_stmt|;
comment|/* corresponding code entry index */
block|}
modifier|*
name|regdeps
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|regdepslen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regdepstotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dv_mode
index|[]
init|=
block|{
literal|"RAW"
block|,
literal|"WAW"
block|,
literal|"WAR"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dv_sem
index|[]
init|=
block|{
literal|"none"
block|,
literal|"implied"
block|,
literal|"impliedf"
block|,
literal|"data"
block|,
literal|"instr"
block|,
literal|"specific"
block|,
literal|"stop"
block|,
literal|"other"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dv_cmp_type
index|[]
init|=
block|{
literal|"none"
block|,
literal|"OR"
block|,
literal|"AND"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current state of PR mutexation */
end_comment

begin_struct
specifier|static
struct|struct
name|qpmutex
block|{
name|valueT
name|prmask
decl_stmt|;
name|int
name|path
decl_stmt|;
block|}
modifier|*
name|qp_mutexes
init|=
name|NULL
struct|;
end_struct

begin_comment
comment|/* QP mutex bitmasks */
end_comment

begin_decl_stmt
specifier|static
name|int
name|qp_mutexeslen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qp_mutexestotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|valueT
name|qp_safe_across_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current state of PR implications */
end_comment

begin_struct
specifier|static
struct|struct
name|qp_imply
block|{
name|unsigned
name|p1
range|:
literal|6
decl_stmt|;
name|unsigned
name|p2
range|:
literal|6
decl_stmt|;
name|unsigned
name|p2_branched
range|:
literal|1
decl_stmt|;
name|int
name|path
decl_stmt|;
block|}
modifier|*
name|qp_implies
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|qp_implieslen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qp_impliestotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of static GR values so that indirect register usage can    sometimes be tracked.  */
end_comment

begin_struct
specifier|static
struct|struct
name|gr
block|{
name|unsigned
name|known
range|:
literal|1
decl_stmt|;
name|int
name|path
decl_stmt|;
name|valueT
name|value
decl_stmt|;
block|}
name|gr_values
index|[
literal|128
index|]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* These are the routines required to output the various types of    unwind records.  */
end_comment

begin_comment
comment|/* A slot_number is a frag address plus the slot index (0-2).  We use the    frag address here so that if there is a section switch in the middle of    a function, then instructions emitted to a different section are not    counted.  Since there may be more than one frag for a function, this    means we also need to keep track of which frag this address belongs to    so we can compute inter-frag distances.  This also nicely solves the    problem with nops emitted for align directives, which can't easily be    counted, but can easily be derived from frag sizes.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|unw_rec_list
block|{
name|unwind_record
name|r
decl_stmt|;
name|unsigned
name|long
name|slot_number
decl_stmt|;
name|fragS
modifier|*
name|slot_frag
decl_stmt|;
name|struct
name|unw_rec_list
modifier|*
name|next
decl_stmt|;
block|}
name|unw_rec_list
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SLOT_NUM_NOT_SET
value|(unsigned)-1
end_define

begin_comment
comment|/* Linked list of saved prologue counts.  A very poor    implementation of a map from label numbers to prologue counts.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|label_prologue_count
block|{
name|struct
name|label_prologue_count
modifier|*
name|next
decl_stmt|;
name|unsigned
name|long
name|label_number
decl_stmt|;
name|unsigned
name|int
name|prologue_count
decl_stmt|;
block|}
name|label_prologue_count
typedef|;
end_typedef

begin_struct
specifier|static
struct|struct
block|{
name|unsigned
name|long
name|next_slot_number
decl_stmt|;
name|fragS
modifier|*
name|next_slot_frag
decl_stmt|;
comment|/* Maintain a list of unwind entries for the current function.  */
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
name|unw_rec_list
modifier|*
name|tail
decl_stmt|;
comment|/* Any unwind entires that should be attached to the current slot      that an insn is being constructed for.  */
name|unw_rec_list
modifier|*
name|current_entry
decl_stmt|;
comment|/* These are used to create the unwind table entry for this function.  */
name|symbolS
modifier|*
name|proc_start
decl_stmt|;
name|symbolS
modifier|*
name|proc_end
decl_stmt|;
name|symbolS
modifier|*
name|info
decl_stmt|;
comment|/* pointer to unwind info */
name|symbolS
modifier|*
name|personality_routine
decl_stmt|;
name|segT
name|saved_text_seg
decl_stmt|;
name|subsegT
name|saved_text_subseg
decl_stmt|;
name|unsigned
name|int
name|force_unwind_entry
range|:
literal|1
decl_stmt|;
comment|/* force generation of unwind entry? */
comment|/* TRUE if processing unwind directives in a prologue region.  */
name|int
name|prologue
decl_stmt|;
name|int
name|prologue_mask
decl_stmt|;
name|unsigned
name|int
name|prologue_count
decl_stmt|;
comment|/* number of .prologues seen so far */
comment|/* Prologue counts at previous .label_state directives.  */
name|struct
name|label_prologue_count
modifier|*
name|saved_prologue_counts
decl_stmt|;
block|}
name|unwind
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*vbyte_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/* Forward delarations:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ar_is_in_integer_unit
name|PARAMS
argument_list|(
operator|(
name|int
name|regnum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_section
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|set_regstack
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_radix
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_special_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_proc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_fframe
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_vframe
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_vframesp
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_vframepsp
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_save
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_restore
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_restorereg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_restorereg_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_handlerdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_unwentry
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_altrp
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_savemem
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_saveg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_savef
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_saveb
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_savegf
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_spill
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_spillreg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_spillmem
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_spillreg_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_spillmem_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_label_state
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_copy_state
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_unwabi
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_personality
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_body
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_prologue
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_endp
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_template
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_regstk
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_rot
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_byteorder
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_psr
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_alias
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_ln
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_section_name
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stmt_float_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stmt_cons_ua
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xfloat_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xstringer
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xdata_ua
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xfloat_cons_ua
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_prmask
name|PARAMS
argument_list|(
operator|(
name|valueT
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_pred_rel
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_reg_val
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_dv_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_entry
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_mem_offset
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_unwind_entry
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|declare_register
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
name|int
name|regnum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|declare_register_set
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|operand_width
name|PARAMS
argument_list|(
operator|(
expr|enum
name|ia64_opnd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|operand_match_result
name|operand_match
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|ia64_opcode
operator|*
name|idesc
operator|,
name|int
name|index
operator|,
name|expressionS
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_operand
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ia64_opcode
modifier|*
name|parse_operands
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errata_nop_necessary_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|slot
operator|*
operator|,
expr|enum
name|ia64_unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|slot
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_one_bundle
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_insn
name|PARAMS
argument_list|(
operator|(
name|fixS
operator|*
operator|,
specifier|const
expr|struct
name|ia64_operand
operator|*
operator|,
name|valueT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|ia64_gen_real_reloc_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
name|sym
operator|,
name|bfd_reloc_code_real_type
name|r_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insn_group_break
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_resource
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|,
specifier|const
expr|struct
name|ia64_dependency
operator|*
operator|,
expr|struct
name|rsrc
operator|*
operator|,
name|int
name|depind
operator|,
name|int
name|path
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_qp_mutex
name|PARAMS
argument_list|(
operator|(
name|valueT
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_qp_imply
name|PARAMS
argument_list|(
operator|(
name|int
name|p1
operator|,
name|int
name|p2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_qp_branch_flag
name|PARAMS
argument_list|(
operator|(
name|valueT
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_qp_mutex
name|PARAMS
argument_list|(
operator|(
name|valueT
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_qp_implies
name|PARAMS
argument_list|(
operator|(
name|valueT
name|p1_mask
operator|,
name|valueT
name|p2_mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|has_suffix_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_register_values
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_dependency
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|action
operator|,
name|int
name|depind
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|instruction_serialization
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|data_serialization
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_marked_resource
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rsrc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_conditional_branch
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_taken_branch
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_interruption_or_rfi
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|depends_on
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|specify_resource
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|ia64_dependency
operator|*
operator|,
expr|struct
name|ia64_opcode
operator|*
operator|,
name|int
operator|,
expr|struct
name|rsrc
index|[]
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_dv
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
name|idesc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_dependencies
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_resources
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_dependencies
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_register_values
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qp_mutex
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resources_match
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rsrc
operator|*
operator|,
expr|struct
name|ia64_opcode
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_vbyte_mem
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_output
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_R1_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_R2_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_R3_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P1_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P2_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P3_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P4_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P5_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P6_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P7_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P8_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P9_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P10_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_B1_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_B2_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_B3_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_B4_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|format_ab_reg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_X1_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_X2_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_X3_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_X4_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_list_records
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_prologue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_prologue_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_body
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_mem_stack_f
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_mem_stack_v
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_psp_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_psp_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_br
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fr_mem
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_frgr_mem
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_gr_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_gr_mem
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_br_mem
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_br_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_base
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_when_gr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_when_mem
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unwabi
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_epilogue
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_label_state
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_copy_state
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_psprel_p
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_sprel_p
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_reg
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_reg_p
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_one_record
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|,
name|vbyte_func
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_unw_records
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|,
name|vbyte_func
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|calc_record_size
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_imask
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_bits
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|slot_index
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|fragS
operator|*
operator|,
name|unsigned
name|long
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|optimize_unw_records
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_unw_records
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_unw_records
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|,
name|void
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|convert_expr_to_ab_reg
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|convert_expr_to_xy_reg
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|generate_unwind_image
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|get_saved_prologue_count
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_prologue_count
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_saved_prologue_counts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build the unwind section name by appending the (possibly stripped)    text section NAME to the unwind PREFIX.  The resulting string    pointer is assigned to RESULT.  The string is allocated on the    stack, so this must be a macro... */
end_comment

begin_define
define|#
directive|define
name|make_unw_section_name
parameter_list|(
name|special
parameter_list|,
name|text_name
parameter_list|,
name|result
parameter_list|)
define|\
value|{									   \     const char *_prefix = special_section_name[special];		   \     const char *_suffix = text_name;					   \     size_t _prefix_len, _suffix_len;					   \     char *_result;							   \     if (strncmp (text_name, ".gnu.linkonce.t.",				   \ 		 sizeof (".gnu.linkonce.t.") - 1) == 0)			   \       {									   \ 	_prefix = special_linkonce_name[special - SPECIAL_SECTION_UNWIND]; \ 	_suffix += sizeof (".gnu.linkonce.t.") - 1;			   \       }									   \     _prefix_len = strlen (_prefix), _suffix_len = strlen (_suffix);	   \     _result = alloca (_prefix_len + _suffix_len + 1);		   	   \     memcpy (_result, _prefix, _prefix_len);				   \     memcpy (_result + _prefix_len, _suffix, _suffix_len);		   \     _result[_prefix_len + _suffix_len] = '\0';				   \     result = _result;							   \   }									   \ while (0)
end_define

begin_comment
comment|/* Determine if application register REGNUM resides in the integer    unit (as opposed to the memory unit).  */
end_comment

begin_function
specifier|static
name|int
name|ar_is_in_integer_unit
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
name|reg
operator|-=
name|REG_AR
expr_stmt|;
return|return
operator|(
name|reg
operator|==
literal|64
comment|/* pfs */
operator|||
name|reg
operator|==
literal|65
comment|/* lc */
operator|||
name|reg
operator|==
literal|66
comment|/* ec */
comment|/* ??? ias accepts and puts these in the integer unit.  */
operator|||
operator|(
name|reg
operator|>=
literal|112
operator|&&
name|reg
operator|<=
literal|127
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Switch to section NAME and create section if necessary.  It's    rather ugly that we have to manipulate input_line_pointer but I    don't see any other way to accomplish the same thing without    changing obj-elf.c (which may be the Right Thing, in the end).  */
end_comment

begin_function
specifier|static
name|void
name|set_section
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|saved_input_line_pointer
decl_stmt|;
name|saved_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|name
expr_stmt|;
name|obj_elf_section
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map 's' to SHF_IA_64_SHORT.  */
end_comment

begin_function
name|int
name|ia64_elf_section_letter
parameter_list|(
name|letter
parameter_list|,
name|ptr_msg
parameter_list|)
name|int
name|letter
decl_stmt|;
name|char
modifier|*
modifier|*
name|ptr_msg
decl_stmt|;
block|{
if|if
condition|(
name|letter
operator|==
literal|'s'
condition|)
return|return
name|SHF_IA_64_SHORT
return|;
operator|*
name|ptr_msg
operator|=
name|_
argument_list|(
literal|"Bad .section directive: want a,s,w,x,M,S in string"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map SHF_IA_64_SHORT to SEC_SMALL_DATA.  */
end_comment

begin_function
name|flagword
name|ia64_elf_section_flags
parameter_list|(
name|flags
parameter_list|,
name|attr
parameter_list|,
name|type
parameter_list|)
name|flagword
name|flags
decl_stmt|;
name|int
name|attr
decl_stmt|,
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|attr
operator|&
name|SHF_IA_64_SHORT
condition|)
name|flags
operator||=
name|SEC_SMALL_DATA
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_function
name|int
name|ia64_elf_section_type
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
define|#
directive|define
name|STREQ
parameter_list|(
name|s
parameter_list|)
value|((len == sizeof (s) - 1)&& (strncmp (str, s, sizeof (s) - 1) == 0))
if|if
condition|(
name|STREQ
argument_list|(
name|ELF_STRING_ia64_unwind_info
argument_list|)
condition|)
return|return
name|SHT_PROGBITS
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|ELF_STRING_ia64_unwind_info_once
argument_list|)
condition|)
return|return
name|SHT_PROGBITS
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|ELF_STRING_ia64_unwind
argument_list|)
condition|)
return|return
name|SHT_IA_64_UNWIND
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|ELF_STRING_ia64_unwind_once
argument_list|)
condition|)
return|return
name|SHT_IA_64_UNWIND
return|;
if|if
condition|(
name|STREQ
argument_list|(
literal|"init_array"
argument_list|)
condition|)
return|return
name|SHT_INIT_ARRAY
return|;
if|if
condition|(
name|STREQ
argument_list|(
literal|"fini_array"
argument_list|)
condition|)
return|return
name|SHT_FINI_ARRAY
return|;
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|STREQ
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|set_regstack
parameter_list|(
name|ins
parameter_list|,
name|locs
parameter_list|,
name|outs
parameter_list|,
name|rots
parameter_list|)
name|unsigned
name|int
name|ins
decl_stmt|,
name|locs
decl_stmt|,
name|outs
decl_stmt|,
name|rots
decl_stmt|;
block|{
comment|/* Size of frame.  */
name|unsigned
name|int
name|sof
decl_stmt|;
name|sof
operator|=
name|ins
operator|+
name|locs
operator|+
name|outs
expr_stmt|;
if|if
condition|(
name|sof
operator|>
literal|96
condition|)
block|{
name|as_bad
argument_list|(
literal|"Size of frame exceeds maximum of 96 registers"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|rots
operator|>
name|sof
condition|)
block|{
name|as_warn
argument_list|(
literal|"Size of rotating registers exceeds frame size"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|md
operator|.
name|in
operator|.
name|base
operator|=
name|REG_GR
operator|+
literal|32
expr_stmt|;
name|md
operator|.
name|loc
operator|.
name|base
operator|=
name|md
operator|.
name|in
operator|.
name|base
operator|+
name|ins
expr_stmt|;
name|md
operator|.
name|out
operator|.
name|base
operator|=
name|md
operator|.
name|loc
operator|.
name|base
operator|+
name|locs
expr_stmt|;
name|md
operator|.
name|in
operator|.
name|num_regs
operator|=
name|ins
expr_stmt|;
name|md
operator|.
name|loc
operator|.
name|num_regs
operator|=
name|locs
expr_stmt|;
name|md
operator|.
name|out
operator|.
name|num_regs
operator|=
name|outs
expr_stmt|;
name|md
operator|.
name|rot
operator|.
name|num_regs
operator|=
name|rots
expr_stmt|;
return|return
name|sof
return|;
block|}
end_function

begin_function
name|void
name|ia64_flush_insns
parameter_list|()
block|{
name|struct
name|label_fix
modifier|*
name|lfix
decl_stmt|;
name|segT
name|saved_seg
decl_stmt|;
name|subsegT
name|saved_subseg
decl_stmt|;
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|md
operator|.
name|last_text_seg
condition|)
return|return;
name|saved_seg
operator|=
name|now_seg
expr_stmt|;
name|saved_subseg
operator|=
name|now_subseg
expr_stmt|;
name|subseg_set
argument_list|(
name|md
operator|.
name|last_text_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|md
operator|.
name|num_slots_in_use
operator|>
literal|0
condition|)
name|emit_one_bundle
argument_list|()
expr_stmt|;
comment|/* force out queued instructions */
comment|/* In case there are labels following the last instruction, resolve      those now:  */
for|for
control|(
name|lfix
operator|=
name|CURR_SLOT
operator|.
name|label_fixups
init|;
name|lfix
condition|;
name|lfix
operator|=
name|lfix
operator|->
name|next
control|)
block|{
name|S_SET_VALUE
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
name|CURR_SLOT
operator|.
name|label_fixups
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lfix
operator|=
name|CURR_SLOT
operator|.
name|tag_fixups
init|;
name|lfix
condition|;
name|lfix
operator|=
name|lfix
operator|->
name|next
control|)
block|{
name|S_SET_VALUE
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
name|CURR_SLOT
operator|.
name|tag_fixups
operator|=
literal|0
expr_stmt|;
comment|/* In case there are unwind directives following the last instruction,      resolve those now.  We only handle body and prologue directives here.      Give an error for others.  */
for|for
control|(
name|ptr
operator|=
name|unwind
operator|.
name|current_entry
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|prologue
operator|||
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|prologue_gr
operator|||
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|body
condition|)
block|{
name|ptr
operator|->
name|slot_number
operator|=
operator|(
name|unsigned
name|long
operator|)
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|slot_frag
operator|=
name|frag_now
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unwind directive not followed by an instruction."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unwind
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|as_bad
argument_list|(
literal|"qualifying predicate not followed by instruction"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_do_align
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|char
modifier|*
name|saved_input_line_pointer
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
literal|""
expr_stmt|;
name|s_align_bytes
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_cons_align
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
name|md
operator|.
name|auto_align
condition|)
block|{
name|char
modifier|*
name|saved_input_line_pointer
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
literal|""
expr_stmt|;
name|s_align_bytes
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output COUNT bytes to a memory location.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|vbyte_mem_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|output_vbyte_mem
parameter_list|(
name|count
parameter_list|,
name|ptr
parameter_list|,
name|comment
parameter_list|)
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|comment
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|vbyte_mem_ptr
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
name|x
operator|++
control|)
operator|*
operator|(
name|vbyte_mem_ptr
operator|++
operator|)
operator|=
name|ptr
index|[
name|x
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the number of bytes required for records.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vbyte_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|count_output
parameter_list|(
name|count
parameter_list|,
name|ptr
parameter_list|,
name|comment
parameter_list|)
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|comment
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|vbyte_count
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_R1_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|rlen
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|rlen
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|char
name|byte
decl_stmt|;
if|if
condition|(
name|rlen
operator|>
literal|0x1f
condition|)
block|{
name|output_R3_format
argument_list|(
name|f
argument_list|,
name|rtype
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rtype
operator|==
name|body
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|prologue
condition|)
name|as_bad
argument_list|(
literal|"record type is not valid"
argument_list|)
expr_stmt|;
name|byte
operator|=
name|UNW_R1
operator||
operator|(
name|r
operator|<<
literal|5
operator|)
operator||
operator|(
name|rlen
operator|&
literal|0x1f
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|1
argument_list|,
operator|&
name|byte
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_R2_format
parameter_list|(
name|f
parameter_list|,
name|mask
parameter_list|,
name|grsave
parameter_list|,
name|rlen
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|grsave
decl_stmt|;
name|unsigned
name|long
name|rlen
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|2
decl_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|grsave
operator|=
operator|(
name|grsave
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_R2
operator||
operator|(
name|mask
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|mask
operator|&
literal|0x01
operator|)
operator|<<
literal|7
operator|)
operator||
name|grsave
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|2
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_R3_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|rlen
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|rlen
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|;
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|rlen
operator|<=
literal|0x1f
condition|)
block|{
name|output_R1_format
argument_list|(
name|f
argument_list|,
name|rtype
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rtype
operator|==
name|body
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|prologue
condition|)
name|as_bad
argument_list|(
literal|"record type is not valid"
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_R3
operator||
name|r
operator|)
expr_stmt|;
name|count
operator|=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
operator|+
literal|1
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P1_format
parameter_list|(
name|f
parameter_list|,
name|brmask
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|brmask
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|byte
operator|=
name|UNW_P1
operator||
operator|(
name|brmask
operator|&
literal|0x1f
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|1
argument_list|,
operator|&
name|byte
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P2_format
parameter_list|(
name|f
parameter_list|,
name|brmask
parameter_list|,
name|gr
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|brmask
decl_stmt|;
name|int
name|gr
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|2
index|]
decl_stmt|;
name|brmask
operator|=
operator|(
name|brmask
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P2
operator||
operator|(
name|brmask
operator|>>
literal|1
operator|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|brmask
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
name|gr
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|2
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P3_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|reg
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|reg
operator|=
operator|(
name|reg
operator|&
literal|0x7f
operator|)
expr_stmt|;
switch|switch
condition|(
name|rtype
condition|)
block|{
case|case
name|psp_gr
case|:
name|r
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rp_gr
case|:
name|r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|pfs_gr
case|:
name|r
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|preds_gr
case|:
name|r
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|unat_gr
case|:
name|r
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|lc_gr
case|:
name|r
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|rp_br
case|:
name|r
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|rnat_gr
case|:
name|r
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|bsp_gr
case|:
name|r
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|bspstore_gr
case|:
name|r
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|fpsr_gr
case|:
name|r
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|priunat_gr
case|:
name|r
operator|=
literal|11
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Invalid record type for P3 format."
argument_list|)
expr_stmt|;
block|}
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_P3
operator||
operator|(
name|r
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
name|reg
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|2
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P4_format
parameter_list|(
name|f
parameter_list|,
name|imask
parameter_list|,
name|imask_size
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unsigned
name|char
modifier|*
name|imask
decl_stmt|;
name|unsigned
name|long
name|imask_size
decl_stmt|;
block|{
name|imask
index|[
literal|0
index|]
operator|=
name|UNW_P4
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|imask_size
argument_list|,
name|imask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P5_format
parameter_list|(
name|f
parameter_list|,
name|grmask
parameter_list|,
name|frmask
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|grmask
decl_stmt|;
name|unsigned
name|long
name|frmask
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|4
index|]
decl_stmt|;
name|grmask
operator|=
operator|(
name|grmask
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P5
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|grmask
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|frmask
operator|&
literal|0x000f0000
operator|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|frmask
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|bytes
index|[
literal|3
index|]
operator|=
operator|(
name|frmask
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|4
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P6_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|rmask
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|rmask
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rtype
operator|==
name|gr_mem
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|fr_mem
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format P6"
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|(
name|UNW_P6
operator||
operator|(
name|r
operator|<<
literal|4
operator|)
operator||
operator|(
name|rmask
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|1
argument_list|,
operator|&
name|byte
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P7_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|w1
parameter_list|,
name|w2
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|w1
decl_stmt|;
name|unsigned
name|long
name|w2
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|w1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rtype
condition|)
block|{
case|case
name|mem_stack_f
case|:
name|r
operator|=
literal|0
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
name|count
argument_list|,
name|w2
operator|>>
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|mem_stack_v
case|:
name|r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|spill_base
case|:
name|r
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|psp_sprel
case|:
name|r
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|rp_when
case|:
name|r
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|rp_psprel
case|:
name|r
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|pfs_when
case|:
name|r
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|pfs_psprel
case|:
name|r
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|preds_when
case|:
name|r
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|preds_psprel
case|:
name|r
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|lc_when
case|:
name|r
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|lc_psprel
case|:
name|r
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|unat_when
case|:
name|r
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|unat_psprel
case|:
name|r
operator|=
literal|13
expr_stmt|;
break|break;
case|case
name|fpsr_when
case|:
name|r
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|fpsr_psprel
case|:
name|r
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_P7
operator||
name|r
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P8_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|2
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P8
expr_stmt|;
switch|switch
condition|(
name|rtype
condition|)
block|{
case|case
name|rp_sprel
case|:
name|r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|pfs_sprel
case|:
name|r
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|preds_sprel
case|:
name|r
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|lc_sprel
case|:
name|r
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|unat_sprel
case|:
name|r
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|fpsr_sprel
case|:
name|r
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|bsp_when
case|:
name|r
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|bsp_psprel
case|:
name|r
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|bsp_sprel
case|:
name|r
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|bspstore_when
case|:
name|r
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|bspstore_psprel
case|:
name|r
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|bspstore_sprel
case|:
name|r
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|rnat_when
case|:
name|r
operator|=
literal|13
expr_stmt|;
break|break;
case|case
name|rnat_psprel
case|:
name|r
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|rnat_sprel
case|:
name|r
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|priunat_when_gr
case|:
name|r
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|priunat_psprel
case|:
name|r
operator|=
literal|17
expr_stmt|;
break|break;
case|case
name|priunat_sprel
case|:
name|r
operator|=
literal|18
expr_stmt|;
break|break;
case|case
name|priunat_when_mem
case|:
name|r
operator|=
literal|19
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|bytes
index|[
literal|1
index|]
operator|=
name|r
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|2
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P9_format
parameter_list|(
name|f
parameter_list|,
name|grmask
parameter_list|,
name|gr
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|grmask
decl_stmt|;
name|int
name|gr
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|3
index|]
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P9
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
name|grmask
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
name|gr
operator|&
literal|0x7f
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|3
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P10_format
parameter_list|(
name|f
parameter_list|,
name|abi
parameter_list|,
name|context
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|abi
decl_stmt|;
name|int
name|context
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|3
index|]
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P10
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
name|abi
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
name|context
operator|&
literal|0xff
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|3
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_B1_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|label
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|label
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|label
operator|>
literal|0x1f
condition|)
block|{
name|output_B4_format
argument_list|(
name|f
argument_list|,
name|rtype
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rtype
operator|==
name|copy_state
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|label_state
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format B1"
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|(
name|UNW_B1
operator||
operator|(
name|r
operator|<<
literal|5
operator|)
operator||
operator|(
name|label
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|1
argument_list|,
operator|&
name|byte
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_B2_format
parameter_list|(
name|f
parameter_list|,
name|ecount
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unsigned
name|long
name|ecount
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ecount
operator|>
literal|0x1f
condition|)
block|{
name|output_B3_format
argument_list|(
name|f
argument_list|,
name|ecount
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_B2
operator||
operator|(
name|ecount
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_B3_format
parameter_list|(
name|f
parameter_list|,
name|ecount
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unsigned
name|long
name|ecount
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ecount
operator|<=
literal|0x1f
condition|)
block|{
name|output_B2_format
argument_list|(
name|f
argument_list|,
name|ecount
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_B3
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
name|count
argument_list|,
name|ecount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_B4_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|label
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|label
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|label
operator|<=
literal|0x1f
condition|)
block|{
name|output_B1_format
argument_list|(
name|f
argument_list|,
name|rtype
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rtype
operator|==
name|copy_state
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|label_state
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format B1"
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_B4
operator||
operator|(
name|r
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
name|format_ab_reg
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|)
name|int
name|ab
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|ab
operator|=
operator|(
name|ab
operator|&
literal|3
operator|)
expr_stmt|;
name|reg
operator|=
operator|(
name|reg
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|ret
operator|=
operator|(
name|ab
operator|<<
literal|5
operator|)
operator||
name|reg
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_X1_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|ab
parameter_list|,
name|reg
parameter_list|,
name|t
parameter_list|,
name|w1
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
name|unsigned
name|long
name|w1
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|2
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_X1
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|spill_sprel
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|spill_psprel
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format X1"
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|r
operator|<<
literal|7
operator|)
operator||
name|format_ab_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|2
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
name|count
argument_list|,
name|w1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_X2_format
parameter_list|(
name|f
parameter_list|,
name|ab
parameter_list|,
name|reg
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|treg
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|treg
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|3
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_X2
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
name|format_ab_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
operator|(
operator|(
name|y
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|treg
operator|&
literal|0x7f
operator|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|3
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_X3_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|qp
parameter_list|,
name|ab
parameter_list|,
name|reg
parameter_list|,
name|t
parameter_list|,
name|w1
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|qp
decl_stmt|;
name|int
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
name|unsigned
name|long
name|w1
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|3
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_X3
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|spill_sprel_p
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|spill_psprel_p
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format X3"
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|r
operator|<<
literal|7
operator|)
operator||
operator|(
name|qp
operator|&
literal|0x3f
operator|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
name|format_ab_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|3
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
name|count
argument_list|,
name|w1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_X4_format
parameter_list|(
name|f
parameter_list|,
name|qp
parameter_list|,
name|ab
parameter_list|,
name|reg
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|treg
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|qp
decl_stmt|;
name|int
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|treg
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|4
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_X4
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
name|qp
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
name|format_ab_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|3
index|]
operator|=
operator|(
operator|(
operator|(
name|y
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|treg
operator|&
literal|0x7f
operator|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|4
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function allocates a record list structure, and initializes fields.  */
end_comment

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|alloc_record
parameter_list|(
name|unw_record_type
name|t
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|slot_number
operator|=
name|SLOT_NUM_NOT_SET
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|type
operator|=
name|t
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* This function frees an entire list of record structures.  */
end_comment

begin_function
name|void
name|free_list_records
parameter_list|(
name|unw_rec_list
modifier|*
name|first
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|first
init|;
name|ptr
operator|!=
name|NULL
condition|;
control|)
block|{
name|unw_rec_list
modifier|*
name|tmp
init|=
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|->
name|r
operator|.
name|type
operator|==
name|prologue
operator|||
name|tmp
operator|->
name|r
operator|.
name|type
operator|==
name|prologue_gr
operator|)
operator|&&
name|tmp
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
condition|)
name|free
argument_list|(
name|tmp
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_prologue
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|prologue
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_prologue_gr
parameter_list|(
name|saved_mask
parameter_list|,
name|reg
parameter_list|)
name|unsigned
name|int
name|saved_mask
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|prologue_gr
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|grmask
operator|=
name|saved_mask
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|grsave
operator|=
name|reg
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_body
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|body
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_mem_stack_f
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|mem_stack_f
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|size
operator|=
name|size
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_mem_stack_v
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|mem_stack_v
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_psp_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|psp_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_psp_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|psp_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_br
parameter_list|(
name|br
parameter_list|)
name|unsigned
name|int
name|br
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_br
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|br
operator|=
name|br
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|pfs_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|pfs_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|pfs_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|pfs_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|preds_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|preds_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|preds_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|preds_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fr_mem
parameter_list|(
name|mask
parameter_list|)
name|unsigned
name|int
name|mask
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fr_mem
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|rmask
operator|=
name|mask
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_frgr_mem
parameter_list|(
name|gr_mask
parameter_list|,
name|fr_mask
parameter_list|)
name|unsigned
name|int
name|gr_mask
decl_stmt|;
name|unsigned
name|int
name|fr_mask
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|frgr_mem
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|=
name|gr_mask
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
operator|=
name|fr_mask
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_gr_gr
parameter_list|(
name|mask
parameter_list|,
name|reg
parameter_list|)
name|unsigned
name|int
name|mask
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|gr_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|=
name|mask
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|reg
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_gr_mem
parameter_list|(
name|mask
parameter_list|)
name|unsigned
name|int
name|mask
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|gr_mem
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|rmask
operator|=
name|mask
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_br_mem
parameter_list|(
name|unsigned
name|int
name|mask
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|br_mem
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
operator|=
name|mask
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_br_gr
parameter_list|(
name|save_mask
parameter_list|,
name|reg
parameter_list|)
name|unsigned
name|int
name|save_mask
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|br_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
operator|=
name|save_mask
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|reg
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_base
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|spill_base
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unat_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unat_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unat_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unat_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|lc_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|lc_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|lc_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|lc_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fpsr_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fpsr_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fpsr_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fpsr_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_when_gr
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_when_gr
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_when_mem
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_when_mem
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bsp_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bsp_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bsp_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bsp_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bspstore_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bspstore_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bspstore_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bspstore_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rnat_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rnat_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rnat_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rnat_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unwabi
parameter_list|(
name|abi
parameter_list|,
name|context
parameter_list|)
name|unsigned
name|long
name|abi
decl_stmt|;
name|unsigned
name|long
name|context
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unwabi
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|abi
operator|=
name|abi
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|context
operator|=
name|context
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_epilogue
parameter_list|(
name|unsigned
name|long
name|ecount
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|epilogue
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|ecount
operator|=
name|ecount
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_label_state
parameter_list|(
name|unsigned
name|long
name|label
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|label_state
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|label
operator|=
name|label
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_copy_state
parameter_list|(
name|unsigned
name|long
name|label
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|copy_state
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|label
operator|=
name|label
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_psprel
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|)
name|unsigned
name|int
name|ab
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|spill_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
operator|=
name|ab
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_sprel
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|)
name|unsigned
name|int
name|ab
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|spill_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
operator|=
name|ab
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_psprel_p
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|,
name|predicate
parameter_list|)
name|unsigned
name|int
name|ab
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|predicate
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|spill_psprel_p
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
operator|=
name|ab
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|pspoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
operator|=
name|predicate
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_sprel_p
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|,
name|predicate
parameter_list|)
name|unsigned
name|int
name|ab
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|predicate
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|spill_sprel_p
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
operator|=
name|ab
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
operator|=
name|predicate
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_reg
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|,
name|targ_reg
parameter_list|,
name|xy
parameter_list|)
name|unsigned
name|int
name|ab
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|int
name|targ_reg
decl_stmt|;
name|unsigned
name|int
name|xy
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|spill_reg
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
operator|=
name|ab
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|treg
operator|=
name|targ_reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
operator|=
name|xy
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_reg_p
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|,
name|targ_reg
parameter_list|,
name|xy
parameter_list|,
name|predicate
parameter_list|)
name|unsigned
name|int
name|ab
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|int
name|targ_reg
decl_stmt|;
name|unsigned
name|int
name|xy
decl_stmt|;
name|unsigned
name|int
name|predicate
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|spill_reg_p
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
operator|=
name|ab
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|treg
operator|=
name|targ_reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
operator|=
name|xy
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
operator|=
name|predicate
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Given a unw_rec_list process the correct format with the    specified function.  */
end_comment

begin_function
specifier|static
name|void
name|process_one_record
parameter_list|(
name|ptr
parameter_list|,
name|f
parameter_list|)
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
name|vbyte_func
name|f
decl_stmt|;
block|{
name|unsigned
name|long
name|fr_mask
decl_stmt|,
name|gr_mask
decl_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
condition|)
block|{
case|case
name|gr_mem
case|:
case|case
name|fr_mem
case|:
case|case
name|br_mem
case|:
case|case
name|frgr_mem
case|:
comment|/* These are taken care of by prologue/prologue_gr.  */
break|break;
case|case
name|prologue_gr
case|:
case|case
name|prologue
case|:
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|prologue_gr
condition|)
name|output_R2_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|grmask
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|grsave
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
argument_list|)
expr_stmt|;
else|else
name|output_R1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
argument_list|)
expr_stmt|;
comment|/* Output descriptor(s) for union of register spills (if any).  */
name|gr_mask
operator|=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|gr_mem
expr_stmt|;
name|fr_mask
operator|=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|fr_mem
expr_stmt|;
if|if
condition|(
name|fr_mask
condition|)
block|{
if|if
condition|(
operator|(
name|fr_mask
operator|&
operator|~
literal|0xfUL
operator|)
operator|==
literal|0
condition|)
name|output_P6_format
argument_list|(
name|f
argument_list|,
name|fr_mem
argument_list|,
name|fr_mask
argument_list|)
expr_stmt|;
else|else
block|{
name|output_P5_format
argument_list|(
name|f
argument_list|,
name|gr_mask
argument_list|,
name|fr_mask
argument_list|)
expr_stmt|;
name|gr_mask
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gr_mask
condition|)
name|output_P6_format
argument_list|(
name|f
argument_list|,
name|gr_mem
argument_list|,
name|gr_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|br_mem
condition|)
name|output_P1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|br_mem
argument_list|)
expr_stmt|;
comment|/* output imask descriptor if necessary:  */
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
condition|)
name|output_P4_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|imask_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|body
case|:
name|output_R1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|mem_stack_f
case|:
case|case
name|mem_stack_v
case|:
name|output_P7_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|psp_gr
case|:
case|case
name|rp_gr
case|:
case|case
name|pfs_gr
case|:
case|case
name|preds_gr
case|:
case|case
name|unat_gr
case|:
case|case
name|lc_gr
case|:
case|case
name|fpsr_gr
case|:
case|case
name|priunat_gr
case|:
case|case
name|bsp_gr
case|:
case|case
name|bspstore_gr
case|:
case|case
name|rnat_gr
case|:
name|output_P3_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
argument_list|)
expr_stmt|;
break|break;
case|case
name|rp_br
case|:
name|output_P3_format
argument_list|(
name|f
argument_list|,
name|rp_br
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|br
argument_list|)
expr_stmt|;
break|break;
case|case
name|psp_sprel
case|:
name|output_P7_format
argument_list|(
name|f
argument_list|,
name|psp_sprel
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|rp_when
case|:
case|case
name|pfs_when
case|:
case|case
name|preds_when
case|:
case|case
name|unat_when
case|:
case|case
name|lc_when
case|:
case|case
name|fpsr_when
case|:
name|output_P7_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|rp_psprel
case|:
case|case
name|pfs_psprel
case|:
case|case
name|preds_psprel
case|:
case|case
name|unat_psprel
case|:
case|case
name|lc_psprel
case|:
case|case
name|fpsr_psprel
case|:
case|case
name|spill_base
case|:
name|output_P7_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|rp_sprel
case|:
case|case
name|pfs_sprel
case|:
case|case
name|preds_sprel
case|:
case|case
name|unat_sprel
case|:
case|case
name|lc_sprel
case|:
case|case
name|fpsr_sprel
case|:
case|case
name|priunat_sprel
case|:
case|case
name|bsp_sprel
case|:
case|case
name|bspstore_sprel
case|:
case|case
name|rnat_sprel
case|:
name|output_P8_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|spoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|gr_gr
case|:
name|output_P9_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
argument_list|)
expr_stmt|;
break|break;
case|case
name|br_gr
case|:
name|output_P2_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|gr
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_mask
case|:
name|as_bad
argument_list|(
literal|"spill_mask record unimplemented."
argument_list|)
expr_stmt|;
break|break;
case|case
name|priunat_when_gr
case|:
case|case
name|priunat_when_mem
case|:
case|case
name|bsp_when
case|:
case|case
name|bspstore_when
case|:
case|case
name|rnat_when
case|:
name|output_P8_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|priunat_psprel
case|:
case|case
name|bsp_psprel
case|:
case|case
name|bspstore_psprel
case|:
case|case
name|rnat_psprel
case|:
name|output_P8_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|pspoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|unwabi
case|:
name|output_P10_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|abi
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|context
argument_list|)
expr_stmt|;
break|break;
case|case
name|epilogue
case|:
name|output_B3_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|ecount
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|label_state
case|:
case|case
name|copy_state
case|:
name|output_B4_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_psprel
case|:
name|output_X1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|pspoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_sprel
case|:
name|output_X1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|spoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_reg
case|:
name|output_X2_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
operator|>>
literal|1
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|treg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_psprel_p
case|:
name|output_X3_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|pspoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_sprel_p
case|:
name|output_X3_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|spoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_reg_p
case|:
name|output_X4_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
operator|>>
literal|1
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|treg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"record_type_not_valid"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given a unw_rec_list list, process all the records with    the specified function.  */
end_comment

begin_function
specifier|static
name|void
name|process_unw_records
parameter_list|(
name|list
parameter_list|,
name|f
parameter_list|)
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
name|vbyte_func
name|f
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|process_one_record
argument_list|(
name|ptr
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the size of a record list in bytes.  */
end_comment

begin_function
specifier|static
name|int
name|calc_record_size
parameter_list|(
name|list
parameter_list|)
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
block|{
name|vbyte_count
operator|=
literal|0
expr_stmt|;
name|process_unw_records
argument_list|(
name|list
argument_list|,
name|count_output
argument_list|)
expr_stmt|;
return|return
name|vbyte_count
return|;
block|}
end_function

begin_comment
comment|/* Update IMASK bitmask to reflect the fact that one or more registers    of type TYPE are saved starting at instruction with index T.  If N    bits are set in REGMASK, it is assumed that instructions T through    T+N-1 save these registers.     TYPE values: 	0: no save 	1: instruction saves next fp reg 	2: instruction saves next general reg 	3: instruction saves next branch reg */
end_comment

begin_function
specifier|static
name|void
name|set_imask
parameter_list|(
name|region
parameter_list|,
name|regmask
parameter_list|,
name|t
parameter_list|,
name|type
parameter_list|)
name|unw_rec_list
modifier|*
name|region
decl_stmt|;
name|unsigned
name|long
name|regmask
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|imask
decl_stmt|;
name|unsigned
name|long
name|imask_size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|imask
operator|=
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
expr_stmt|;
name|imask_size
operator|=
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|imask_size
expr_stmt|;
if|if
condition|(
operator|!
name|imask
condition|)
block|{
name|imask_size
operator|=
operator|(
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
operator|*
literal|2
operator|+
literal|7
operator|)
operator|/
literal|8
operator|+
literal|1
expr_stmt|;
name|imask
operator|=
name|xmalloc
argument_list|(
name|imask_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|imask
argument_list|,
literal|0
argument_list|,
name|imask_size
argument_list|)
expr_stmt|;
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|imask_size
operator|=
name|imask_size
expr_stmt|;
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
operator|=
name|imask
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|t
operator|/
literal|4
operator|)
operator|+
literal|1
expr_stmt|;
name|pos
operator|=
literal|2
operator|*
operator|(
literal|3
operator|-
name|t
operator|%
literal|4
operator|)
expr_stmt|;
while|while
condition|(
name|regmask
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|imask_size
condition|)
block|{
name|as_bad
argument_list|(
literal|"Ignoring attempt to spill beyond end of region"
argument_list|)
expr_stmt|;
return|return;
block|}
name|imask
index|[
name|i
index|]
operator||=
operator|(
name|type
operator|&
literal|0x3
operator|)
operator|<<
name|pos
expr_stmt|;
name|regmask
operator|&=
operator|(
name|regmask
operator|-
literal|1
operator|)
expr_stmt|;
name|pos
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|count_bits
parameter_list|(
name|unsigned
name|long
name|mask
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
name|mask
operator|&=
name|mask
operator|-
literal|1
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Return the number of instruction slots from FIRST_ADDR to SLOT_ADDR.    SLOT_FRAG is the frag containing SLOT_ADDR, and FIRST_FRAG is the frag    containing FIRST_ADDR.  */
end_comment

begin_function
name|unsigned
name|long
name|slot_index
parameter_list|(
name|slot_addr
parameter_list|,
name|slot_frag
parameter_list|,
name|first_addr
parameter_list|,
name|first_frag
parameter_list|)
name|unsigned
name|long
name|slot_addr
decl_stmt|;
name|fragS
modifier|*
name|slot_frag
decl_stmt|;
name|unsigned
name|long
name|first_addr
decl_stmt|;
name|fragS
modifier|*
name|first_frag
decl_stmt|;
block|{
name|unsigned
name|long
name|index
init|=
literal|0
decl_stmt|;
comment|/* First time we are called, the initial address and frag are invalid.  */
if|if
condition|(
name|first_addr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the two addresses are in different frags, then we need to add in      the remaining size of this frag, and then the entire size of intermediate      frags.  */
while|while
condition|(
name|slot_frag
operator|!=
name|first_frag
condition|)
block|{
name|unsigned
name|long
name|start_addr
init|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|first_frag
operator|->
name|fr_literal
decl_stmt|;
comment|/* Add in the full size of the frag converted to instruction slots.  */
name|index
operator|+=
literal|3
operator|*
operator|(
name|first_frag
operator|->
name|fr_fix
operator|>>
literal|4
operator|)
expr_stmt|;
comment|/* Subtract away the initial part before first_addr.  */
name|index
operator|-=
operator|(
literal|3
operator|*
operator|(
operator|(
name|first_addr
operator|>>
literal|4
operator|)
operator|-
operator|(
name|start_addr
operator|>>
literal|4
operator|)
operator|)
operator|+
operator|(
operator|(
name|first_addr
operator|&
literal|0x3
operator|)
operator|-
operator|(
name|start_addr
operator|&
literal|0x3
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Move to the beginning of the next frag.  */
name|first_frag
operator|=
name|first_frag
operator|->
name|fr_next
expr_stmt|;
name|first_addr
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|first_frag
operator|->
name|fr_literal
expr_stmt|;
block|}
comment|/* Add in the used part of the last frag.  */
name|index
operator|+=
operator|(
literal|3
operator|*
operator|(
operator|(
name|slot_addr
operator|>>
literal|4
operator|)
operator|-
operator|(
name|first_addr
operator|>>
literal|4
operator|)
operator|)
operator|+
operator|(
operator|(
name|slot_addr
operator|&
literal|0x3
operator|)
operator|-
operator|(
name|first_addr
operator|&
literal|0x3
operator|)
operator|)
operator|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Optimize unwind record directives.  */
end_comment

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|optimize_unw_records
parameter_list|(
name|list
parameter_list|)
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|NULL
return|;
comment|/* If the only unwind record is ".prologue" or ".prologue" followed      by ".body", then we can optimize the unwind directives away.  */
if|if
condition|(
name|list
operator|->
name|r
operator|.
name|type
operator|==
name|prologue
operator|&&
operator|(
name|list
operator|->
name|next
operator|==
name|NULL
operator|||
operator|(
name|list
operator|->
name|next
operator|->
name|r
operator|.
name|type
operator|==
name|body
operator|&&
name|list
operator|->
name|next
operator|->
name|next
operator|==
name|NULL
operator|)
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Given a complete record list, process any records which have    unresolved fields, (ie length counts for a prologue).  After    this has been run, all neccessary information should be available    within each record to generate an image.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_unw_records
parameter_list|(
name|list
parameter_list|)
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|region
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|first_addr
init|=
literal|0
decl_stmt|,
name|rlen
init|=
literal|0
decl_stmt|,
name|t
decl_stmt|;
name|fragS
modifier|*
name|first_frag
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|slot_number
operator|==
name|SLOT_NUM_NOT_SET
condition|)
name|as_bad
argument_list|(
literal|" Insn slot not set in unwind record."
argument_list|)
expr_stmt|;
name|t
operator|=
name|slot_index
argument_list|(
name|ptr
operator|->
name|slot_number
argument_list|,
name|ptr
operator|->
name|slot_frag
argument_list|,
name|first_addr
argument_list|,
name|first_frag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
condition|)
block|{
case|case
name|prologue
case|:
case|case
name|prologue_gr
case|:
case|case
name|body
case|:
block|{
name|unw_rec_list
modifier|*
name|last
decl_stmt|;
name|int
name|size
decl_stmt|,
name|dir_len
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|last_addr
decl_stmt|;
name|fragS
modifier|*
name|last_frag
decl_stmt|;
name|first_addr
operator|=
name|ptr
operator|->
name|slot_number
expr_stmt|;
name|first_frag
operator|=
name|ptr
operator|->
name|slot_frag
expr_stmt|;
name|ptr
operator|->
name|slot_number
operator|=
literal|0
expr_stmt|;
comment|/* Find either the next body/prologue start, or the end of 	       the list, and determine the size of the region.  */
name|last_addr
operator|=
name|unwind
operator|.
name|next_slot_number
expr_stmt|;
name|last_frag
operator|=
name|unwind
operator|.
name|next_slot_frag
expr_stmt|;
for|for
control|(
name|last
operator|=
name|ptr
operator|->
name|next
init|;
name|last
operator|!=
name|NULL
condition|;
name|last
operator|=
name|last
operator|->
name|next
control|)
if|if
condition|(
name|last
operator|->
name|r
operator|.
name|type
operator|==
name|prologue
operator|||
name|last
operator|->
name|r
operator|.
name|type
operator|==
name|prologue_gr
operator|||
name|last
operator|->
name|r
operator|.
name|type
operator|==
name|body
condition|)
block|{
name|last_addr
operator|=
name|last
operator|->
name|slot_number
expr_stmt|;
name|last_frag
operator|=
name|last
operator|->
name|slot_frag
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|last
operator|->
name|next
condition|)
block|{
comment|/* In the absence of an explicit .body directive, 		     the prologue ends after the last instruction 		     covered by an unwind directive.  */
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
operator|!=
name|body
condition|)
block|{
name|last_addr
operator|=
name|last
operator|->
name|slot_number
expr_stmt|;
name|last_frag
operator|=
name|last
operator|->
name|slot_frag
expr_stmt|;
switch|switch
condition|(
name|last
operator|->
name|r
operator|.
name|type
condition|)
block|{
case|case
name|frgr_mem
case|:
name|dir_len
operator|=
operator|(
name|count_bits
argument_list|(
name|last
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
argument_list|)
operator|+
name|count_bits
argument_list|(
name|last
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|fr_mem
case|:
case|case
name|gr_mem
case|:
name|dir_len
operator|+=
name|count_bits
argument_list|(
name|last
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|rmask
argument_list|)
expr_stmt|;
break|break;
case|case
name|br_mem
case|:
case|case
name|br_gr
case|:
name|dir_len
operator|+=
name|count_bits
argument_list|(
name|last
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
argument_list|)
expr_stmt|;
break|break;
case|case
name|gr_gr
case|:
name|dir_len
operator|+=
name|count_bits
argument_list|(
name|last
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dir_len
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
name|size
operator|=
operator|(
name|slot_index
argument_list|(
name|last_addr
argument_list|,
name|last_frag
argument_list|,
name|first_addr
argument_list|,
name|first_frag
argument_list|)
operator|+
name|dir_len
operator|)
expr_stmt|;
name|rlen
operator|=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
operator|=
name|size
expr_stmt|;
name|region
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
case|case
name|epilogue
case|:
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|t
operator|=
name|rlen
operator|-
literal|1
operator|-
name|t
expr_stmt|;
break|break;
case|case
name|mem_stack_f
case|:
case|case
name|mem_stack_v
case|:
case|case
name|rp_when
case|:
case|case
name|pfs_when
case|:
case|case
name|preds_when
case|:
case|case
name|unat_when
case|:
case|case
name|lc_when
case|:
case|case
name|fpsr_when
case|:
case|case
name|priunat_when_gr
case|:
case|case
name|priunat_when_mem
case|:
case|case
name|bsp_when
case|:
case|case
name|bspstore_when
case|:
case|case
name|rnat_when
case|:
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|t
operator|=
name|t
expr_stmt|;
break|break;
case|case
name|spill_reg
case|:
case|case
name|spill_sprel
case|:
case|case
name|spill_psprel
case|:
case|case
name|spill_reg_p
case|:
case|case
name|spill_sprel_p
case|:
case|case
name|spill_psprel_p
case|:
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
operator|=
name|t
expr_stmt|;
break|break;
case|case
name|frgr_mem
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"frgr_mem record before region record!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|fr_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
expr_stmt|;
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|gr_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
argument_list|,
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|fr_mem
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"fr_mem record before region record!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|fr_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|rmask
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|rmask
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|gr_mem
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"gr_mem record before region record!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|gr_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|rmask
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|rmask
argument_list|,
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|br_mem
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"br_mem record before region record!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|br_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
argument_list|,
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|gr_gr
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"gr_gr record before region record!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
argument_list|,
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|br_gr
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"br_gr record before region record!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
argument_list|,
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper routine for output_unw_records.  Emits the header for the unwind    info.  */
end_comment

begin_function
specifier|static
name|int
name|setup_unwind_header
parameter_list|(
name|int
name|size
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|mem
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|extra
init|=
literal|0
decl_stmt|;
name|valueT
name|flag_value
decl_stmt|;
comment|/* pad to pointer-size boundry.  */
name|x
operator|=
name|size
operator|%
name|md
operator|.
name|pointer_size
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|extra
operator|=
name|md
operator|.
name|pointer_size
operator|-
name|x
expr_stmt|;
comment|/* Add 8 for the header + a pointer for the       personality offset.  */
operator|*
name|mem
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
name|extra
operator|+
literal|8
operator|+
name|md
operator|.
name|pointer_size
argument_list|)
expr_stmt|;
comment|/* Clear the padding area and personality.  */
name|memset
argument_list|(
operator|*
name|mem
operator|+
literal|8
operator|+
name|size
argument_list|,
literal|0
argument_list|,
name|extra
operator|+
name|md
operator|.
name|pointer_size
argument_list|)
expr_stmt|;
comment|/* Initialize the header area.  */
if|if
condition|(
name|unwind
operator|.
name|personality_routine
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
name|flag_value
operator|=
operator|(
name|bfd_vma
operator|)
literal|3
operator|<<
literal|32
expr_stmt|;
else|else
comment|/* 32-bit unwind info block.  */
name|flag_value
operator|=
operator|(
name|bfd_vma
operator|)
literal|0x1003
operator|<<
literal|32
expr_stmt|;
block|}
else|else
name|flag_value
operator|=
literal|0
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|mem
argument_list|,
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|48
operator|)
comment|/* Version.  */
operator||
name|flag_value
comment|/* U& E handler flags.  */
operator||
operator|(
operator|(
name|size
operator|+
name|extra
operator|)
operator|/
name|md
operator|.
name|pointer_size
operator|)
operator|)
argument_list|,
comment|/* Length.  */
literal|8
argument_list|)
expr_stmt|;
return|return
name|extra
return|;
block|}
end_function

begin_comment
comment|/* Generate an unwind image from a record list.  Returns the number of    bytes in the resulting image. The memory image itselof is returned    in the 'ptr' parameter.  */
end_comment

begin_function
specifier|static
name|int
name|output_unw_records
parameter_list|(
name|list
parameter_list|,
name|ptr
parameter_list|)
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
name|void
modifier|*
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|extra
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
operator|*
name|ptr
operator|=
name|NULL
expr_stmt|;
name|list
operator|=
name|optimize_unw_records
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|fixup_unw_records
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|size
operator|=
name|calc_record_size
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|||
name|unwind
operator|.
name|force_unwind_entry
condition|)
block|{
name|unwind
operator|.
name|force_unwind_entry
operator|=
literal|0
expr_stmt|;
name|extra
operator|=
name|setup_unwind_header
argument_list|(
name|size
argument_list|,
operator|&
name|mem
argument_list|)
expr_stmt|;
name|vbyte_mem_ptr
operator|=
name|mem
operator|+
literal|8
expr_stmt|;
name|process_unw_records
argument_list|(
name|list
argument_list|,
name|output_vbyte_mem
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|mem
expr_stmt|;
name|size
operator|+=
name|extra
operator|+
literal|8
operator|+
name|md
operator|.
name|pointer_size
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|convert_expr_to_ab_reg
parameter_list|(
name|e
parameter_list|,
name|ab
parameter_list|,
name|regp
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
modifier|*
name|ab
decl_stmt|;
name|unsigned
name|int
modifier|*
name|regp
decl_stmt|;
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_register
condition|)
return|return
literal|0
return|;
name|reg
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
operator|(
name|REG_GR
operator|+
literal|4
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_GR
operator|+
literal|7
operator|)
condition|)
block|{
operator|*
name|ab
operator|=
literal|0
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_GR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|reg
operator|>=
operator|(
name|REG_FR
operator|+
literal|2
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_FR
operator|+
literal|5
operator|)
operator|)
operator|||
operator|(
name|reg
operator|>=
operator|(
name|REG_FR
operator|+
literal|16
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_FR
operator|+
literal|31
operator|)
operator|)
condition|)
block|{
operator|*
name|ab
operator|=
literal|1
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_FR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
operator|(
name|REG_BR
operator|+
literal|1
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_BR
operator|+
literal|5
operator|)
condition|)
block|{
operator|*
name|ab
operator|=
literal|2
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_BR
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ab
operator|=
literal|3
expr_stmt|;
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|REG_PR
case|:
operator|*
name|regp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REG_PSP
case|:
operator|*
name|regp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|REG_PRIUNAT
case|:
operator|*
name|regp
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|REG_BR
operator|+
literal|0
case|:
operator|*
name|regp
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_BSP
case|:
operator|*
name|regp
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_BSPSTORE
case|:
operator|*
name|regp
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_RNAT
case|:
operator|*
name|regp
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_UNAT
case|:
operator|*
name|regp
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_FPSR
case|:
operator|*
name|regp
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_PFS
case|:
operator|*
name|regp
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_LC
case|:
operator|*
name|regp
operator|=
literal|10
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|convert_expr_to_xy_reg
parameter_list|(
name|e
parameter_list|,
name|xy
parameter_list|,
name|regp
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
modifier|*
name|xy
decl_stmt|;
name|unsigned
name|int
modifier|*
name|regp
decl_stmt|;
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_register
condition|)
return|return
literal|0
return|;
name|reg
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
comment|/* reg>= REG_GR&& */
name|reg
operator|<=
operator|(
name|REG_GR
operator|+
literal|127
operator|)
condition|)
block|{
operator|*
name|xy
operator|=
literal|0
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_GR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
name|REG_FR
operator|&&
name|reg
operator|<=
operator|(
name|REG_FR
operator|+
literal|127
operator|)
condition|)
block|{
operator|*
name|xy
operator|=
literal|1
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_FR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
name|REG_BR
operator|&&
name|reg
operator|<=
operator|(
name|REG_BR
operator|+
literal|7
operator|)
condition|)
block|{
operator|*
name|xy
operator|=
literal|2
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_BR
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_radix
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|radix
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|radix
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|radix
operator|!=
literal|'C'
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|radix
index|]
condition|)
block|{
name|as_bad
argument_list|(
literal|"Radix `%c' unsupported"
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* .sbss, .bss etc. are macros that expand into ".section SECNAME".  */
end_comment

begin_function
specifier|static
name|void
name|dot_special_section
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
name|set_section
argument_list|(
operator|(
name|char
operator|*
operator|)
name|special_section_name
index|[
name|which
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_unwind_entry
parameter_list|(
name|ptr
parameter_list|)
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
block|{
if|if
condition|(
name|unwind
operator|.
name|tail
condition|)
name|unwind
operator|.
name|tail
operator|->
name|next
operator|=
name|ptr
expr_stmt|;
else|else
name|unwind
operator|.
name|list
operator|=
name|ptr
expr_stmt|;
name|unwind
operator|.
name|tail
operator|=
name|ptr
expr_stmt|;
comment|/* The current entry can in fact be a chain of unwind entries.  */
if|if
condition|(
name|unwind
operator|.
name|current_entry
operator|==
name|NULL
condition|)
name|unwind
operator|.
name|current_entry
operator|=
name|ptr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_fframe
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"Operand to .fframe must be a constant"
argument_list|)
expr_stmt|;
else|else
name|add_unwind_entry
argument_list|(
name|output_mem_stack_f
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_vframe
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
name|reg
operator|=
name|e
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|reg
operator|<
literal|128
condition|)
block|{
name|add_unwind_entry
argument_list|(
name|output_mem_stack_v
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|unwind
operator|.
name|prologue_mask
operator|&
literal|2
operator|)
condition|)
name|add_unwind_entry
argument_list|(
name|output_psp_gr
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"First operand to .vframe must be a general register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_vframesp
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|add_unwind_entry
argument_list|(
name|output_mem_stack_v
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_psp_sprel
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"First operand to .vframesp must be a general register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_vframepsp
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|add_unwind_entry
argument_list|(
name|output_mem_stack_v
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_psp_sprel
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"First operand to .vframepsp must be a general register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_save
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|int
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
literal|"No second operand to .save"
argument_list|)
expr_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|e1
operator|.
name|X_add_number
expr_stmt|;
name|reg2
operator|=
name|e2
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
comment|/* Make sure its a valid ar.xxx reg, OR its br0, aka 'rp'.  */
if|if
condition|(
name|e1
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
if|if
condition|(
name|e2
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|reg2
operator|>=
literal|0
operator|&&
name|reg2
operator|<
literal|128
condition|)
block|{
switch|switch
condition|(
name|reg1
condition|)
block|{
case|case
name|REG_AR
operator|+
name|AR_BSP
case|:
name|add_unwind_entry
argument_list|(
name|output_bsp_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_bsp_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_BSPSTORE
case|:
name|add_unwind_entry
argument_list|(
name|output_bspstore_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_bspstore_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_RNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_rnat_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_rnat_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_UNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_unat_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_unat_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_FPSR
case|:
name|add_unwind_entry
argument_list|(
name|output_fpsr_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_fpsr_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_PFS
case|:
name|add_unwind_entry
argument_list|(
name|output_pfs_when
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|unwind
operator|.
name|prologue_mask
operator|&
literal|4
operator|)
condition|)
name|add_unwind_entry
argument_list|(
name|output_pfs_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_LC
case|:
name|add_unwind_entry
argument_list|(
name|output_lc_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_lc_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_BR
case|:
name|add_unwind_entry
argument_list|(
name|output_rp_when
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|unwind
operator|.
name|prologue_mask
operator|&
literal|8
operator|)
condition|)
name|add_unwind_entry
argument_list|(
name|output_rp_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_PR
case|:
name|add_unwind_entry
argument_list|(
name|output_preds_when
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|unwind
operator|.
name|prologue_mask
operator|&
literal|1
operator|)
condition|)
name|add_unwind_entry
argument_list|(
name|output_preds_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_PRIUNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_priunat_when_gr
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_priunat_gr
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"First operand not a valid register"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|as_bad
argument_list|(
literal|" Second operand not a valid register"
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"First operand not a register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_restore
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|unsigned
name|long
name|ecount
decl_stmt|;
comment|/* # of _additional_ regions to pop */
name|int
name|sep
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|e1
operator|.
name|X_add_number
operator|!=
name|REG_GR
operator|+
literal|12
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .restore must be stack pointer (sp)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
block|{
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|e2
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .restore must be a constant>= 0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ecount
operator|=
name|e2
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
name|ecount
operator|=
name|unwind
operator|.
name|prologue_count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ecount
operator|>=
name|unwind
operator|.
name|prologue_count
condition|)
block|{
name|as_bad
argument_list|(
literal|"Epilogue count of %lu exceeds number of nested prologues (%u)"
argument_list|,
name|ecount
operator|+
literal|1
argument_list|,
name|unwind
operator|.
name|prologue_count
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_unwind_entry
argument_list|(
name|output_epilogue
argument_list|(
name|ecount
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecount
operator|<
name|unwind
operator|.
name|prologue_count
condition|)
name|unwind
operator|.
name|prologue_count
operator|-=
name|ecount
operator|+
literal|1
expr_stmt|;
else|else
name|unwind
operator|.
name|prologue_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_restorereg
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|convert_expr_to_ab_reg
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .restorereg must be a preserved register"
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_unwind_entry
argument_list|(
name|output_spill_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_restorereg_p
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|qp
decl_stmt|,
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"No second operand to .restorereg.p"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
name|qp
operator|=
name|e1
operator|.
name|X_add_number
operator|-
name|REG_P
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|qp
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .restorereg.p must be a predicate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|convert_expr_to_ab_reg
argument_list|(
operator|&
name|e2
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .restorereg.p must be a preserved register"
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_unwind_entry
argument_list|(
name|output_spill_reg_p
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|qp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|generate_unwind_image
parameter_list|(
name|text_name
parameter_list|)
specifier|const
name|char
modifier|*
name|text_name
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|unw_rec
decl_stmt|;
comment|/* Force out pending instructions, to make sure all unwind records have      a valid slot_number field.  */
name|ia64_flush_insns
argument_list|()
expr_stmt|;
comment|/* Generate the unwind record.  */
name|size
operator|=
name|output_unw_records
argument_list|(
name|unwind
operator|.
name|list
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|unw_rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|md
operator|.
name|pointer_size
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
literal|"Unwind record is not a multiple of %d bytes."
argument_list|,
name|md
operator|.
name|pointer_size
argument_list|)
expr_stmt|;
comment|/* If there are unwind records, switch sections, and output the info.  */
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|where
decl_stmt|;
name|char
modifier|*
name|sec_name
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|make_unw_section_name
argument_list|(
name|SPECIAL_SECTION_UNWIND_INFO
argument_list|,
name|text_name
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
name|set_section
argument_list|(
name|sec_name
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|,
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
comment|/* Make sure the section has 4 byte alignment for ILP32 and 	 8 byte alignment for LP64.  */
name|frag_align
argument_list|(
name|md
operator|.
name|pointer_size_shift
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|md
operator|.
name|pointer_size_shift
argument_list|)
expr_stmt|;
comment|/* Set expression which points to start of unwind descriptor area.  */
name|unwind
operator|.
name|info
operator|=
name|expr_build_dot
argument_list|()
expr_stmt|;
name|where
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Issue a label for this address, and keep track of it to put it 	 in the unwind section.  */
comment|/* Copy the information from the unwind record into this section. The 	 data is already in the correct byte order.  */
name|memcpy
argument_list|(
name|where
argument_list|,
name|unw_rec
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Add the personality address to the image.  */
if|if
condition|(
name|unwind
operator|.
name|personality_routine
operator|!=
literal|0
condition|)
block|{
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|unwind
operator|.
name|personality_routine
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_BE
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
name|reloc
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR64MSB
expr_stmt|;
else|else
name|reloc
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR32MSB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
name|reloc
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR64LSB
expr_stmt|;
else|else
name|reloc
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR32LSB
expr_stmt|;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
name|md
operator|.
name|pointer_size
argument_list|,
name|md
operator|.
name|pointer_size
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|personality_routine
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free_list_records
argument_list|(
name|unwind
operator|.
name|list
argument_list|)
expr_stmt|;
name|free_saved_prologue_counts
argument_list|()
expr_stmt|;
name|unwind
operator|.
name|list
operator|=
name|unwind
operator|.
name|tail
operator|=
name|unwind
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_handlerdata
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|text_name
init|=
name|segment_name
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
comment|/* If text section name starts with ".text" (which it should),      strip this prefix off.  */
if|if
condition|(
name|strcmp
argument_list|(
name|text_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|text_name
operator|=
literal|""
expr_stmt|;
name|unwind
operator|.
name|force_unwind_entry
operator|=
literal|1
expr_stmt|;
comment|/* Remember which segment we're in so we can switch back after .endp */
name|unwind
operator|.
name|saved_text_seg
operator|=
name|now_seg
expr_stmt|;
name|unwind
operator|.
name|saved_text_subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* Generate unwind info into unwind-info section and then leave that      section as the currently active one so dataXX directives go into      the language specific data area of the unwind info block.  */
name|generate_unwind_image
argument_list|(
name|text_name
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_unwentry
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unwind
operator|.
name|force_unwind_entry
operator|=
literal|1
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_altrp
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
name|reg
operator|=
name|e
operator|.
name|X_add_number
operator|-
name|REG_BR
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|reg
operator|<
literal|8
condition|)
name|add_unwind_entry
argument_list|(
name|output_rp_br
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"First operand not a valid branch register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_savemem
parameter_list|(
name|psprel
parameter_list|)
name|int
name|psprel
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|int
name|reg1
decl_stmt|,
name|val
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
literal|"No second operand to .save%ssp"
argument_list|,
name|psprel
condition|?
literal|"p"
else|:
literal|""
argument_list|)
expr_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|e1
operator|.
name|X_add_number
expr_stmt|;
name|val
operator|=
name|e2
operator|.
name|X_add_number
expr_stmt|;
comment|/* Make sure its a valid ar.xxx reg, OR its br0, aka 'rp'.  */
if|if
condition|(
name|e1
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
if|if
condition|(
name|e2
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
switch|switch
condition|(
name|reg1
condition|)
block|{
case|case
name|REG_AR
operator|+
name|AR_BSP
case|:
name|add_unwind_entry
argument_list|(
name|output_bsp_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_bsp_psprel
else|:
name|output_bsp_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_BSPSTORE
case|:
name|add_unwind_entry
argument_list|(
name|output_bspstore_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_bspstore_psprel
else|:
name|output_bspstore_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_RNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_rnat_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_rnat_psprel
else|:
name|output_rnat_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_UNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_unat_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_unat_psprel
else|:
name|output_unat_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_FPSR
case|:
name|add_unwind_entry
argument_list|(
name|output_fpsr_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_fpsr_psprel
else|:
name|output_fpsr_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_PFS
case|:
name|add_unwind_entry
argument_list|(
name|output_pfs_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_pfs_psprel
else|:
name|output_pfs_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_LC
case|:
name|add_unwind_entry
argument_list|(
name|output_lc_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_lc_psprel
else|:
name|output_lc_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_BR
case|:
name|add_unwind_entry
argument_list|(
name|output_rp_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_rp_psprel
else|:
name|output_rp_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_PR
case|:
name|add_unwind_entry
argument_list|(
name|output_preds_when
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_preds_psprel
else|:
name|output_preds_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_PRIUNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_priunat_when_mem
argument_list|()
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_priunat_psprel
else|:
name|output_priunat_sprel
operator|)
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"First operand not a valid register"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|as_bad
argument_list|(
literal|" Second operand not a valid constant"
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"First operand not a register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_saveg
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"First operand to .save.g must be a constant."
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|grmask
init|=
name|e1
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
name|add_unwind_entry
argument_list|(
name|output_gr_mem
argument_list|(
name|grmask
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|reg
init|=
name|e2
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|e2
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<
literal|128
condition|)
name|add_unwind_entry
argument_list|(
name|output_gr_gr
argument_list|(
name|grmask
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Second operand is an invalid register."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dot_savef
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"Operand to .save.f must be a constant."
argument_list|)
expr_stmt|;
else|else
name|add_unwind_entry
argument_list|(
name|output_fr_mem
argument_list|(
name|e1
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_saveb
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|char
name|sep
decl_stmt|;
name|int
name|brmask
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .save.b must be a constant."
argument_list|)
expr_stmt|;
return|return;
block|}
name|brmask
operator|=
name|e1
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
block|{
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
name|reg
operator|=
name|e2
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
if|if
condition|(
name|e2
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|reg
operator|>
literal|127
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .save.b must be a general register."
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_unwind_entry
argument_list|(
name|output_br_gr
argument_list|(
name|brmask
argument_list|,
name|e2
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|add_unwind_entry
argument_list|(
name|output_br_mem
argument_list|(
name|brmask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
name|sep
index|]
operator|&&
operator|!
name|is_it_end_of_statement
argument_list|()
condition|)
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_savegf
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|sep
operator|!=
literal|','
operator|||
name|e2
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"Both operands of .save.gf must be constants."
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|grmask
init|=
name|e1
operator|.
name|X_add_number
decl_stmt|;
name|int
name|frmask
init|=
name|e2
operator|.
name|X_add_number
decl_stmt|;
name|add_unwind_entry
argument_list|(
name|output_frgr_mem
argument_list|(
name|grmask
argument_list|,
name|frmask
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dot_spill
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|unsigned
name|char
name|sep
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
name|sep
index|]
operator|&&
operator|!
name|is_it_end_of_statement
argument_list|()
condition|)
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"Operand to .spill must be a constant"
argument_list|)
expr_stmt|;
else|else
name|add_unwind_entry
argument_list|(
name|output_spill_base
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_spillreg
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|sep
decl_stmt|,
name|ab
decl_stmt|,
name|xy
decl_stmt|,
name|reg
decl_stmt|,
name|treg
decl_stmt|;
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"No second operand to .spillreg"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|convert_expr_to_ab_reg
argument_list|(
operator|&
name|e1
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .spillreg must be a preserved register"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|convert_expr_to_xy_reg
argument_list|(
operator|&
name|e2
argument_list|,
operator|&
name|xy
argument_list|,
operator|&
name|treg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .spillreg must be a register"
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_unwind_entry
argument_list|(
name|output_spill_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
name|treg
argument_list|,
name|xy
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_spillmem
parameter_list|(
name|psprel
parameter_list|)
name|int
name|psprel
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|sep
decl_stmt|,
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand missing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|convert_expr_to_ab_reg
argument_list|(
operator|&
name|e1
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .spill%s must be a preserved register"
argument_list|,
name|psprel
condition|?
literal|"psp"
else|:
literal|"sp"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|e2
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .spill%s must be a constant"
argument_list|,
name|psprel
condition|?
literal|"psp"
else|:
literal|"sp"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|psprel
condition|)
name|add_unwind_entry
argument_list|(
name|output_spill_psprel
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
name|e2
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_unwind_entry
argument_list|(
name|output_spill_sprel
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
name|e2
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_spillreg_p
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|sep
decl_stmt|,
name|ab
decl_stmt|,
name|xy
decl_stmt|,
name|reg
decl_stmt|,
name|treg
decl_stmt|;
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|;
name|unsigned
name|int
name|qp
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"No second and third operand to .spillreg.p"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"No third operand to .spillreg.p"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse_operand
argument_list|(
operator|&
name|e3
argument_list|)
expr_stmt|;
name|qp
operator|=
name|e1
operator|.
name|X_add_number
operator|-
name|REG_P
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|qp
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .spillreg.p must be a predicate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|convert_expr_to_ab_reg
argument_list|(
operator|&
name|e2
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .spillreg.p must be a preserved register"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|convert_expr_to_xy_reg
argument_list|(
operator|&
name|e3
argument_list|,
operator|&
name|xy
argument_list|,
operator|&
name|treg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Third operand to .spillreg.p must be a register"
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_unwind_entry
argument_list|(
name|output_spill_reg_p
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
name|treg
argument_list|,
name|xy
argument_list|,
name|qp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_spillmem_p
parameter_list|(
name|psprel
parameter_list|)
name|int
name|psprel
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|;
name|int
name|sep
decl_stmt|,
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|unsigned
name|int
name|qp
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand missing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand missing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse_operand
argument_list|(
operator|&
name|e3
argument_list|)
expr_stmt|;
name|qp
operator|=
name|e1
operator|.
name|X_add_number
operator|-
name|REG_P
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|qp
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .spill%s_p must be a predicate"
argument_list|,
name|psprel
condition|?
literal|"psp"
else|:
literal|"sp"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|convert_expr_to_ab_reg
argument_list|(
operator|&
name|e2
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .spill%s_p must be a preserved register"
argument_list|,
name|psprel
condition|?
literal|"psp"
else|:
literal|"sp"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|e3
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Third operand to .spill%s_p must be a constant"
argument_list|,
name|psprel
condition|?
literal|"psp"
else|:
literal|"sp"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|psprel
condition|)
name|add_unwind_entry
argument_list|(
name|output_spill_psprel_p
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
name|e3
operator|.
name|X_add_number
argument_list|,
name|qp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_unwind_entry
argument_list|(
name|output_spill_sprel_p
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
name|e3
operator|.
name|X_add_number
argument_list|,
name|qp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|get_saved_prologue_count
parameter_list|(
name|lbl
parameter_list|)
name|unsigned
name|long
name|lbl
decl_stmt|;
block|{
name|label_prologue_count
modifier|*
name|lpc
init|=
name|unwind
operator|.
name|saved_prologue_counts
decl_stmt|;
while|while
condition|(
name|lpc
operator|!=
name|NULL
operator|&&
name|lpc
operator|->
name|label_number
operator|!=
name|lbl
condition|)
name|lpc
operator|=
name|lpc
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lpc
operator|!=
name|NULL
condition|)
return|return
name|lpc
operator|->
name|prologue_count
return|;
name|as_bad
argument_list|(
literal|"Missing .label_state %ld"
argument_list|,
name|lbl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_prologue_count
parameter_list|(
name|lbl
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|long
name|lbl
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|{
name|label_prologue_count
modifier|*
name|lpc
init|=
name|unwind
operator|.
name|saved_prologue_counts
decl_stmt|;
while|while
condition|(
name|lpc
operator|!=
name|NULL
operator|&&
name|lpc
operator|->
name|label_number
operator|!=
name|lbl
condition|)
name|lpc
operator|=
name|lpc
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lpc
operator|!=
name|NULL
condition|)
name|lpc
operator|->
name|prologue_count
operator|=
name|count
expr_stmt|;
else|else
block|{
name|label_prologue_count
modifier|*
name|new_lpc
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_lpc
argument_list|)
argument_list|)
decl_stmt|;
name|new_lpc
operator|->
name|next
operator|=
name|unwind
operator|.
name|saved_prologue_counts
expr_stmt|;
name|new_lpc
operator|->
name|label_number
operator|=
name|lbl
expr_stmt|;
name|new_lpc
operator|->
name|prologue_count
operator|=
name|count
expr_stmt|;
name|unwind
operator|.
name|saved_prologue_counts
operator|=
name|new_lpc
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_saved_prologue_counts
parameter_list|()
block|{
name|label_prologue_count
modifier|*
name|lpc
init|=
name|unwind
operator|.
name|saved_prologue_counts
decl_stmt|;
name|label_prologue_count
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|lpc
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|lpc
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|lpc
argument_list|)
expr_stmt|;
name|lpc
operator|=
name|next
expr_stmt|;
block|}
name|unwind
operator|.
name|saved_prologue_counts
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_label_state
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Operand to .label_state must be a constant"
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_unwind_entry
argument_list|(
name|output_label_state
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
name|save_prologue_count
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|,
name|unwind
operator|.
name|prologue_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_copy_state
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Operand to .copy_state must be a constant"
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_unwind_entry
argument_list|(
name|output_copy_state
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|prologue_count
operator|=
name|get_saved_prologue_count
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_unwabi
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|unsigned
name|char
name|sep
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .unwabi missing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
name|sep
index|]
operator|&&
operator|!
name|is_it_end_of_statement
argument_list|()
condition|)
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .unwabi must be a constant"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|e2
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .unwabi must be a constant"
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_unwind_entry
argument_list|(
name|output_unwabi
argument_list|(
name|e1
operator|.
name|X_add_number
argument_list|,
name|e2
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_personality
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|unwind
operator|.
name|personality_routine
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|force_unwind_entry
operator|=
literal|1
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_proc
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|unwind
operator|.
name|proc_start
operator|=
name|expr_build_dot
argument_list|()
expr_stmt|;
comment|/* Parse names of main and alternate entry points and mark them as      function symbols:  */
while|while
condition|(
literal|1
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|proc_start
operator|==
literal|0
condition|)
block|{
name|unwind
operator|.
name|proc_start
operator|=
name|sym
expr_stmt|;
block|}
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|ia64_do_align
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|prologue_count
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|list
operator|=
name|unwind
operator|.
name|tail
operator|=
name|unwind
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
name|unwind
operator|.
name|personality_routine
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_body
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unwind
operator|.
name|prologue
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|prologue_mask
operator|=
literal|0
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_body
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_prologue
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|char
name|sep
decl_stmt|;
name|int
name|mask
init|=
literal|0
decl_stmt|,
name|grsave
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
literal|"No second operand to .prologue"
argument_list|)
expr_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
name|sep
index|]
operator|&&
operator|!
name|is_it_end_of_statement
argument_list|()
condition|)
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|mask
operator|=
name|e1
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|e2
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|grsave
operator|=
name|e2
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|e2
operator|.
name|X_op
operator|==
name|O_register
operator|&&
operator|(
name|grsave
operator|=
name|e2
operator|.
name|X_add_number
operator|-
name|REG_GR
operator|)
operator|<
literal|128
condition|)
empty_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Second operand not a constant or general register"
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_prologue_gr
argument_list|(
name|mask
argument_list|,
name|grsave
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"First operand not a constant"
argument_list|)
expr_stmt|;
block|}
else|else
name|add_unwind_entry
argument_list|(
name|output_prologue
argument_list|()
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|prologue
operator|=
literal|1
expr_stmt|;
name|unwind
operator|.
name|prologue_mask
operator|=
name|mask
expr_stmt|;
operator|++
name|unwind
operator|.
name|prologue_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_endp
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|bytes_per_address
decl_stmt|;
name|long
name|where
decl_stmt|;
name|segT
name|saved_seg
decl_stmt|;
name|subsegT
name|saved_subseg
decl_stmt|;
specifier|const
name|char
modifier|*
name|sec_name
decl_stmt|,
modifier|*
name|text_name
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|unwind
operator|.
name|saved_text_seg
condition|)
block|{
name|saved_seg
operator|=
name|unwind
operator|.
name|saved_text_seg
expr_stmt|;
name|saved_subseg
operator|=
name|unwind
operator|.
name|saved_text_subseg
expr_stmt|;
name|unwind
operator|.
name|saved_text_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|saved_seg
operator|=
name|now_seg
expr_stmt|;
name|saved_subseg
operator|=
name|now_subseg
expr_stmt|;
block|}
comment|/*     Use a slightly ugly scheme to derive the unwind section names from     the text section name:      text sect.  unwind table sect.     name:       name:                      comments:     ----------  -----------------          --------------------------------     .text       .IA_64.unwind     .text.foo   .IA_64.unwind.text.foo     .foo        .IA_64.unwind.foo     .gnu.linkonce.t.foo 		.gnu.linkonce.ia64unw.foo     _info       .IA_64.unwind_info         gas issues error message (ditto)     _infoFOO    .IA_64.unwind_infoFOO      gas issues error message (ditto)      This mapping is done so that:  	(a) An object file with unwind info only in .text will use 	    unwind section names .IA_64.unwind and .IA_64.unwind_info. 	    This follows the letter of the ABI and also ensures backwards 	    compatibility with older toolchains.  	(b) An object file with unwind info in multiple text sections 	    will use separate unwind sections for each text section. 	    This allows us to properly set the "sh_info" and "sh_link" 	    fields in SHT_IA_64_UNWIND as required by the ABI and also 	    lets GNU ld support programs with multiple segments 	    containing unwind info (as might be the case for certain 	    embedded applications). 	     	(c) An error is issued if there would be a name clash.   */
name|text_name
operator|=
name|segment_name
argument_list|(
name|saved_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|text_name
argument_list|,
literal|"_info"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"Illegal section name `%s' (causes unwind section name clash)"
argument_list|,
name|text_name
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|text_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|text_name
operator|=
literal|""
expr_stmt|;
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there wasn't a .handlerdata, we haven't generated an image yet.  */
if|if
condition|(
operator|!
name|unwind
operator|.
name|info
condition|)
name|generate_unwind_image
argument_list|(
name|text_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|info
operator|||
name|unwind
operator|.
name|force_unwind_entry
condition|)
block|{
name|subseg_set
argument_list|(
name|md
operator|.
name|last_text_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|proc_end
operator|=
name|expr_build_dot
argument_list|()
expr_stmt|;
name|make_unw_section_name
argument_list|(
name|SPECIAL_SECTION_UNWIND
argument_list|,
name|text_name
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
name|set_section
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sec_name
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|,
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
comment|/* Make sure that section has 4 byte alignment for ILP32 and          8 byte alignment for LP64.  */
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|md
operator|.
name|pointer_size_shift
argument_list|)
expr_stmt|;
comment|/* Need space for 3 pointers for procedure start, procedure end, 	 and unwind info.  */
name|ptr
operator|=
name|frag_more
argument_list|(
literal|3
operator|*
name|md
operator|.
name|pointer_size
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag_now_fix
argument_list|()
operator|-
operator|(
literal|3
operator|*
name|md
operator|.
name|pointer_size
operator|)
expr_stmt|;
name|bytes_per_address
operator|=
name|bfd_arch_bits_per_address
argument_list|(
name|stdoutput
argument_list|)
operator|/
literal|8
expr_stmt|;
comment|/* Issue the values of  a) Proc Begin, b) Proc End, c) Unwind Record. */
name|e
operator|.
name|X_op
operator|=
name|O_pseudo_fixup
expr_stmt|;
name|e
operator|.
name|X_op_symbol
operator|=
name|pseudo_func
index|[
name|FUNC_SEG_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|e
operator|.
name|X_add_symbol
operator|=
name|unwind
operator|.
name|proc_start
expr_stmt|;
name|ia64_cons_fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|bytes_per_address
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_op
operator|=
name|O_pseudo_fixup
expr_stmt|;
name|e
operator|.
name|X_op_symbol
operator|=
name|pseudo_func
index|[
name|FUNC_SEG_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|e
operator|.
name|X_add_symbol
operator|=
name|unwind
operator|.
name|proc_end
expr_stmt|;
name|ia64_cons_fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
name|bytes_per_address
argument_list|,
name|bytes_per_address
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|info
condition|)
block|{
name|e
operator|.
name|X_op
operator|=
name|O_pseudo_fixup
expr_stmt|;
name|e
operator|.
name|X_op_symbol
operator|=
name|pseudo_func
index|[
name|FUNC_SEG_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|e
operator|.
name|X_add_symbol
operator|=
name|unwind
operator|.
name|info
expr_stmt|;
name|ia64_cons_fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
operator|(
name|bytes_per_address
operator|*
literal|2
operator|)
argument_list|,
name|bytes_per_address
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
else|else
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
operator|(
name|bytes_per_address
operator|*
literal|2
operator|)
argument_list|,
literal|0
argument_list|,
name|bytes_per_address
argument_list|)
expr_stmt|;
block|}
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
comment|/* Parse names of main and alternate entry points and set symbol sizes.  */
while|while
condition|(
literal|1
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|sym
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|unwind
operator|.
name|proc_start
operator|&&
operator|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|&&
name|S_GET_SIZE
argument_list|(
name|sym
argument_list|)
operator|==
literal|0
operator|&&
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|==
name|NULL
condition|)
block|{
name|fragS
modifier|*
name|fr
init|=
name|symbol_get_frag
argument_list|(
name|unwind
operator|.
name|proc_start
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|frag
init|=
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
decl_stmt|;
comment|/* Check whether the function label is at or beyond last 	     .proc directive.  */
while|while
condition|(
name|fr
operator|&&
name|fr
operator|!=
name|frag
condition|)
name|fr
operator|=
name|fr
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|fr
condition|)
block|{
if|if
condition|(
name|frag
operator|==
name|frag_now
operator|&&
name|SEG_NORMAL
argument_list|(
name|now_seg
argument_list|)
condition|)
name|S_SET_SIZE
argument_list|(
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|=
operator|(
name|expressionS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|->
name|X_add_symbol
operator|=
name|symbol_new
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|now_seg
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|->
name|X_op_symbol
operator|=
name|sym
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|unwind
operator|.
name|proc_start
operator|=
name|unwind
operator|.
name|proc_end
operator|=
name|unwind
operator|.
name|info
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_template
parameter_list|(
name|template
parameter_list|)
name|int
name|template
decl_stmt|;
block|{
name|CURR_SLOT
operator|.
name|user_template
operator|=
name|template
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_regstk
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|ins
decl_stmt|,
name|locs
decl_stmt|,
name|outs
decl_stmt|,
name|rots
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
name|ins
operator|=
name|locs
operator|=
name|outs
operator|=
name|rots
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|ins
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|err
goto|;
name|locs
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|err
goto|;
name|outs
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|err
goto|;
name|rots
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
name|set_regstack
argument_list|(
name|ins
argument_list|,
name|locs
argument_list|,
name|outs
argument_list|,
name|rots
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|as_bad
argument_list|(
literal|"Comma expected"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_rot
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|unsigned
name|num_regs
decl_stmt|,
name|num_alloced
init|=
literal|0
decl_stmt|;
name|struct
name|dynreg
modifier|*
modifier|*
name|drpp
decl_stmt|,
modifier|*
name|dr
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|base_reg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DYNREG_GR
case|:
name|base_reg
operator|=
name|REG_GR
operator|+
literal|32
expr_stmt|;
break|break;
case|case
name|DYNREG_FR
case|:
name|base_reg
operator|=
name|REG_FR
operator|+
literal|32
expr_stmt|;
break|break;
case|case
name|DYNREG_PR
case|:
name|base_reg
operator|=
name|REG_P
operator|+
literal|16
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* First, remove existing names from hash table.  */
for|for
control|(
name|dr
operator|=
name|md
operator|.
name|dynreg
index|[
name|type
index|]
init|;
name|dr
operator|&&
name|dr
operator|->
name|num_regs
condition|;
name|dr
operator|=
name|dr
operator|->
name|next
control|)
block|{
name|hash_delete
argument_list|(
name|md
operator|.
name|dynreg_hash
argument_list|,
name|dr
operator|->
name|name
argument_list|)
expr_stmt|;
name|dr
operator|->
name|num_regs
operator|=
literal|0
expr_stmt|;
block|}
name|drpp
operator|=
operator|&
name|md
operator|.
name|dynreg
index|[
name|type
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|start
operator|=
name|input_line_pointer
expr_stmt|;
name|ch
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|len
operator|=
operator|(
name|input_line_pointer
operator|-
name|start
operator|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'['
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected '['"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* skip '[' */
name|num_regs
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected ']'"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|num_alloced
operator|+=
name|num_regs
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DYNREG_GR
case|:
if|if
condition|(
name|num_alloced
operator|>
name|md
operator|.
name|rot
operator|.
name|num_regs
condition|)
block|{
name|as_bad
argument_list|(
literal|"Used more than the declared %d rotating registers"
argument_list|,
name|md
operator|.
name|rot
operator|.
name|num_regs
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|DYNREG_FR
case|:
if|if
condition|(
name|num_alloced
operator|>
literal|96
condition|)
block|{
name|as_bad
argument_list|(
literal|"Used more than the available 96 rotating registers"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|DYNREG_PR
case|:
if|if
condition|(
name|num_alloced
operator|>
literal|48
condition|)
block|{
name|as_bad
argument_list|(
literal|"Used more than the available 48 rotating registers"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
default|default:
break|break;
block|}
name|name
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|drpp
condition|)
block|{
operator|*
name|drpp
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|drpp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dr
operator|=
operator|*
name|drpp
expr_stmt|;
name|dr
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|dr
operator|->
name|num_regs
operator|=
name|num_regs
expr_stmt|;
name|dr
operator|->
name|base
operator|=
name|base_reg
expr_stmt|;
name|drpp
operator|=
operator|&
name|dr
operator|->
name|next
expr_stmt|;
name|base_reg
operator|+=
name|num_regs
expr_stmt|;
if|if
condition|(
name|hash_insert
argument_list|(
name|md
operator|.
name|dynreg_hash
argument_list|,
name|name
argument_list|,
name|dr
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Attempt to redefine register set `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* skip comma */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
name|err
label|:
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_byteorder
parameter_list|(
name|byteorder
parameter_list|)
name|int
name|byteorder
decl_stmt|;
block|{
name|target_big_endian
operator|=
name|byteorder
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_psr
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|option
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|option
operator|=
name|input_line_pointer
expr_stmt|;
name|ch
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"lsb"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|flags
operator|&=
operator|~
name|EF_IA_64_BE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"msb"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_BE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"abi32"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|flags
operator|&=
operator|~
name|EF_IA_64_ABI64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"abi64"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_ABI64
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Unknown psr option `%s'"
argument_list|,
name|option
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_alias
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_bad
argument_list|(
literal|".alias not implemented yet"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_ln
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|new_logical_line
argument_list|(
literal|0
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_section_name
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing section name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Comma expected after section name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* skip comma */
return|return
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_xdata
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|parse_section_name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return;
name|md
operator|.
name|keep_pending_output
operator|=
literal|1
expr_stmt|;
name|set_section
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|cons
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|obj_elf_previous
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|keep_pending_output
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Why doesn't float_cons() call md_cons_align() the way cons() does?  */
end_comment

begin_function
specifier|static
name|void
name|stmt_float_cons
parameter_list|(
name|kind
parameter_list|)
name|int
name|kind
decl_stmt|;
block|{
name|size_t
name|size
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'d'
case|:
name|size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|size
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
default|default:
name|size
operator|=
literal|4
expr_stmt|;
break|break;
block|}
name|ia64_do_align
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|float_cons
argument_list|(
name|kind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stmt_cons_ua
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|saved_auto_align
init|=
name|md
operator|.
name|auto_align
decl_stmt|;
name|md
operator|.
name|auto_align
operator|=
literal|0
expr_stmt|;
name|cons
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md
operator|.
name|auto_align
operator|=
name|saved_auto_align
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_xfloat_cons
parameter_list|(
name|kind
parameter_list|)
name|int
name|kind
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|parse_section_name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return;
name|md
operator|.
name|keep_pending_output
operator|=
literal|1
expr_stmt|;
name|set_section
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stmt_float_cons
argument_list|(
name|kind
argument_list|)
expr_stmt|;
name|obj_elf_previous
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|keep_pending_output
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_xstringer
parameter_list|(
name|zero
parameter_list|)
name|int
name|zero
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|parse_section_name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return;
name|md
operator|.
name|keep_pending_output
operator|=
literal|1
expr_stmt|;
name|set_section
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stringer
argument_list|(
name|zero
argument_list|)
expr_stmt|;
name|obj_elf_previous
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|keep_pending_output
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_xdata_ua
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|saved_auto_align
init|=
name|md
operator|.
name|auto_align
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|parse_section_name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return;
name|md
operator|.
name|keep_pending_output
operator|=
literal|1
expr_stmt|;
name|set_section
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|md
operator|.
name|auto_align
operator|=
literal|0
expr_stmt|;
name|cons
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md
operator|.
name|auto_align
operator|=
name|saved_auto_align
expr_stmt|;
name|obj_elf_previous
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|keep_pending_output
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_xfloat_cons_ua
parameter_list|(
name|kind
parameter_list|)
name|int
name|kind
decl_stmt|;
block|{
name|int
name|saved_auto_align
init|=
name|md
operator|.
name|auto_align
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|parse_section_name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return;
name|md
operator|.
name|keep_pending_output
operator|=
literal|1
expr_stmt|;
name|set_section
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|md
operator|.
name|auto_align
operator|=
literal|0
expr_stmt|;
name|stmt_float_cons
argument_list|(
name|kind
argument_list|)
expr_stmt|;
name|md
operator|.
name|auto_align
operator|=
name|saved_auto_align
expr_stmt|;
name|obj_elf_previous
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|keep_pending_output
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .reg.val<regname>,value */
end_comment

begin_function
specifier|static
name|void
name|dot_reg_val
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|reg
decl_stmt|;
name|expression
argument_list|(
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Register name expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Comma expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|valueT
name|value
init|=
name|get_absolute_expression
argument_list|()
decl_stmt|;
name|int
name|regno
init|=
name|reg
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|REG_GR
operator|||
name|regno
operator|>
name|REG_GR
operator|+
literal|128
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Register value annotation ignored"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|gr_values
index|[
name|regno
operator|-
name|REG_GR
index|]
operator|.
name|known
operator|=
literal|1
expr_stmt|;
name|gr_values
index|[
name|regno
operator|-
name|REG_GR
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|gr_values
index|[
name|regno
operator|-
name|REG_GR
index|]
operator|.
name|path
operator|=
name|md
operator|.
name|path
expr_stmt|;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* select dv checking mode    .auto    .explicit    .default     A stop is inserted when changing modes  */
end_comment

begin_function
specifier|static
name|void
name|dot_dv_mode
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
name|md
operator|.
name|manual_bundling
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Directive invalid within a bundle"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'E'
operator|||
name|type
operator|==
literal|'A'
condition|)
name|md
operator|.
name|mode_explicitly_set
operator|=
literal|0
expr_stmt|;
else|else
name|md
operator|.
name|mode_explicitly_set
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|detect_dv
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|md
operator|.
name|explicit_mode
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|explicit_mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|md
operator|.
name|explicit_mode
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|explicit_mode
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
case|case
literal|'d'
case|:
if|if
condition|(
name|md
operator|.
name|explicit_mode
operator|!=
name|md
operator|.
name|default_explicit_mode
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|explicit_mode
operator|=
name|md
operator|.
name|default_explicit_mode
expr_stmt|;
name|md
operator|.
name|mode_explicitly_set
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_prmask
parameter_list|(
name|mask
parameter_list|)
name|valueT
name|mask
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|comma
init|=
literal|""
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|64
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s p%d"
argument_list|,
name|comma
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   .pred.rel.clear [p1 [,p2 [,...]]]     (also .pred.rel "clear")   .pred.rel.imply p1, p2                (also .pred.rel "imply")   .pred.rel.mutex p1, p2 [,...]         (also .pred.rel "mutex")   .pred.safe_across_calls p1 [, p2 [,...]]  */
end_comment

begin_function
specifier|static
name|void
name|dot_pred_rel
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|p1
init|=
operator|-
literal|1
decl_stmt|,
name|p2
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing predicate relation type"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|form
init|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|form
argument_list|,
literal|"mutex"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
literal|'m'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|form
argument_list|,
literal|"clear"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
literal|'c'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|form
argument_list|,
literal|"imply"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
literal|'i'
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized predicate relation type"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|valueT
name|bit
init|=
literal|1
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|TOUPPER
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|!=
literal|'P'
operator|||
operator|(
name|regno
operator|=
name|atoi
argument_list|(
operator|++
name|input_line_pointer
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|regno
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Predicate register expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|p1
operator|==
operator|-
literal|1
condition|)
name|p1
operator|=
name|regno
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
operator|==
operator|-
literal|1
condition|)
name|p2
operator|=
name|regno
expr_stmt|;
name|bit
operator|<<=
name|regno
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|bit
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Duplicate predicate register ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator||=
name|bit
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* See if it's a range.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
block|{
name|valueT
name|stop
init|=
literal|1
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|TOUPPER
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|!=
literal|'P'
operator|||
operator|(
name|regno
operator|=
name|atoi
argument_list|(
operator|++
name|input_line_pointer
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|regno
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Predicate register expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|stop
operator|<<=
name|regno
expr_stmt|;
if|if
condition|(
name|bit
operator|>=
name|stop
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bad register range"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|bit
operator|<
name|stop
condition|)
block|{
name|bit
operator|<<=
literal|1
expr_stmt|;
name|mask
operator||=
name|bit
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|mask
operator|=
operator|~
operator|(
name|valueT
operator|)
literal|0
expr_stmt|;
name|clear_qp_mutex
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
name|mask
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|count
operator|!=
literal|2
operator|||
name|p1
operator|==
operator|-
literal|1
operator|||
name|p2
operator|==
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Predicate source and target required"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|==
literal|0
operator|||
name|p2
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Use of p0 is not valid in this context"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_qp_imply
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|count
operator|<
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"At least two PR arguments expected"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Use of p0 is not valid in this context"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|add_qp_mutex
argument_list|(
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* note that we don't override any existing relations */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"At least one PR argument expected"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Safe across calls: "
argument_list|)
expr_stmt|;
name|print_prmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|qp_safe_across_calls
operator|=
name|mask
expr_stmt|;
break|break;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .entry label [, label [, ...]]    Hint to DV code that the given labels are to be considered entry points.    Otherwise, only global labels are considered entry points.  */
end_comment

begin_function
specifier|static
name|void
name|dot_entry
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|hash_insert
argument_list|(
name|md
operator|.
name|entry_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Inserting \"%s\" into entry hint table failed: %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .mem.offset offset, base    "base" is used to distinguish between offsets from a different base.  */
end_comment

begin_function
specifier|static
name|void
name|dot_mem_offset
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|md
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|mem_offset
operator|.
name|offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Comma expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|md
operator|.
name|mem_offset
operator|.
name|base
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ia64-specific pseudo-ops:  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"radix"
block|,
name|dot_radix
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|s_lcomm_bytes
block|,
literal|1
block|}
block|,
block|{
literal|"bss"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_BSS
block|}
block|,
block|{
literal|"sbss"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_SBSS
block|}
block|,
block|{
literal|"sdata"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_SDATA
block|}
block|,
block|{
literal|"rodata"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_RODATA
block|}
block|,
block|{
literal|"comment"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_COMMENT
block|}
block|,
block|{
literal|"ia_64.unwind"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_UNWIND
block|}
block|,
block|{
literal|"ia_64.unwind_info"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_UNWIND_INFO
block|}
block|,
block|{
literal|"init_array"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_INIT_ARRAY
block|}
block|,
block|{
literal|"fini_array"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_FINI_ARRAY
block|}
block|,
block|{
literal|"proc"
block|,
name|dot_proc
block|,
literal|0
block|}
block|,
block|{
literal|"body"
block|,
name|dot_body
block|,
literal|0
block|}
block|,
block|{
literal|"prologue"
block|,
name|dot_prologue
block|,
literal|0
block|}
block|,
block|{
literal|"endp"
block|,
name|dot_endp
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
block|{
literal|"fframe"
block|,
name|dot_fframe
block|,
literal|0
block|}
block|,
block|{
literal|"vframe"
block|,
name|dot_vframe
block|,
literal|0
block|}
block|,
block|{
literal|"vframesp"
block|,
name|dot_vframesp
block|,
literal|0
block|}
block|,
block|{
literal|"vframepsp"
block|,
name|dot_vframepsp
block|,
literal|0
block|}
block|,
block|{
literal|"save"
block|,
name|dot_save
block|,
literal|0
block|}
block|,
block|{
literal|"restore"
block|,
name|dot_restore
block|,
literal|0
block|}
block|,
block|{
literal|"restorereg"
block|,
name|dot_restorereg
block|,
literal|0
block|}
block|,
block|{
literal|"restorereg.p"
block|,
name|dot_restorereg_p
block|,
literal|0
block|}
block|,
block|{
literal|"handlerdata"
block|,
name|dot_handlerdata
block|,
literal|0
block|}
block|,
block|{
literal|"unwentry"
block|,
name|dot_unwentry
block|,
literal|0
block|}
block|,
block|{
literal|"altrp"
block|,
name|dot_altrp
block|,
literal|0
block|}
block|,
block|{
literal|"savesp"
block|,
name|dot_savemem
block|,
literal|0
block|}
block|,
block|{
literal|"savepsp"
block|,
name|dot_savemem
block|,
literal|1
block|}
block|,
block|{
literal|"save.g"
block|,
name|dot_saveg
block|,
literal|0
block|}
block|,
block|{
literal|"save.f"
block|,
name|dot_savef
block|,
literal|0
block|}
block|,
block|{
literal|"save.b"
block|,
name|dot_saveb
block|,
literal|0
block|}
block|,
block|{
literal|"save.gf"
block|,
name|dot_savegf
block|,
literal|0
block|}
block|,
block|{
literal|"spill"
block|,
name|dot_spill
block|,
literal|0
block|}
block|,
block|{
literal|"spillreg"
block|,
name|dot_spillreg
block|,
literal|0
block|}
block|,
block|{
literal|"spillsp"
block|,
name|dot_spillmem
block|,
literal|0
block|}
block|,
block|{
literal|"spillpsp"
block|,
name|dot_spillmem
block|,
literal|1
block|}
block|,
block|{
literal|"spillreg.p"
block|,
name|dot_spillreg_p
block|,
literal|0
block|}
block|,
block|{
literal|"spillsp.p"
block|,
name|dot_spillmem_p
block|,
literal|0
block|}
block|,
block|{
literal|"spillpsp.p"
block|,
name|dot_spillmem_p
block|,
literal|1
block|}
block|,
block|{
literal|"label_state"
block|,
name|dot_label_state
block|,
literal|0
block|}
block|,
block|{
literal|"copy_state"
block|,
name|dot_copy_state
block|,
literal|0
block|}
block|,
block|{
literal|"unwabi"
block|,
name|dot_unwabi
block|,
literal|0
block|}
block|,
block|{
literal|"personality"
block|,
name|dot_personality
block|,
literal|0
block|}
block|,
if|#
directive|if
literal|0
block|{ "estate", dot_estate, 0 },
endif|#
directive|endif
block|{
literal|"mii"
block|,
name|dot_template
block|,
literal|0x0
block|}
block|,
block|{
literal|"mli"
block|,
name|dot_template
block|,
literal|0x2
block|}
block|,
comment|/* old format, for compatibility */
block|{
literal|"mlx"
block|,
name|dot_template
block|,
literal|0x2
block|}
block|,
block|{
literal|"mmi"
block|,
name|dot_template
block|,
literal|0x4
block|}
block|,
block|{
literal|"mfi"
block|,
name|dot_template
block|,
literal|0x6
block|}
block|,
block|{
literal|"mmf"
block|,
name|dot_template
block|,
literal|0x7
block|}
block|,
block|{
literal|"mib"
block|,
name|dot_template
block|,
literal|0x8
block|}
block|,
block|{
literal|"mbb"
block|,
name|dot_template
block|,
literal|0x9
block|}
block|,
block|{
literal|"bbb"
block|,
name|dot_template
block|,
literal|0xb
block|}
block|,
block|{
literal|"mmb"
block|,
name|dot_template
block|,
literal|0xc
block|}
block|,
block|{
literal|"mfb"
block|,
name|dot_template
block|,
literal|0xe
block|}
block|,
if|#
directive|if
literal|0
block|{ "lb", dot_scope, 0 },     { "le", dot_scope, 1 },
endif|#
directive|endif
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
block|{
literal|"regstk"
block|,
name|dot_regstk
block|,
literal|0
block|}
block|,
block|{
literal|"rotr"
block|,
name|dot_rot
block|,
name|DYNREG_GR
block|}
block|,
block|{
literal|"rotf"
block|,
name|dot_rot
block|,
name|DYNREG_FR
block|}
block|,
block|{
literal|"rotp"
block|,
name|dot_rot
block|,
name|DYNREG_PR
block|}
block|,
block|{
literal|"lsb"
block|,
name|dot_byteorder
block|,
literal|0
block|}
block|,
block|{
literal|"msb"
block|,
name|dot_byteorder
block|,
literal|1
block|}
block|,
block|{
literal|"psr"
block|,
name|dot_psr
block|,
literal|0
block|}
block|,
block|{
literal|"alias"
block|,
name|dot_alias
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|dot_ln
block|,
literal|0
block|}
block|,
comment|/* source line info (for debugging) */
block|{
literal|"xdata1"
block|,
name|dot_xdata
block|,
literal|1
block|}
block|,
block|{
literal|"xdata2"
block|,
name|dot_xdata
block|,
literal|2
block|}
block|,
block|{
literal|"xdata4"
block|,
name|dot_xdata
block|,
literal|4
block|}
block|,
block|{
literal|"xdata8"
block|,
name|dot_xdata
block|,
literal|8
block|}
block|,
block|{
literal|"xreal4"
block|,
name|dot_xfloat_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"xreal8"
block|,
name|dot_xfloat_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"xreal10"
block|,
name|dot_xfloat_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"xstring"
block|,
name|dot_xstringer
block|,
literal|0
block|}
block|,
block|{
literal|"xstringz"
block|,
name|dot_xstringer
block|,
literal|1
block|}
block|,
comment|/* unaligned versions:  */
block|{
literal|"xdata2.ua"
block|,
name|dot_xdata_ua
block|,
literal|2
block|}
block|,
block|{
literal|"xdata4.ua"
block|,
name|dot_xdata_ua
block|,
literal|4
block|}
block|,
block|{
literal|"xdata8.ua"
block|,
name|dot_xdata_ua
block|,
literal|8
block|}
block|,
block|{
literal|"xreal4.ua"
block|,
name|dot_xfloat_cons_ua
block|,
literal|'f'
block|}
block|,
block|{
literal|"xreal8.ua"
block|,
name|dot_xfloat_cons_ua
block|,
literal|'d'
block|}
block|,
block|{
literal|"xreal10.ua"
block|,
name|dot_xfloat_cons_ua
block|,
literal|'x'
block|}
block|,
comment|/* annotations/DV checking support */
block|{
literal|"entry"
block|,
name|dot_entry
block|,
literal|0
block|}
block|,
block|{
literal|"mem.offset"
block|,
name|dot_mem_offset
block|,
literal|0
block|}
block|,
block|{
literal|"pred.rel"
block|,
name|dot_pred_rel
block|,
literal|0
block|}
block|,
block|{
literal|"pred.rel.clear"
block|,
name|dot_pred_rel
block|,
literal|'c'
block|}
block|,
block|{
literal|"pred.rel.imply"
block|,
name|dot_pred_rel
block|,
literal|'i'
block|}
block|,
block|{
literal|"pred.rel.mutex"
block|,
name|dot_pred_rel
block|,
literal|'m'
block|}
block|,
block|{
literal|"pred.safe_across_calls"
block|,
name|dot_pred_rel
block|,
literal|'s'
block|}
block|,
block|{
literal|"reg.val"
block|,
name|dot_reg_val
block|,
literal|0
block|}
block|,
block|{
literal|"auto"
block|,
name|dot_dv_mode
block|,
literal|'a'
block|}
block|,
block|{
literal|"explicit"
block|,
name|dot_dv_mode
block|,
literal|'e'
block|}
block|,
block|{
literal|"default"
block|,
name|dot_dv_mode
block|,
literal|'d'
block|}
block|,
comment|/* ??? These are needed to make gas/testsuite/gas/elf/ehopt.s work.        IA-64 aligns data allocation pseudo-ops by default, so we have to        tell it that these ones are supposed to be unaligned.  Long term,        should rewrite so that only IA-64 specific data allocation pseudo-ops        are aligned by default.  */
block|{
literal|"2byte"
block|,
name|stmt_cons_ua
block|,
literal|2
block|}
block|,
block|{
literal|"4byte"
block|,
name|stmt_cons_ua
block|,
literal|4
block|}
block|,
block|{
literal|"8byte"
block|,
name|stmt_cons_ua
block|,
literal|8
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|pseudo_opcode
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|int
name|arg
decl_stmt|;
block|}
name|pseudo_opcode
index|[]
init|=
block|{
comment|/* these are more like pseudo-ops, but don't start with a dot */
block|{
literal|"data1"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"data2"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"data4"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"data8"
block|,
name|cons
block|,
literal|8
block|}
block|,
block|{
literal|"data16"
block|,
name|cons
block|,
literal|16
block|}
block|,
block|{
literal|"real4"
block|,
name|stmt_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"real8"
block|,
name|stmt_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"real10"
block|,
name|stmt_float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"string"
block|,
name|stringer
block|,
literal|0
block|}
block|,
block|{
literal|"stringz"
block|,
name|stringer
block|,
literal|1
block|}
block|,
comment|/* unaligned versions:  */
block|{
literal|"data2.ua"
block|,
name|stmt_cons_ua
block|,
literal|2
block|}
block|,
block|{
literal|"data4.ua"
block|,
name|stmt_cons_ua
block|,
literal|4
block|}
block|,
block|{
literal|"data8.ua"
block|,
name|stmt_cons_ua
block|,
literal|8
block|}
block|,
block|{
literal|"data16.ua"
block|,
name|stmt_cons_ua
block|,
literal|16
block|}
block|,
block|{
literal|"real4.ua"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"real8.ua"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"real10.ua"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,   }
struct|;
end_struct

begin_comment
comment|/* Declare a register by creating a symbol for it and entering it in    the symbol table.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|declare_register
parameter_list|(
name|name
parameter_list|,
name|regnum
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|reg_section
argument_list|,
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|err
operator|=
name|hash_insert
argument_list|(
name|md
operator|.
name|reg_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
literal|"Inserting \"%s\" into register table failed: %s"
argument_list|,
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|declare_register_set
parameter_list|(
name|prefix
parameter_list|,
name|num_regs
parameter_list|,
name|base_regnum
parameter_list|)
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|num_regs
decl_stmt|;
name|int
name|base_regnum
decl_stmt|;
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs
condition|;
operator|++
name|i
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%u"
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
name|name
argument_list|,
name|base_regnum
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|operand_width
parameter_list|(
name|opnd
parameter_list|)
name|enum
name|ia64_opnd
name|opnd
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_operand
modifier|*
name|odesc
init|=
operator|&
name|elf64_ia64_operands
index|[
name|opnd
index|]
decl_stmt|;
name|unsigned
name|int
name|bits
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|odesc
operator|->
name|field
argument_list|)
operator|&&
name|odesc
operator|->
name|field
index|[
name|i
index|]
operator|.
name|bits
condition|;
operator|++
name|i
control|)
name|bits
operator|+=
name|odesc
operator|->
name|field
index|[
name|i
index|]
operator|.
name|bits
expr_stmt|;
return|return
name|bits
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|operand_match_result
name|operand_match
parameter_list|(
name|idesc
parameter_list|,
name|index
parameter_list|,
name|e
parameter_list|)
specifier|const
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|int
name|index
decl_stmt|;
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|enum
name|ia64_opnd
name|opnd
init|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
decl_stmt|;
name|int
name|bits
decl_stmt|,
name|relocatable
init|=
literal|0
decl_stmt|;
name|struct
name|insn_fix
modifier|*
name|fix
decl_stmt|;
name|bfd_signed_vma
name|val
decl_stmt|;
switch|switch
condition|(
name|opnd
condition|)
block|{
comment|/* constants:  */
case|case
name|IA64_OPND_AR_CCV
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_AR
operator|+
literal|32
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_AR_PFS
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_AR
operator|+
literal|64
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_GR0
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_GR
operator|+
literal|0
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_IP
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_IP
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PR
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PR
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PR_ROT
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PR_ROT
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PSR
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PSR
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PSR_L
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PSR_L
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PSR_UM
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PSR_UM
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_C1
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|1
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_C8
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|8
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_C16
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|16
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
comment|/* register operands:  */
case|case
name|IA64_OPND_AR3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_AR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_AR
operator|+
literal|128
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_B1
case|:
case|case
name|IA64_OPND_B2
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_BR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_BR
operator|+
literal|8
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_CR3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_CR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_CR
operator|+
literal|128
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_F1
case|:
case|case
name|IA64_OPND_F2
case|:
case|case
name|IA64_OPND_F3
case|:
case|case
name|IA64_OPND_F4
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_FR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_FR
operator|+
literal|128
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_P1
case|:
case|case
name|IA64_OPND_P2
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_P
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_P
operator|+
literal|64
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_R1
case|:
case|case
name|IA64_OPND_R2
case|:
case|case
name|IA64_OPND_R3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_GR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_GR
operator|+
literal|128
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_R3_2
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_GR
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|<
name|REG_GR
operator|+
literal|4
condition|)
return|return
name|OPERAND_MATCH
return|;
elseif|else
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|<
name|REG_GR
operator|+
literal|128
condition|)
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
comment|/* indirect operands:  */
case|case
name|IA64_OPND_CPUID_R3
case|:
case|case
name|IA64_OPND_DBR_R3
case|:
case|case
name|IA64_OPND_DTR_R3
case|:
case|case
name|IA64_OPND_ITR_R3
case|:
case|case
name|IA64_OPND_IBR_R3
case|:
case|case
name|IA64_OPND_MSR_R3
case|:
case|case
name|IA64_OPND_PKR_R3
case|:
case|case
name|IA64_OPND_PMC_R3
case|:
case|case
name|IA64_OPND_PMD_R3
case|:
case|case
name|IA64_OPND_RR_R3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_index
operator|&&
name|e
operator|->
name|X_op_symbol
operator|&&
operator|(
name|S_GET_VALUE
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|)
operator|-
name|IND_CPUID
operator|==
name|opnd
operator|-
name|IA64_OPND_CPUID_R3
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_MR3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_index
operator|&&
operator|!
name|e
operator|->
name|X_op_symbol
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
comment|/* immediate operands:  */
case|case
name|IA64_OPND_CNT2a
case|:
case|case
name|IA64_OPND_LEN4
case|:
case|case
name|IA64_OPND_LEN6
case|:
name|bits
operator|=
name|operand_width
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|e
operator|->
name|X_add_number
operator|-
literal|1
argument_list|)
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|bits
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_CNT2b
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|e
operator|->
name|X_add_number
operator|-
literal|1
argument_list|)
operator|<
literal|3
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_CNT2c
case|:
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|==
literal|0
operator|||
name|val
operator|==
literal|7
operator|||
name|val
operator|==
literal|15
operator|||
name|val
operator|==
literal|16
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_SOR
case|:
comment|/* SOR must be an integer multiple of 8 */
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|e
operator|->
name|X_add_number
operator|&
literal|0x7
condition|)
return|return
name|OPERAND_OUT_OF_RANGE
return|;
case|case
name|IA64_OPND_SOF
case|:
case|case
name|IA64_OPND_SOL
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<=
literal|96
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMMU62
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|62
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
else|else
block|{
comment|/* FIXME -- need 62-bit relocation type */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"62-bit relocation not yet implemented"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IA64_OPND_IMMU64
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
name|e
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
operator|||
name|e
operator|->
name|X_op
operator|==
name|O_subtract
condition|)
block|{
name|fix
operator|=
name|CURR_SLOT
operator|.
name|fixup
operator|+
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_IMM64
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_subtract
condition|)
block|{
name|fix
operator|->
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|,
name|fix
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
condition|)
name|e
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
name|fix
operator|->
name|opnd
operator|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
expr_stmt|;
name|fix
operator|->
name|expr
operator|=
operator|*
name|e
expr_stmt|;
name|fix
operator|->
name|is_pcrel
operator|=
literal|0
expr_stmt|;
operator|++
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_CCNT5
case|:
case|case
name|IA64_OPND_CNT5
case|:
case|case
name|IA64_OPND_CNT6
case|:
case|case
name|IA64_OPND_CPOS6a
case|:
case|case
name|IA64_OPND_CPOS6b
case|:
case|case
name|IA64_OPND_CPOS6c
case|:
case|case
name|IA64_OPND_IMMU2
case|:
case|case
name|IA64_OPND_IMMU7a
case|:
case|case
name|IA64_OPND_IMMU7b
case|:
case|case
name|IA64_OPND_IMMU21
case|:
case|case
name|IA64_OPND_IMMU24
case|:
case|case
name|IA64_OPND_MBTYPE4
case|:
case|case
name|IA64_OPND_MHTYPE8
case|:
case|case
name|IA64_OPND_POS6
case|:
name|bits
operator|=
name|operand_width
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|bits
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMMU9
case|:
name|bits
operator|=
name|operand_width
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|bits
operator|)
condition|)
block|{
name|int
name|lobits
init|=
name|e
operator|->
name|X_add_number
operator|&
literal|0x3
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|&
literal|0x3C
operator|)
operator|!=
literal|0
operator|&&
name|lobits
operator|==
literal|0
condition|)
name|e
operator|->
name|X_add_number
operator||=
operator|(
name|bfd_vma
operator|)
literal|0x3
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
block|}
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMM44
case|:
comment|/* least 16 bits must be zero */
if|if
condition|(
operator|(
name|e
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
comment|/* XXX technically, this is wrong: we should not be issuing warning 	   messages until we're sure this instruction pattern is going to 	   be used! */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"lower 16 bits of mask ignored"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|44
operator|)
operator|)
operator|||
operator|(
name|e
operator|->
name|X_add_number
operator|<
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
operator|-
name|e
operator|->
name|X_add_number
operator|<=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|44
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* sign-extend */
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|e
operator|->
name|X_add_number
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|43
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|e
operator|->
name|X_add_number
operator||=
operator|~
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|44
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|OPERAND_MATCH
return|;
block|}
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMM17
case|:
comment|/* bit 0 is a don't care (pr0 is hardwired to 1) */
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|17
operator|)
operator|)
operator|||
operator|(
name|e
operator|->
name|X_add_number
operator|<
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
operator|-
name|e
operator|->
name|X_add_number
operator|<=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|17
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* sign-extend */
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|e
operator|->
name|X_add_number
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|e
operator|->
name|X_add_number
operator||=
operator|~
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|17
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|OPERAND_MATCH
return|;
block|}
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMM14
case|:
case|case
name|IA64_OPND_IMM22
case|:
name|relocatable
operator|=
literal|1
expr_stmt|;
case|case
name|IA64_OPND_IMM1
case|:
case|case
name|IA64_OPND_IMM8
case|:
case|case
name|IA64_OPND_IMM8U4
case|:
case|case
name|IA64_OPND_IMM8M1
case|:
case|case
name|IA64_OPND_IMM8M1U4
case|:
case|case
name|IA64_OPND_IMM8M1U8
case|:
case|case
name|IA64_OPND_IMM9a
case|:
case|case
name|IA64_OPND_IMM9b
case|:
name|bits
operator|=
name|operand_width
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable
operator|&&
operator|(
name|e
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
name|e
operator|->
name|X_op
operator|==
name|O_subtract
operator|||
name|e
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
operator|)
condition|)
block|{
name|fix
operator|=
name|CURR_SLOT
operator|.
name|fixup
operator|+
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
operator|==
name|IA64_OPND_IMM14
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_IMM14
expr_stmt|;
else|else
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_IMM22
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_subtract
condition|)
block|{
name|fix
operator|->
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|,
name|fix
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
condition|)
name|e
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
name|fix
operator|->
name|opnd
operator|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
expr_stmt|;
name|fix
operator|->
name|expr
operator|=
operator|*
name|e
expr_stmt|;
name|fix
operator|->
name|is_pcrel
operator|=
literal|0
expr_stmt|;
operator|++
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
operator|!
operator|(
name|e
operator|->
name|X_op
operator|==
name|O_big
operator|&&
name|opnd
operator|==
name|IA64_OPND_IMM8M1U8
operator|)
condition|)
return|return
name|OPERAND_MISMATCH
return|;
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_IMM8M1U4
condition|)
block|{
comment|/* Zero is not valid for unsigned compares that take an adjusted 	     constant immediate range.  */
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|0
condition|)
return|return
name|OPERAND_OUT_OF_RANGE
return|;
comment|/* Sign-extend 32-bit unsigned numbers, so that the following range 	     checks will work.  */
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|&
operator|(
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
operator|<<
literal|32
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|val
operator|=
operator|(
operator|(
name|val
operator|<<
literal|32
operator|)
operator|>>
literal|32
operator|)
expr_stmt|;
comment|/* Check for 0x100000000.  This is valid because 	     0x100000000-1 is the same as ((uint32_t) -1).  */
if|if
condition|(
name|val
operator|==
operator|(
operator|(
name|bfd_signed_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
name|val
operator|=
name|val
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_IMM8M1U8
condition|)
block|{
comment|/* Zero is not valid for unsigned compares that take an adjusted 	     constant immediate range.  */
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|0
condition|)
return|return
name|OPERAND_OUT_OF_RANGE
return|;
comment|/* Check for 0x10000000000000000.  */
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|generic_bignum
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|generic_bignum
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|generic_bignum
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|generic_bignum
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|generic_bignum
index|[
literal|4
index|]
operator|==
literal|1
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
else|else
name|val
operator|=
name|e
operator|->
name|X_add_number
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_IMM8M1
condition|)
name|val
operator|=
name|e
operator|->
name|X_add_number
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_IMM8U4
condition|)
block|{
comment|/* Sign-extend 32-bit unsigned numbers, so that the following range 	     checks will work.  */
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|&
operator|(
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
operator|<<
literal|32
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|val
operator|=
operator|(
operator|(
name|val
operator|<<
literal|32
operator|)
operator|>>
literal|32
operator|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|>=
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
name|val
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|val
operator|<
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
operator|-
name|val
operator|<=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
case|case
name|IA64_OPND_INC3
case|:
comment|/* +/- 1, 4, 8, 16 */
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|==
literal|1
operator|||
name|val
operator|==
literal|4
operator|||
name|val
operator|==
literal|8
operator|||
name|val
operator|==
literal|16
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_TGT25
case|:
case|case
name|IA64_OPND_TGT25b
case|:
case|case
name|IA64_OPND_TGT25c
case|:
case|case
name|IA64_OPND_TGT64
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|fix
operator|=
name|CURR_SLOT
operator|.
name|fixup
operator|+
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_TGT25
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_PCREL21F
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_TGT25b
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_PCREL21M
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_TGT25c
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_PCREL21B
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_TGT64
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_PCREL60B
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fix
operator|->
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|,
name|fix
operator|->
name|code
argument_list|)
expr_stmt|;
name|fix
operator|->
name|opnd
operator|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
expr_stmt|;
name|fix
operator|->
name|expr
operator|=
operator|*
name|e
expr_stmt|;
name|fix
operator|->
name|is_pcrel
operator|=
literal|1
expr_stmt|;
operator|++
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
block|}
case|case
name|IA64_OPND_TAG13
case|:
case|case
name|IA64_OPND_TAG13b
case|:
switch|switch
condition|(
name|e
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
return|return
name|OPERAND_MATCH
return|;
case|case
name|O_symbol
case|:
name|fix
operator|=
name|CURR_SLOT
operator|.
name|fixup
operator|+
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
comment|/* There are no external relocs for TAG13/TAG13b fields, so we 	     create a dummy reloc.  This will not live past md_apply_fix3.  */
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|fix
operator|->
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|,
name|fix
operator|->
name|code
argument_list|)
expr_stmt|;
name|fix
operator|->
name|opnd
operator|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
expr_stmt|;
name|fix
operator|->
name|expr
operator|=
operator|*
name|e
expr_stmt|;
name|fix
operator|->
name|is_pcrel
operator|=
literal|1
expr_stmt|;
operator|++
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|OPERAND_MISMATCH
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_operand
parameter_list|(
name|e
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|sep
init|=
literal|'\0'
decl_stmt|;
name|memset
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'}'
condition|)
name|expression
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sep
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
operator|!
name|md
operator|.
name|manual_bundling
condition|)
name|as_warn
argument_list|(
literal|"Found '}' when manual bundling is off"
argument_list|)
expr_stmt|;
else|else
name|CURR_SLOT
operator|.
name|manual_bundling_off
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|manual_bundling
operator|=
literal|0
expr_stmt|;
name|sep
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|sep
return|;
block|}
end_function

begin_comment
comment|/* Returns the next entry in the opcode table that matches the one in    IDESC, and frees the entry in IDESC.  If no matching entry is    found, NULL is returned instead.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_opcode
modifier|*
name|get_next_opcode
parameter_list|(
name|struct
name|ia64_opcode
modifier|*
name|idesc
parameter_list|)
block|{
name|struct
name|ia64_opcode
modifier|*
name|next
init|=
name|ia64_find_next_opcode
argument_list|(
name|idesc
argument_list|)
decl_stmt|;
name|ia64_free_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Parse the operands for the opcode and find the opcode variant that    matches the specified operands, or NULL if no match is possible.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_opcode
modifier|*
name|parse_operands
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|highest_unmatched_operand
decl_stmt|,
name|num_operands
init|=
literal|0
decl_stmt|,
name|num_outputs
init|=
literal|0
decl_stmt|;
name|int
name|error_pos
decl_stmt|,
name|out_of_range_pos
decl_stmt|,
name|curr_out_of_range_pos
decl_stmt|,
name|sep
init|=
literal|0
decl_stmt|;
name|enum
name|ia64_opnd
name|expected_operand
init|=
name|IA64_OPND_NIL
decl_stmt|;
name|enum
name|operand_match_result
name|result
decl_stmt|;
name|char
name|mnemonic
index|[
literal|129
index|]
decl_stmt|;
name|char
modifier|*
name|first_arg
init|=
literal|0
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|saved_input_pointer
decl_stmt|;
name|unsigned
name|int
name|sof
decl_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|idesc
operator|->
name|name
argument_list|)
operator|<=
literal|128
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mnemonic
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
operator|==
name|IA64_OPND_SOF
condition|)
block|{
comment|/* To make the common idiom "alloc loc?=ar.pfs,0,1,0,0" work, we 	 can't parse the first operand until we have parsed the 	 remaining operands of the "alloc" instruction.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|first_arg
operator|=
name|input_line_pointer
expr_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected separator `='"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|input_line_pointer
operator|=
name|end
operator|+
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
operator|++
name|num_outputs
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|sep
operator|=
name|parse_operand
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_absent
condition|)
break|break;
operator|++
name|num_operands
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|'='
operator|&&
name|sep
operator|!=
literal|','
condition|)
break|break;
if|if
condition|(
name|sep
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|num_outputs
operator|>
literal|0
condition|)
name|as_bad
argument_list|(
literal|"Duplicate equal sign (=) in instruction"
argument_list|)
expr_stmt|;
else|else
name|num_outputs
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sep
operator|!=
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Illegal operand separator `%c'"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
operator|==
name|IA64_OPND_SOF
condition|)
block|{
comment|/* map alloc r1=ar.pfs,i,l,o,r to alloc r1=ar.pfs,(i+l+o),(i+l),r */
name|know
argument_list|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"alloc"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_operands
operator|==
literal|5
comment|/* first_arg not included in this count! */
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|3
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|4
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|5
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|sof
operator|=
name|set_regstack
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
argument_list|,
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|3
index|]
operator|.
name|X_add_number
argument_list|,
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|4
index|]
operator|.
name|X_add_number
argument_list|,
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|5
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
comment|/* now we can parse the first arg:  */
name|saved_input_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|first_arg
expr_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
operator|+
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|'='
condition|)
operator|--
name|num_outputs
expr_stmt|;
comment|/* force error */
name|input_line_pointer
operator|=
name|saved_input_pointer
expr_stmt|;
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|=
name|sof
expr_stmt|;
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|3
index|]
operator|.
name|X_add_number
operator|=
name|sof
operator|-
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|4
index|]
operator|.
name|X_add_number
expr_stmt|;
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|4
index|]
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|5
index|]
expr_stmt|;
block|}
block|}
name|highest_unmatched_operand
operator|=
literal|0
expr_stmt|;
name|curr_out_of_range_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|error_pos
operator|=
literal|0
expr_stmt|;
name|expected_operand
operator|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
name|idesc
condition|;
name|idesc
operator|=
name|get_next_opcode
argument_list|(
name|idesc
argument_list|)
control|)
block|{
if|if
condition|(
name|num_outputs
operator|!=
name|idesc
operator|->
name|num_outputs
condition|)
continue|continue;
comment|/* mismatch in # of outputs */
name|CURR_SLOT
operator|.
name|num_fixups
operator|=
literal|0
expr_stmt|;
comment|/* Try to match all operands.  If we see an out-of-range operand, 	 then continue trying to match the rest of the operands, since if 	 the rest match, then this idesc will give the best error message.  */
name|out_of_range_pos
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_operands
operator|&&
name|idesc
operator|->
name|operands
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|=
name|operand_match
argument_list|(
name|idesc
argument_list|,
name|i
argument_list|,
name|CURR_SLOT
operator|.
name|opnd
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|OPERAND_MATCH
condition|)
block|{
if|if
condition|(
name|result
operator|!=
name|OPERAND_OUT_OF_RANGE
condition|)
break|break;
if|if
condition|(
name|out_of_range_pos
operator|<
literal|0
condition|)
comment|/* remember position of the first out-of-range operand: */
name|out_of_range_pos
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If we did not match all operands, or if at least one operand was 	 out-of-range, then this idesc does not match.  Keep track of which 	 idesc matched the most operands before failing.  If we have two 	 idescs that failed at the same position, and one had an out-of-range 	 operand, then prefer the out-of-range operand.  Thus if we have 	 "add r0=0x1000000,r1" we get an error saying the constant is out 	 of range instead of an error saying that the constant should have been 	 a register.  */
if|if
condition|(
name|i
operator|!=
name|num_operands
operator|||
name|out_of_range_pos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|highest_unmatched_operand
operator|||
operator|(
name|i
operator|==
name|highest_unmatched_operand
operator|&&
name|out_of_range_pos
operator|>
name|curr_out_of_range_pos
operator|)
condition|)
block|{
name|highest_unmatched_operand
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|out_of_range_pos
operator|>=
literal|0
condition|)
block|{
name|expected_operand
operator|=
name|idesc
operator|->
name|operands
index|[
name|out_of_range_pos
index|]
expr_stmt|;
name|error_pos
operator|=
name|out_of_range_pos
expr_stmt|;
block|}
else|else
block|{
name|expected_operand
operator|=
name|idesc
operator|->
name|operands
index|[
name|i
index|]
expr_stmt|;
name|error_pos
operator|=
name|i
expr_stmt|;
block|}
name|curr_out_of_range_pos
operator|=
name|out_of_range_pos
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|num_operands
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
operator|&&
name|idesc
operator|->
name|operands
index|[
name|num_operands
index|]
condition|)
continue|continue;
comment|/* mismatch in number of arguments */
break|break;
block|}
if|if
condition|(
operator|!
name|idesc
condition|)
block|{
if|if
condition|(
name|expected_operand
condition|)
name|as_bad
argument_list|(
literal|"Operand %u of `%s' should be %s"
argument_list|,
name|error_pos
operator|+
literal|1
argument_list|,
name|mnemonic
argument_list|,
name|elf64_ia64_operands
index|[
name|expected_operand
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Operand mismatch"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|idesc
return|;
block|}
end_function

begin_comment
comment|/* Keep track of state necessary to determine whether a NOP is necessary    to avoid an erratum in A and B step Itanium chips, and return 1 if we    detect a case where additional NOPs may be necessary.  */
end_comment

begin_function
specifier|static
name|int
name|errata_nop_necessary_p
parameter_list|(
name|slot
parameter_list|,
name|insn_unit
parameter_list|)
name|struct
name|slot
modifier|*
name|slot
decl_stmt|;
name|enum
name|ia64_unit
name|insn_unit
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|group
modifier|*
name|this_group
init|=
name|md
operator|.
name|last_groups
operator|+
name|md
operator|.
name|group_idx
decl_stmt|;
name|struct
name|group
modifier|*
name|prev_group
init|=
name|md
operator|.
name|last_groups
operator|+
operator|(
name|md
operator|.
name|group_idx
operator|+
literal|2
operator|)
operator|%
literal|3
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
init|=
name|slot
operator|->
name|idesc
decl_stmt|;
comment|/* Test whether this could be the first insn in a problematic sequence.  */
if|if
condition|(
name|insn_unit
operator|==
name|IA64_UNIT_F
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P2
condition|)
block|{
name|int
name|regno
init|=
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
comment|/* Ignore invalid operands; they generate errors elsewhere.  */
if|if
condition|(
name|regno
operator|>=
literal|64
condition|)
return|return
literal|0
return|;
name|this_group
operator|->
name|p_reg_set
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Test whether this could be the second insn in a problematic sequence.  */
if|if
condition|(
name|insn_unit
operator|==
name|IA64_UNIT_M
operator|&&
name|slot
operator|->
name|qp_regno
operator|>
literal|0
operator|&&
name|prev_group
operator|->
name|p_reg_set
index|[
name|slot
operator|->
name|qp_regno
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
name|int
name|regno
init|=
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
comment|/* Ignore invalid operands; they generate errors elsewhere.  */
if|if
condition|(
name|regno
operator|>=
literal|128
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"add"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"sub"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"shladd"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_POSTINC
operator|)
operator|==
literal|0
condition|)
name|this_group
operator|->
name|g_reg_set_conditionally
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Test whether this could be the third insn in a problematic sequence.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
operator|&&
name|idesc
operator|->
name|operands
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
comment|/* For fc, ptc, ptr, tak, thash, tpa, ttag, probe, ptr, ptc.  */
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
comment|/* For mov indirect.  */
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_RR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_DBR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_IBR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PKR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PMC_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PMD_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_MSR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_CPUID_R3
comment|/* For itr.  */
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_ITR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_DTR_R3
comment|/* Normal memory addresses (load, store, xchg, cmpxchg, etc.).  */
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_MR3
condition|)
block|{
name|int
name|regno
init|=
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
comment|/* Ignore invalid operands; they generate errors elsewhere.  */
if|if
condition|(
name|regno
operator|>=
literal|128
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"fc"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"tak"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"thash"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"tpa"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"ttag"
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"ptr"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"ptc"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"probe"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|prev_group
operator|->
name|g_reg_set_conditionally
index|[
name|regno
index|]
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_insn
parameter_list|(
name|slot
parameter_list|,
name|insnp
parameter_list|)
name|struct
name|slot
modifier|*
name|slot
decl_stmt|;
name|bfd_vma
modifier|*
name|insnp
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_operand
modifier|*
name|odesc
decl_stmt|,
modifier|*
name|o2desc
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
init|=
name|slot
operator|->
name|idesc
decl_stmt|;
name|bfd_signed_vma
name|insn
decl_stmt|,
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|insn
operator|=
name|idesc
operator|->
name|opcode
operator||
name|slot
operator|->
name|qp_regno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
operator|&&
name|idesc
operator|->
name|operands
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|||
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_index
condition|)
name|val
operator|=
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* This must be the value 0x10000000000000000.  */
name|assert
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_IMM8M1U8
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
condition|)
block|{
case|case
name|IA64_OPND_IMMU64
case|:
operator|*
name|insnp
operator|++
operator|=
operator|(
name|val
operator|>>
literal|22
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
operator|(
name|val
operator|&
literal|0x7f
operator|)
operator|<<
literal|13
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|7
operator|)
operator|&
literal|0x1ff
operator|)
operator|<<
literal|27
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|21
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|63
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator|)
expr_stmt|;
continue|continue;
case|case
name|IA64_OPND_IMMU62
case|:
name|val
operator|&=
literal|0x3fffffffffffffffULL
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Value truncated to 62 bits"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|insnp
operator|++
operator|=
operator|(
name|val
operator|>>
literal|21
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
operator|(
name|val
operator|&
literal|0xfffff
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|20
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator|)
expr_stmt|;
continue|continue;
case|case
name|IA64_OPND_TGT64
case|:
name|val
operator|>>=
literal|4
expr_stmt|;
operator|*
name|insnp
operator|++
operator|=
operator|(
operator|(
name|val
operator|>>
literal|20
operator|)
operator|&
literal|0x7fffffffffLL
operator|)
operator|<<
literal|2
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
operator|(
operator|(
name|val
operator|>>
literal|59
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|0
operator|)
operator|&
literal|0xfffff
operator|)
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
continue|continue;
case|case
name|IA64_OPND_AR3
case|:
name|val
operator|-=
name|REG_AR
expr_stmt|;
break|break;
case|case
name|IA64_OPND_B1
case|:
case|case
name|IA64_OPND_B2
case|:
name|val
operator|-=
name|REG_BR
expr_stmt|;
break|break;
case|case
name|IA64_OPND_CR3
case|:
name|val
operator|-=
name|REG_CR
expr_stmt|;
break|break;
case|case
name|IA64_OPND_F1
case|:
case|case
name|IA64_OPND_F2
case|:
case|case
name|IA64_OPND_F3
case|:
case|case
name|IA64_OPND_F4
case|:
name|val
operator|-=
name|REG_FR
expr_stmt|;
break|break;
case|case
name|IA64_OPND_P1
case|:
case|case
name|IA64_OPND_P2
case|:
name|val
operator|-=
name|REG_P
expr_stmt|;
break|break;
case|case
name|IA64_OPND_R1
case|:
case|case
name|IA64_OPND_R2
case|:
case|case
name|IA64_OPND_R3
case|:
case|case
name|IA64_OPND_R3_2
case|:
case|case
name|IA64_OPND_CPUID_R3
case|:
case|case
name|IA64_OPND_DBR_R3
case|:
case|case
name|IA64_OPND_DTR_R3
case|:
case|case
name|IA64_OPND_ITR_R3
case|:
case|case
name|IA64_OPND_IBR_R3
case|:
case|case
name|IA64_OPND_MR3
case|:
case|case
name|IA64_OPND_MSR_R3
case|:
case|case
name|IA64_OPND_PKR_R3
case|:
case|case
name|IA64_OPND_PMC_R3
case|:
case|case
name|IA64_OPND_PMD_R3
case|:
case|case
name|IA64_OPND_RR_R3
case|:
name|val
operator|-=
name|REG_GR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|odesc
operator|=
name|elf64_ia64_operands
operator|+
name|idesc
operator|->
name|operands
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|odesc
operator|->
name|insert
call|)
argument_list|(
name|odesc
argument_list|,
name|val
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_bad_where
argument_list|(
name|slot
operator|->
name|src_file
argument_list|,
name|slot
operator|->
name|src_line
argument_list|,
literal|"Bad operand value: %s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_PSEUDO
condition|)
block|{
if|if
condition|(
operator|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_F2_EQ_F3
operator|)
operator|&&
name|odesc
operator|==
name|elf64_ia64_operands
operator|+
name|IA64_OPND_F3
condition|)
block|{
name|o2desc
operator|=
name|elf64_ia64_operands
operator|+
name|IA64_OPND_F2
expr_stmt|;
call|(
modifier|*
name|o2desc
operator|->
name|insert
call|)
argument_list|(
name|o2desc
argument_list|,
name|val
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_LEN_EQ_64MCNT
operator|)
operator|&&
operator|(
name|odesc
operator|==
name|elf64_ia64_operands
operator|+
name|IA64_OPND_CPOS6a
operator|||
name|odesc
operator|==
name|elf64_ia64_operands
operator|+
name|IA64_OPND_POS6
operator|)
condition|)
block|{
name|o2desc
operator|=
name|elf64_ia64_operands
operator|+
name|IA64_OPND_LEN6
expr_stmt|;
call|(
modifier|*
name|o2desc
operator|->
name|insert
call|)
argument_list|(
name|o2desc
argument_list|,
literal|64
operator|-
name|val
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|insnp
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_one_bundle
parameter_list|()
block|{
name|unsigned
name|int
name|manual_bundling_on
init|=
literal|0
decl_stmt|,
name|manual_bundling_off
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|manual_bundling
init|=
literal|0
decl_stmt|;
name|enum
name|ia64_unit
name|required_unit
decl_stmt|,
name|insn_unit
init|=
literal|0
decl_stmt|;
name|enum
name|ia64_insn_type
name|type
index|[
literal|3
index|]
decl_stmt|,
name|insn_type
decl_stmt|;
name|unsigned
name|int
name|template
decl_stmt|,
name|orig_template
decl_stmt|;
name|bfd_vma
name|insn
index|[
literal|3
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|int
name|end_of_insn_group
init|=
literal|0
decl_stmt|,
name|user_template
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|first
decl_stmt|,
name|curr
decl_stmt|;
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
name|bfd_vma
name|t0
init|=
literal|0
decl_stmt|,
name|t1
init|=
literal|0
decl_stmt|;
name|struct
name|label_fix
modifier|*
name|lfix
decl_stmt|;
name|struct
name|insn_fix
modifier|*
name|ifix
decl_stmt|;
name|char
name|mnemonic
index|[
literal|16
index|]
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|first
operator|=
operator|(
name|md
operator|.
name|curr_slot
operator|+
name|NUM_SLOTS
operator|-
name|md
operator|.
name|num_slots_in_use
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
name|know
argument_list|(
name|first
operator|>=
literal|0
operator|&
name|first
operator|<
name|NUM_SLOTS
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
literal|3
argument_list|,
name|md
operator|.
name|num_slots_in_use
argument_list|)
expr_stmt|;
comment|/* Determine template: user user_template if specified, best match      otherwise:  */
if|if
condition|(
name|md
operator|.
name|slot
index|[
name|first
index|]
operator|.
name|user_template
operator|>=
literal|0
condition|)
name|user_template
operator|=
name|template
operator|=
name|md
operator|.
name|slot
index|[
name|first
index|]
operator|.
name|user_template
expr_stmt|;
else|else
block|{
comment|/* Auto select appropriate template.  */
name|memset
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|=
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|label_fixups
operator|&&
name|i
operator|!=
literal|0
condition|)
break|break;
name|type
index|[
name|i
index|]
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
operator|->
name|type
expr_stmt|;
name|curr
operator|=
operator|(
name|curr
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
block|}
name|template
operator|=
name|best_template
index|[
name|type
index|[
literal|0
index|]
index|]
index|[
name|type
index|[
literal|1
index|]
index|]
index|[
name|type
index|[
literal|2
index|]
index|]
expr_stmt|;
block|}
comment|/* initialize instructions with appropriate nops:  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
name|insn
index|[
name|i
index|]
operator|=
name|nop
index|[
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
name|i
index|]
index|]
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|/* now fill in slots with as many insns as possible:  */
name|curr
operator|=
name|first
expr_stmt|;
name|idesc
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
expr_stmt|;
name|end_of_insn_group
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
operator|&&
name|md
operator|.
name|num_slots_in_use
operator|>
literal|0
condition|;
operator|++
name|i
control|)
block|{
comment|/* Set the slot number for prologue/body records now as those 	 refer to the current point, not the point after the 	 instruction has been issued:  */
comment|/* Don't try to delete prologue/body records here, as that will cause 	 them to also be deleted from the master list of unwind records.  */
for|for
control|(
name|ptr
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|unwind_record
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|prologue
operator|||
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|prologue_gr
operator|||
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|body
condition|)
block|{
name|ptr
operator|->
name|slot_number
operator|=
operator|(
name|unsigned
name|long
operator|)
name|f
operator|+
name|i
expr_stmt|;
name|ptr
operator|->
name|slot_frag
operator|=
name|frag_now
expr_stmt|;
block|}
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_SLOT2
condition|)
block|{
if|if
condition|(
name|manual_bundling
operator|&&
name|i
operator|!=
literal|2
condition|)
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"`%s' must be last in bundle"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_LAST
condition|)
block|{
name|int
name|required_slot
decl_stmt|;
name|unsigned
name|int
name|required_template
decl_stmt|;
comment|/* If we need a stop bit after an M slot, our only choice is 	     template 5 (M;;MI).  If we need a stop bit after a B 	     slot, our only choice is to place it at the end of the 	     bundle, because the only available templates are MIB, 	     MBB, BBB, MMB, and MFB.  We don't handle anything other 	     than M and B slots because these are the only kind of 	     instructions that can have the IA64_OPCODE_LAST bit set.  */
name|required_template
operator|=
name|template
expr_stmt|;
switch|switch
condition|(
name|idesc
operator|->
name|type
condition|)
block|{
case|case
name|IA64_TYPE_M
case|:
name|required_slot
operator|=
literal|0
expr_stmt|;
name|required_template
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_B
case|:
name|required_slot
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"Internal error: don't know how to force %s to end"
literal|"of instruction group"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
name|required_slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|manual_bundling
operator|&&
name|i
operator|!=
name|required_slot
condition|)
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"`%s' must be last in instruction group"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|required_slot
operator|<
name|i
condition|)
comment|/* Can't fit this instruction.  */
break|break;
name|i
operator|=
name|required_slot
expr_stmt|;
if|if
condition|(
name|required_template
operator|!=
name|template
condition|)
block|{
comment|/* If we switch the template, we need to reset the NOPs 	         after slot i.  The slot-types of the instructions ahead 	         of i never change, so we don't need to worry about 	         changing NOPs in front of this slot.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
literal|3
condition|;
operator|++
name|j
control|)
name|insn
index|[
name|j
index|]
operator|=
name|nop
index|[
name|ia64_templ_desc
index|[
name|required_template
index|]
operator|.
name|exec_unit
index|[
name|j
index|]
index|]
expr_stmt|;
block|}
name|template
operator|=
name|required_template
expr_stmt|;
block|}
if|if
condition|(
name|curr
operator|!=
name|first
operator|&&
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|label_fixups
condition|)
block|{
if|if
condition|(
name|manual_bundling_on
condition|)
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"Label must be first in a bundle"
argument_list|)
expr_stmt|;
comment|/* This insn must go into the first slot of a bundle.  */
break|break;
block|}
name|manual_bundling_on
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|manual_bundling_on
expr_stmt|;
name|manual_bundling_off
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|manual_bundling_off
expr_stmt|;
if|if
condition|(
name|manual_bundling_on
condition|)
block|{
if|if
condition|(
name|curr
operator|==
name|first
condition|)
name|manual_bundling
operator|=
literal|1
expr_stmt|;
else|else
break|break;
comment|/* need to start a new bundle */
block|}
if|if
condition|(
name|end_of_insn_group
operator|&&
name|md
operator|.
name|num_slots_in_use
operator|>=
literal|1
condition|)
block|{
comment|/* We need an instruction group boundary in the middle of a 	     bundle.  See if we can switch to an other template with 	     an appropriate boundary.  */
name|orig_template
operator|=
name|template
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
operator|(
name|user_template
operator|==
literal|4
operator|||
operator|(
name|user_template
operator|<
literal|0
operator|&&
operator|(
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
literal|0
index|]
operator|==
name|IA64_UNIT_M
operator|)
operator|)
operator|)
condition|)
block|{
name|template
operator|=
literal|5
expr_stmt|;
name|end_of_insn_group
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
operator|&&
operator|(
name|user_template
operator|==
literal|0
operator|||
operator|(
name|user_template
operator|<
literal|0
operator|&&
operator|(
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
literal|1
index|]
operator|==
name|IA64_UNIT_I
operator|)
operator|)
operator|)
comment|/* This test makes sure we don't switch the template if 		      the next instruction is one that needs to be first in 		      an instruction group.  Since all those instructions are 		      in the M group, there is no way such an instruction can 		      fit in this bundle even if we switch the template.  The 		      reason we have to check for this is that otherwise we 		      may end up generating "MI;;I M.." which has the deadly 		      effect that the second M instruction is no longer the 		      first in the bundle! --davidm 99/12/16  */
operator|&&
operator|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_FIRST
operator|)
operator|==
literal|0
condition|)
block|{
name|template
operator|=
literal|1
expr_stmt|;
name|end_of_insn_group
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curr
operator|!=
name|first
condition|)
comment|/* can't fit this insn */
break|break;
if|if
condition|(
name|template
operator|!=
name|orig_template
condition|)
comment|/* if we switch the template, we need to reset the NOPs 	       after slot i.  The slot-types of the instructions ahead 	       of i never change, so we don't need to worry about 	       changing NOPs in front of this slot.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
literal|3
condition|;
operator|++
name|j
control|)
name|insn
index|[
name|j
index|]
operator|=
name|nop
index|[
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
name|j
index|]
index|]
expr_stmt|;
block|}
name|required_unit
operator|=
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
name|i
index|]
expr_stmt|;
comment|/* resolve dynamic opcodes such as "break" and "nop":  */
if|if
condition|(
name|idesc
operator|->
name|type
operator|==
name|IA64_TYPE_DYN
condition|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"nop"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"break"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|insn_unit
operator|=
name|required_unit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"chk.s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|insn_unit
operator|=
name|IA64_UNIT_M
expr_stmt|;
if|if
condition|(
name|required_unit
operator|==
name|IA64_UNIT_I
condition|)
name|insn_unit
operator|=
name|IA64_UNIT_I
expr_stmt|;
block|}
else|else
name|as_fatal
argument_list|(
literal|"emit_one_bundle: unexpected dynamic op"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|mnemonic
argument_list|,
literal|"%s.%c"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
literal|"?imbf??"
index|[
name|insn_unit
index|]
argument_list|)
expr_stmt|;
name|ia64_free_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
operator|=
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
name|mnemonic
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|know (!idesc->next);
comment|/* no resolved dynamic ops have collisions */
endif|#
directive|endif
block|}
else|else
block|{
name|insn_type
operator|=
name|idesc
operator|->
name|type
expr_stmt|;
name|insn_unit
operator|=
name|IA64_UNIT_NIL
expr_stmt|;
switch|switch
condition|(
name|insn_type
condition|)
block|{
case|case
name|IA64_TYPE_A
case|:
if|if
condition|(
name|required_unit
operator|==
name|IA64_UNIT_I
operator|||
name|required_unit
operator|==
name|IA64_UNIT_M
condition|)
name|insn_unit
operator|=
name|required_unit
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_X
case|:
name|insn_unit
operator|=
name|IA64_UNIT_L
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_I
case|:
name|insn_unit
operator|=
name|IA64_UNIT_I
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_M
case|:
name|insn_unit
operator|=
name|IA64_UNIT_M
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_B
case|:
name|insn_unit
operator|=
name|IA64_UNIT_B
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_F
case|:
name|insn_unit
operator|=
name|IA64_UNIT_F
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|insn_unit
operator|!=
name|required_unit
condition|)
block|{
if|if
condition|(
name|required_unit
operator|==
name|IA64_UNIT_L
operator|&&
name|insn_unit
operator|==
name|IA64_UNIT_I
operator|&&
operator|!
operator|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_X_IN_MLX
operator|)
condition|)
block|{
comment|/* we got ourselves an MLX template but the current 		 instruction isn't an X-unit, or an I-unit instruction 		 that can go into the X slot of an MLX template.  Duh.  */
if|if
condition|(
name|md
operator|.
name|num_slots_in_use
operator|>=
name|NUM_SLOTS
condition|)
block|{
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"`%s' can't go in X slot of "
literal|"MLX template"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* drop this insn so we don't livelock:  */
operator|--
name|md
operator|.
name|num_slots_in_use
expr_stmt|;
block|}
break|break;
block|}
continue|continue;
comment|/* try next slot */
block|}
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|addr
operator|=
name|frag_now
operator|->
name|fr_address
operator|+
name|frag_now_fix
argument_list|()
operator|-
literal|16
operator|+
name|i
expr_stmt|;
name|dwarf2_gen_line_info
argument_list|(
name|addr
argument_list|,
operator|&
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|debug_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errata_nop_necessary_p
argument_list|(
name|md
operator|.
name|slot
operator|+
name|curr
argument_list|,
name|insn_unit
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Additional NOP may be necessary to workaround Itanium processor A/B step errata"
argument_list|)
argument_list|)
expr_stmt|;
name|build_insn
argument_list|(
name|md
operator|.
name|slot
operator|+
name|curr
argument_list|,
name|insn
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* Set slot counts for non prologue/body unwind records.  */
for|for
control|(
name|ptr
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|unwind_record
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
operator|!=
name|prologue
operator|&&
name|ptr
operator|->
name|r
operator|.
name|type
operator|!=
name|prologue_gr
operator|&&
name|ptr
operator|->
name|r
operator|.
name|type
operator|!=
name|body
condition|)
block|{
name|ptr
operator|->
name|slot_number
operator|=
operator|(
name|unsigned
name|long
operator|)
name|f
operator|+
name|i
expr_stmt|;
name|ptr
operator|->
name|slot_frag
operator|=
name|frag_now
expr_stmt|;
block|}
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|unwind_record
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|required_unit
operator|==
name|IA64_UNIT_L
condition|)
block|{
name|know
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* skip one slot for long/X-unit instructions */
operator|++
name|i
expr_stmt|;
block|}
operator|--
name|md
operator|.
name|num_slots_in_use
expr_stmt|;
comment|/* now is a good time to fix up the labels for this insn:  */
for|for
control|(
name|lfix
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|label_fixups
init|;
name|lfix
condition|;
name|lfix
operator|=
name|lfix
operator|->
name|next
control|)
block|{
name|S_SET_VALUE
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|16
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
comment|/* and fix up the tags also.  */
for|for
control|(
name|lfix
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|tag_fixups
init|;
name|lfix
condition|;
name|lfix
operator|=
name|lfix
operator|->
name|next
control|)
block|{
name|S_SET_VALUE
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|16
operator|+
name|i
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|num_fixups
condition|;
operator|++
name|j
control|)
block|{
name|ifix
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|fixup
operator|+
name|j
expr_stmt|;
name|fix
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|16
operator|+
name|i
argument_list|,
literal|8
argument_list|,
operator|&
name|ifix
operator|->
name|expr
argument_list|,
name|ifix
operator|->
name|is_pcrel
argument_list|,
name|ifix
operator|->
name|code
argument_list|)
expr_stmt|;
name|fix
operator|->
name|tc_fix_data
operator|.
name|opnd
operator|=
name|ifix
operator|->
name|opnd
expr_stmt|;
name|fix
operator|->
name|fx_plt
operator|=
operator|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_IA64_PLTOFF22
operator|)
expr_stmt|;
name|fix
operator|->
name|fx_file
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
expr_stmt|;
name|fix
operator|->
name|fx_line
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
expr_stmt|;
block|}
name|end_of_insn_group
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|end_of_insn_group
expr_stmt|;
if|if
condition|(
name|end_of_insn_group
condition|)
block|{
name|md
operator|.
name|group_idx
operator|=
operator|(
name|md
operator|.
name|group_idx
operator|+
literal|1
operator|)
operator|%
literal|3
expr_stmt|;
name|memset
argument_list|(
name|md
operator|.
name|last_groups
operator|+
name|md
operator|.
name|group_idx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|md
operator|.
name|last_groups
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* clear slot:  */
name|ia64_free_opcode
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|md
operator|.
name|slot
operator|+
name|curr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|user_template
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|manual_bundling_off
condition|)
block|{
name|manual_bundling
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|curr
operator|=
operator|(
name|curr
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
name|idesc
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
expr_stmt|;
block|}
if|if
condition|(
name|manual_bundling
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|num_slots_in_use
operator|>
literal|0
condition|)
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"`%s' does not fit into %s template"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"Missing '}' at end of file"
argument_list|)
expr_stmt|;
block|}
name|know
argument_list|(
name|md
operator|.
name|num_slots_in_use
operator|<
name|NUM_SLOTS
argument_list|)
expr_stmt|;
name|t0
operator|=
name|end_of_insn_group
operator||
operator|(
name|template
operator|<<
literal|1
operator|)
operator||
operator|(
name|insn
index|[
literal|0
index|]
operator|<<
literal|5
operator|)
operator||
operator|(
name|insn
index|[
literal|1
index|]
operator|<<
literal|46
operator|)
expr_stmt|;
name|t1
operator|=
operator|(
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|18
operator|)
operator|&
literal|0x7fffff
operator|)
operator||
operator|(
name|insn
index|[
literal|2
index|]
operator|<<
literal|23
operator|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|0
argument_list|,
name|t0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|8
argument_list|,
name|t1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|next_slot_number
operator|=
operator|(
name|unsigned
name|long
operator|)
name|f
operator|+
literal|16
expr_stmt|;
name|unwind
operator|.
name|next_slot_frag
operator|=
name|frag_now
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Switches from the Intel assembler.  */
case|case
literal|'m'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ilp64"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"lp64"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"p64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_ABI64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ilp32"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|flags
operator|&=
operator|~
name|EF_IA_64_ABI64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"le"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|flags
operator|&=
operator|~
name|EF_IA_64_BE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"be"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_BE
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"so"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Suppress signon message.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pi"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Reject privileged instructions.  FIXME */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"us"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Allow union of signed and unsigned range.  FIXME */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"close_fcalls"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Do not resolve global function calls.  */
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'C'
case|:
comment|/* temp[="prefix"]  Insert temporary labels into the object file 			  symbol table prefixed by "prefix". 			  Default prefix is ":temp:".        */
break|break;
case|case
literal|'a'
case|:
comment|/* indirect=<tgt>	Assume unannotated indirect branches behavior 			according to<tgt> -- 			exit:	branch out from the current context (default) 			labels:	all labels in context may be branch targets        */
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"indirect="
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'x'
case|:
comment|/* -X conflicts with an ignored option, use -x instead */
name|md
operator|.
name|detect_dv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"explicit"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* set default mode to explicit */
name|md
operator|.
name|default_explicit_mode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|default_explicit_mode
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"debug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|debug_dv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"debugx"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|default_explicit_mode
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|debug_dv
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized option '-x%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* nops		Print nops statistics.  */
break|break;
comment|/* GNU specific switches for gcc.  */
case|case
name|OPTION_MCONSTANT_GP
case|:
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_CONS_GP
expr_stmt|;
break|break;
case|case
name|OPTION_MAUTO_PIC
case|:
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_NOFUNCDESC_CONS_GP
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ IA-64 options:\n\   --mconstant-gp	  mark output file as using the constant-GP model\n\ 			  (sets ELF header flag EF_IA_64_CONS_GP)\n\   --mauto-pic		  mark output file as using the constant-GP model\n\ 			  without function descriptors (sets ELF header flag\n\ 			  EF_IA_64_NOFUNCDESC_CONS_GP)\n\   -milp32|-milp64|-mlp64|-mp64	select data model (default -mlp64)\n\   -mle | -mbe		  select little- or big-endian byte order (default -mle)\n\   -x | -xexplicit	  turn on dependency violation checking (default)\n\   -xauto		  automagically remove dependency violations\n\   -xdebug		  debug dependency violation checker\n"
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_after_parse_args
parameter_list|()
block|{
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"--gstabs is not supported for ia64"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE fits in TEMPL at SLOT.  */
end_comment

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|int
name|templ
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|enum
name|ia64_unit
name|unit
decl_stmt|;
name|int
name|result
decl_stmt|;
name|unit
operator|=
name|ia64_templ_desc
index|[
name|templ
index|]
operator|.
name|exec_unit
index|[
name|slot
index|]
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IA64_TYPE_DYN
case|:
name|result
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* for nop and break */
case|case
name|IA64_TYPE_A
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_I
operator|||
name|unit
operator|==
name|IA64_UNIT_M
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_X
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_L
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_I
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_I
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_M
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_M
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_B
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_B
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_F
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_F
operator|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Add a bit of extra goodness if a nop of type F or B would fit    in TEMPL at SLOT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|extra_goodness
parameter_list|(
name|int
name|templ
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|==
literal|1
operator|&&
name|match
argument_list|(
name|templ
argument_list|,
name|IA64_TYPE_F
argument_list|,
name|slot
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|slot
operator|==
literal|2
operator|&&
name|match
argument_list|(
name|templ
argument_list|,
name|IA64_TYPE_B
argument_list|,
name|slot
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It sets    up all the tables, etc. that the MD part of the assembler will need    that can be determined before arguments are parsed.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|t
decl_stmt|,
name|total
decl_stmt|,
name|ar_base
decl_stmt|,
name|cr_base
decl_stmt|,
name|goodness
decl_stmt|,
name|best
decl_stmt|,
name|regnum
decl_stmt|,
name|ok
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|md
operator|.
name|auto_align
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|explicit_mode
operator|=
name|md
operator|.
name|default_explicit_mode
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|target_big_endian
operator|=
name|TARGET_BYTES_BIG_ENDIAN
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_FPTR_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<fptr>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_FPTR_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_GP_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<gprel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_GP_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LT_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltoff>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LT_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_PC_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<pcrel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_PC_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_PLT_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<pltoff>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_PLT_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_SEC_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<secrel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_SEC_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_SEG_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<segrel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_SEG_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LTV_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltv>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LTV_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LT_FPTR_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltoff.fptr>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LT_FPTR_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_IPLT_RELOC
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<iplt>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_IPLT_RELOC
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
comment|/* Compute the table of best templates.  We compute goodness as a      base 4 value, in which each match counts for 3, each F counts      for 2, each B counts for 1.  This should maximize the number of      F and B nops in the chosen bundles, which is good because these      pipelines are least likely to be overcommitted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IA64_NUM_TYPES
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IA64_NUM_TYPES
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|IA64_NUM_TYPES
condition|;
operator|++
name|k
control|)
block|{
name|best
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|NELEMS
argument_list|(
name|ia64_templ_desc
argument_list|)
condition|;
operator|++
name|t
control|)
block|{
name|goodness
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|k
argument_list|,
literal|2
argument_list|)
condition|)
name|goodness
operator|=
literal|3
operator|+
literal|3
operator|+
literal|3
expr_stmt|;
else|else
name|goodness
operator|=
literal|3
operator|+
literal|3
operator|+
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|j
argument_list|,
literal|2
argument_list|)
condition|)
name|goodness
operator|=
literal|3
operator|+
literal|3
operator|+
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|goodness
operator|=
literal|3
expr_stmt|;
name|goodness
operator|+=
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|goodness
operator|+=
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|j
argument_list|,
literal|2
argument_list|)
condition|)
name|goodness
operator|=
literal|3
operator|+
literal|3
expr_stmt|;
else|else
name|goodness
operator|=
literal|3
operator|+
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
condition|)
name|goodness
operator|=
literal|3
operator|+
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|goodness
operator|>
name|best
condition|)
block|{
name|best
operator|=
name|goodness
expr_stmt|;
name|best_template
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SLOTS
condition|;
operator|++
name|i
control|)
name|md
operator|.
name|slot
index|[
name|i
index|]
operator|.
name|user_template
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|.
name|pseudo_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|pseudo_opcode
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|hash_insert
argument_list|(
name|md
operator|.
name|pseudo_hash
argument_list|,
name|pseudo_opcode
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|pseudo_opcode
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
literal|"ia64.md_begin: can't hash `%s': %s"
argument_list|,
name|pseudo_opcode
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|md
operator|.
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|md
operator|.
name|dynreg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|md
operator|.
name|const_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|md
operator|.
name|entry_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* general registers:  */
name|total
operator|=
literal|128
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"r%d"
argument_list|,
name|i
operator|-
name|REG_GR
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|i
index|]
operator|=
name|declare_register
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* floating point registers:  */
name|total
operator|+=
literal|128
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"f%d"
argument_list|,
name|i
operator|-
name|REG_FR
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|i
index|]
operator|=
name|declare_register
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* application registers:  */
name|total
operator|+=
literal|128
expr_stmt|;
name|ar_base
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"ar%d"
argument_list|,
name|i
operator|-
name|REG_AR
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|i
index|]
operator|=
name|declare_register
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* control registers:  */
name|total
operator|+=
literal|128
expr_stmt|;
name|cr_base
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"cr%d"
argument_list|,
name|i
operator|-
name|REG_CR
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|i
index|]
operator|=
name|declare_register
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* predicate registers:  */
name|total
operator|+=
literal|64
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"p%d"
argument_list|,
name|i
operator|-
name|REG_P
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|i
index|]
operator|=
name|declare_register
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* branch registers:  */
name|total
operator|+=
literal|8
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"b%d"
argument_list|,
name|i
operator|-
name|REG_BR
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|i
index|]
operator|=
name|declare_register
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|md
operator|.
name|regsym
index|[
name|REG_IP
index|]
operator|=
name|declare_register
argument_list|(
literal|"ip"
argument_list|,
name|REG_IP
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|REG_CFM
index|]
operator|=
name|declare_register
argument_list|(
literal|"cfm"
argument_list|,
name|REG_CFM
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|REG_PR
index|]
operator|=
name|declare_register
argument_list|(
literal|"pr"
argument_list|,
name|REG_PR
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|REG_PR_ROT
index|]
operator|=
name|declare_register
argument_list|(
literal|"pr.rot"
argument_list|,
name|REG_PR_ROT
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|REG_PSR
index|]
operator|=
name|declare_register
argument_list|(
literal|"psr"
argument_list|,
name|REG_PSR
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|REG_PSR_L
index|]
operator|=
name|declare_register
argument_list|(
literal|"psr.l"
argument_list|,
name|REG_PSR_L
argument_list|)
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|REG_PSR_UM
index|]
operator|=
name|declare_register
argument_list|(
literal|"psr.um"
argument_list|,
name|REG_PSR_UM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|indirect_reg
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|regnum
operator|=
name|indirect_reg
index|[
name|i
index|]
operator|.
name|regnum
expr_stmt|;
name|md
operator|.
name|regsym
index|[
name|regnum
index|]
operator|=
name|declare_register
argument_list|(
name|indirect_reg
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
comment|/* define synonyms for application registers:  */
for|for
control|(
name|i
operator|=
name|REG_AR
init|;
name|i
operator|<
name|REG_AR
operator|+
name|NELEMS
argument_list|(
name|ar
argument_list|)
condition|;
operator|++
name|i
control|)
name|md
operator|.
name|regsym
index|[
name|i
index|]
operator|=
name|declare_register
argument_list|(
name|ar
index|[
name|i
operator|-
name|REG_AR
index|]
operator|.
name|name
argument_list|,
name|REG_AR
operator|+
name|ar
index|[
name|i
operator|-
name|REG_AR
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
comment|/* define synonyms for control registers:  */
for|for
control|(
name|i
operator|=
name|REG_CR
init|;
name|i
operator|<
name|REG_CR
operator|+
name|NELEMS
argument_list|(
name|cr
argument_list|)
condition|;
operator|++
name|i
control|)
name|md
operator|.
name|regsym
index|[
name|i
index|]
operator|=
name|declare_register
argument_list|(
name|cr
index|[
name|i
operator|-
name|REG_CR
index|]
operator|.
name|name
argument_list|,
name|REG_CR
operator|+
name|cr
index|[
name|i
operator|-
name|REG_CR
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"gp"
argument_list|,
name|REG_GR
operator|+
literal|1
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"sp"
argument_list|,
name|REG_GR
operator|+
literal|12
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"rp"
argument_list|,
name|REG_BR
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* pseudo-registers used to specify unwind info:  */
name|declare_register
argument_list|(
literal|"psp"
argument_list|,
name|REG_PSP
argument_list|)
expr_stmt|;
name|declare_register_set
argument_list|(
literal|"ret"
argument_list|,
literal|4
argument_list|,
name|REG_GR
operator|+
literal|8
argument_list|)
expr_stmt|;
name|declare_register_set
argument_list|(
literal|"farg"
argument_list|,
literal|8
argument_list|,
name|REG_FR
operator|+
literal|8
argument_list|)
expr_stmt|;
name|declare_register_set
argument_list|(
literal|"fret"
argument_list|,
literal|8
argument_list|,
name|REG_FR
operator|+
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|const_bits
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|hash_insert
argument_list|(
name|md
operator|.
name|const_hash
argument_list|,
name|const_bits
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|const_bits
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
literal|"Inserting \"%s\" into constant hash table failed: %s"
argument_list|,
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* Set the architecture and machine depending on defaults and command line      options.  */
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
name|ok
operator|=
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_ia64
argument_list|,
name|bfd_mach_ia64_elf64
argument_list|)
expr_stmt|;
else|else
name|ok
operator|=
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_ia64
argument_list|,
name|bfd_mach_ia64_elf32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the pointer size and pointer shift size depending on md.flags */
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
block|{
name|md
operator|.
name|pointer_size
operator|=
literal|8
expr_stmt|;
comment|/* pointers are 8 bytes */
name|md
operator|.
name|pointer_size_shift
operator|=
literal|3
expr_stmt|;
comment|/* alignment is 8 bytes = 2^2 */
block|}
else|else
block|{
name|md
operator|.
name|pointer_size
operator|=
literal|4
expr_stmt|;
comment|/* pointers are 4 bytes */
name|md
operator|.
name|pointer_size_shift
operator|=
literal|2
expr_stmt|;
comment|/* alignment is 4 bytes = 2^2 */
block|}
name|md
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|0
expr_stmt|;
name|md
operator|.
name|path
operator|=
literal|0
expr_stmt|;
name|md
operator|.
name|maxpaths
operator|=
literal|0
expr_stmt|;
name|md
operator|.
name|entry_labels
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the elf type to 64 bit ABI by default.  Cannot do this in md_begin    because that is called after md_parse_option which is where we do the    dynamic changing of md.flags based on -mlp64 or -milp32.  Also, set the    default endianness.  */
end_comment

begin_function
name|void
name|ia64_init
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|md
operator|.
name|flags
operator|=
name|MD_FLAGS_DEFAULT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a string for the target object file format.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ia64_target_format
parameter_list|()
block|{
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_BE
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
if|#
directive|if
name|defined
argument_list|(
name|TE_AIX50
argument_list|)
return|return
literal|"elf64-ia64-aix-big"
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TE_HPUX
argument_list|)
return|return
literal|"elf64-ia64-hpux-big"
return|;
else|#
directive|else
return|return
literal|"elf64-ia64-big"
return|;
endif|#
directive|endif
else|else
if|#
directive|if
name|defined
argument_list|(
name|TE_AIX50
argument_list|)
return|return
literal|"elf32-ia64-aix-big"
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TE_HPUX
argument_list|)
return|return
literal|"elf32-ia64-hpux-big"
return|;
else|#
directive|else
return|return
literal|"elf32-ia64-big"
return|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
ifdef|#
directive|ifdef
name|TE_AIX50
return|return
literal|"elf64-ia64-aix-little"
return|;
else|#
directive|else
return|return
literal|"elf64-ia64-little"
return|;
endif|#
directive|endif
else|else
ifdef|#
directive|ifdef
name|TE_AIX50
return|return
literal|"elf32-ia64-aix-little"
return|;
else|#
directive|else
return|return
literal|"elf32-ia64-little"
return|;
endif|#
directive|endif
block|}
block|}
else|else
return|return
literal|"unknown-format"
return|;
block|}
end_function

begin_function
name|void
name|ia64_end_of_source
parameter_list|()
block|{
comment|/* terminate insn group upon reaching end of file:  */
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* emits slots we haven't written yet:  */
name|ia64_flush_insns
argument_list|()
expr_stmt|;
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|md
operator|.
name|flags
argument_list|)
expr_stmt|;
name|md
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_start_line
parameter_list|()
block|{
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|as_bad
argument_list|(
literal|"qualifying predicate not followed by instruction"
argument_list|)
expr_stmt|;
name|md
operator|.
name|qp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
name|ignore_input
argument_list|()
condition|)
return|return;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|';'
operator|&&
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|detect_dv
operator|&&
operator|!
name|md
operator|.
name|explicit_mode
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Explicit stops are ignored in auto mode"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is a hook for ia64_frob_label, so that it can distinguish tags from    labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|defining_tag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ia64_unrecognized_line
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'('
case|:
name|expression
argument_list|(
operator|&
name|md
operator|.
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected ')'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
literal|"Qualifying predicate expected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_add_number
operator|<
name|REG_P
operator|||
name|md
operator|.
name|qp
operator|.
name|X_add_number
operator|>=
name|REG_P
operator|+
literal|64
condition|)
block|{
name|as_bad
argument_list|(
literal|"Predicate register expected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
case|case
literal|'{'
case|:
if|if
condition|(
name|md
operator|.
name|manual_bundling
condition|)
name|as_warn
argument_list|(
literal|"Found '{' when manual bundling is already turned on"
argument_list|)
expr_stmt|;
else|else
name|CURR_SLOT
operator|.
name|manual_bundling_on
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|manual_bundling
operator|=
literal|1
expr_stmt|;
comment|/* Bundling is only acceptable in explicit mode 	 or when in default automatic mode.  */
if|if
condition|(
name|md
operator|.
name|detect_dv
operator|&&
operator|!
name|md
operator|.
name|explicit_mode
condition|)
block|{
if|if
condition|(
operator|!
name|md
operator|.
name|mode_explicitly_set
operator|&&
operator|!
name|md
operator|.
name|default_explicit_mode
condition|)
name|dot_dv_mode
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Found '{' after explicit switch to automatic mode"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
case|case
literal|'}'
case|:
if|if
condition|(
operator|!
name|md
operator|.
name|manual_bundling
condition|)
name|as_warn
argument_list|(
literal|"Found '}' when manual bundling is off"
argument_list|)
expr_stmt|;
else|else
name|PREV_SLOT
operator|.
name|manual_bundling_off
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|manual_bundling
operator|=
literal|0
expr_stmt|;
comment|/* switch back to automatic mode, if applicable */
if|if
condition|(
name|md
operator|.
name|detect_dv
operator|&&
name|md
operator|.
name|explicit_mode
operator|&&
operator|!
name|md
operator|.
name|mode_explicitly_set
operator|&&
operator|!
name|md
operator|.
name|default_explicit_mode
condition|)
name|dot_dv_mode
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
comment|/* Allow '{' to follow on the same line.  We also allow ";;", but that 	 happens automatically because ';' is an end of line marker.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'{'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
return|return
name|ia64_unrecognized_line
argument_list|(
literal|'{'
argument_list|)
return|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'['
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|symbolS
modifier|*
name|tag
decl_stmt|;
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
literal|"Tag must come before qualifying predicate."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* This implements just enough of read_a_source_file in read.c to 	   recognize labels.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|temp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|temp
operator|=
operator|(
name|temp
operator|*
literal|10
operator|)
operator|+
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
name|fb_label_instance_inc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|s
operator|=
name|fb_label_name
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
block|{
comment|/* Put ':' back for error messages' sake.  */
operator|*
name|input_line_pointer
operator|++
operator|=
literal|':'
expr_stmt|;
name|as_bad
argument_list|(
literal|"Expected ':'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|defining_tag
operator|=
literal|1
expr_stmt|;
name|tag
operator|=
name|colon
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|defining_tag
operator|=
literal|0
expr_stmt|;
comment|/* Put ':' back for error messages' sake.  */
operator|*
name|input_line_pointer
operator|++
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected ']'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|tag
condition|)
block|{
name|as_bad
argument_list|(
literal|"Tag name expected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
default|default:
break|break;
block|}
comment|/* Not a valid line.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ia64_frob_label
parameter_list|(
name|sym
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|label_fix
modifier|*
name|fix
decl_stmt|;
comment|/* Tags need special handling since they are not bundle breaks like      labels.  */
if|if
condition|(
name|defining_tag
condition|)
block|{
name|fix
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
expr_stmt|;
name|fix
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|CURR_SLOT
operator|.
name|tag_fixups
expr_stmt|;
name|CURR_SLOT
operator|.
name|tag_fixups
operator|=
name|fix
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
condition|)
block|{
name|md
operator|.
name|last_text_seg
operator|=
name|now_seg
expr_stmt|;
name|fix
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
expr_stmt|;
name|fix
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|CURR_SLOT
operator|.
name|label_fixups
expr_stmt|;
name|CURR_SLOT
operator|.
name|label_fixups
operator|=
name|fix
expr_stmt|;
comment|/* Keep track of how many code entry points we've seen.  */
if|if
condition|(
name|md
operator|.
name|path
operator|==
name|md
operator|.
name|maxpaths
condition|)
block|{
name|md
operator|.
name|maxpaths
operator|+=
literal|20
expr_stmt|;
name|md
operator|.
name|entry_labels
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|md
operator|.
name|entry_labels
argument_list|,
name|md
operator|.
name|maxpaths
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|md
operator|.
name|entry_labels
index|[
name|md
operator|.
name|path
operator|++
index|]
operator|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ia64_flush_pending_output
parameter_list|()
block|{
if|if
condition|(
operator|!
name|md
operator|.
name|keep_pending_output
operator|&&
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
condition|)
block|{
comment|/* ??? This causes many unnecessary stop bits to be emitted. 	 Unfortunately, it isn't clear if it is safe to remove this.  */
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ia64_flush_insns
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do ia64-specific expression optimization.  All that's done here is    to transform index expressions that are either due to the indexing    of rotating registers or due to the indexing of indirect register    sets.  */
end_comment

begin_function
name|int
name|ia64_optimize_expr
parameter_list|(
name|l
parameter_list|,
name|op
parameter_list|,
name|r
parameter_list|)
name|expressionS
modifier|*
name|l
decl_stmt|;
name|operatorT
name|op
decl_stmt|;
name|expressionS
modifier|*
name|r
decl_stmt|;
block|{
name|unsigned
name|num_regs
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|O_index
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|r
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num_regs
operator|=
operator|(
name|l
operator|->
name|X_add_number
operator|>>
literal|16
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|r
operator|->
name|X_add_number
operator|>=
name|num_regs
condition|)
block|{
if|if
condition|(
operator|!
name|num_regs
condition|)
name|as_bad
argument_list|(
literal|"No current frame"
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Index out of range 0..%u"
argument_list|,
name|num_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|l
operator|->
name|X_add_number
operator|=
operator|(
name|l
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|+
name|r
operator|->
name|X_add_number
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|l
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|r
operator|->
name|X_op
operator|==
name|O_register
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|X_add_number
operator|<
name|IND_CPUID
operator|||
name|l
operator|->
name|X_add_number
operator|>
name|IND_RR
operator|||
name|l
operator|->
name|X_add_number
operator|==
name|IND_MEM
condition|)
block|{
name|as_bad
argument_list|(
literal|"Indirect register set name expected"
argument_list|)
expr_stmt|;
name|l
operator|->
name|X_add_number
operator|=
name|IND_CPUID
expr_stmt|;
block|}
name|l
operator|->
name|X_op
operator|=
name|O_index
expr_stmt|;
name|l
operator|->
name|X_op_symbol
operator|=
name|md
operator|.
name|regsym
index|[
name|l
operator|->
name|X_add_number
index|]
expr_stmt|;
name|l
operator|->
name|X_add_number
operator|=
name|r
operator|->
name|X_add_number
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ia64_parse_name
parameter_list|(
name|name
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|struct
name|const_desc
modifier|*
name|cdesc
decl_stmt|;
name|struct
name|dynreg
modifier|*
name|dr
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|regnum
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
comment|/* first see if NAME is a known register name:  */
name|sym
operator|=
name|hash_find
argument_list|(
name|md
operator|.
name|reg_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|cdesc
operator|=
name|hash_find
argument_list|(
name|md
operator|.
name|const_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdesc
condition|)
block|{
name|e
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|cdesc
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* check for inN, locN, or outN:  */
switch|switch
condition|(
name|name
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'n'
operator|&&
name|ISDIGIT
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|dr
operator|=
operator|&
name|md
operator|.
name|in
expr_stmt|;
name|name
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|ISDIGIT
argument_list|(
name|name
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|dr
operator|=
operator|&
name|md
operator|.
name|loc
expr_stmt|;
name|name
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'u'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|ISDIGIT
argument_list|(
name|name
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|dr
operator|=
operator|&
name|md
operator|.
name|out
expr_stmt|;
name|name
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|dr
condition|)
block|{
comment|/* The name is inN, locN, or outN; parse the register number.  */
name|regnum
operator|=
name|strtoul
argument_list|(
name|name
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|name
operator|&&
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|regnum
operator|>=
name|dr
operator|->
name|num_regs
condition|)
block|{
if|if
condition|(
operator|!
name|dr
operator|->
name|num_regs
condition|)
name|as_bad
argument_list|(
literal|"No current frame"
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Register number out of range 0..%u"
argument_list|,
name|dr
operator|->
name|num_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|regnum
operator|=
literal|0
expr_stmt|;
block|}
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|dr
operator|->
name|base
operator|+
name|regnum
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|(
name|dr
operator|=
name|hash_find
argument_list|(
name|md
operator|.
name|dynreg_hash
argument_list|,
name|name
argument_list|)
operator|)
condition|)
block|{
comment|/* We've got ourselves the name of a rotating register set. 	 Store the base register number in the low 16 bits of 	 X_add_number and the size of the register set in the top 16 	 bits.  */
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|dr
operator|->
name|base
operator||
operator|(
name|dr
operator|->
name|num_regs
operator|<<
literal|16
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove the '#' suffix that indicates a symbol as opposed to a register.  */
end_comment

begin_function
name|char
modifier|*
name|ia64_canonicalize_symbol_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'#'
condition|)
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return true if idesc is a conditional branch instruction.  This excludes    the modulo scheduled branches, and br.ia.  Mod-sched branches are excluded    because they always read/write resources regardless of the value of the    qualifying predicate.  br.ia must always use p0, and hence is always    taken.  Thus this function returns true for branches which can fall    through, and which use no resources if they do fall through.  */
end_comment

begin_function
specifier|static
name|int
name|is_conditional_branch
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
comment|/* br is a conditional branch.  Everything that starts with br. except      br.ia, br.c{loop,top,exit}, and br.w{top,exit} is a conditional branch.      Everything that starts with brl is a conditional branch.  */
return|return
operator|(
name|idesc
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'b'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
operator|(
name|idesc
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|idesc
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|3
index|]
operator|!=
literal|'i'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|3
index|]
operator|!=
literal|'c'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|3
index|]
operator|!=
literal|'w'
operator|)
operator|||
name|idesc
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'l'
comment|/* br.cond, br.call, br.clr  */
operator|||
operator|(
name|idesc
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|3
index|]
operator|==
literal|'c'
operator|&&
operator|(
name|idesc
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'a'
operator|||
name|idesc
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'o'
operator|||
operator|(
name|idesc
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'l'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|5
index|]
operator|==
literal|'r'
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether the given opcode is a taken branch.  If there's any doubt,    returns zero.  */
end_comment

begin_function
specifier|static
name|int
name|is_taken_branch
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|is_conditional_branch
argument_list|(
name|idesc
argument_list|)
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|0
operator|)
operator|||
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"br.ia"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether the given opcode is an interruption or rfi.  If there's any    doubt, returns zero.  */
end_comment

begin_function
specifier|static
name|int
name|is_interruption_or_rfi
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"rfi"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the index of the given dependency in the opcode's list of chks, or    -1 if there is no dependency.  */
end_comment

begin_function
specifier|static
name|int
name|depends_on
parameter_list|(
name|depind
parameter_list|,
name|idesc
parameter_list|)
name|int
name|depind
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|ia64_opcode_dependency
modifier|*
name|dep
init|=
name|idesc
operator|->
name|dependencies
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dep
operator|->
name|nchks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|depind
operator|==
name|DEP
argument_list|(
name|dep
operator|->
name|chks
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine a set of specific resources used for a particular resource    class.  Returns the number of specific resources identified  For those    cases which are not determinable statically, the resource returned is    marked nonspecific.     Meanings of value in 'NOTE':    1) only read/write when the register number is explicitly encoded in the    insn.    2) only read CFM when accessing a rotating GR, FR, or PR.  mov pr only    accesses CFM when qualifying predicate is in the rotating region.    3) general register value is used to specify an indirect register; not    determinable statically.    4) only read the given resource when bits 7:0 of the indirect index    register value does not match the register number of the resource; not    determinable statically.    5) all rules are implementation specific.    6) only when both the index specified by the reader and the index specified    by the writer have the same value in bits 63:61; not determinable    statically.    7) only access the specified resource when the corresponding mask bit is    set    8) PSR.dfh is only read when these insns reference FR32-127.  PSR.dfl is    only read when these insns reference FR2-31    9) PSR.mfl is only written when these insns write FR2-31.  PSR.mfh is only    written when these insns write FR32-127    10) The PSR.bn bit is only accessed when one of GR16-31 is specified in the    instruction    11) The target predicates are written independently of PR[qp], but source    registers are only read if PR[qp] is true.  Since the state of PR[qp]    cannot statically be determined, all source registers are marked used.    12) This insn only reads the specified predicate register when that    register is the PR[qp].    13) This reference to ld-c only applies to teh GR whose value is loaded    with data returned from memory, not the post-incremented address register.    14) The RSE resource includes the implementation-specific RSE internal    state resources.  At least one (and possibly more) of these resources are    read by each instruction listed in IC:rse-readers.  At least one (and    possibly more) of these resources are written by each insn listed in    IC:rse-writers.    15+16) Represents reserved instructions, which the assembler does not    generate.     Memory resources (i.e. locations in memory) are *not* marked or tracked by    this code; there are no dependency violations based on memory access. */
end_comment

begin_define
define|#
directive|define
name|MAX_SPECS
value|256
end_define

begin_define
define|#
directive|define
name|DV_CHK
value|1
end_define

begin_define
define|#
directive|define
name|DV_REG
value|0
end_define

begin_function
specifier|static
name|int
name|specify_resource
parameter_list|(
name|dep
parameter_list|,
name|idesc
parameter_list|,
name|type
parameter_list|,
name|specs
parameter_list|,
name|note
parameter_list|,
name|path
parameter_list|)
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* is this a DV chk or a DV reg? */
name|struct
name|rsrc
name|specs
index|[
name|MAX_SPECS
index|]
decl_stmt|;
comment|/* returned specific resources */
name|int
name|note
decl_stmt|;
comment|/* resource note for this insn's usage */
name|int
name|path
decl_stmt|;
comment|/* which execution path to examine */
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rsrc_write
init|=
literal|0
decl_stmt|;
name|struct
name|rsrc
name|tmpl
decl_stmt|;
if|if
condition|(
name|dep
operator|->
name|mode
operator|==
name|IA64_DV_WAW
operator|||
operator|(
name|dep
operator|->
name|mode
operator|==
name|IA64_DV_RAW
operator|&&
name|type
operator|==
name|DV_REG
operator|)
operator|||
operator|(
name|dep
operator|->
name|mode
operator|==
name|IA64_DV_WAR
operator|&&
name|type
operator|==
name|DV_CHK
operator|)
condition|)
name|rsrc_write
operator|=
literal|1
expr_stmt|;
comment|/* template for any resources we identify */
name|tmpl
operator|.
name|dependency
operator|=
name|dep
expr_stmt|;
name|tmpl
operator|.
name|note
operator|=
name|note
expr_stmt|;
name|tmpl
operator|.
name|insn_srlz
operator|=
name|tmpl
operator|.
name|data_srlz
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|.
name|qp_regno
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
name|tmpl
operator|.
name|link_to_qp_branch
operator|=
literal|1
expr_stmt|;
name|tmpl
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|.
name|specific
operator|=
literal|1
expr_stmt|;
name|tmpl
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|.
name|cmp_type
operator|=
name|CMP_NONE
expr_stmt|;
define|#
directive|define
name|UNHANDLED
define|\
value|as_warn (_("Unhandled dependency %s for %s (%s), note %d"), \ dep->name, idesc->name, (rsrc_write?"write":"read"), note)
define|#
directive|define
name|KNOWN
parameter_list|(
name|REG
parameter_list|)
value|(gr_values[REG].known&& gr_values[REG].path>= path)
comment|/* we don't need to track these */
if|if
condition|(
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_NONE
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|dep
operator|->
name|specifier
condition|)
block|{
case|case
name|IA64_RS_AR_K
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<=
literal|7
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_AR_UNAT
case|:
comment|/* This is a mov =AR or mov AR= instruction.  */
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|AR_UNAT
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a spill/fill, or other instruction that modifies the 	     unat register.  */
comment|/* Unless we can determine the specific bits used, mark the whole 	     thing; bits 8:3 of the memory address indicate the bit used in 	     UNAT.  The .mem.offset hint may be used to eliminate a small 	     subset of conflicts.  */
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|mem_offset
operator|.
name|hint
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Using hint for spill/fill\n"
argument_list|)
expr_stmt|;
comment|/* The index isn't actually used, just set it to something 		 approximating the bit index.  */
name|specs
index|[
name|count
index|]
operator|.
name|index
operator|=
operator|(
name|md
operator|.
name|mem_offset
operator|.
name|offset
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|1
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|offset
operator|=
name|md
operator|.
name|mem_offset
operator|.
name|offset
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|mem_offset
operator|.
name|base
operator|=
name|md
operator|.
name|mem_offset
operator|.
name|base
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IA64_RS_AR
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>=
literal|8
operator|&&
name|regno
operator|<=
literal|15
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|20
operator|&&
name|regno
operator|<=
literal|23
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|31
operator|&&
name|regno
operator|<=
literal|39
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|41
operator|&&
name|regno
operator|<=
literal|47
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|67
operator|&&
name|regno
operator|<=
literal|111
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_ARb
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>=
literal|48
operator|&&
name|regno
operator|<=
literal|63
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|112
operator|&&
name|regno
operator|<=
literal|127
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|48
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|112
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_BR
case|:
if|if
condition|(
name|note
operator|!=
literal|1
condition|)
block|{
name|UNHANDLED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_B1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_B2
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_BR
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|idesc
operator|->
name|num_outputs
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_B1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_B2
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_BR
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|IA64_RS_CPUID
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CPUID_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_DBR
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_DBR_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
operator|&&
operator|!
name|rsrc_write
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_IBR
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_IBR_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_MSR
case|:
if|if
condition|(
name|note
operator|==
literal|5
condition|)
block|{
comment|/* These are implementation specific.  Force all references to 	     conflict with all other references.  */
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_PKR
case|:
comment|/* 16 or more registers */
if|if
condition|(
name|note
operator|==
literal|3
operator|||
name|note
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PKR_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Uses all registers *except* the one in R3.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|!=
operator|(
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
comment|/* probe et al.  */
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_PMC
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PMC_R3
operator|||
operator|(
operator|!
name|rsrc_write
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_PMD_R3
operator|)
condition|)
block|{
name|int
name|index
init|=
operator|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_R3
operator|&&
operator|!
name|rsrc_write
operator|)
condition|?
literal|1
else|:
operator|!
name|rsrc_write
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|index
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_PMD
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PMD_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_RR
case|:
comment|/* eight registers */
if|if
condition|(
name|note
operator|==
literal|6
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_RR_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
operator|(
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|>>
literal|61
operator|)
operator|&
literal|0x7
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
operator|&&
operator|!
name|rsrc_write
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_CR_IRR
case|:
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
comment|/* handle mov-from-CR-IVR; it's a read that writes CR[IRR] */
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
if|if
condition|(
name|rsrc_write
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
name|regno
operator|==
name|CR_IVR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CR_IRR0
operator|+
name|i
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
name|regno
operator|>=
name|CR_IRR0
operator|&&
name|regno
operator|<=
name|CR_IRR3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_CR_LRR
case|:
if|if
condition|(
name|note
operator|!=
literal|1
condition|)
block|{
name|UNHANDLED
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
operator|(
name|regno
operator|==
name|CR_LRR0
operator|||
name|regno
operator|==
name|CR_LRR1
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IA64_RS_CR
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CR3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_FR
case|:
case|case
name|IA64_RS_FRb
case|:
if|if
condition|(
name|note
operator|!=
literal|1
condition|)
block|{
name|UNHANDLED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsrc_write
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|specifier
operator|==
name|IA64_RS_FRb
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_F1
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|idesc
operator|->
name|num_outputs
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F4
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|IA64_RS_GR
case|:
if|if
condition|(
name|note
operator|==
literal|13
condition|)
block|{
comment|/* This reference applies only to the GR whose value is loaded with 	     data returned from memory.  */
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
block|}
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_POSTINC
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_MR3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Look for anything that reads a GR.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_MR3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_CPUID_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_DBR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_IBR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_MSR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PKR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PMC_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PMD_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_RR_R3
operator|||
operator|(
operator|(
name|i
operator|>=
name|idesc
operator|->
name|num_outputs
operator|)
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
comment|/* addl source register.  */
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3_2
operator|)
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
comment|/* This is the same as IA64_RS_PRr, except that the register range is 	 from 1 - 15, and there are no rotating register reads/writes here.  */
case|case
name|IA64_RS_PR
case|:
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|7
condition|)
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
comment|/* Mark only those registers indicated by the mask.  */
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|mask
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|11
condition|)
comment|/* note 11 implies note 1 as well */
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P2
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|1
operator|&&
name|regno
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>=
literal|1
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|int
name|p1
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|p2
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|or_andcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"or.andcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|int
name|and_orcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"and.orcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
name|p1
operator|>=
literal|1
operator|&&
name|p1
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_OR
else|:
operator|(
name|and_orcm
condition|?
name|CMP_AND
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|p1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
name|p2
operator|>=
literal|1
operator|&&
name|p2
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_AND
else|:
operator|(
name|and_orcm
condition|?
name|CMP_OR
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|p2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>=
literal|1
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
block|}
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_PR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
comment|/* This is the general case for PRs.  IA64_RS_PR and IA64_RS_PR63 are 	 simplified cases of this.  */
case|case
name|IA64_RS_PRr
case|:
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|63
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|7
condition|)
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
comment|/* Mark only those registers indicated by the mask.  */
if|if
condition|(
name|rsrc_write
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_PR
condition|)
block|{
name|mask
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
literal|16
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|63
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rsrc_write
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_PR_ROT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|63
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|11
condition|)
comment|/* note 11 implies note 1 as well */
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P2
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|16
operator|&&
name|regno
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>=
literal|16
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|int
name|p1
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|p2
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|or_andcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"or.andcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|int
name|and_orcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"and.orcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
name|p1
operator|>=
literal|16
operator|&&
name|p1
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_OR
else|:
operator|(
name|and_orcm
condition|?
name|CMP_AND
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|p1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
name|p2
operator|>=
literal|16
operator|&&
name|p2
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_AND
else|:
operator|(
name|and_orcm
condition|?
name|CMP_OR
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|p2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>=
literal|16
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
block|}
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_PR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|63
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_PSR
case|:
comment|/* Verify that the instruction is using the PSR bit indicated in 	 dep->regindex.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PSR_UM
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|regindex
operator|<
literal|6
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PSR
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|regindex
operator|<
literal|32
operator|||
name|dep
operator|->
name|regindex
operator|==
literal|35
operator|||
name|dep
operator|->
name|regindex
operator|==
literal|36
operator|||
operator|(
operator|!
name|rsrc_write
operator|&&
name|dep
operator|->
name|regindex
operator|==
name|PSR_CPL
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PSR_L
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|regindex
operator|<
literal|32
operator|||
name|dep
operator|->
name|regindex
operator|==
literal|35
operator|||
name|dep
operator|->
name|regindex
operator|==
literal|36
operator|||
operator|(
name|rsrc_write
operator|&&
name|dep
operator|->
name|regindex
operator|==
name|PSR_CPL
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Several PSR bits have very specific dependencies.  */
switch|switch
condition|(
name|dep
operator|->
name|regindex
condition|)
block|{
default|default:
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
break|break;
case|case
name|PSR_IC
case|:
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
else|else
block|{
comment|/* Only certain CR accesses use PSR.ic */
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_CR3
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_CR3
condition|)
block|{
name|int
name|index
init|=
operator|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_CR3
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|index
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
switch|switch
condition|(
name|regno
condition|)
block|{
default|default:
break|break;
case|case
name|CR_ITIR
case|:
case|case
name|CR_IFS
case|:
case|case
name|CR_IIM
case|:
case|case
name|CR_IIP
case|:
case|case
name|CR_IPSR
case|:
case|case
name|CR_ISR
case|:
case|case
name|CR_IFA
case|:
case|case
name|CR_IHA
case|:
case|case
name|CR_IIPA
case|:
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|PSR_CPL
case|:
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
else|else
block|{
comment|/* Only some AR accesses use cpl */
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|index
init|=
operator|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|index
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|AR_ITC
operator|||
operator|(
name|index
operator|==
literal|0
operator|&&
operator|(
name|regno
operator|==
name|AR_ITC
operator|||
name|regno
operator|==
name|AR_RSC
operator|||
operator|(
name|regno
operator|>=
name|AR_K0
operator|&&
name|regno
operator|<=
name|AR_K7
operator|)
operator|)
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|7
condition|)
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_IMMU24
condition|)
block|{
name|mask
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|dep
operator|->
name|regindex
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|8
condition|)
block|{
name|int
name|min
init|=
name|dep
operator|->
name|regindex
operator|==
name|PSR_DFL
condition|?
literal|2
else|:
literal|32
decl_stmt|;
name|int
name|max
init|=
name|dep
operator|->
name|regindex
operator|==
name|PSR_DFL
condition|?
literal|31
else|:
literal|127
decl_stmt|;
comment|/* dfh is read on FR32-127; dfl is read on FR2-31 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F4
condition|)
block|{
name|int
name|reg
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
name|min
operator|&&
name|reg
operator|<=
name|max
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|9
condition|)
block|{
name|int
name|min
init|=
name|dep
operator|->
name|regindex
operator|==
name|PSR_MFL
condition|?
literal|2
else|:
literal|32
decl_stmt|;
name|int
name|max
init|=
name|dep
operator|->
name|regindex
operator|==
name|PSR_MFL
condition|?
literal|31
else|:
literal|127
decl_stmt|;
comment|/* mfh is read on writes to FR32-127; mfl is read on writes to 	     FR2-31 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F1
condition|)
block|{
name|int
name|reg
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
name|min
operator|&&
name|reg
operator|<=
name|max
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|10
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|16
operator|&&
name|regno
operator|<=
literal|31
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_AR_FPSR
case|:
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|AR_FPSR
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_ARX
case|:
comment|/* Handle all AR[REG] resources */
if|if
condition|(
name|note
operator|==
literal|0
operator|||
name|note
operator|==
literal|1
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
operator|&&
name|regno
operator|==
name|dep
operator|->
name|regindex
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
comment|/* other AR[REG] resources may be affected by AR accesses */
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
comment|/* AR[] writes */
name|regno
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
expr_stmt|;
switch|switch
condition|(
name|dep
operator|->
name|regindex
condition|)
block|{
default|default:
break|break;
case|case
name|AR_BSP
case|:
case|case
name|AR_RNAT
case|:
if|if
condition|(
name|regno
operator|==
name|AR_BSPSTORE
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
case|case
name|AR_RSC
case|:
if|if
condition|(
operator|!
name|rsrc_write
operator|&&
operator|(
name|regno
operator|==
name|AR_BSPSTORE
operator|||
name|regno
operator|==
name|AR_RNAT
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
comment|/* AR[] reads */
name|regno
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
expr_stmt|;
switch|switch
condition|(
name|dep
operator|->
name|regindex
condition|)
block|{
default|default:
break|break;
case|case
name|AR_RSC
case|:
if|if
condition|(
name|regno
operator|==
name|AR_BSPSTORE
operator|||
name|regno
operator|==
name|AR_RNAT
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_CRX
case|:
comment|/* Handle all CR[REG] resources */
if|if
condition|(
name|note
operator|==
literal|0
operator|||
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|dep
operator|->
name|regindex
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rsrc_write
condition|)
block|{
comment|/* Reads from CR[IVR] affect other resources.  */
if|if
condition|(
name|regno
operator|==
name|CR_IVR
condition|)
block|{
if|if
condition|(
operator|(
name|dep
operator|->
name|regindex
operator|>=
name|CR_IRR0
operator|&&
name|dep
operator|->
name|regindex
operator|<=
name|CR_IRR3
operator|)
operator|||
name|dep
operator|->
name|regindex
operator|==
name|CR_TPR
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_INSERVICE
case|:
comment|/* look for write of EOI (67) or read of IVR (65) */
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
operator|==
name|CR_EOI
operator|)
operator|||
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
operator|==
name|CR_IVR
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_GR0
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_CFM
case|:
if|if
condition|(
name|note
operator|!=
literal|2
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if any of the registers accessed are in the rotating region. 	     mov to/from pr accesses CFM only when qp_regno is in the rotating 	     region */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
name|int
name|num
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
comment|/* Assumes that md.rot.num_regs is always valid */
if|if
condition|(
name|md
operator|.
name|rot
operator|.
name|num_regs
operator|>
literal|0
operator|&&
name|num
operator|>
literal|31
operator|&&
name|num
operator|<
literal|31
operator|+
name|md
operator|.
name|rot
operator|.
name|num_regs
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F4
condition|)
block|{
name|int
name|num
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|31
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P2
condition|)
block|{
name|int
name|num
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|15
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>
literal|15
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
comment|/* This is the same as IA64_RS_PRr, except simplified to account for 	 the fact that there is only one register.  */
case|case
name|IA64_RS_PR63
case|:
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|7
condition|)
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
operator|==
name|IA64_OPND_IMM17
condition|)
name|mask
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
literal|63
operator|)
condition|)
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|11
condition|)
block|{
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
operator|==
literal|63
operator|)
operator|||
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
operator|==
literal|63
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|63
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|int
name|p1
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|p2
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|or_andcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"or.andcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|int
name|and_orcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"and.orcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
if|if
condition|(
name|p1
operator|==
literal|63
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P2
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_OR
else|:
operator|(
name|and_orcm
condition|?
name|CMP_AND
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|p2
operator|==
literal|63
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_AND
else|:
operator|(
name|and_orcm
condition|?
name|CMP_OR
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|63
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_RSE
case|:
comment|/* FIXME we can identify some individual RSE written resources, but RSE 	 read resources have not yet been completely identified, so for now 	 treat RSE as a single resource */
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_BSPSTORE
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
literal|0
expr_stmt|;
comment|/* IA64_RSE_BSPLOAD/RNATBITINDEX */
block|}
block|}
else|else
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_BSPSTORE
operator|||
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_RNAT
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_BSP
operator|||
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_BSPSTORE
operator|||
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_RNAT
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_ANY
case|:
comment|/* FIXME -- do any of these need to be non-specific? */
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized dependency specifier %d\n"
argument_list|)
argument_list|,
name|dep
operator|->
name|specifier
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Clear branch flags on marked resources.  This breaks the link between the    QP of the marking instruction and a subsequent branch on the same QP.  */
end_comment

begin_function
specifier|static
name|void
name|clear_qp_branch_flag
parameter_list|(
name|mask
parameter_list|)
name|valueT
name|mask
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regdepslen
condition|;
name|i
operator|++
control|)
block|{
name|valueT
name|bit
init|=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|regdeps
index|[
name|i
index|]
operator|.
name|qp_regno
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|bit
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|regdeps
index|[
name|i
index|]
operator|.
name|link_to_qp_branch
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove any mutexes which contain any of the PRs indicated in the mask.     Any changes to a PR clears the mutex relations which include that PR.  */
end_comment

begin_function
specifier|static
name|void
name|clear_qp_mutex
parameter_list|(
name|mask
parameter_list|)
name|valueT
name|mask
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|qp_mutexeslen
condition|)
block|{
if|if
condition|(
operator|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Clearing mutex relation"
argument_list|)
expr_stmt|;
name|print_prmask
argument_list|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|qp_mutexes
index|[
name|i
index|]
operator|=
name|qp_mutexes
index|[
operator|--
name|qp_mutexeslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear implies relations which contain PRs in the given masks.    P1_MASK indicates the source of the implies relation, while P2_MASK    indicates the implied PR.  */
end_comment

begin_function
specifier|static
name|void
name|clear_qp_implies
parameter_list|(
name|p1_mask
parameter_list|,
name|p2_mask
parameter_list|)
name|valueT
name|p1_mask
decl_stmt|;
name|valueT
name|p2_mask
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|qp_implieslen
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
operator|)
operator|&
name|p1_mask
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
operator|)
operator|&
name|p2_mask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Clearing implied relation PR%d->PR%d\n"
argument_list|,
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
argument_list|,
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
argument_list|)
expr_stmt|;
name|qp_implies
index|[
name|i
index|]
operator|=
name|qp_implies
index|[
operator|--
name|qp_implieslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add the PRs specified to the list of implied relations.  */
end_comment

begin_function
specifier|static
name|void
name|add_qp_imply
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
block|{
name|valueT
name|mask
decl_stmt|;
name|valueT
name|bit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* p0 is not meaningful here.  */
if|if
condition|(
name|p1
operator|==
literal|0
operator|||
name|p2
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return;
comment|/* If it exists already, ignore it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_implieslen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
operator|==
name|p1
operator|&&
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
operator|==
name|p2
operator|&&
name|qp_implies
index|[
name|i
index|]
operator|.
name|path
operator|==
name|md
operator|.
name|path
operator|&&
operator|!
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2_branched
condition|)
return|return;
block|}
if|if
condition|(
name|qp_implieslen
operator|==
name|qp_impliestotlen
condition|)
block|{
name|qp_impliestotlen
operator|+=
literal|20
expr_stmt|;
name|qp_implies
operator|=
operator|(
expr|struct
name|qp_imply
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|qp_implies
argument_list|,
name|qp_impliestotlen
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|qp_imply
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Registering PR%d implies PR%d\n"
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|qp_implies
index|[
name|qp_implieslen
index|]
operator|.
name|p1
operator|=
name|p1
expr_stmt|;
name|qp_implies
index|[
name|qp_implieslen
index|]
operator|.
name|p2
operator|=
name|p2
expr_stmt|;
name|qp_implies
index|[
name|qp_implieslen
index|]
operator|.
name|path
operator|=
name|md
operator|.
name|path
expr_stmt|;
name|qp_implies
index|[
name|qp_implieslen
operator|++
index|]
operator|.
name|p2_branched
operator|=
literal|0
expr_stmt|;
comment|/* Add in the implied transitive relations; for everything that p2 implies,      make p1 imply that, too; for everything that implies p1, make it imply p2      as well.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_implieslen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
operator|==
name|p2
condition|)
name|add_qp_imply
argument_list|(
name|p1
argument_list|,
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
operator|==
name|p1
condition|)
name|add_qp_imply
argument_list|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
comment|/* Add in mutex relations implied by this implies relation; for each mutex      relation containing p2, duplicate it and replace p2 with p1.  */
name|bit
operator|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p1
expr_stmt|;
name|mask
operator|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_mutexeslen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
name|mask
condition|)
name|add_qp_mutex
argument_list|(
operator|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
operator|~
name|mask
operator|)
operator||
name|bit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add the PRs specified in the mask to the mutex list; this means that only    one of the PRs can be true at any time.  PR0 should never be included in    the mask.  */
end_comment

begin_function
specifier|static
name|void
name|add_qp_mutex
parameter_list|(
name|mask
parameter_list|)
name|valueT
name|mask
decl_stmt|;
block|{
if|if
condition|(
name|mask
operator|&
literal|0x1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|qp_mutexeslen
operator|==
name|qp_mutexestotlen
condition|)
block|{
name|qp_mutexestotlen
operator|+=
literal|20
expr_stmt|;
name|qp_mutexes
operator|=
operator|(
expr|struct
name|qpmutex
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|qp_mutexes
argument_list|,
name|qp_mutexestotlen
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|qpmutex
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Registering mutex on"
argument_list|)
expr_stmt|;
name|print_prmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|qp_mutexes
index|[
name|qp_mutexeslen
index|]
operator|.
name|path
operator|=
name|md
operator|.
name|path
expr_stmt|;
name|qp_mutexes
index|[
name|qp_mutexeslen
operator|++
index|]
operator|.
name|prmask
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|has_suffix_p
parameter_list|(
name|name
parameter_list|,
name|suffix
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
block|{
name|size_t
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|size_t
name|sufflen
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|namelen
operator|<=
name|sufflen
condition|)
return|return
literal|0
return|;
return|return
name|strcmp
argument_list|(
name|name
operator|+
name|namelen
operator|-
name|sufflen
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_register_values
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Clearing register values\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
condition|;
name|i
operator|++
control|)
name|gr_values
index|[
name|i
index|]
operator|.
name|known
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keep track of register values/changes which affect DV tracking.     optimization note: should add a flag to classes of insns where otherwise we    have to examine a group of strings to identify them.  */
end_comment

begin_function
specifier|static
name|void
name|note_register_values
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|valueT
name|qp_changemask
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Invalidate values for registers being written to.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
condition|)
name|gr_values
index|[
name|regno
index|]
operator|.
name|known
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3_2
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>
literal|0
operator|&&
name|regno
operator|<
literal|4
condition|)
name|gr_values
index|[
name|regno
index|]
operator|.
name|known
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P2
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|qp_changemask
operator||=
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PR
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
operator|&
operator|(
name|valueT
operator|)
literal|0x10000
condition|)
name|qp_changemask
operator|=
operator|~
operator|(
name|valueT
operator|)
literal|0x1FFFF
operator||
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
expr_stmt|;
else|else
name|qp_changemask
operator|=
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PR_ROT
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
literal|43
operator|)
condition|)
name|qp_changemask
operator|=
operator|~
operator|(
name|valueT
operator|)
literal|0xFFFFFFFFFFF
operator||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
expr_stmt|;
else|else
name|qp_changemask
operator|=
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|qp_changemask
operator|&=
operator|~
operator|(
name|valueT
operator|)
literal|0xFFFF
expr_stmt|;
break|break;
block|}
block|}
comment|/* Always clear qp branch flags on any PR change.  */
comment|/* FIXME there may be exceptions for certain compares.  */
name|clear_qp_branch_flag
argument_list|(
name|qp_changemask
argument_list|)
expr_stmt|;
comment|/* Invalidate rotating registers on insns which affect RRBs in CFM.  */
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_MOD_RRBS
condition|)
block|{
name|qp_changemask
operator||=
operator|~
operator|(
name|valueT
operator|)
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"clrrrb.pr"
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|32
operator|+
name|md
operator|.
name|rot
operator|.
name|num_regs
condition|;
name|i
operator|++
control|)
name|gr_values
index|[
name|i
index|]
operator|.
name|known
operator|=
literal|0
expr_stmt|;
block|}
name|clear_qp_mutex
argument_list|(
name|qp_changemask
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
name|qp_changemask
argument_list|,
name|qp_changemask
argument_list|)
expr_stmt|;
block|}
comment|/* After a call, all register values are undefined, except those marked      as "safe".  */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"br.call"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"brl.call"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME keep GR values which are marked as "safe_across_calls"  */
name|clear_register_values
argument_list|()
expr_stmt|;
name|clear_qp_mutex
argument_list|(
operator|~
name|qp_safe_across_calls
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
operator|~
name|qp_safe_across_calls
argument_list|,
operator|~
name|qp_safe_across_calls
argument_list|)
expr_stmt|;
name|clear_qp_branch_flag
argument_list|(
operator|~
name|qp_safe_across_calls
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_interruption_or_rfi
argument_list|(
name|idesc
argument_list|)
operator|||
name|is_taken_branch
argument_list|(
name|idesc
argument_list|)
condition|)
block|{
name|clear_register_values
argument_list|()
expr_stmt|;
name|clear_qp_mutex
argument_list|(
operator|~
operator|(
name|valueT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
operator|~
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|~
operator|(
name|valueT
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Look for mutex and implies relations.  */
elseif|else
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|)
condition|)
block|{
name|int
name|p1
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|p2
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|valueT
name|p1mask
init|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p1
decl_stmt|;
name|valueT
name|p2mask
init|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p2
decl_stmt|;
comment|/* If one of the PRs is PR0, we can't really do anything.  */
if|if
condition|(
name|p1
operator|==
literal|0
operator|||
name|p2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Ignoring PRs due to inclusion of p0\n"
argument_list|)
expr_stmt|;
block|}
comment|/* In general, clear mutexes and implies which include P1 or P2, 	 with the following exceptions.  */
elseif|else
if|if
condition|(
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".or.andcm"
argument_list|)
operator|||
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".and.orcm"
argument_list|)
condition|)
block|{
name|add_qp_mutex
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
name|p2mask
argument_list|,
name|p1mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".andcm"
argument_list|)
operator|||
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".and"
argument_list|)
condition|)
block|{
name|clear_qp_implies
argument_list|(
literal|0
argument_list|,
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".orcm"
argument_list|)
operator|||
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".or"
argument_list|)
condition|)
block|{
name|clear_qp_mutex
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clear_qp_implies
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|,
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".unc"
argument_list|)
condition|)
block|{
name|add_qp_mutex
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|!=
literal|0
condition|)
block|{
name|add_qp_imply
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
argument_list|,
name|CURR_SLOT
operator|.
name|qp_regno
argument_list|)
expr_stmt|;
name|add_qp_imply
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
argument_list|,
name|CURR_SLOT
operator|.
name|qp_regno
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|0
condition|)
block|{
name|add_qp_mutex
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clear_qp_mutex
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Look for mov imm insns into GRs.  */
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_R1
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IMM22
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IMMU64
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"movl"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
condition|)
block|{
name|gr_values
index|[
name|regno
index|]
operator|.
name|known
operator|=
literal|1
expr_stmt|;
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
name|gr_values
index|[
name|regno
index|]
operator|.
name|path
operator|=
name|md
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Know gr%d = "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|clear_qp_mutex
argument_list|(
name|qp_changemask
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
name|qp_changemask
argument_list|,
name|qp_changemask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return whether the given predicate registers are currently mutex.  */
end_comment

begin_function
specifier|static
name|int
name|qp_mutex
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|path
parameter_list|)
name|int
name|p1
decl_stmt|;
name|int
name|p2
decl_stmt|;
name|int
name|path
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|valueT
name|mask
decl_stmt|;
if|if
condition|(
name|p1
operator|!=
name|p2
condition|)
block|{
name|mask
operator|=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p1
operator|)
operator||
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_mutexeslen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|path
operator|>=
name|path
operator|&&
operator|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return whether the given resource is in the given insn's list of chks    Return 1 if the conflict is absolutely determined, 2 if it's a potential    conflict.  */
end_comment

begin_function
specifier|static
name|int
name|resources_match
parameter_list|(
name|rs
parameter_list|,
name|idesc
parameter_list|,
name|note
parameter_list|,
name|qp_regno
parameter_list|,
name|path
parameter_list|)
name|struct
name|rsrc
modifier|*
name|rs
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|int
name|note
decl_stmt|;
name|int
name|qp_regno
decl_stmt|;
name|int
name|path
decl_stmt|;
block|{
name|struct
name|rsrc
name|specs
index|[
name|MAX_SPECS
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* If the marked resource's qp_regno and the given qp_regno are mutex,      we don't need to check.  One exception is note 11, which indicates that      target predicates are written regardless of PR[qp].  */
if|if
condition|(
name|qp_mutex
argument_list|(
name|rs
operator|->
name|qp_regno
argument_list|,
name|qp_regno
argument_list|,
name|path
argument_list|)
operator|&&
name|note
operator|!=
literal|11
condition|)
return|return
literal|0
return|;
name|count
operator|=
name|specify_resource
argument_list|(
name|rs
operator|->
name|dependency
argument_list|,
name|idesc
argument_list|,
name|DV_CHK
argument_list|,
name|specs
argument_list|,
name|note
argument_list|,
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* UNAT checking is a bit more specific than other resources */
if|if
condition|(
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|==
name|IA64_RS_AR_UNAT
operator|&&
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|hint
operator|&&
name|rs
operator|->
name|mem_offset
operator|.
name|hint
condition|)
block|{
if|if
condition|(
name|rs
operator|->
name|mem_offset
operator|.
name|base
operator|==
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|base
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|rs
operator|->
name|mem_offset
operator|.
name|offset
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
operator|)
operator|==
operator|(
operator|(
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|offset
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
operator|)
condition|)
return|return
literal|1
return|;
else|else
continue|continue;
block|}
block|}
comment|/* Skip apparent PR write conflicts where both writes are an AND or both 	 writes are an OR.  */
if|if
condition|(
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|==
name|IA64_RS_PR
operator|||
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|==
name|IA64_RS_PRr
operator|||
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|==
name|IA64_RS_PR63
condition|)
block|{
if|if
condition|(
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|!=
name|CMP_NONE
operator|&&
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|==
name|rs
operator|->
name|cmp_type
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s on parallel compare allowed (PR%d)\n"
argument_list|,
name|dv_mode
index|[
name|rs
operator|->
name|dependency
operator|->
name|mode
index|]
argument_list|,
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|!=
name|IA64_RS_PR63
condition|?
name|specs
index|[
name|count
index|]
operator|.
name|index
else|:
literal|63
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s on parallel compare conflict %s vs %s on PR%d\n"
argument_list|,
name|dv_mode
index|[
name|rs
operator|->
name|dependency
operator|->
name|mode
index|]
argument_list|,
name|dv_cmp_type
index|[
name|rs
operator|->
name|cmp_type
index|]
argument_list|,
name|dv_cmp_type
index|[
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
index|]
argument_list|,
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|!=
name|IA64_RS_PR63
condition|?
name|specs
index|[
name|count
index|]
operator|.
name|index
else|:
literal|63
argument_list|)
expr_stmt|;
block|}
comment|/* If either resource is not specific, conservatively assume a conflict        */
if|if
condition|(
operator|!
name|specs
index|[
name|count
index|]
operator|.
name|specific
operator|||
operator|!
name|rs
operator|->
name|specific
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|specs
index|[
name|count
index|]
operator|.
name|index
operator|==
name|rs
operator|->
name|index
condition|)
return|return
literal|1
return|;
block|}
if|#
directive|if
literal|0
block|if (md.debug_dv)     fprintf (stderr, "  No %s conflicts\n", rs->dependency->name);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate an instruction group break; if INSERT_STOP is non-zero, then    insert a stop to create the break.  Update all resource dependencies    appropriately.  If QP_REGNO is non-zero, only apply the break to resources    which use the same QP_REGNO and have the link_to_qp_branch flag set.    If SAVE_CURRENT is non-zero, don't affect resources marked by the current    instruction.  */
end_comment

begin_function
specifier|static
name|void
name|insn_group_break
parameter_list|(
name|insert_stop
parameter_list|,
name|qp_regno
parameter_list|,
name|save_current
parameter_list|)
name|int
name|insert_stop
decl_stmt|;
name|int
name|qp_regno
decl_stmt|;
name|int
name|save_current
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|insert_stop
operator|&&
name|md
operator|.
name|num_slots_in_use
operator|>
literal|0
condition|)
name|PREV_SLOT
operator|.
name|end_of_insn_group
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Insn group break%s"
argument_list|,
operator|(
name|insert_stop
condition|?
literal|" (w/stop)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp_regno
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" effective for QP=%d"
argument_list|,
name|qp_regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|regdepslen
condition|)
block|{
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
init|=
name|regdeps
index|[
name|i
index|]
operator|.
name|dependency
decl_stmt|;
if|if
condition|(
name|qp_regno
operator|!=
literal|0
operator|&&
name|regdeps
index|[
name|i
index|]
operator|.
name|qp_regno
operator|!=
name|qp_regno
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|save_current
operator|&&
name|CURR_SLOT
operator|.
name|src_file
operator|==
name|regdeps
index|[
name|i
index|]
operator|.
name|file
operator|&&
name|CURR_SLOT
operator|.
name|src_line
operator|==
name|regdeps
index|[
name|i
index|]
operator|.
name|line
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* clear dependencies which are automatically cleared by a stop, or 	 those that have reached the appropriate state of insn serialization */
if|if
condition|(
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_IMPLIED
operator|||
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_IMPLIEDF
operator|||
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|==
name|STATE_SRLZ
condition|)
block|{
name|print_dependency
argument_list|(
literal|"Removing"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regdeps
index|[
name|i
index|]
operator|=
name|regdeps
index|[
operator|--
name|regdepslen
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_DATA
operator|||
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_INSTR
operator|||
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_SPECIFIC
condition|)
block|{
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|==
name|STATE_NONE
condition|)
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|=
name|STATE_STOP
expr_stmt|;
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|data_srlz
operator|==
name|STATE_NONE
condition|)
name|regdeps
index|[
name|i
index|]
operator|.
name|data_srlz
operator|=
name|STATE_STOP
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add the given resource usage spec to the list of active dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|mark_resource
parameter_list|(
name|idesc
parameter_list|,
name|dep
parameter_list|,
name|spec
parameter_list|,
name|depind
parameter_list|,
name|path
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|rsrc
modifier|*
name|spec
decl_stmt|;
name|int
name|depind
decl_stmt|;
name|int
name|path
decl_stmt|;
block|{
if|if
condition|(
name|regdepslen
operator|==
name|regdepstotlen
condition|)
block|{
name|regdepstotlen
operator|+=
literal|20
expr_stmt|;
name|regdeps
operator|=
operator|(
expr|struct
name|rsrc
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|regdeps
argument_list|,
name|regdepstotlen
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rsrc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|regdeps
index|[
name|regdepslen
index|]
operator|=
operator|*
name|spec
expr_stmt|;
name|regdeps
index|[
name|regdepslen
index|]
operator|.
name|depind
operator|=
name|depind
expr_stmt|;
name|regdeps
index|[
name|regdepslen
index|]
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|regdeps
index|[
name|regdepslen
index|]
operator|.
name|file
operator|=
name|CURR_SLOT
operator|.
name|src_file
expr_stmt|;
name|regdeps
index|[
name|regdepslen
index|]
operator|.
name|line
operator|=
name|CURR_SLOT
operator|.
name|src_line
expr_stmt|;
name|print_dependency
argument_list|(
literal|"Adding"
argument_list|,
name|regdepslen
argument_list|)
expr_stmt|;
operator|++
name|regdepslen
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_dependency
parameter_list|(
name|action
parameter_list|,
name|depind
parameter_list|)
specifier|const
name|char
modifier|*
name|action
decl_stmt|;
name|int
name|depind
decl_stmt|;
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s %s '%s'"
argument_list|,
name|action
argument_list|,
name|dv_mode
index|[
operator|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|dependency
operator|)
operator|->
name|mode
index|]
argument_list|,
operator|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|dependency
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|specific
operator|&&
name|regdeps
index|[
name|depind
index|]
operator|.
name|index
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%d)"
argument_list|,
name|regdeps
index|[
name|depind
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|mem_offset
operator|.
name|hint
condition|)
block|{
name|fputs
argument_list|(
literal|" "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|regdeps
index|[
name|depind
index|]
operator|.
name|mem_offset
operator|.
name|base
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"+"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|regdeps
index|[
name|depind
index|]
operator|.
name|mem_offset
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|instruction_serialization
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Instruction serialization\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regdepslen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|==
name|STATE_STOP
condition|)
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|=
name|STATE_SRLZ
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|data_serialization
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Data serialization\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|regdepslen
condition|)
block|{
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|data_srlz
operator|==
name|STATE_STOP
comment|/* Note: as of 991210, all "other" dependencies are cleared by a 	     data serialization.  This might change with new tables */
operator|||
operator|(
name|regdeps
index|[
name|i
index|]
operator|.
name|dependency
operator|)
operator|->
name|semantics
operator|==
name|IA64_DVS_OTHER
condition|)
block|{
name|print_dependency
argument_list|(
literal|"Removing"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regdeps
index|[
name|i
index|]
operator|=
name|regdeps
index|[
operator|--
name|regdepslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert stops and serializations as needed to avoid DVs.  */
end_comment

begin_function
specifier|static
name|void
name|remove_marked_resource
parameter_list|(
name|rs
parameter_list|)
name|struct
name|rsrc
modifier|*
name|rs
decl_stmt|;
block|{
switch|switch
condition|(
name|rs
operator|->
name|dependency
operator|->
name|semantics
condition|)
block|{
case|case
name|IA64_DVS_SPECIFIC
case|:
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Implementation-specific, assume worst case...\n"
argument_list|)
expr_stmt|;
comment|/* ...fall through...  */
case|case
name|IA64_DVS_INSTR
case|:
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Inserting instr serialization\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|insn_srlz
operator|<
name|STATE_STOP
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|insn_srlz
operator|<
name|STATE_SRLZ
condition|)
block|{
name|int
name|oldqp
init|=
name|CURR_SLOT
operator|.
name|qp_regno
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|oldidesc
init|=
name|CURR_SLOT
operator|.
name|idesc
decl_stmt|;
comment|/* Manually jam a srlz.i insn into the stream */
name|CURR_SLOT
operator|.
name|qp_regno
operator|=
literal|0
expr_stmt|;
name|CURR_SLOT
operator|.
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
literal|"srlz.i"
argument_list|)
expr_stmt|;
name|instruction_serialization
argument_list|()
expr_stmt|;
name|md
operator|.
name|curr_slot
operator|=
operator|(
name|md
operator|.
name|curr_slot
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
if|if
condition|(
operator|++
name|md
operator|.
name|num_slots_in_use
operator|>=
name|NUM_SLOTS
condition|)
name|emit_one_bundle
argument_list|()
expr_stmt|;
name|CURR_SLOT
operator|.
name|qp_regno
operator|=
name|oldqp
expr_stmt|;
name|CURR_SLOT
operator|.
name|idesc
operator|=
name|oldidesc
expr_stmt|;
block|}
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_DVS_OTHER
case|:
comment|/* as of rev2 (991220) of the DV tables, all 			    "other" types of DV are eliminated 			    by a data serialization */
case|case
name|IA64_DVS_DATA
case|:
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Inserting data serialization\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|data_srlz
operator|<
name|STATE_STOP
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|int
name|oldqp
init|=
name|CURR_SLOT
operator|.
name|qp_regno
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|oldidesc
init|=
name|CURR_SLOT
operator|.
name|idesc
decl_stmt|;
comment|/* Manually jam a srlz.d insn into the stream */
name|CURR_SLOT
operator|.
name|qp_regno
operator|=
literal|0
expr_stmt|;
name|CURR_SLOT
operator|.
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
literal|"srlz.d"
argument_list|)
expr_stmt|;
name|data_serialization
argument_list|()
expr_stmt|;
name|md
operator|.
name|curr_slot
operator|=
operator|(
name|md
operator|.
name|curr_slot
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
if|if
condition|(
operator|++
name|md
operator|.
name|num_slots_in_use
operator|>=
name|NUM_SLOTS
condition|)
name|emit_one_bundle
argument_list|()
expr_stmt|;
name|CURR_SLOT
operator|.
name|qp_regno
operator|=
name|oldqp
expr_stmt|;
name|CURR_SLOT
operator|.
name|idesc
operator|=
name|oldidesc
expr_stmt|;
block|}
break|break;
case|case
name|IA64_DVS_IMPLIED
case|:
case|case
name|IA64_DVS_IMPLIEDF
case|:
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Inserting stop\n"
argument_list|)
expr_stmt|;
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Check the resources used by the given opcode against the current dependency    list.     The check is run once for each execution path encountered.  In this case,    a unique execution path is the sequence of instructions following a code    entry point, e.g. the following has three execution paths, one starting    at L0, one at L1, and one at L2.     L0:     nop    L1:     add    L2:     add    br.ret */
end_comment

begin_function
specifier|static
name|void
name|check_dependencies
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_opcode_dependency
modifier|*
name|opdeps
init|=
name|idesc
operator|->
name|dependencies
decl_stmt|;
name|int
name|path
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Note that the number of marked resources may change within the      loop if in auto mode.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|regdepslen
condition|)
block|{
name|struct
name|rsrc
modifier|*
name|rs
init|=
operator|&
name|regdeps
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
init|=
name|rs
operator|->
name|dependency
decl_stmt|;
name|int
name|chkind
decl_stmt|;
name|int
name|note
decl_stmt|;
name|int
name|start_over
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_NONE
operator|||
operator|(
name|chkind
operator|=
name|depends_on
argument_list|(
name|rs
operator|->
name|depind
argument_list|,
name|idesc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|note
operator|=
name|NOTE
argument_list|(
name|opdeps
operator|->
name|chks
index|[
name|chkind
index|]
argument_list|)
expr_stmt|;
comment|/* Check this resource against each execution path seen thus far.  */
for|for
control|(
name|path
operator|=
literal|0
init|;
name|path
operator|<=
name|md
operator|.
name|path
condition|;
name|path
operator|++
control|)
block|{
name|int
name|matchtype
decl_stmt|;
comment|/* If the dependency wasn't on the path being checked, ignore it.  */
if|if
condition|(
name|rs
operator|->
name|path
operator|<
name|path
condition|)
continue|continue;
comment|/* If the QP for this insn implies a QP which has branched, don't 	     bother checking.  Ed. NOTE: I don't think this check is terribly 	     useful; what's the point of generating code which will only be 	     reached if its QP is zero? 	     This code was specifically inserted to handle the following code, 	     based on notes from Intel's DV checking code, where p1 implies p2.  		  mov r4 = 2 	     (p2) br.cond L 	     (p1) mov r4 = 7 	  */
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|!=
literal|0
condition|)
block|{
name|int
name|skip
init|=
literal|0
decl_stmt|;
name|int
name|implies
decl_stmt|;
for|for
control|(
name|implies
operator|=
literal|0
init|;
name|implies
operator|<
name|qp_implieslen
condition|;
name|implies
operator|++
control|)
block|{
if|if
condition|(
name|qp_implies
index|[
name|implies
index|]
operator|.
name|path
operator|>=
name|path
operator|&&
name|qp_implies
index|[
name|implies
index|]
operator|.
name|p1
operator|==
name|CURR_SLOT
operator|.
name|qp_regno
operator|&&
name|qp_implies
index|[
name|implies
index|]
operator|.
name|p2_branched
condition|)
block|{
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|skip
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|matchtype
operator|=
name|resources_match
argument_list|(
name|rs
argument_list|,
name|idesc
argument_list|,
name|note
argument_list|,
name|CURR_SLOT
operator|.
name|qp_regno
argument_list|,
name|path
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|pathmsg
index|[
literal|256
index|]
init|=
literal|""
decl_stmt|;
name|char
name|indexmsg
index|[
literal|256
index|]
init|=
literal|""
decl_stmt|;
name|int
name|certain
init|=
operator|(
name|matchtype
operator|==
literal|1
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|pathmsg
argument_list|,
literal|" when entry is at label '%s'"
argument_list|,
name|md
operator|.
name|entry_labels
index|[
name|path
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|specific
operator|&&
name|rs
operator|->
name|index
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|indexmsg
argument_list|,
literal|", specific resource number is %d"
argument_list|,
name|rs
operator|->
name|index
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Use of '%s' %s %s dependency '%s' (%s)%s%s"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
operator|(
name|certain
condition|?
literal|"violates"
else|:
literal|"may violate"
operator|)
argument_list|,
name|dv_mode
index|[
name|dep
operator|->
name|mode
index|]
argument_list|,
name|dep
operator|->
name|name
argument_list|,
name|dv_sem
index|[
name|dep
operator|->
name|semantics
index|]
argument_list|,
name|pathmsg
argument_list|,
name|indexmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|explicit_mode
condition|)
block|{
name|as_warn
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|<
name|md
operator|.
name|path
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Only the first path encountering the conflict "
literal|"is reported"
argument_list|)
argument_list|)
expr_stmt|;
name|as_warn_where
argument_list|(
name|rs
operator|->
name|file
argument_list|,
name|rs
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"This is the location of the "
literal|"conflicting usage"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't bother checking other paths, to avoid duplicating 		     the same warning */
break|break;
block|}
else|else
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s @ %s:%d\n"
argument_list|,
name|msg
argument_list|,
name|rs
operator|->
name|file
argument_list|,
name|rs
operator|->
name|line
argument_list|)
expr_stmt|;
name|remove_marked_resource
argument_list|(
name|rs
argument_list|)
expr_stmt|;
comment|/* since the set of dependencies has changed, start over */
comment|/* FIXME -- since we're removing dvs as we go, we 		     probably don't really need to start over...  */
name|start_over
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|start_over
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Register new dependencies based on the given opcode.  */
end_comment

begin_function
specifier|static
name|void
name|mark_resources
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|ia64_opcode_dependency
modifier|*
name|opdeps
init|=
name|idesc
operator|->
name|dependencies
decl_stmt|;
name|int
name|add_only_qp_reads
init|=
literal|0
decl_stmt|;
comment|/* A conditional branch only uses its resources if it is taken; if it is      taken, we stop following that path.  The other branch types effectively      *always* write their resources.  If it's not taken, register only QP      reads.  */
if|if
condition|(
name|is_conditional_branch
argument_list|(
name|idesc
argument_list|)
operator|||
name|is_interruption_or_rfi
argument_list|(
name|idesc
argument_list|)
condition|)
block|{
name|add_only_qp_reads
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Registering '%s' resource usage\n"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opdeps
operator|->
name|nregs
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
decl_stmt|;
name|struct
name|rsrc
name|specs
index|[
name|MAX_SPECS
index|]
decl_stmt|;
name|int
name|note
decl_stmt|;
name|int
name|path
decl_stmt|;
name|int
name|count
decl_stmt|;
name|dep
operator|=
name|ia64_find_dependency
argument_list|(
name|opdeps
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|note
operator|=
name|NOTE
argument_list|(
name|opdeps
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_only_qp_reads
operator|&&
operator|!
operator|(
name|dep
operator|->
name|mode
operator|==
name|IA64_DV_WAR
operator|&&
operator|(
name|dep
operator|->
name|specifier
operator|==
name|IA64_RS_PR
operator|||
name|dep
operator|->
name|specifier
operator|==
name|IA64_RS_PRr
operator|||
name|dep
operator|->
name|specifier
operator|==
name|IA64_RS_PR63
operator|)
operator|)
condition|)
continue|continue;
name|count
operator|=
name|specify_resource
argument_list|(
name|dep
argument_list|,
name|idesc
argument_list|,
name|DV_REG
argument_list|,
name|specs
argument_list|,
name|note
argument_list|,
name|md
operator|.
name|path
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (md.debug_dv&& !count) 	fprintf (stderr, "  No %s %s usage found (path %d)\n", 		 dv_mode[dep->mode], dep->name, md.path);
endif|#
directive|endif
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|mark_resource
argument_list|(
name|idesc
argument_list|,
name|dep
argument_list|,
operator|&
name|specs
index|[
name|count
index|]
argument_list|,
name|DEP
argument_list|(
name|opdeps
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
argument_list|,
name|md
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* The execution path may affect register values, which may in turn 	 affect which indirect-access resources are accessed.  */
switch|switch
condition|(
name|dep
operator|->
name|specifier
condition|)
block|{
default|default:
break|break;
case|case
name|IA64_RS_CPUID
case|:
case|case
name|IA64_RS_DBR
case|:
case|case
name|IA64_RS_IBR
case|:
case|case
name|IA64_RS_MSR
case|:
case|case
name|IA64_RS_PKR
case|:
case|case
name|IA64_RS_PMC
case|:
case|case
name|IA64_RS_PMD
case|:
case|case
name|IA64_RS_RR
case|:
for|for
control|(
name|path
operator|=
literal|0
init|;
name|path
operator|<
name|md
operator|.
name|path
condition|;
name|path
operator|++
control|)
block|{
name|count
operator|=
name|specify_resource
argument_list|(
name|dep
argument_list|,
name|idesc
argument_list|,
name|DV_REG
argument_list|,
name|specs
argument_list|,
name|note
argument_list|,
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|mark_resource
argument_list|(
name|idesc
argument_list|,
name|dep
argument_list|,
operator|&
name|specs
index|[
name|count
index|]
argument_list|,
name|DEP
argument_list|(
name|opdeps
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove dependencies when they no longer apply.  */
end_comment

begin_function
specifier|static
name|void
name|update_dependencies
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"srlz.i"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|instruction_serialization
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"srlz.d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data_serialization
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_interruption_or_rfi
argument_list|(
name|idesc
argument_list|)
operator|||
name|is_taken_branch
argument_list|(
name|idesc
argument_list|)
condition|)
block|{
comment|/* Although technically the taken branch doesn't clear dependencies 	 which require a srlz.[id], we don't follow the branch; the next 	 instruction is assumed to start with a clean slate.  */
name|regdepslen
operator|=
literal|0
expr_stmt|;
name|md
operator|.
name|path
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_conditional_branch
argument_list|(
name|idesc
argument_list|)
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|!=
literal|0
condition|)
block|{
name|int
name|is_call
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".call"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_implieslen
condition|;
name|i
operator|++
control|)
block|{
comment|/* If the conditional branch's predicate is implied by the predicate 	     in an existing dependency, remove that dependency.  */
if|if
condition|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
operator|==
name|CURR_SLOT
operator|.
name|qp_regno
condition|)
block|{
name|int
name|depind
init|=
literal|0
decl_stmt|;
comment|/* Note that this implied predicate takes a branch so that if 		 a later insn generates a DV but its predicate implies this 		 one, we can avoid the false DV warning.  */
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2_branched
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|depind
operator|<
name|regdepslen
condition|)
block|{
if|if
condition|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|qp_regno
operator|==
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
condition|)
block|{
name|print_dependency
argument_list|(
literal|"Removing"
argument_list|,
name|depind
argument_list|)
expr_stmt|;
name|regdeps
index|[
name|depind
index|]
operator|=
name|regdeps
index|[
operator|--
name|regdepslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|depind
expr_stmt|;
block|}
block|}
block|}
comment|/* Any marked resources which have this same predicate should be 	 cleared, provided that the QP hasn't been modified between the 	 marking instruction and the branch.  */
if|if
condition|(
name|is_call
condition|)
block|{
name|insn_group_break
argument_list|(
literal|0
argument_list|,
name|CURR_SLOT
operator|.
name|qp_regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|regdepslen
condition|)
block|{
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|qp_regno
operator|==
name|CURR_SLOT
operator|.
name|qp_regno
operator|&&
name|regdeps
index|[
name|i
index|]
operator|.
name|link_to_qp_branch
operator|&&
operator|(
name|regdeps
index|[
name|i
index|]
operator|.
name|file
operator|!=
name|CURR_SLOT
operator|.
name|src_file
operator|||
name|regdeps
index|[
name|i
index|]
operator|.
name|line
operator|!=
name|CURR_SLOT
operator|.
name|src_line
operator|)
condition|)
block|{
comment|/* Treat like a taken branch */
name|print_dependency
argument_list|(
literal|"Removing"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regdeps
index|[
name|i
index|]
operator|=
name|regdeps
index|[
operator|--
name|regdepslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Examine the current instruction for dependency violations.  */
end_comment

begin_function
specifier|static
name|int
name|check_dv
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checking %s for violations (line %d, %d/%d)\n"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
name|CURR_SLOT
operator|.
name|src_line
argument_list|,
name|idesc
operator|->
name|dependencies
operator|->
name|nchks
argument_list|,
name|idesc
operator|->
name|dependencies
operator|->
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* Look through the list of currently marked resources; if the current      instruction has the dependency in its chks list which uses that resource,      check against the specific resources used.  */
name|check_dependencies
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
comment|/* Look up the instruction's regdeps (RAW writes, WAW writes, and WAR reads),      then add them to the list of marked resources.  */
name|mark_resources
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
comment|/* There are several types of dependency semantics, and each has its own      requirements for being cleared       Instruction serialization (insns separated by interruption, rfi, or      writer + srlz.i + reader, all in separate groups) clears DVS_INSTR.       Data serialization (instruction serialization, or writer + srlz.d +      reader, where writer and srlz.d are in separate groups) clears      DVS_DATA. (This also clears DVS_OTHER, but that is not guaranteed to      always be the case).       Instruction group break (groups separated by stop, taken branch,      interruption or rfi) clears DVS_IMPLIED and DVS_IMPLIEDF.    */
name|update_dependencies
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
comment|/* Sometimes, knowing a register value allows us to avoid giving a false DV      warning.  Keep track of as many as possible that are useful.  */
name|note_register_values
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
comment|/* We don't need or want this anymore.  */
name|md
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Translate one line of assembly.  Pseudo ops and labels do not show    here.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|saved_input_line_pointer
decl_stmt|,
modifier|*
name|mnemonic
decl_stmt|;
specifier|const
name|struct
name|pseudo_opcode
modifier|*
name|pdesc
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|unsigned
name|char
name|qp_regno
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|saved_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
comment|/* extract the opcode (mnemonic):  */
name|mnemonic
operator|=
name|input_line_pointer
expr_stmt|;
name|ch
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|pdesc
operator|=
operator|(
expr|struct
name|pseudo_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|md
operator|.
name|pseudo_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdesc
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
call|(
modifier|*
name|pdesc
operator|->
name|handler
call|)
argument_list|(
name|pdesc
operator|->
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Find the instruction descriptor matching the arguments.  */
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
name|mnemonic
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|!
name|idesc
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown opcode `%s'"
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|idesc
operator|=
name|parse_operands
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|idesc
condition|)
goto|goto
name|done
goto|;
comment|/* Handle the dynamic ops we can handle now:  */
if|if
condition|(
name|idesc
operator|->
name|type
operator|==
name|IA64_TYPE_DYN
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|<
literal|4
condition|)
name|mnemonic
operator|=
literal|"addl"
expr_stmt|;
else|else
name|mnemonic
operator|=
literal|"adds"
expr_stmt|;
name|ia64_free_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
name|mnemonic
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|know (!idesc->next);
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enum
name|ia64_opnd
name|opnd1
decl_stmt|,
name|opnd2
decl_stmt|;
name|int
name|rop
decl_stmt|;
name|opnd1
operator|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|opnd2
operator|=
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|opnd1
operator|==
name|IA64_OPND_AR3
condition|)
name|rop
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd2
operator|==
name|IA64_OPND_AR3
condition|)
name|rop
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|rop
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|ar_is_in_integer_unit
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|rop
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
name|mnemonic
operator|=
literal|"mov.i"
expr_stmt|;
else|else
name|mnemonic
operator|=
literal|"mov.m"
expr_stmt|;
name|ia64_free_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
name|mnemonic
argument_list|)
expr_stmt|;
while|while
condition|(
name|idesc
operator|!=
name|NULL
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|!=
name|opnd1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|!=
name|opnd2
operator|)
condition|)
name|idesc
operator|=
name|get_next_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
block|}
block|}
name|qp_regno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|qp_regno
operator|=
name|md
operator|.
name|qp
operator|.
name|X_add_number
operator|-
name|REG_P
expr_stmt|;
name|md
operator|.
name|qp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
name|flags
operator|=
name|idesc
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IA64_OPCODE_FIRST
operator|)
operator|!=
literal|0
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IA64_OPCODE_NO_PRED
operator|)
operator|!=
literal|0
operator|&&
name|qp_regno
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"`%s' cannot be predicated"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Build the instruction.  */
name|CURR_SLOT
operator|.
name|qp_regno
operator|=
name|qp_regno
expr_stmt|;
name|CURR_SLOT
operator|.
name|idesc
operator|=
name|idesc
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|CURR_SLOT
operator|.
name|src_file
argument_list|,
operator|&
name|CURR_SLOT
operator|.
name|src_line
argument_list|)
expr_stmt|;
name|dwarf2_where
argument_list|(
operator|&
name|CURR_SLOT
operator|.
name|debug_line
argument_list|)
expr_stmt|;
comment|/* Add unwind entry, if there is one.  */
if|if
condition|(
name|unwind
operator|.
name|current_entry
condition|)
block|{
name|CURR_SLOT
operator|.
name|unwind_record
operator|=
name|unwind
operator|.
name|current_entry
expr_stmt|;
name|unwind
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Check for dependency violations.  */
if|if
condition|(
name|md
operator|.
name|detect_dv
condition|)
name|check_dv
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
name|md
operator|.
name|curr_slot
operator|=
operator|(
name|md
operator|.
name|curr_slot
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
if|if
condition|(
operator|++
name|md
operator|.
name|num_slots_in_use
operator|>=
name|NUM_SLOTS
condition|)
name|emit_one_bundle
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IA64_OPCODE_LAST
operator|)
operator|!=
literal|0
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|last_text_seg
operator|=
name|now_seg
expr_stmt|;
name|done
label|:
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when symbol NAME cannot be found in the symbol table.    Should be used for dynamic valued symbols only.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called for any expression that can not be recognized.  When the    function is called, `input_line_pointer' will point to the start of    the expression.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|e
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|enum
name|pseudo_type
name|pseudo_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'@'
case|:
comment|/* Find what relocation pseudo-function we're dealing with.  */
name|pseudo_type
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
operator|*
operator|++
name|input_line_pointer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|pseudo_func
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|pseudo_func
index|[
name|i
index|]
operator|.
name|name
operator|&&
name|pseudo_func
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
name|ch
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|pseudo_func
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pseudo_func
index|[
name|i
index|]
operator|.
name|name
operator|+
literal|1
argument_list|,
name|input_line_pointer
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|+=
name|len
expr_stmt|;
name|pseudo_type
operator|=
name|pseudo_func
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|pseudo_type
condition|)
block|{
case|case
name|PSEUDO_FUNC_RELOC
case|:
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'('
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected '('"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Skip '('.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing ')'"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_pseudo_fixup
condition|)
block|{
name|as_bad
argument_list|(
literal|"Not a symbolic expression"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|)
operator|==
name|FUNC_FPTR_RELATIVE
operator|&&
name|i
operator|==
name|FUNC_LT_RELATIVE
condition|)
name|i
operator|=
name|FUNC_LT_FPTR_RELATIVE
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
literal|"Illegal combination of relocation functions"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* Make sure gas doesn't get rid of local symbols that are used 	     in relocs.  */
name|e
operator|->
name|X_op
operator|=
name|O_pseudo_fixup
expr_stmt|;
name|e
operator|->
name|X_op_symbol
operator|=
name|pseudo_func
index|[
name|i
index|]
operator|.
name|u
operator|.
name|sym
expr_stmt|;
break|break;
case|case
name|PSEUDO_FUNC_CONST
case|:
name|e
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|pseudo_func
index|[
name|i
index|]
operator|.
name|u
operator|.
name|ival
expr_stmt|;
break|break;
case|case
name|PSEUDO_FUNC_REG
case|:
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|pseudo_func
index|[
name|i
index|]
operator|.
name|u
operator|.
name|ival
expr_stmt|;
break|break;
default|default:
name|name
operator|=
name|input_line_pointer
operator|-
literal|1
expr_stmt|;
name|get_symbol_end
argument_list|()
expr_stmt|;
name|as_bad
argument_list|(
literal|"Unknown pseudo function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
literal|'['
case|:
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Closing bracket misssing"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_register
condition|)
name|as_bad
argument_list|(
literal|"Register expected as index"
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|e
operator|->
name|X_op
operator|=
name|O_index
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return;
name|err
label|:
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if it's OK to adjust a reloc by replacing the symbol with    a section symbol plus some offset.  For relocs involving @fptr(),    directives we don't want such adjustments since we need to have the    original symbol's name in the reloc.  */
end_comment

begin_function
name|int
name|ia64_fix_adjustable
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
comment|/* Prevent all adjustments to global symbols */
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_FPTR64I
case|:
case|case
name|BFD_RELOC_IA64_FPTR32MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR32LSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64LSB
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR22
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64I
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ia64_force_relocation
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_FPTR64I
case|:
case|case
name|BFD_RELOC_IA64_FPTR32MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR32LSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64LSB
case|:
case|case
name|BFD_RELOC_IA64_LTOFF22
case|:
case|case
name|BFD_RELOC_IA64_LTOFF64I
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR22
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64I
case|:
case|case
name|BFD_RELOC_IA64_PLTOFF22
case|:
case|case
name|BFD_RELOC_IA64_PLTOFF64I
case|:
case|case
name|BFD_RELOC_IA64_PLTOFF64MSB
case|:
case|case
name|BFD_RELOC_IA64_PLTOFF64LSB
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Decide from what point a pc-relative relocation is relative to,    relative to the pc-relative fixup.  Er, relatively speaking.  */
end_comment

begin_function
name|long
name|ia64_pcrel_from_section
parameter_list|(
name|fix
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
name|unsigned
name|long
name|off
init|=
name|fix
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fix
operator|->
name|fx_where
decl_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
condition|)
name|off
operator|&=
operator|~
literal|0xfUL
expr_stmt|;
return|return
name|off
return|;
block|}
end_function

begin_comment
comment|/* This is called whenever some data item (not an instruction) needs a    fixup.  We pick the right reloc code depending on the byteorder    currently in effect.  */
end_comment

begin_function
name|void
name|ia64_cons_fix_new
parameter_list|(
name|f
parameter_list|,
name|where
parameter_list|,
name|nbytes
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|f
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
comment|/* There are no reloc for 8 and 16 bit quantities, but we allow 	 them here since they will work fine as long as the expression 	 is fully defined at the end of the pass over the source file.  */
case|case
literal|1
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|target_big_endian
condition|)
name|code
operator|=
name|BFD_RELOC_IA64_DIR32MSB
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_IA64_DIR32LSB
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|target_big_endian
condition|)
name|code
operator|=
name|BFD_RELOC_IA64_DIR64MSB
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_IA64_DIR64LSB
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
operator|&&
name|exp
operator|->
name|X_op_symbol
operator|&&
name|S_GET_VALUE
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|==
name|FUNC_IPLT_RELOC
condition|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|code
operator|=
name|BFD_RELOC_IA64_IPLTMSB
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_IA64_IPLTLSB
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
default|default:
name|as_bad
argument_list|(
literal|"Unsupported fixup size %d"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
condition|)
block|{
comment|/* ??? */
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|fix
operator|=
name|fix_new_exp
argument_list|(
name|f
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* We need to store the byte order in effect in case we're going      to fix an 8 or 16 bit relocation (for which there no real      relocs available).  See md_apply_fix3().  */
name|fix
operator|->
name|tc_fix_data
operator|.
name|bigendian
operator|=
name|target_big_endian
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual relocation we wish to associate with the pseudo    reloc described by SYM and R_TYPE.  SYM should be one of the    symbols in the pseudo_func array, or NULL.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|ia64_gen_real_reloc_type
parameter_list|(
name|sym
parameter_list|,
name|r_type
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|new
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
return|return
name|r_type
return|;
block|}
switch|switch
condition|(
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|FUNC_FPTR_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR64LSB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FUNC_GP_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL64LSB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FUNC_LT_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF64I
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FUNC_PC_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL64LSB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FUNC_PLT_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PLTOFF22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PLTOFF64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PLTOFF64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PLTOFF64LSB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FUNC_SEC_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SECREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SECREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SECREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SECREL64LSB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FUNC_SEG_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SEGREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SEGREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SEGREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SEGREL64LSB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FUNC_LTV_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTV32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTV32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTV64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTV64LSB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FUNC_LT_FPTR_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR64I
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FUNC_IPLT_RELOC
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Hmmmm.  Should this ever occur?  */
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
else|else
return|return
name|r_type
return|;
block|}
end_function

begin_comment
comment|/* Here is where generate the appropriate reloc for pseudo relocation    functions.  */
end_comment

begin_function
name|void
name|ia64_validate_fix
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_FPTR64I
case|:
case|case
name|BFD_RELOC_IA64_FPTR32MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64LSB
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR22
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64I
case|:
if|if
condition|(
name|fix
operator|->
name|fx_offset
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
literal|"No addend allowed in @fptr() relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fix_insn
parameter_list|(
name|fix
parameter_list|,
name|odesc
parameter_list|,
name|value
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
specifier|const
name|struct
name|ia64_operand
modifier|*
name|odesc
decl_stmt|;
name|valueT
name|value
decl_stmt|;
block|{
name|bfd_vma
name|insn
index|[
literal|3
index|]
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|control_bits
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|fixpos
decl_stmt|;
name|long
name|slot
decl_stmt|;
name|slot
operator|=
name|fix
operator|->
name|fx_where
operator|&
literal|0x3
expr_stmt|;
name|fixpos
operator|=
name|fix
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
operator|(
name|fix
operator|->
name|fx_where
operator|-
name|slot
operator|)
expr_stmt|;
comment|/* Bundles are always in little-endian byte order */
name|t0
operator|=
name|bfd_getl64
argument_list|(
name|fixpos
argument_list|)
expr_stmt|;
name|t1
operator|=
name|bfd_getl64
argument_list|(
name|fixpos
operator|+
literal|8
argument_list|)
expr_stmt|;
name|control_bits
operator|=
name|t0
operator|&
literal|0x1f
expr_stmt|;
name|insn
index|[
literal|0
index|]
operator|=
operator|(
name|t0
operator|>>
literal|5
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|t0
operator|>>
literal|46
operator|)
operator|&
literal|0x3ffff
operator|)
operator||
operator|(
operator|(
name|t1
operator|&
literal|0x7fffff
operator|)
operator|<<
literal|18
operator|)
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator|=
operator|(
name|t1
operator|>>
literal|23
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|odesc
operator|-
name|elf64_ia64_operands
operator|==
name|IA64_OPND_IMMU64
condition|)
block|{
name|insn
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|22
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator||=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0x7f
operator|)
operator|<<
literal|13
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|7
operator|)
operator|&
literal|0x1ff
operator|)
operator|<<
literal|27
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|21
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|63
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|odesc
operator|-
name|elf64_ia64_operands
operator|==
name|IA64_OPND_IMMU62
condition|)
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0x3fffffffffffffffULL
condition|)
name|err
operator|=
literal|"integer operand out of range"
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|21
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator||=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0xfffff
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|20
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|odesc
operator|-
name|elf64_ia64_operands
operator|==
name|IA64_OPND_TGT64
condition|)
block|{
name|value
operator|>>=
literal|4
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|value
operator|>>
literal|20
operator|)
operator|&
literal|0x7fffffffffLL
operator|)
operator|<<
literal|2
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator||=
operator|(
operator|(
operator|(
operator|(
name|value
operator|>>
literal|59
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|0
operator|)
operator|&
literal|0xfffff
operator|)
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|err
operator|=
call|(
modifier|*
name|odesc
operator|->
name|insert
call|)
argument_list|(
name|odesc
argument_list|,
name|value
argument_list|,
name|insn
operator|+
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|t0
operator|=
name|control_bits
operator||
operator|(
name|insn
index|[
literal|0
index|]
operator|<<
literal|5
operator|)
operator||
operator|(
name|insn
index|[
literal|1
index|]
operator|<<
literal|46
operator|)
expr_stmt|;
name|t1
operator|=
operator|(
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|18
operator|)
operator|&
literal|0x7fffff
operator|)
operator||
operator|(
name|insn
index|[
literal|2
index|]
operator|<<
literal|23
operator|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|fixpos
operator|+
literal|0
argument_list|,
name|t0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|fixpos
operator|+
literal|8
argument_list|,
name|t1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to simplify or even eliminate a fixup.  The return value is    ignored; perhaps it was once meaningful, but now it is historical.    To indicate that a fixup has been eliminated, set FIXP->FX_DONE.     If fixp->fx_addsy is non-NULL, we'll have to generate a reloc entry    (if possible).  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fix
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|fixpos
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valP
decl_stmt|;
name|int
name|adjust
init|=
literal|0
decl_stmt|;
name|fixpos
operator|=
name|fix
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fix
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_IA64_PCREL32MSB
expr_stmt|;
name|adjust
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_IA64_PCREL32LSB
expr_stmt|;
name|adjust
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_IA64_PCREL64MSB
expr_stmt|;
name|adjust
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_IA64_PCREL64LSB
expr_stmt|;
name|adjust
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|fix
operator|->
name|fx_addsy
condition|)
block|{
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
comment|/* This must be a TAG13 or TAG13b operand.  There are no external 	     relocs defined for them, so we must give an error.  */
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
literal|"%s must have a constant value"
argument_list|,
name|elf64_ia64_operands
index|[
name|fix
operator|->
name|tc_fix_data
operator|.
name|opnd
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* ??? This is a hack copied from tc-i386.c to make PCREL relocs 	 work.  There should be a better way to handle this.  */
if|if
condition|(
name|adjust
condition|)
name|fix
operator|->
name|fx_offset
operator|+=
name|fix
operator|->
name|fx_where
operator|+
name|fix
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fix
operator|->
name|tc_fix_data
operator|.
name|opnd
operator|==
name|IA64_OPND_NIL
condition|)
block|{
if|if
condition|(
name|fix
operator|->
name|tc_fix_data
operator|.
name|bigendian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|fixpos
argument_list|,
name|value
argument_list|,
name|fix
operator|->
name|fx_size
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|fixpos
argument_list|,
name|value
argument_list|,
name|fix
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fix_insn
argument_list|(
name|fix
argument_list|,
name|elf64_ia64_operands
operator|+
name|fix
operator|->
name|tc_fix_data
operator|.
name|opnd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the BFD reloc to be stuck in the object file from the    fixup used internally in the assembler.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|sec
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
operator|->
name|howto
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Cannot represent %s relocation in object file"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LIT.  The number    of LITTLENUMS emitted is stored in *SIZE.  An error message is    returned, or NULL on OK.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|5
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|lit
parameter_list|,
name|size
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|lit
decl_stmt|;
name|int
modifier|*
name|size
decl_stmt|;
block|{
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|word
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|prec
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* IEEE floats */
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
operator|*
name|size
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to MD_ATOF()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|size
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|word
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|lit
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|word
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|lit
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Round up a section's size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|size
parameter_list|)
name|segT
name|seg
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
name|valueT
name|mask
init|=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|size
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Handle ia64 specific semantics of the align directive.  */
end_comment

begin_function
name|void
name|ia64_md_do_align
parameter_list|(
name|n
parameter_list|,
name|fill
parameter_list|,
name|len
parameter_list|,
name|max
parameter_list|)
name|int
name|n
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|fill
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|len
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|max
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|subseg_text_p
argument_list|(
name|now_seg
argument_list|)
condition|)
name|ia64_flush_insns
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents    of an rs_align_code fragment.  */
end_comment

begin_function
name|void
name|ia64_handle_align
parameter_list|(
name|fragp
parameter_list|)
name|fragS
modifier|*
name|fragp
decl_stmt|;
block|{
comment|/* Use mfi bundle of nops with no stop bits.  */
specifier|static
specifier|const
name|unsigned
name|char
name|be_nop
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x04
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0c
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|le_nop
index|[]
init|=
block|{
literal|0x0c
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x00
block|}
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
name|bytes
operator|=
name|fragp
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* Make sure we are on a 16-byte boundary, in case someone has been      putting data into a text section.  */
if|if
condition|(
name|bytes
operator|&
literal|15
condition|)
block|{
name|int
name|fix
init|=
name|bytes
operator|&
literal|15
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|fix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|fix
expr_stmt|;
name|bytes
operator|-=
name|fix
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fix
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
operator|(
name|target_big_endian
condition|?
name|be_nop
else|:
name|le_nop
operator|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
literal|16
expr_stmt|;
block|}
end_function

end_unit

