begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* a.out object file format    Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000,    2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2,    or (at your option) any later version.     GAS is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See    the GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_define
define|#
directive|define
name|OBJ_HEADER
value|"obj-aout.h"
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_undef
undef|#
directive|undef
name|NO_RELOC
end_undef

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_function
name|void
name|obj_aout_frob_symbol
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|int
modifier|*
name|punt
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|desc
decl_stmt|,
name|type
decl_stmt|,
name|other
decl_stmt|;
name|flags
operator|=
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
expr_stmt|;
name|desc
operator|=
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|desc
expr_stmt|;
name|type
operator|=
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|type
expr_stmt|;
name|other
operator|=
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|other
expr_stmt|;
name|sec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* Only frob simple symbols this way right now.  */
if|if
condition|(
operator|!
operator|(
name|type
operator|&
operator|~
operator|(
name|N_TYPE
operator||
name|N_EXT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|sec
operator|==
operator|&
name|bfd_abs_section
condition|)
block|{
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_INDR
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETA
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETT
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETD
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETB
operator|&&
name|type
operator|!=
name|N_WARNING
operator|&&
operator|(
name|sec
operator|==
operator|&
name|bfd_abs_section
operator|||
name|sec
operator|==
operator|&
name|bfd_und_section
operator|)
condition|)
return|return;
if|if
condition|(
name|flags
operator|&
name|BSF_EXPORT
condition|)
name|type
operator||=
name|N_EXT
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_SETA
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETB
case|:
comment|/* Set the debugging flag for constructor symbols so that 	     BFD leaves them alone.  */
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
comment|/* You can't put a common symbol in a set.  The way a set 	     element works is that the symbol has a definition and a 	     name, and the linker adds the definition to the set of 	     that name.  That does not work for a common symbol, 	     because the linker can't tell which common symbol the 	     user means.  FIXME: Using as_bad here may be 	     inappropriate, since the user may want to force a 	     particular type without regard to the semantics of sets; 	     on the other hand, we certainly don't want anybody to be 	     mislead into thinking that their code will work.  */
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Attempt to put a common symbol into set %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Similarly, you can't put an undefined symbol in a set.  */
elseif|else
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Attempt to put an undefined symbol into set %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_INDR
case|:
comment|/* Put indirect symbols in the indirect section.  */
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|bfd_ind_section_ptr
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_INDIRECT
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|N_EXT
condition|)
block|{
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_EXPORT
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|BSF_LOCAL
expr_stmt|;
block|}
break|break;
case|case
name|N_WARNING
case|:
comment|/* Mark warning symbols.  */
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_WARNING
expr_stmt|;
break|break;
block|}
block|}
else|else
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* Double check weak symbols.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|sym
argument_list|)
operator|&&
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Symbol `%s' can not be both weak and common"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|obj_aout_frob_file_before_fix
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Relocation processing may require knowing the VMAs of the sections.      Since writing to a section will cause the BFD back end to compute the      VMAs, fake it out here....  */
name|bfd_byte
name|b
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|x
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|bfd_section_size
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|)
operator|!=
literal|0
condition|)
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|,
operator|&
name|b
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_section_size
argument_list|(
name|stdoutput
argument_list|,
name|data_section
argument_list|)
operator|!=
literal|0
condition|)
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|data_section
argument_list|,
operator|&
name|b
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_aout_line
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Assume delimiter is part of expression.      BSD4.2 as fails with delightful bug, so we      are not being incompatible here.  */
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
call|(
name|int
call|)
argument_list|(
name|get_absolute_expression
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .weak.  This is a GNU extension.  */
end_comment

begin_function
specifier|static
name|void
name|obj_aout_weak
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_SET_WEAK
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .type.  On {Net,Open}BSD, this is used to set the n_other field,    which is then apparently used when doing dynamic linking.  Older    versions of gas ignored the .type pseudo-op, so we also ignore it if    we can't parse it.  */
end_comment

begin_function
specifier|static
name|void
name|obj_aout_type
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'@'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"object"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|S_SET_OTHER
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"function"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|S_SET_OTHER
argument_list|(
name|sym
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Ignore everything else on the line.  */
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support for an AOUT emulation.  */
end_comment

begin_function
specifier|static
name|void
name|aout_pop_insert
parameter_list|(
name|void
parameter_list|)
block|{
name|pop_insert
argument_list|(
name|aout_pseudo_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_s_get_other
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
return|return
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|other
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_aout_s_set_other
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|int
name|o
parameter_list|)
block|{
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|other
operator|=
name|o
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_sec_sym_ok_for_reloc
parameter_list|(
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|obj_sec_sym_ok_for_reloc
argument_list|(
name|sec
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_aout_process_stab
parameter_list|(
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|w
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|t
parameter_list|,
name|int
name|o
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|aout_process_stab
argument_list|(
name|w
argument_list|,
name|s
argument_list|,
name|t
argument_list|,
name|o
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_s_get_desc
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
return|return
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|desc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_aout_s_set_desc
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|desc
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_s_get_type
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
return|return
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_aout_s_set_type
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|type
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_separate_stab_sections
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When changed, make sure these table entries match the single-format    definitions in obj-aout.h.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|format_ops
name|aout_format_ops
init|=
block|{
name|bfd_target_aout_flavour
block|,
literal|1
block|,
comment|/* dfl_leading_underscore.  */
literal|0
block|,
comment|/* emit_section_symbols.  */
literal|0
block|,
comment|/* begin.  */
literal|0
block|,
comment|/* app_file.  */
name|obj_aout_frob_symbol
block|,
literal|0
block|,
comment|/* frob_file.  */
literal|0
block|,
comment|/* frob_file_before_adjust.  */
name|obj_aout_frob_file_before_fix
block|,
literal|0
block|,
comment|/* frob_file_after_relocs.  */
literal|0
block|,
comment|/* s_get_size.  */
literal|0
block|,
comment|/* s_set_size.  */
literal|0
block|,
comment|/* s_get_align.  */
literal|0
block|,
comment|/* s_set_align.  */
name|obj_aout_s_get_other
block|,
name|obj_aout_s_set_other
block|,
name|obj_aout_s_get_desc
block|,
name|obj_aout_s_set_desc
block|,
name|obj_aout_s_get_type
block|,
name|obj_aout_s_set_type
block|,
literal|0
block|,
comment|/* copy_symbol_attributes.  */
literal|0
block|,
comment|/* generate_asm_lineno.  */
name|obj_aout_process_stab
block|,
name|obj_aout_separate_stab_sections
block|,
literal|0
block|,
comment|/* init_stab_section.  */
name|obj_aout_sec_sym_ok_for_reloc
block|,
name|aout_pop_insert
block|,
literal|0
block|,
comment|/* ecoff_set_ext.  */
literal|0
block|,
comment|/* read_begin_hook.  */
literal|0
comment|/* symbol_new_hook.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|aout_pseudo_table
index|[]
init|=
block|{
block|{
literal|"line"
block|,
name|obj_aout_line
block|,
literal|0
block|}
block|,
comment|/* Source code line number.  */
block|{
literal|"ln"
block|,
name|obj_aout_line
block|,
literal|0
block|}
block|,
comment|/* COFF line number that we use anyway.  */
block|{
literal|"weak"
block|,
name|obj_aout_weak
block|,
literal|0
block|}
block|,
comment|/* Mark symbol as weak.  */
block|{
literal|"type"
block|,
name|obj_aout_type
block|,
literal|0
block|}
block|,
comment|/* coff debug pseudos (ignored) */
block|{
literal|"def"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ident"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"line"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"scl"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"version"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* For sun386i cc (?).  */
comment|/* other stuff */
block|{
literal|"ABORT"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

