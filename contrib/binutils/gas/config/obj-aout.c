begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* a.out object file format    Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000    Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|OBJ_HEADER
value|"obj-aout.h"
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_undef
undef|#
directive|undef
name|NO_RELOC
end_undef

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_comment
comment|/* in: segT   out: N_TYPE bits */
end_comment

begin_decl_stmt
specifier|const
name|short
name|seg_N_TYPE
index|[]
init|=
block|{
name|N_ABS
block|,
name|N_TEXT
block|,
name|N_DATA
block|,
name|N_BSS
block|,
name|N_UNDF
block|,
comment|/* unknown */
name|N_UNDF
block|,
comment|/* error */
name|N_UNDF
block|,
comment|/* expression */
name|N_UNDF
block|,
comment|/* debug */
name|N_UNDF
block|,
comment|/* ntv */
name|N_UNDF
block|,
comment|/* ptv */
name|N_REGISTER
block|,
comment|/* register */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|segT
name|N_TYPE_seg
index|[
name|N_TYPE
operator|+
literal|2
index|]
init|=
block|{
comment|/* N_TYPE == 0x1E = 32-2 */
name|SEG_UNKNOWN
block|,
comment|/* N_UNDF == 0 */
name|SEG_GOOF
block|,
name|SEG_ABSOLUTE
block|,
comment|/* N_ABS == 2 */
name|SEG_GOOF
block|,
name|SEG_TEXT
block|,
comment|/* N_TEXT == 4 */
name|SEG_GOOF
block|,
name|SEG_DATA
block|,
comment|/* N_DATA == 6 */
name|SEG_GOOF
block|,
name|SEG_BSS
block|,
comment|/* N_BSS == 8 */
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_REGISTER
block|,
comment|/* dummy N_REGISTER for regs = 30 */
name|SEG_GOOF
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|obj_aout_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_aout_weak
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_aout_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|aout_pseudo_table
index|[]
init|=
block|{
block|{
literal|"line"
block|,
name|obj_aout_line
block|,
literal|0
block|}
block|,
comment|/* source code line number */
block|{
literal|"ln"
block|,
name|obj_aout_line
block|,
literal|0
block|}
block|,
comment|/* coff line number that we use anyway */
block|{
literal|"weak"
block|,
name|obj_aout_weak
block|,
literal|0
block|}
block|,
comment|/* mark symbol as weak.  */
block|{
literal|"type"
block|,
name|obj_aout_type
block|,
literal|0
block|}
block|,
comment|/* coff debug pseudos (ignored) */
block|{
literal|"def"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ident"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"line"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"scl"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"version"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* For sun386i cc (?) */
comment|/* other stuff */
block|{
literal|"ABORT"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
comment|/* end sentinel */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* aout_pseudo_table */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|void
name|obj_aout_frob_symbol
parameter_list|(
name|sym
parameter_list|,
name|punt
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
modifier|*
name|punt
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|desc
decl_stmt|,
name|type
decl_stmt|,
name|other
decl_stmt|;
name|flags
operator|=
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
expr_stmt|;
name|desc
operator|=
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|desc
expr_stmt|;
name|type
operator|=
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|type
expr_stmt|;
name|other
operator|=
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|other
expr_stmt|;
name|sec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* Only frob simple symbols this way right now.  */
if|if
condition|(
operator|!
operator|(
name|type
operator|&
operator|~
operator|(
name|N_TYPE
operator||
name|N_EXT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|sec
operator|==
operator|&
name|bfd_abs_section
condition|)
block|{
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_INDR
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETA
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETT
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETD
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETB
operator|&&
name|type
operator|!=
name|N_WARNING
operator|&&
operator|(
name|sec
operator|==
operator|&
name|bfd_abs_section
operator|||
name|sec
operator|==
operator|&
name|bfd_und_section
operator|)
condition|)
return|return;
if|if
condition|(
name|flags
operator|&
name|BSF_EXPORT
condition|)
name|type
operator||=
name|N_EXT
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_SETA
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETB
case|:
comment|/* Set the debugging flag for constructor symbols so that 	     BFD leaves them alone.  */
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
comment|/* You can't put a common symbol in a set.  The way a set 	     element works is that the symbol has a definition and a 	     name, and the linker adds the definition to the set of 	     that name.  That does not work for a common symbol, 	     because the linker can't tell which common symbol the 	     user means.  FIXME: Using as_bad here may be 	     inappropriate, since the user may want to force a 	     particular type without regard to the semantics of sets; 	     on the other hand, we certainly don't want anybody to be 	     mislead into thinking that their code will work.  */
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Attempt to put a common symbol into set %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Similarly, you can't put an undefined symbol in a set.  */
elseif|else
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Attempt to put an undefined symbol into set %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_INDR
case|:
comment|/* Put indirect symbols in the indirect section.  */
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|bfd_ind_section_ptr
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_INDIRECT
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|N_EXT
condition|)
block|{
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_EXPORT
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|BSF_LOCAL
expr_stmt|;
block|}
break|break;
case|case
name|N_WARNING
case|:
comment|/* Mark warning symbols.  */
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_WARNING
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
block|}
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* Double check weak symbols.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Symbol `%s' can not be both weak and common"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|obj_aout_frob_file
parameter_list|()
block|{
comment|/* Relocation processing may require knowing the VMAs of the sections.      Since writing to a section will cause the BFD back end to compute the      VMAs, fake it out here....  */
name|bfd_byte
name|b
init|=
literal|0
decl_stmt|;
name|boolean
name|x
init|=
name|true
decl_stmt|;
if|if
condition|(
name|bfd_section_size
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|,
operator|&
name|b
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_section_size
argument_list|(
name|stdoutput
argument_list|,
name|data_section
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|data_section
argument_list|,
operator|&
name|b
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|x
operator|==
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_comment
comment|/* Relocation.  */
end_comment

begin_comment
comment|/*  *		emit_relocations()  *  * Crawl along a fixS chain. Emit the segment's relocations.  */
end_comment

begin_function
name|void
name|obj_emit_relocations
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Fixup chain for this segment.  */
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|==
literal|0
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|fixP
operator|->
name|fx_addsy
expr_stmt|;
while|while
condition|(
name|sym
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
name|sym
operator|=
name|sym
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|sym
expr_stmt|;
if|if
condition|(
operator|!
name|sym
operator|->
name|sy_resolved
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
if|if
condition|(
name|expr_symbol_where
argument_list|(
name|sym
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"unresolved relocation"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad relocation: symbol `%s' not in symbol table"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tc_aout_fix_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|fixP
argument_list|,
name|segment_address_in_file
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
name|md_reloc_size
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|obj_header_append
end_ifndef

begin_comment
comment|/* Aout file generation& utilities */
end_comment

begin_function
name|void
name|obj_header_append
parameter_list|(
name|where
parameter_list|,
name|headers
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|tc_headers_hook
argument_list|(
name|headers
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_info
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_info
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_info
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_text
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_text
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_data
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_data
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_bss
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_bss
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_bss
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_syms
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_entry
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_entry
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_trsize
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_drsize
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|headers
operator|->
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (obj_header_append) */
end_comment

begin_function
name|void
name|obj_symbol_to_chars
parameter_list|(
name|where
parameter_list|,
name|symbolP
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|S_GET_OFFSET
argument_list|(
name|symbolP
argument_list|)
operator|)
argument_list|,
name|S_GET_OFFSET
argument_list|(
name|symbolP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|S_GET_OFFSET
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|)
argument_list|,
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|n_value
operator|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|n_value
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
operator|->
name|sy_symbol
argument_list|,
sizeof|sizeof
argument_list|(
name|obj_symbol_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|obj_emit_symbols
parameter_list|(
name|where
parameter_list|,
name|symbol_rootP
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Emit all symbols left in the symbol chain.  */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* Used to save the offset of the name. It is used to point 	 to the string in memory but must be a file offset.  */
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_OFFSET
argument_list|(
name|symbolP
argument_list|,
name|symbolP
operator|->
name|sy_name_offset
argument_list|)
expr_stmt|;
comment|/* Any symbol still undefined and is not a dbg symbol is made N_EXT.  */
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* Adjust the type of a weak symbol.  */
if|if
condition|(
name|S_GET_WEAK
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
case|case
name|N_UNDF
case|:
name|S_SET_TYPE
argument_list|(
name|symbolP
argument_list|,
name|N_WEAKU
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
name|S_SET_TYPE
argument_list|(
name|symbolP
argument_list|,
name|N_WEAKA
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_TEXT
case|:
name|S_SET_TYPE
argument_list|(
name|symbolP
argument_list|,
name|N_WEAKT
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|S_SET_TYPE
argument_list|(
name|symbolP
argument_list|,
name|N_WEAKD
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|S_SET_TYPE
argument_list|(
name|symbolP
argument_list|,
name|N_WEAKB
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: bad type for weak symbol"
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|obj_symbol_to_chars
argument_list|(
name|where
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_function
specifier|static
name|void
name|obj_aout_line
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Assume delimiter is part of expression.      BSD4.2 as fails with delightful bug, so we      are not being incompatible here.  */
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
call|(
name|int
call|)
argument_list|(
name|get_absolute_expression
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* obj_aout_line() */
end_comment

begin_comment
comment|/* Handle .weak.  This is a GNU extension.  */
end_comment

begin_function
specifier|static
name|void
name|obj_aout_weak
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_SET_WEAK
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .type.  On {Net,Open}BSD, this is used to set the n_other field,    which is then apparently used when doing dynamic linking.  Older    versions of gas ignored the .type pseudo-op, so we also ignore it if    we can't parse it.  */
end_comment

begin_function
specifier|static
name|void
name|obj_aout_type
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'@'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"object"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|other
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|S_SET_OTHER
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"function"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|other
operator|=
literal|2
expr_stmt|;
else|#
directive|else
name|S_SET_OTHER
argument_list|(
name|sym
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Ignore everything else on the line.  */
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|obj_crawl_symbol_chain
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|symbolPP
decl_stmt|;
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
name|tc_crawl_symbol_chain
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|symbolPP
operator|=
operator|&
name|symbol_rootP
expr_stmt|;
comment|/*->last symbol chain link.  */
while|while
condition|(
operator|(
name|symbolP
operator|=
operator|*
name|symbolPP
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_mri_common
condition|)
block|{
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: global symbols not supported in common sections"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|symbolPP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flag_readonly_data_in_text
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_DATA
operator|)
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_TEXT
argument_list|)
expr_stmt|;
block|}
comment|/* if pusing data into text */
name|resolve_symbol_value
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Skip symbols which were equated to undefined or common 	 symbols.  */
if|if
condition|(
name|symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
operator|*
name|symbolPP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* OK, here is how we decide which symbols go out into the brave 	 new symtab.  Symbols that do are:  	 * symbols with no name (stabd's?) 	 * symbols with debug info in their N_TYPE  	 Symbols that don't are: 	 * symbols that are registers 	 * symbols with \1 as their 3rd character (numeric labels) 	 * "local labels" as defined by S_LOCAL_NAME(name) if the -L 	 switch was passed to gas.  	 All other symbols are output.  We complain if a deleted 	 symbol was marked external.  */
if|if
condition|(
operator|!
name|S_IS_REGISTER
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
operator|!
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|||
operator|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\001'
operator|&&
operator|(
name|flag_keep_locals
operator|||
operator|!
name|S_LOCAL_NAME
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|symbolP
operator|->
name|sy_number
operator|=
name|symbol_number
operator|++
expr_stmt|;
comment|/* The + 1 after strlen account for the \0 at the 			   end of each string */
if|if
condition|(
operator|!
name|S_IS_STABD
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Ordinary case.  */
name|symbolP
operator|->
name|sy_name_offset
operator|=
name|string_byte_count
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
comment|/* .Stabd case.  */
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
name|symbolPP
operator|=
operator|&
name|symbolP
operator|->
name|sy_next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
comment|/* This warning should never get triggered any more. 	       Well, maybe if you're doing twisted things with 	       register names...  */
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Local symbol %s never defined."
argument_list|)
argument_list|,
name|decode_local_label_name
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* oops.  */
comment|/* Unhook it from the chain */
operator|*
name|symbolPP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if this symbol should be in the output */
block|}
comment|/* for each symbol */
name|H_SET_SYMBOL_TABLE_SIZE
argument_list|(
name|headers
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find strings by crawling along symbol table chain.  */
end_comment

begin_function
name|void
name|obj_emit_strings
parameter_list|(
name|where
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|string_byte_count
argument_list|,
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|string_byte_count
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
if|if
condition|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
condition|)
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* walk symbol chain */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|AOUT_VERSION
end_ifndef

begin_define
define|#
directive|define
name|AOUT_VERSION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|obj_pre_write_hook
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|H_SET_DYNAMIC
argument_list|(
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|H_SET_VERSION
argument_list|(
name|headers
argument_list|,
name|AOUT_VERSION
argument_list|)
expr_stmt|;
name|H_SET_MACHTYPE
argument_list|(
name|headers
argument_list|,
name|AOUT_MACHTYPE
argument_list|)
expr_stmt|;
name|tc_aout_pre_write_hook
argument_list|(
name|headers
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_sect
parameter_list|()
block|{
comment|/* Strip out the section name */
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
modifier|*
name|section_name_end
decl_stmt|;
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|exp
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|section_name_end
operator|=
name|input_line_pointer
expr_stmt|;
name|len
operator|=
name|section_name_end
operator|-
name|section_name
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|exp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|exp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|=
name|save
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|>=
literal|1000
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"subsegment index too high"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|section_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|subseg_set
argument_list|(
name|SEG_TEXT
argument_list|,
operator|(
name|subsegT
operator|)
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|section_name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag_readonly_data_in_text
condition|)
name|subseg_set
argument_list|(
name|SEG_TEXT
argument_list|,
operator|(
name|subsegT
operator|)
name|exp
operator|+
literal|1000
argument_list|)
expr_stmt|;
else|else
name|subseg_set
argument_list|(
name|SEG_DATA
argument_list|,
operator|(
name|subsegT
operator|)
name|exp
argument_list|)
expr_stmt|;
block|}
operator|*
name|section_name_end
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_comment
comment|/* Support for an AOUT emulation.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|aout_pop_insert
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|obj_aout_s_get_other
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_aout_s_set_other
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|obj_aout_s_get_desc
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_aout_s_set_desc
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|obj_aout_s_get_type
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_aout_s_set_type
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|obj_aout_separate_stab_sections
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|obj_aout_sec_sym_ok_for_reloc
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_aout_process_stab
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|aout_pop_insert
parameter_list|()
block|{
name|pop_insert
argument_list|(
name|aout_pseudo_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_s_get_other
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|other
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_aout_s_set_other
parameter_list|(
name|sym
parameter_list|,
name|o
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|o
decl_stmt|;
block|{
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|other
operator|=
name|o
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_sec_sym_ok_for_reloc
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|obj_sec_sym_ok_for_reloc
argument_list|(
name|sec
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_aout_process_stab
parameter_list|(
name|seg
parameter_list|,
name|w
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|,
name|o
parameter_list|,
name|d
parameter_list|)
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|w
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|o
decl_stmt|;
name|int
name|d
decl_stmt|;
block|{
name|aout_process_stab
argument_list|(
name|w
argument_list|,
name|s
argument_list|,
name|t
argument_list|,
name|o
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_s_get_desc
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|desc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_aout_s_set_desc
parameter_list|(
name|sym
parameter_list|,
name|d
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|d
decl_stmt|;
block|{
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|desc
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_s_get_type
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_aout_s_set_type
parameter_list|(
name|sym
parameter_list|,
name|t
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|t
decl_stmt|;
block|{
name|aout_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|type
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|obj_aout_separate_stab_sections
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When changed, make sure these table entries match the single-format    definitions in obj-aout.h.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|format_ops
name|aout_format_ops
init|=
block|{
name|bfd_target_aout_flavour
block|,
literal|1
block|,
comment|/* dfl_leading_underscore */
literal|0
block|,
comment|/* emit_section_symbols */
literal|0
block|,
comment|/* begin */
literal|0
block|,
comment|/* app_file */
name|obj_aout_frob_symbol
block|,
name|obj_aout_frob_file
block|,
literal|0
block|,
comment|/* frob_file_before_adjust */
literal|0
block|,
comment|/* frob_file_after_relocs */
literal|0
block|,
comment|/* s_get_size */
literal|0
block|,
comment|/* s_set_size */
literal|0
block|,
comment|/* s_get_align */
literal|0
block|,
comment|/* s_set_align */
name|obj_aout_s_get_other
block|,
name|obj_aout_s_set_other
block|,
name|obj_aout_s_get_desc
block|,
name|obj_aout_s_set_desc
block|,
name|obj_aout_s_get_type
block|,
name|obj_aout_s_set_type
block|,
literal|0
block|,
comment|/* copy_symbol_attributes */
literal|0
block|,
comment|/* generate_asm_lineno */
name|obj_aout_process_stab
block|,
name|obj_aout_separate_stab_sections
block|,
literal|0
block|,
comment|/* init_stab_section */
name|obj_aout_sec_sym_ok_for_reloc
block|,
name|aout_pop_insert
block|,
literal|0
block|,
comment|/* ecoff_set_ext */
literal|0
block|,
comment|/* read_begin_hook */
literal|0
comment|/* symbol_new_hook */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|BFD_ASSEMBLER
end_endif

end_unit

