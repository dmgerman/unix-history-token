begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-mep.c -- Assembler for the Toshiba Media Processor.    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/mep-desc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/mep-opc.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/mep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"xregex.h"
end_include

begin_comment
comment|/* Structure to hold all of the different components describing    an individual instruction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|orig_insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
name|CGEN_INSN_INT
name|buffer
index|[
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(*(buf))
else|#
directive|else
name|unsigned
name|char
name|buffer
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(buf)
endif|#
directive|endif
name|char
modifier|*
name|addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|num_fixups
decl_stmt|;
name|fixS
modifier|*
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|indices
index|[
name|MAX_OPERAND_INSTANCES
index|]
decl_stmt|;
block|}
name|mep_insn
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|mode
init|=
name|CORE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start in core mode. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pluspresent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allow_disabled_registers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|library_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're going to need to store all of the instructions along with    their fixups so that we can parallelization grouping rules. */
end_comment

begin_decl_stmt
specifier|static
name|mep_insn
name|saved_insns
index|[
name|MAX_SAVED_FIXUP_CHAINS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_insns_saved
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|";#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mep_switch_to_vliw_mode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mep_switch_to_core_mode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mep_s_vtext
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mep_noregerr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"file"
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
block|{
literal|"vliw"
block|,
name|mep_switch_to_vliw_mode
block|,
literal|0
block|}
block|,
block|{
literal|"core"
block|,
name|mep_switch_to_core_mode
block|,
literal|0
block|}
block|,
block|{
literal|"vtext"
block|,
name|mep_s_vtext
block|,
literal|0
block|}
block|,
block|{
literal|"noregerr"
block|,
name|mep_noregerr
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocations against symbols are done in two    parts, with a HI relocation and a LO relocation.  Each relocation    has only 16 bits of space to store an addend.  This means that in    order for the linker to handle carries correctly, it must be able    to locate both the HI and the LO relocation.  This means that the    relocations must appear in order in the relocation table.     In order to implement this, we keep track of each unmatched HI    relocation.  We then sort them so that they immediately precede the    corresponding LO relocation. */
end_comment

begin_struct
struct|struct
name|mep_hi_fixup
block|{
name|struct
name|mep_hi_fixup
modifier|*
name|next
decl_stmt|;
comment|/* Next HI fixup.  */
name|fixS
modifier|*
name|fixp
decl_stmt|;
comment|/* This fixup.  */
name|segT
name|seg
decl_stmt|;
comment|/* The section this fixup is in.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The list of unmatched HI relocs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mep_hi_fixup
modifier|*
name|mep_hi_fixup_list
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
end_define

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CONFIG
value|(OPTION_MD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|OPTION_AVERAGE
value|(OPTION_MD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|OPTION_NOAVERAGE
value|(OPTION_MD_BASE + 4)
end_define

begin_define
define|#
directive|define
name|OPTION_MULT
value|(OPTION_MD_BASE + 5)
end_define

begin_define
define|#
directive|define
name|OPTION_NOMULT
value|(OPTION_MD_BASE + 6)
end_define

begin_define
define|#
directive|define
name|OPTION_DIV
value|(OPTION_MD_BASE + 7)
end_define

begin_define
define|#
directive|define
name|OPTION_NODIV
value|(OPTION_MD_BASE + 8)
end_define

begin_define
define|#
directive|define
name|OPTION_BITOPS
value|(OPTION_MD_BASE + 9)
end_define

begin_define
define|#
directive|define
name|OPTION_NOBITOPS
value|(OPTION_MD_BASE + 10)
end_define

begin_define
define|#
directive|define
name|OPTION_LEADZ
value|(OPTION_MD_BASE + 11)
end_define

begin_define
define|#
directive|define
name|OPTION_NOLEADZ
value|(OPTION_MD_BASE + 12)
end_define

begin_define
define|#
directive|define
name|OPTION_ABSDIFF
value|(OPTION_MD_BASE + 13)
end_define

begin_define
define|#
directive|define
name|OPTION_NOABSDIFF
value|(OPTION_MD_BASE + 14)
end_define

begin_define
define|#
directive|define
name|OPTION_MINMAX
value|(OPTION_MD_BASE + 15)
end_define

begin_define
define|#
directive|define
name|OPTION_NOMINMAX
value|(OPTION_MD_BASE + 16)
end_define

begin_define
define|#
directive|define
name|OPTION_CLIP
value|(OPTION_MD_BASE + 17)
end_define

begin_define
define|#
directive|define
name|OPTION_NOCLIP
value|(OPTION_MD_BASE + 18)
end_define

begin_define
define|#
directive|define
name|OPTION_SATUR
value|(OPTION_MD_BASE + 19)
end_define

begin_define
define|#
directive|define
name|OPTION_NOSATUR
value|(OPTION_MD_BASE + 20)
end_define

begin_define
define|#
directive|define
name|OPTION_COP32
value|(OPTION_MD_BASE + 21)
end_define

begin_define
define|#
directive|define
name|OPTION_REPEAT
value|(OPTION_MD_BASE + 25)
end_define

begin_define
define|#
directive|define
name|OPTION_NOREPEAT
value|(OPTION_MD_BASE + 26)
end_define

begin_define
define|#
directive|define
name|OPTION_DEBUG
value|(OPTION_MD_BASE + 27)
end_define

begin_define
define|#
directive|define
name|OPTION_NODEBUG
value|(OPTION_MD_BASE + 28)
end_define

begin_define
define|#
directive|define
name|OPTION_LIBRARY
value|(OPTION_MD_BASE + 29)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
block|{
literal|"mconfig"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_CONFIG
block|}
block|,
block|{
literal|"maverage"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_AVERAGE
block|}
block|,
block|{
literal|"mno-average"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOAVERAGE
block|}
block|,
block|{
literal|"mmult"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MULT
block|}
block|,
block|{
literal|"mno-mult"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOMULT
block|}
block|,
block|{
literal|"mdiv"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DIV
block|}
block|,
block|{
literal|"mno-div"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NODIV
block|}
block|,
block|{
literal|"mbitops"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BITOPS
block|}
block|,
block|{
literal|"mno-bitops"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOBITOPS
block|}
block|,
block|{
literal|"mleadz"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LEADZ
block|}
block|,
block|{
literal|"mno-leadz"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOLEADZ
block|}
block|,
block|{
literal|"mabsdiff"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ABSDIFF
block|}
block|,
block|{
literal|"mno-absdiff"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOABSDIFF
block|}
block|,
block|{
literal|"mminmax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MINMAX
block|}
block|,
block|{
literal|"mno-minmax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOMINMAX
block|}
block|,
block|{
literal|"mclip"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CLIP
block|}
block|,
block|{
literal|"mno-clip"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOCLIP
block|}
block|,
block|{
literal|"msatur"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SATUR
block|}
block|,
block|{
literal|"mno-satur"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOSATUR
block|}
block|,
block|{
literal|"mcop32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_COP32
block|}
block|,
block|{
literal|"mdebug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DEBUG
block|}
block|,
block|{
literal|"mno-debug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NODEBUG
block|}
block|,
block|{
literal|"mlibrary"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LIBRARY
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|optbits
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|optbitset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_EB
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_CONFIG
case|:
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|mep_config_map
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|mep_config_map
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|idx
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|idx
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unknown configuration %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mep_config_index
operator|=
name|idx
expr_stmt|;
name|target_big_endian
operator|=
name|mep_config_map
index|[
name|idx
index|]
operator|.
name|big_endian
expr_stmt|;
break|break;
case|case
name|OPTION_AVERAGE
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_AVE_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_AVE_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NOAVERAGE
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_AVE_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_AVE_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_MULT
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_MUL_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_MUL_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NOMULT
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_MUL_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_MUL_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_DIV
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DIV_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DIV_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NODIV
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DIV_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DIV_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_BITOPS
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_BIT_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_BIT_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NOBITOPS
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_BIT_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_BIT_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_LEADZ
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_LDZ_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_LDZ_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NOLEADZ
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_LDZ_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_LDZ_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_ABSDIFF
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_ABS_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_ABS_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NOABSDIFF
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_ABS_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_ABS_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_MINMAX
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_MINMAX_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_MINMAX_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NOMINMAX
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_MINMAX_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_MINMAX_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_CLIP
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_CLIP_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_CLIP_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NOCLIP
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_CLIP_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_CLIP_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_SATUR
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_SAT_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_SAT_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NOSATUR
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_SAT_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_SAT_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_COP32
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_CP_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_CP_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_DEBUG
case|:
name|optbits
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DEBUG_INSN
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DEBUG_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_NODEBUG
case|:
name|optbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DEBUG_INSN
operator|)
expr_stmt|;
name|optbitset
operator||=
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DEBUG_INSN
expr_stmt|;
break|break;
case|case
name|OPTION_LIBRARY
case|:
name|library_flag
operator|=
name|EF_MEP_LIBRARY
expr_stmt|;
break|break;
case|case
name|OPTION_REPEAT
case|:
case|case
name|OPTION_NOREPEAT
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"MeP specific command line options:\n\   -EB                     assemble for a big endian system (default)\n\   -EL                     assemble for a little endian system\n\   -mconfig=<name>         specify a chip configuration to use\n\   -maverage -mno-average -mmult -mno-mult -mdiv -mno-div\n\   -mbitops -mno-bitops -mleadz -mno-leadz -mabsdiff -mno-absdiff\n\   -mminmax -mno-minmax -mclip -mno-clip -msatur -mno-satur -mcop32\n\                           enable/disable the given opcodes\n\ \n\   If -mconfig is given, the other -m options modify it.  Otherwise,\n\   if no -m options are given, all core opcodes are enabled;\n\   if any enabling -m options are given, only those are enabled;\n\   if only disabling -m options are given, only those are disabled.\n\ "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mep_config_map
index|[
literal|1
index|]
operator|.
name|name
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  -mconfig=STR            specify the configuration to use\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  Configurations:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mep_config_map
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|mep_config_map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|mep_check_for_disabled_registers
parameter_list|(
name|mep_insn
modifier|*
name|insn
parameter_list|)
block|{
specifier|static
name|int
name|initted
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|has_mul_div
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|has_cop
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|has_debug
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|b
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|allow_disabled_registers
condition|)
return|return;
if|#
directive|if
operator|!
name|CGEN_INT_INSN_P
if|if
condition|(
name|target_big_endian
condition|)
name|b
operator|=
name|insn
operator|->
name|buffer
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|insn
operator|->
name|buffer
index|[
literal|1
index|]
expr_stmt|;
else|else
name|b
operator|=
name|insn
operator|->
name|buffer
index|[
literal|1
index|]
operator|*
literal|256
operator|+
name|insn
operator|->
name|buffer
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|b
operator|=
name|insn
operator|->
name|buffer
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|b
operator|&
literal|0xfffff00e
operator|)
operator|==
literal|0x7008
comment|/* stc */
operator|||
operator|(
name|b
operator|&
literal|0xfffff00e
operator|)
operator|==
literal|0x700a
comment|/* ldc */
condition|)
block|{
if|if
condition|(
operator|!
name|initted
condition|)
block|{
name|initted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|MEP_OMASK
operator|&
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_MUL_INSN
operator|)
operator|)
operator|||
operator|(
name|MEP_OMASK
operator|&
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DIV_INSN
operator|)
operator|)
condition|)
name|has_mul_div
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEP_OMASK
operator|&
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_DEBUG_INSN
operator|)
condition|)
name|has_debug
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEP_OMASK
operator|&
operator|(
literal|1
operator|<<
name|CGEN_INSN_OPTIONAL_CP_INSN
operator|)
condition|)
name|has_cop
operator|=
literal|1
expr_stmt|;
block|}
name|r
operator|=
operator|(
operator|(
name|b
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
name|b
operator|&
literal|0x0001
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|7
case|:
comment|/* $hi */
case|case
literal|8
case|:
comment|/* $lo */
if|if
condition|(
operator|!
name|has_mul_div
condition|)
name|as_bad
argument_list|(
literal|"$hi and $lo are disabled when MUL and DIV are off"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* $mb0 */
case|case
literal|13
case|:
comment|/* $me0 */
case|case
literal|14
case|:
comment|/* $mb1 */
case|case
literal|15
case|:
comment|/* $me1 */
if|if
condition|(
operator|!
name|has_cop
condition|)
name|as_bad
argument_list|(
literal|"$mb0, $me0, $mb1, and $me1 are disabled when COP is off"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
comment|/* $dbg */
case|case
literal|25
case|:
comment|/* $depc */
if|if
condition|(
operator|!
name|has_debug
condition|)
name|as_bad
argument_list|(
literal|"$dbg and $depc are disabled when DEBUG is off"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mep_machine
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|MEP_CPU
condition|)
block|{
default|default:
break|break;
case|case
name|EF_MEP_CPU_C2
case|:
return|return
name|bfd_mach_mep
return|;
case|case
name|EF_MEP_CPU_C3
case|:
return|return
name|bfd_mach_mep
return|;
case|case
name|EF_MEP_CPU_C4
case|:
return|return
name|bfd_mach_mep
return|;
case|case
name|EF_MEP_CPU_H1
case|:
return|return
name|bfd_mach_mep_h1
return|;
block|}
return|return
name|bfd_mach_mep
return|;
block|}
end_function

begin_comment
comment|/* The MeP version of the cgen parse_operand function.  The only difference    from the standard version is that we want to avoid treating '$foo' and    '($foo...)' as references to a symbol called '$foo'.  The chances are    that '$foo' is really a misspelt register.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mep_parse_operand
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|enum
name|cgen_parse_operand_type
name|want
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|strP
parameter_list|,
name|int
name|opindex
parameter_list|,
name|int
name|opinfo
parameter_list|,
name|enum
name|cgen_parse_operand_result
modifier|*
name|resultP
parameter_list|,
name|bfd_vma
modifier|*
name|valueP
parameter_list|)
block|{
if|if
condition|(
name|want
operator|==
name|CGEN_PARSE_OPERAND_INTEGER
operator|||
name|want
operator|==
name|CGEN_PARSE_OPERAND_ADDRESS
condition|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|next
operator|=
operator|*
name|strP
expr_stmt|;
while|while
condition|(
operator|*
name|next
operator|==
literal|'('
condition|)
name|next
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|next
operator|==
literal|'$'
condition|)
return|return
literal|"Not a valid literal"
return|;
block|}
return|return
name|gas_cgen_parse_operand
argument_list|(
name|cd
argument_list|,
name|want
argument_list|,
name|strP
argument_list|,
name|opindex
argument_list|,
name|opinfo
argument_list|,
name|resultP
argument_list|,
name|valueP
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
comment|/* Initialize the `cgen' interface.  */
comment|/* If the user specifies no options, we default to allowing      everything.  If the user specifies any enabling options, we      default to allowing only what is specified.  If the user      specifies only disabling options, we only disable what is      specified.  If the user specifies options and a config, the      options modify the config.  */
if|if
condition|(
name|optbits
operator|&&
name|mep_config_index
operator|==
literal|0
condition|)
name|MEP_OMASK
operator|=
name|optbits
expr_stmt|;
else|else
name|MEP_OMASK
operator|=
operator|(
name|MEP_OMASK
operator|&
operator|~
name|optbitset
operator|)
operator||
name|optbits
expr_stmt|;
comment|/* Set the machine number and endian.  */
name|gas_cgen_cpu_desc
operator|=
name|mep_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_MACHS
argument_list|,
literal|0
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
name|target_big_endian
condition|?
name|CGEN_ENDIAN_BIG
else|:
name|CGEN_ENDIAN_LITTLE
argument_list|,
name|CGEN_CPU_OPEN_ISAS
argument_list|,
literal|0
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
name|mep_cgen_init_asm
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* This is a callback from cgen to gas to parse operands.  */
name|cgen_set_parse_operand_fn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|mep_parse_operand
argument_list|)
expr_stmt|;
comment|/* Identify the architecture.  */
name|bfd_default_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_mep
argument_list|,
name|mep_machine
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Store the configuration number and core.  */
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|MEP_CPU
operator||
name|MEP_CONFIG
operator||
name|library_flag
argument_list|)
expr_stmt|;
comment|/* Initialize the array we'll be using to store fixups.  */
name|gas_cgen_initialize_saved_fixups_array
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Variant of mep_cgen_assemble_insn.  Assemble insn STR of cpu CD as a     coprocessor instruction, if possible, into FIELDS, BUF, and INSN.  */
end_comment

begin_function
specifier|static
specifier|const
name|CGEN_INSN
modifier|*
name|mep_cgen_assemble_cop_insn
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|CGEN_FIELDS
modifier|*
name|fields
parameter_list|,
name|CGEN_INSN_BYTES_PTR
name|buf
parameter_list|,
specifier|const
name|struct
name|cgen_insn
modifier|*
name|pinsn
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|ilist
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
comment|/* The instructions are stored in hashed lists. */
name|ilist
operator|=
name|CGEN_ASM_LOOKUP_INSN
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|CGEN_INSN_MNEMONIC
argument_list|(
name|pinsn
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|str
expr_stmt|;
for|for
control|(
init|;
name|ilist
operator|!=
name|NULL
condition|;
name|ilist
operator|=
name|CGEN_ASM_NEXT_INSN
argument_list|(
name|ilist
argument_list|)
control|)
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
name|ilist
operator|->
name|insn
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|CGEN_INSN_MNEMONIC
argument_list|(
name|ilist
operator|->
name|insn
argument_list|)
argument_list|,
name|CGEN_INSN_MNEMONIC
argument_list|(
name|pinsn
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|MEP_INSN_COP_P
argument_list|(
name|ilist
operator|->
name|insn
argument_list|)
operator|&&
name|mep_cgen_insn_supported
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|str
operator|=
name|start
expr_stmt|;
comment|/* skip this insn if str doesn't look right lexically */
if|if
condition|(
name|CGEN_INSN_RX
argument_list|(
name|insn
argument_list|)
operator|!=
name|NULL
operator|&&
name|regexec
argument_list|(
operator|(
name|regex_t
operator|*
operator|)
name|CGEN_INSN_RX
argument_list|(
name|insn
argument_list|)
argument_list|,
name|str
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|REG_NOMATCH
condition|)
continue|continue;
comment|/* Allow parse/insert handlers to obtain length of insn.  */
name|CGEN_FIELDS_BITSIZE
argument_list|(
name|fields
argument_list|)
operator|=
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|errmsg
operator|=
name|CGEN_PARSE_FN
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|)
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|,
operator|&
name|str
argument_list|,
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
continue|continue;
name|errmsg
operator|=
name|CGEN_INSERT_FN
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|)
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|,
name|fields
argument_list|,
name|buf
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
continue|continue;
return|return
name|insn
return|;
block|}
block|}
return|return
name|pinsn
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mep_save_insn
parameter_list|(
name|mep_insn
name|insn
parameter_list|)
block|{
comment|/* Consider change MAX_SAVED_FIXUP_CHAINS to MAX_PARALLEL_INSNS. */
if|if
condition|(
name|num_insns_saved
operator|<
literal|0
operator|||
name|num_insns_saved
operator|>=
name|MAX_SAVED_FIXUP_CHAINS
condition|)
block|{
name|as_fatal
argument_list|(
literal|"index into saved_insns[] out of bounds."
argument_list|)
expr_stmt|;
return|return;
block|}
name|saved_insns
index|[
name|num_insns_saved
index|]
operator|=
name|insn
expr_stmt|;
name|gas_cgen_save_fixups
argument_list|(
name|num_insns_saved
argument_list|)
expr_stmt|;
name|num_insns_saved
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mep_check_parallel32_scheduling
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|insn0iscopro
decl_stmt|,
name|insn1iscopro
decl_stmt|,
name|insn0length
decl_stmt|,
name|insn1length
decl_stmt|;
comment|/* More than two instructions means that either someone is referring to      an internally parallel core or an internally parallel coprocessor,      neither of which are supported at this time.  */
if|if
condition|(
name|num_insns_saved
operator|>
literal|2
condition|)
name|as_fatal
argument_list|(
literal|"Internally paralled cores and coprocessors not supported."
argument_list|)
expr_stmt|;
comment|/* If there are no insns saved, that's ok.  Just return.  This will      happen when mep_process_saved_insns is called when the end of the      source file is reached and there are no insns left to be processed.  */
if|if
condition|(
name|num_insns_saved
operator|==
literal|0
condition|)
return|return;
comment|/* Check some of the attributes of the first insn.  */
name|insn0iscopro
operator|=
name|MEP_INSN_COP_P
argument_list|(
name|saved_insns
index|[
literal|0
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
name|insn0length
operator|=
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|saved_insns
index|[
literal|0
index|]
operator|.
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_insns_saved
operator|==
literal|2
condition|)
block|{
comment|/* Check some of the attributes of the first insn.  */
name|insn1iscopro
operator|=
name|MEP_INSN_COP_P
argument_list|(
name|saved_insns
index|[
literal|1
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
name|insn1length
operator|=
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|saved_insns
index|[
literal|1
index|]
operator|.
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn0iscopro
operator|&&
operator|!
name|insn1iscopro
operator|)
operator|||
operator|(
name|insn1iscopro
operator|&&
operator|!
name|insn0iscopro
operator|)
condition|)
block|{
comment|/* We have one core and one copro insn.  If their sizes              add up to 32, then the combination is valid.  */
if|if
condition|(
name|insn0length
operator|+
name|insn1length
operator|==
literal|32
condition|)
return|return;
else|else
name|as_bad
argument_list|(
literal|"core and copro insn lengths must total 32 bits."
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"vliw group must consist of 1 core and 1 copro insn."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we arrive here, we have one saved instruction.  There are a 	 number of possible cases:  	 1.  The instruction is a 32 bit core or coprocessor insn and              can be executed by itself.  Valid.           2.  The instrucion is a core instruction for which a cop nop              exists.  In this case, insert the cop nop into the saved              insn array after the core insn and return.  Valid.           3.  The instruction is a coprocessor insn for which a core nop              exists.  In this case, move the coprocessor insn to the              second element of the array and put the nop in the first 	     element then return.  Valid.           4. The instruction is a core or coprocessor instruction for             which there is no matching coprocessor or core nop to use 	    to form a valid vliw insn combination.  In this case, we 	    we have to abort.  */
if|if
condition|(
name|insn0length
operator|>
literal|32
condition|)
name|as_fatal
argument_list|(
literal|"Cannot use 48- or 64-bit insns with a 32 bit datapath."
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn0length
operator|==
literal|32
condition|)
return|return;
comment|/* Insn is smaller than datapath.  If there are no matching          nops for this insn, then terminate assembly.  */
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|saved_insns
index|[
literal|0
index|]
operator|.
name|insn
argument_list|,
name|CGEN_INSN_VLIW32_NO_MATCHING_NOP
argument_list|)
condition|)
name|as_fatal
argument_list|(
literal|"No valid nop."
argument_list|)
expr_stmt|;
comment|/* At this point we know that we have a single 16-bit insn that has  	 a matching nop.  We have to assemble it and put it into the saved           insn and fixup chain arrays. */
if|if
condition|(
name|insn0iscopro
condition|)
block|{
name|char
modifier|*
name|errmsg
decl_stmt|;
name|mep_insn
name|insn
decl_stmt|;
comment|/* Move the insn and it's fixups to the second element of the              saved insns arrary and insert a 16 bit core nope into the              first element. */
name|insn
operator|.
name|insn
operator|=
name|mep_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
literal|"nop"
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Move the insn in element 0 to element 1 and insert the                  nop into element 0.  Move the fixups in element 0 to                  element 1 and save the current fixups to element 0.                    Really there aren't any fixups at this point because we're                  inserting a nop but we might as well be general so that                  if there's ever a need to insert a general insn, we'll                  have an example. */
name|saved_insns
index|[
literal|1
index|]
operator|=
name|saved_insns
index|[
literal|0
index|]
expr_stmt|;
name|saved_insns
index|[
literal|0
index|]
operator|=
name|insn
expr_stmt|;
name|num_insns_saved
operator|++
expr_stmt|;
name|gas_cgen_swap_fixups
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gas_cgen_save_fixups
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|errmsg
decl_stmt|;
name|mep_insn
name|insn
decl_stmt|;
name|int
name|insn_num
init|=
name|saved_insns
index|[
literal|0
index|]
operator|.
name|insn
operator|->
name|base
operator|->
name|num
decl_stmt|;
comment|/* Use 32 bit branches and skip the nop.  */
if|if
condition|(
name|insn_num
operator|==
name|MEP_INSN_BSR12
operator|||
name|insn_num
operator|==
name|MEP_INSN_BEQZ
operator|||
name|insn_num
operator|==
name|MEP_INSN_BNEZ
condition|)
return|return;
comment|/* Insert a 16-bit coprocessor nop.  Note that at the time */
comment|/* this was done, no 16-bit coprocessor nop was defined.   */
name|insn
operator|.
name|insn
operator|=
name|mep_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
literal|"cpnop16"
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now put the insn and fixups into the arrays.  */
name|mep_save_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mep_check_parallel64_scheduling
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|insn0iscopro
decl_stmt|,
name|insn1iscopro
decl_stmt|,
name|insn0length
decl_stmt|,
name|insn1length
decl_stmt|;
comment|/* More than two instructions means that someone is referring to an      internally parallel core or an internally parallel coprocessor.  */
comment|/* These are not currently supported.  */
if|if
condition|(
name|num_insns_saved
operator|>
literal|2
condition|)
name|as_fatal
argument_list|(
literal|"Internally parallel cores of coprocessors not supported."
argument_list|)
expr_stmt|;
comment|/* If there are no insns saved, that's ok.  Just return.  This will      happen when mep_process_saved_insns is called when the end of the      source file is reached and there are no insns left to be processed.  */
if|if
condition|(
name|num_insns_saved
operator|==
literal|0
condition|)
return|return;
comment|/* Check some of the attributes of the first insn.  */
name|insn0iscopro
operator|=
name|MEP_INSN_COP_P
argument_list|(
name|saved_insns
index|[
literal|0
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
name|insn0length
operator|=
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|saved_insns
index|[
literal|0
index|]
operator|.
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_insns_saved
operator|==
literal|2
condition|)
block|{
comment|/* Check some of the attributes of the first insn. */
name|insn1iscopro
operator|=
name|MEP_INSN_COP_P
argument_list|(
name|saved_insns
index|[
literal|1
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
name|insn1length
operator|=
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|saved_insns
index|[
literal|1
index|]
operator|.
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn0iscopro
operator|&&
operator|!
name|insn1iscopro
operator|)
operator|||
operator|(
name|insn1iscopro
operator|&&
operator|!
name|insn0iscopro
operator|)
condition|)
block|{
comment|/* We have one core and one copro insn.  If their sizes 	     add up to 64, then the combination is valid.  */
if|if
condition|(
name|insn0length
operator|+
name|insn1length
operator|==
literal|64
condition|)
return|return;
else|else
name|as_bad
argument_list|(
literal|"core and copro insn lengths must total 64 bits."
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"vliw group must consist of 1 core and 1 copro insn."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we arrive here, we have one saved instruction.  There are a 	 number of possible cases:           1.  The instruction is a 64 bit coprocessor insn and can be              executed by itself.  Valid.           2.  The instrucion is a core instruction for which a cop nop              exists.  In this case, insert the cop nop into the saved              insn array after the core insn and return.  Valid.           3.  The instruction is a coprocessor insn for which a core nop              exists.  In this case, move the coprocessor insn to the              second element of the array and put the nop in the first              element then return.  Valid.           4.  The instruction is a core or coprocessor instruction for              which there is no matching coprocessor or core nop to use              to form a valid vliw insn combination.  In this case, we 	     we have to abort.  */
comment|/* If the insn is 64 bits long, it can run alone.  The size check 	 is done indepependantly of whether the insn is core or copro 	 in case 64 bit coprocessor insns are added later.  */
if|if
condition|(
name|insn0length
operator|==
literal|64
condition|)
return|return;
comment|/* Insn is smaller than datapath.  If there are no matching 	 nops for this insn, then terminate assembly.  */
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|saved_insns
index|[
literal|0
index|]
operator|.
name|insn
argument_list|,
name|CGEN_INSN_VLIW64_NO_MATCHING_NOP
argument_list|)
condition|)
name|as_fatal
argument_list|(
literal|"No valid nop."
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn0iscopro
condition|)
block|{
name|char
modifier|*
name|errmsg
decl_stmt|;
name|mep_insn
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize the insn buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|insn
operator|.
name|buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We have a coprocessor insn.  At this point in time there 	     are is 32-bit core nop.  There is only a 16-bit core 	     nop.  The idea is to allow for a relatively arbitrary 	     coprocessor to be specified.  We aren't looking at 	     trying to cover future changes in the core at this time 	     since it is assumed that the core will remain fairly 	     static.  If there ever are 32 or 48 bit core nops added, 	     they will require entries below.  */
if|if
condition|(
name|insn0length
operator|==
literal|48
condition|)
block|{
comment|/* Move the insn and fixups to the second element of the 		 arrays then assemble and insert a 16 bit core nop.  */
name|insn
operator|.
name|insn
operator|=
name|mep_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
literal|"nop"
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If this is reached, then we have a single coprocessor                  insn that is not 48 bits long, but for which the assembler                  thinks there is a matching core nop.  If a 32-bit core                  nop has been added, then make the necessary changes and                  handle its assembly and insertion here.  Otherwise,                  go figure out why either:                                 1. The assembler thinks that there is a 32-bit core nop                     to match a 32-bit coprocessor insn, or                  2. The assembler thinks that there is a 48-bit core nop                     to match a 16-bit coprocessor insn.  */
name|as_fatal
argument_list|(
literal|"Assembler expects a non-existent core nop."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Move the insn in element 0 to element 1 and insert the             nop into element 0.  Move the fixups in element 0 to             element 1 and save the current fixups to element 0.  	    Really there aren't any fixups at this point because we're 	    inserting a nop but we might as well be general so that 	    if there's ever a need to insert a general insn, we'll 	    have an example. */
name|saved_insns
index|[
literal|1
index|]
operator|=
name|saved_insns
index|[
literal|0
index|]
expr_stmt|;
name|saved_insns
index|[
literal|0
index|]
operator|=
name|insn
expr_stmt|;
name|num_insns_saved
operator|++
expr_stmt|;
name|gas_cgen_swap_fixups
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gas_cgen_save_fixups
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|errmsg
decl_stmt|;
name|mep_insn
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize the insn buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|insn
operator|.
name|buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We have a core insn.  We have to handle all possible nop 	     lengths.  If a coprocessor doesn't have a nop of a certain 	     length but there exists core insns that when combined with 	      a nop of that length would fill the datapath, those core 	      insns will be flagged with the VLIW_NO_CORRESPONDING_NOP 	      attribute.  That will ensure that when used in a way that 	      requires a nop to be inserted, assembly will terminate 	      before reaching this section of code.  This guarantees 	      that cases below which would result in the attempted 	      insertion of nop that doesn't exist will never be entered.  */
if|if
condition|(
name|insn0length
operator|==
literal|16
condition|)
block|{
comment|/* Insert 48 bit coprocessor nop.          */
comment|/* Assemble it and put it into the arrays. */
name|insn
operator|.
name|insn
operator|=
name|mep_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
literal|"cpnop48"
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn0length
operator|==
literal|32
condition|)
block|{
comment|/* Insert 32 bit coprocessor nop. */
name|insn
operator|.
name|insn
operator|=
name|mep_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
literal|"cpnop32"
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn0length
operator|==
literal|48
condition|)
block|{
comment|/* Insert 16 bit coprocessor nop. */
name|insn
operator|.
name|insn
operator|=
name|mep_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
literal|"cpnop16"
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Core insn has an invalid length.  Something has gone wrong. */
name|as_fatal
argument_list|(
literal|"Core insn has invalid length!  Something is wrong!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now put the insn and fixups into the arrays.  */
name|mep_save_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The scheduling functions are just filters for invalid combinations.    If there is a violation, they terminate assembly.  Otherise they    just fall through.  Succesful combinations cause no side effects    other than valid nop insertion.  */
end_comment

begin_function
specifier|static
name|void
name|mep_check_parallel_scheduling
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This is where we will eventually read the config information      and choose which scheduling checking function to call.  */
if|if
condition|(
name|MEP_VLIW64
condition|)
name|mep_check_parallel64_scheduling
argument_list|()
expr_stmt|;
else|else
name|mep_check_parallel32_scheduling
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mep_process_saved_insns
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gas_cgen_save_fixups
argument_list|(
name|MAX_SAVED_FIXUP_CHAINS
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* We have to check for valid scheduling here. */
name|mep_check_parallel_scheduling
argument_list|()
expr_stmt|;
comment|/* If the last call didn't cause assembly to terminate, we have      a valid vliw insn/insn pair saved. Restore this instructions'      fixups and process the insns. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_insns_saved
condition|;
name|i
operator|++
control|)
block|{
name|gas_cgen_restore_fixups
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|gas_cgen_finish_insn
argument_list|(
name|saved_insns
index|[
name|i
index|]
operator|.
name|insn
argument_list|,
name|saved_insns
index|[
name|i
index|]
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|saved_insns
index|[
name|i
index|]
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|gas_cgen_restore_fixups
argument_list|(
name|MAX_SAVED_FIXUP_CHAINS
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Clear the fixups and reset the number insn saved to 0. */
name|gas_cgen_initialize_saved_fixups_array
argument_list|()
expr_stmt|;
name|num_insns_saved
operator|=
literal|0
expr_stmt|;
name|listing_prev_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
name|CGEN_BITSET
modifier|*
name|isas
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Initialize GAS's cgen interface for a new instruction.  */
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
comment|/* There are two possible modes: core and vliw.  We have to assemble      differently for each.       Core Mode:  We assemble normally.  All instructions are on a                  single line and are made up of one mnemonic and one                  set of operands.      VLIW Mode:  Vliw combinations are indicated as follows:  		       core insn 		     + copro insn                   We want to handle the general case where more than                  one instruction can be preceeded by a +.  This will                  happen later if we add support for internally parallel                  coprocessors.  We'll make the parsing nice and general                  so that it can handle an arbitrary number of insns                  with leading +'s.  The actual checking for valid                  combinations is done elsewhere.  */
comment|/* Initialize the isa to refer to the core.  */
if|if
condition|(
name|isas
operator|==
name|NULL
condition|)
name|isas
operator|=
name|cgen_bitset_copy
argument_list|(
operator|&
name|MEP_CORE_ISA
argument_list|)
expr_stmt|;
else|else
block|{
name|cgen_bitset_clear
argument_list|(
name|isas
argument_list|)
expr_stmt|;
name|cgen_bitset_union
argument_list|(
name|isas
argument_list|,
operator|&
name|MEP_CORE_ISA
argument_list|,
name|isas
argument_list|)
expr_stmt|;
block|}
name|gas_cgen_cpu_desc
operator|->
name|isas
operator|=
name|isas
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VLIW
condition|)
block|{
comment|/* VLIW mode.  */
name|int
name|thisInsnIsCopro
init|=
literal|0
decl_stmt|;
name|mep_insn
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize the insn buffer */
if|if
condition|(
operator|!
name|CGEN_INT_INSN_P
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CGEN_MAX_INSN_SIZE
condition|;
name|i
operator|++
control|)
name|insn
operator|.
name|buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Can't tell core / copro insns apart at parse time! */
name|cgen_bitset_union
argument_list|(
name|isas
argument_list|,
operator|&
name|MEP_COP_ISA
argument_list|,
name|isas
argument_list|)
expr_stmt|;
comment|/* Assemble the insn so we can examine its attributes. */
name|insn
operator|.
name|insn
operator|=
name|mep_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
name|mep_check_for_disabled_registers
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
comment|/* Check to see if it's a coprocessor instruction. */
name|thisInsnIsCopro
operator|=
name|MEP_INSN_COP_P
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thisInsnIsCopro
condition|)
block|{
name|insn
operator|.
name|insn
operator|=
name|mep_cgen_assemble_cop_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|insn
operator|.
name|insn
argument_list|)
expr_stmt|;
name|thisInsnIsCopro
operator|=
name|MEP_INSN_COP_P
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
expr_stmt|;
name|mep_check_for_disabled_registers
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pluspresent
condition|)
block|{
comment|/* A plus was present. */
comment|/* Check for a + with a core insn and abort if found. */
if|if
condition|(
operator|!
name|thisInsnIsCopro
condition|)
block|{
name|as_fatal
argument_list|(
literal|"A core insn cannot be preceeded by a +.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|num_insns_saved
operator|>
literal|0
condition|)
block|{
comment|/* There are insns in the queue. Add this one. */
name|mep_save_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There are no insns in the queue and a plus is present. 		 This is a syntax error.  Let's not tolerate this. 		 We can relax this later if necessary.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid use of parallelization operator."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* No plus was present. */
if|if
condition|(
name|num_insns_saved
operator|>
literal|0
condition|)
block|{
comment|/* There are insns saved and we came across an insn without a 		 leading +.  That's the signal to process the saved insns 		 before proceeding then treat the current insn as the first 		 in a new vliw group.  */
name|mep_process_saved_insns
argument_list|()
expr_stmt|;
name|num_insns_saved
operator|=
literal|0
expr_stmt|;
comment|/* mep_save_insn (insn); */
block|}
name|mep_save_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|else 	    {
comment|/* Core Insn. Add it to the beginning of the queue. */
block|mep_save_insn (insn);
comment|/* gas_cgen_save_fixups(num_insns_saved); */
block|}
endif|#
directive|endif
block|}
name|pluspresent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Core mode.  */
comment|/* Only single instructions are assembled in core mode. */
name|mep_insn
name|insn
decl_stmt|;
comment|/* If a leading '+' was present, issue an error. 	 That's not allowed in core mode. */
if|if
condition|(
name|pluspresent
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Leading plus sign not allowed in core mode"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|insn
operator|.
name|insn
operator|=
name|mep_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mep_check_for_disabled_registers
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interface to relax_segment.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The fields are:      1) most positive reach of this state,      2) most negative reach of this state,      3) how many bytes this mode will have in the variable part of the frag      4) which index into the table to try if we can't fit into this one.  */
comment|/* Note that we use "beq" because "jmp" has a peculiarity - it cannot      jump to addresses with any bits 27..24 set.  So, we use beq as a      17-bit pc-relative branch to avoid using jmp, just in case.  */
comment|/* 0 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused */
comment|/* 1 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* marker for "don't know yet" */
comment|/* 2 */
block|{
literal|2047
block|,
operator|-
literal|2048
block|,
literal|0
block|,
literal|3
block|}
block|,
comment|/* bsr12 */
comment|/* 3 */
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
comment|/* bsr16 */
comment|/* 4 */
block|{
literal|2047
block|,
operator|-
literal|2048
block|,
literal|0
block|,
literal|5
block|}
block|,
comment|/* bra */
comment|/* 5 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* beq $0,$0 */
comment|/* 6 */
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
comment|/* jmp24 */
comment|/* 7 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|0
block|,
literal|8
block|}
block|,
comment|/* beqi */
comment|/* 8 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* bnei/jmp */
comment|/* 9 */
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|0
block|,
literal|10
block|}
block|,
comment|/* beqz */
comment|/* 10 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|2
block|,
literal|11
block|}
block|,
comment|/* beqi */
comment|/* 11 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* bnei/jmp */
comment|/* 12 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|0
block|,
literal|13
block|}
block|,
comment|/* bnei */
comment|/* 13 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* beqi/jmp */
comment|/* 14 */
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|0
block|,
literal|15
block|}
block|,
comment|/* bnez */
comment|/* 15 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|2
block|,
literal|16
block|}
block|,
comment|/* bnei */
comment|/* 16 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* beqi/jmp */
comment|/* 17 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|0
block|,
literal|13
block|}
block|,
comment|/* bgei */
comment|/* 18 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* 19 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|0
block|,
literal|13
block|}
block|,
comment|/* blti */
comment|/* 20 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* 19 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|0
block|,
literal|13
block|}
block|,
comment|/* bcpeq */
comment|/* 20 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* 19 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|0
block|,
literal|13
block|}
block|,
comment|/* bcpne */
comment|/* 20 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* 19 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|0
block|,
literal|13
block|}
block|,
comment|/* bcpat */
comment|/* 20 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* 19 */
block|{
literal|65535
block|,
operator|-
literal|65536
block|,
literal|0
block|,
literal|13
block|}
block|,
comment|/* bcpaf */
comment|/* 20 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo-values for 64 bit "insns" which are combinations of two 32    bit insns.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|MEP_PSEUDO64_NONE
block|,
name|MEP_PSEUDO64_16BITCC
block|,
name|MEP_PSEUDO64_32BITCC
block|, }
name|MepPseudo64Values
typedef|;
end_typedef

begin_struct
specifier|static
struct|struct
block|{
name|int
name|insn
decl_stmt|;
name|int
name|growth
decl_stmt|;
name|int
name|insn_for_extern
decl_stmt|;
block|}
name|subtype_mappings
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MEP_INSN_BSR12
block|,
literal|0
block|,
name|MEP_INSN_BSR24
block|}
block|,
block|{
name|MEP_INSN_BSR24
block|,
literal|2
block|,
name|MEP_INSN_BSR24
block|}
block|,
block|{
name|MEP_INSN_BRA
block|,
literal|0
block|,
name|MEP_INSN_BRA
block|}
block|,
block|{
name|MEP_INSN_BEQ
block|,
literal|2
block|,
name|MEP_INSN_BEQ
block|}
block|,
block|{
name|MEP_INSN_JMP
block|,
literal|2
block|,
name|MEP_INSN_JMP
block|}
block|,
block|{
name|MEP_INSN_BEQI
block|,
literal|0
block|,
name|MEP_INSN_BEQI
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_32BITCC
block|}
block|,
block|{
name|MEP_INSN_BEQZ
block|,
literal|0
block|,
name|MEP_INSN_BEQZ
block|}
block|,
block|{
name|MEP_INSN_BEQI
block|,
literal|2
block|,
name|MEP_INSN_BEQI
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_16BITCC
block|}
block|,
block|{
name|MEP_INSN_BNEI
block|,
literal|0
block|,
name|MEP_INSN_BNEI
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_32BITCC
block|}
block|,
block|{
name|MEP_INSN_BNEZ
block|,
literal|0
block|,
name|MEP_INSN_BNEZ
block|}
block|,
block|{
name|MEP_INSN_BNEI
block|,
literal|2
block|,
name|MEP_INSN_BNEI
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_16BITCC
block|}
block|,
block|{
name|MEP_INSN_BGEI
block|,
literal|0
block|,
name|MEP_INSN_BGEI
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_32BITCC
block|}
block|,
block|{
name|MEP_INSN_BLTI
block|,
literal|0
block|,
name|MEP_INSN_BLTI
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_32BITCC
block|}
block|,
block|{
name|MEP_INSN_BCPEQ
block|,
literal|0
block|,
name|MEP_INSN_BCPEQ
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_32BITCC
block|}
block|,
block|{
name|MEP_INSN_BCPNE
block|,
literal|0
block|,
name|MEP_INSN_BCPNE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_32BITCC
block|}
block|,
block|{
name|MEP_INSN_BCPAT
block|,
literal|0
block|,
name|MEP_INSN_BCPAT
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_32BITCC
block|}
block|,
block|{
name|MEP_INSN_BCPAF
block|,
literal|0
block|,
name|MEP_INSN_BCPAF
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
name|MEP_PSEUDO64_32BITCC
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NUM_MAPPINGS
value|(sizeof (subtype_mappings) / sizeof (subtype_mappings[0]))
end_define

begin_function
name|void
name|mep_prepare_relax_scan
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|offsetT
modifier|*
name|aim
parameter_list|,
name|relax_substateT
name|this_state
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|fragP
operator|->
name|fr_symbol
decl_stmt|;
if|if
condition|(
name|symbolP
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
operator|*
name|aim
operator|=
literal|0
expr_stmt|;
comment|/* Adjust for MeP pcrel not being relative to the next opcode.  */
operator|*
name|aim
operator|+=
literal|2
operator|+
name|md_relax_table
index|[
name|this_state
index|]
operator|.
name|rlx_length
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|insn_to_subtype
parameter_list|(
name|int
name|insn
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MAPPINGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|==
name|subtype_mappings
index|[
name|i
index|]
operator|.
name|insn
condition|)
return|return
name|i
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an initial guess of the length by which a fragment must grow    to hold a branch to reach its destination.  Also updates fr_type    and fr_subtype as necessary.     Called just before doing relaxation.  Any symbol that is now    undefined will not become defined.  The guess for fr_var is    ACTUALLY the growth beyond fr_fix.  Whatever we do to grow fr_fix    or fr_var contributes to our returned value.  Although it may not    be explicit in the frag, pretend fr_var starts with a 0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment
parameter_list|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|1
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|insn_to_subtype
argument_list|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
condition|)
block|{
name|int
name|new_insn
decl_stmt|;
name|new_insn
operator|=
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn_for_extern
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|insn_to_subtype
argument_list|(
name|new_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MEP_VLIW
operator|&&
operator|!
name|MEP_VLIW64
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
operator|&
name|SEC_MEP_VLIW
operator|)
condition|)
block|{
comment|/* Use 32 bit branches for vliw32 so the vliw word is not split.  */
switch|switch
condition|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|num
condition|)
block|{
case|case
name|MEP_INSN_BSR12
case|:
name|fragP
operator|->
name|fr_subtype
operator|=
name|insn_to_subtype
argument_list|(
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn_for_extern
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_INSN_BEQZ
case|:
name|fragP
operator|->
name|fr_subtype
operator|++
expr_stmt|;
break|break;
case|case
name|MEP_INSN_BNEZ
case|:
name|fragP
operator|->
name|fr_subtype
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|&&
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|num
operator|!=
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn
condition|)
block|{
name|int
name|new_insn
init|=
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn
decl_stmt|;
if|if
condition|(
name|new_insn
operator|!=
operator|-
literal|1
condition|)
block|{
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|=
operator|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|-
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|num
operator|+
name|new_insn
operator|)
expr_stmt|;
block|}
block|}
return|return
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|growth
return|;
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size.     Called after relaxation is finished.    fragP->fr_type == rs_machine_dependent.    fragP->fr_subtype is the subtype of what the address relaxed to.  */
end_comment

begin_function
specifier|static
name|int
name|target_address_for
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
name|int
name|rv
init|=
name|frag
operator|->
name|fr_offset
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
name|frag
operator|->
name|fr_symbol
decl_stmt|;
if|if
condition|(
name|sym
condition|)
name|rv
operator|+=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|int
name|addend
decl_stmt|,
name|rn
decl_stmt|,
name|bit
init|=
literal|0
decl_stmt|;
name|int
name|operand
decl_stmt|;
name|int
name|where
init|=
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
decl_stmt|;
name|int
name|e
init|=
name|target_big_endian
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|addend
operator|=
name|target_address_for
argument_list|(
name|fragP
argument_list|)
operator|-
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|where
operator|)
expr_stmt|;
if|if
condition|(
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn
operator|==
operator|-
literal|1
condition|)
block|{
name|fragP
operator|->
name|fr_fix
operator|+=
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|growth
expr_stmt|;
switch|switch
condition|(
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn_for_extern
condition|)
block|{
case|case
name|MEP_PSEUDO64_16BITCC
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|=
operator|(
operator|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|&
literal|1
operator|)
operator|^
literal|1
operator|)
operator||
literal|0x06
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|2
operator|^
name|e
index|]
operator|=
literal|0xd8
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|3
operator|^
name|e
index|]
operator|=
literal|0x08
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|4
operator|^
name|e
index|]
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|5
operator|^
name|e
index|]
operator|=
literal|0
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|MEP_PSEUDO64_32BITCC
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
operator|^
name|e
index|]
operator|&
literal|0x10
condition|)
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|^=
literal|0x01
expr_stmt|;
else|else
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|^=
literal|0x04
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|2
operator|^
name|e
index|]
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|3
operator|^
name|e
index|]
operator|=
literal|4
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|4
operator|^
name|e
index|]
operator|=
literal|0xd8
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|5
operator|^
name|e
index|]
operator|=
literal|0x08
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|6
operator|^
name|e
index|]
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|7
operator|^
name|e
index|]
operator|=
literal|0
expr_stmt|;
name|where
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|=
operator|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|-
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|num
operator|+
name|MEP_INSN_JMP
operator|)
expr_stmt|;
name|operand
operator|=
name|MEP_OPERAND_PCABS24A2
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|num
condition|)
block|{
case|case
name|MEP_INSN_BSR12
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
operator|^
name|e
index|]
operator|=
literal|0xb0
operator||
operator|(
operator|(
name|addend
operator|>>
literal|8
operator|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|=
literal|0x01
operator||
operator|(
name|addend
operator|&
literal|0xfe
operator|)
expr_stmt|;
name|operand
operator|=
name|MEP_OPERAND_PCREL12A2
expr_stmt|;
break|break;
case|case
name|MEP_INSN_BSR24
case|:
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
operator|^
name|e
index|]
operator|=
literal|0xd8
operator||
operator|(
operator|(
name|addend
operator|>>
literal|5
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|=
literal|0x09
operator||
operator|(
operator|(
name|addend
operator|<<
literal|3
operator|)
operator|&
literal|0xf0
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|2
operator|^
name|e
index|]
operator|=
literal|0x00
operator||
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|3
operator|^
name|e
index|]
operator|=
literal|0x00
operator||
operator|(
operator|(
name|addend
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|operand
operator|=
name|MEP_OPERAND_PCREL24A2
expr_stmt|;
break|break;
case|case
name|MEP_INSN_BRA
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
operator|^
name|e
index|]
operator|=
literal|0xb0
operator||
operator|(
operator|(
name|addend
operator|>>
literal|8
operator|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|=
literal|0x00
operator||
operator|(
name|addend
operator|&
literal|0xfe
operator|)
expr_stmt|;
name|operand
operator|=
name|MEP_OPERAND_PCREL12A2
expr_stmt|;
break|break;
case|case
name|MEP_INSN_BEQ
case|:
comment|/* The default relax_frag doesn't change the state if there is no 	   growth, so we must manually handle converting out-of-range BEQ 	   instructions to JMP.  */
if|if
condition|(
name|addend
operator|<=
literal|65535
operator|&&
name|addend
operator|>=
operator|-
literal|65536
condition|)
block|{
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
operator|^
name|e
index|]
operator|=
literal|0xe0
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|=
literal|0x01
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|2
operator|^
name|e
index|]
operator|=
literal|0x00
operator||
operator|(
operator|(
name|addend
operator|>>
literal|9
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|3
operator|^
name|e
index|]
operator|=
literal|0x00
operator||
operator|(
operator|(
name|addend
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|operand
operator|=
name|MEP_OPERAND_PCREL17A2
expr_stmt|;
break|break;
block|}
comment|/* ...FALLTHROUGH... */
case|case
name|MEP_INSN_JMP
case|:
name|addend
operator|=
name|target_address_for
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
operator|^
name|e
index|]
operator|=
literal|0xd8
operator||
operator|(
operator|(
name|addend
operator|>>
literal|5
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|=
literal|0x08
operator||
operator|(
operator|(
name|addend
operator|<<
literal|3
operator|)
operator|&
literal|0xf0
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|2
operator|^
name|e
index|]
operator|=
literal|0x00
operator||
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|3
operator|^
name|e
index|]
operator|=
literal|0x00
operator||
operator|(
operator|(
name|addend
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|operand
operator|=
name|MEP_OPERAND_PCABS24A2
expr_stmt|;
break|break;
case|case
name|MEP_INSN_BNEZ
case|:
name|bit
operator|=
literal|1
expr_stmt|;
case|case
name|MEP_INSN_BEQZ
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|=
name|bit
operator||
operator|(
name|addend
operator|&
literal|0xfe
operator|)
expr_stmt|;
name|operand
operator|=
name|MEP_OPERAND_PCREL8A2
expr_stmt|;
break|break;
case|case
name|MEP_INSN_BNEI
case|:
name|bit
operator|=
literal|4
expr_stmt|;
case|case
name|MEP_INSN_BEQI
case|:
if|if
condition|(
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|growth
condition|)
block|{
name|fragP
operator|->
name|fr_fix
operator|+=
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|growth
expr_stmt|;
name|rn
operator|=
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
operator|^
name|e
index|]
operator|&
literal|0x0f
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
operator|^
name|e
index|]
operator|=
literal|0xe0
operator||
name|rn
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
operator|^
name|e
index|]
operator|=
name|bit
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_opcode
index|[
literal|2
operator|^
name|e
index|]
operator|=
literal|0x00
operator||
operator|(
operator|(
name|addend
operator|>>
literal|9
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|3
operator|^
name|e
index|]
operator|=
literal|0x00
operator||
operator|(
operator|(
name|addend
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|operand
operator|=
name|MEP_OPERAND_PCREL17A2
expr_stmt|;
break|break;
case|case
name|MEP_INSN_BLTI
case|:
case|case
name|MEP_INSN_BGEI
case|:
case|case
name|MEP_INSN_BCPEQ
case|:
case|case
name|MEP_INSN_BCPNE
case|:
case|case
name|MEP_INSN_BCPAT
case|:
case|case
name|MEP_INSN_BCPAF
case|:
comment|/* No opcode change needed, just operand.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|2
operator|^
name|e
index|]
operator|=
operator|(
name|addend
operator|>>
literal|9
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|3
operator|^
name|e
index|]
operator|=
operator|(
name|addend
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|operand
operator|=
name|MEP_OPERAND_PCREL17A2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|sec
operator|||
name|operand
operator|==
name|MEP_OPERAND_PCABS24A2
condition|)
block|{
name|assert
argument_list|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|gas_cgen_record_fixup
argument_list|(
name|fragP
argument_list|,
name|where
argument_list|,
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
argument_list|,
operator|(
name|fragP
operator|->
name|fr_fix
operator|-
name|where
operator|)
operator|*
literal|8
argument_list|,
name|cgen_operand_lookup_by_num
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|operand
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_cgen
operator|.
name|opinfo
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_function
name|void
name|mep_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If we already know the fixup value, adjust it in the same      way that the linker would have done.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
switch|switch
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
condition|)
block|{
case|case
name|BFD_RELOC_MEP_LOW16
case|:
operator|*
name|valP
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
operator|*
name|valP
operator|&
literal|0xffff
argument_list|)
operator|)
operator|<<
literal|16
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MEP_HI16U
case|:
operator|*
name|valP
operator|>>=
literal|16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MEP_HI16S
case|:
operator|*
name|valP
operator|=
operator|(
operator|*
name|valP
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
expr_stmt|;
break|break;
block|}
comment|/* Now call cgen's md_aply_fix.  */
name|gas_cgen_md_apply_fix
argument_list|(
name|fixP
argument_list|,
name|valP
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|sec
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
condition|)
comment|/* The symbol is undefined (or is defined but not in this section).        Let the linker figure it out.  */
return|return
literal|0
return|;
comment|/* Return the address of the opcode - cgen adjusts for opcode size      itself, to be consistent with the disassembler, which must do      so.  */
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.    Returns BFD_RELOC_NONE if no reloc type can be found.    *FIXP may be modified if desired.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALMOST_STDC
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_STRINGIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAP
parameter_list|(
name|n
parameter_list|)
value|case MEP_OPERAND_##n: return BFD_RELOC_MEP_##n;
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAP
parameter_list|(
name|n
parameter_list|)
value|case MEP_OPERAND_
comment|/**/
value|n: return BFD_RELOC_MEP_
comment|/**/
value|n;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bfd_reloc_code_real_type
name|md_cgen_lookup_reloc
parameter_list|(
specifier|const
name|CGEN_INSN
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|enum
name|bfd_reloc_code_real
name|reloc
init|=
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
decl_stmt|;
specifier|static
name|char
name|printed
index|[
name|MEP_OPERAND_MAX
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* If there's a reloc here, it's because the parser saw a %foo() and      is giving us the correct reloc to use, or because we converted to      a different size reloc below and want to avoid "converting" more      than once.  */
if|if
condition|(
name|reloc
operator|&&
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
return|return
name|reloc
return|;
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
name|MAP
argument_list|(
name|PCREL8A2
argument_list|)
expr_stmt|;
comment|/* beqz */
name|MAP
argument_list|(
name|PCREL12A2
argument_list|)
expr_stmt|;
comment|/* bsr16 */
name|MAP
argument_list|(
name|PCREL17A2
argument_list|)
expr_stmt|;
comment|/* beqi */
name|MAP
argument_list|(
name|PCREL24A2
argument_list|)
expr_stmt|;
comment|/* bsr24 */
name|MAP
argument_list|(
name|PCABS24A2
argument_list|)
expr_stmt|;
comment|/* jmp */
name|MAP
argument_list|(
name|UIMM24
argument_list|)
expr_stmt|;
comment|/* mov */
name|MAP
argument_list|(
name|ADDR24A4
argument_list|)
expr_stmt|;
comment|/* sw/lw */
comment|/* The rest of the relocs should be generated by the parser,        for things such as %tprel(), etc. */
case|case
name|MEP_OPERAND_SIMM16
case|:
ifdef|#
directive|ifdef
name|OBJ_COMPLEX_RELC
comment|/* coalescing this into RELOC_MEP_16 is actually a bug, 	 since it's a signed operand. let the relc code handle it. */
return|return
name|BFD_RELOC_RELC
return|;
endif|#
directive|endif
case|case
name|MEP_OPERAND_UIMM16
case|:
case|case
name|MEP_OPERAND_SDISP16
case|:
case|case
name|MEP_OPERAND_CODE16
case|:
name|fixP
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
comment|/* to avoid doing the above add twice */
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|=
name|BFD_RELOC_MEP_16
expr_stmt|;
return|return
name|BFD_RELOC_MEP_16
return|;
default|default:
ifdef|#
directive|ifdef
name|OBJ_COMPLEX_RELC
comment|/* this is not an error, yet.  	 pass it to the linker. */
return|return
name|BFD_RELOC_RELC
return|;
endif|#
directive|endif
if|if
condition|(
name|printed
index|[
name|operand
operator|->
name|type
index|]
condition|)
return|return
name|BFD_RELOC_NONE
return|;
name|printed
index|[
name|operand
operator|->
name|type
index|]
operator|=
literal|1
expr_stmt|;
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Don't know how to relocate plain operands of type %s"
argument_list|)
argument_list|,
name|operand
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Print some helpful hints for the user.  */
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
case|case
name|MEP_OPERAND_UDISP7
case|:
case|case
name|MEP_OPERAND_UDISP7A2
case|:
case|case
name|MEP_OPERAND_UDISP7A4
case|:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Perhaps you are missing %%tpoff()?"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|BFD_RELOC_NONE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Called while parsing an instruction to create a fixup.    We need to check for HI16 relocs and queue them up for later sorting.  */
end_comment

begin_function
name|fixS
modifier|*
name|mep_cgen_record_fixup_exp
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
specifier|const
name|CGEN_INSN
modifier|*
name|insn
parameter_list|,
name|int
name|length
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|,
name|int
name|opinfo
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|fixS
modifier|*
name|fixP
init|=
name|gas_cgen_record_fixup_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|insn
argument_list|,
name|length
argument_list|,
name|operand
argument_list|,
name|opinfo
argument_list|,
name|exp
argument_list|)
decl_stmt|;
return|return
name|fixP
return|;
block|}
end_function

begin_comment
comment|/* Return BFD reloc type from opinfo field in a fixS.    It's tricky using fx_r_type in mep_frob_file because the values    are BFD_RELOC_UNUSED + operand number.  */
end_comment

begin_define
define|#
directive|define
name|FX_OPINFO_R_TYPE
parameter_list|(
name|f
parameter_list|)
value|((f)->fx_cgen.opinfo)
end_define

begin_comment
comment|/* Sort any unmatched HI16 relocs so that they immediately precede    the corresponding LO16 reloc.  This is called before md_apply_fix and    tc_gen_reloc.  */
end_comment

begin_function
name|void
name|mep_frob_file
parameter_list|()
block|{
name|struct
name|mep_hi_fixup
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|mep_hi_fixup_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|assert
argument_list|(
name|FX_OPINFO_R_TYPE
argument_list|(
name|l
operator|->
name|fixp
argument_list|)
operator|==
name|BFD_RELOC_HI16
operator|||
name|FX_OPINFO_R_TYPE
argument_list|(
name|l
operator|->
name|fixp
argument_list|)
operator|==
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
comment|/* Check quickly whether the next fixup happens to be a matching low.  */
if|if
condition|(
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|!=
name|NULL
operator|&&
name|FX_OPINFO_R_TYPE
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_next
argument_list|)
operator|==
name|BFD_RELOC_LO16
operator|&&
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|->
name|fx_addsy
operator|&&
name|l
operator|->
name|fixp
operator|->
name|fx_offset
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|->
name|fx_offset
condition|)
continue|continue;
comment|/* Look through the fixups for this segment for a matching          `low'.  When we find one, move the high just in front of it.          We do this in two passes.  In the first pass, we try to find          a unique `low'.  In the second pass, we permit multiple          high's relocs for a single `low'.  */
name|seginfo
operator|=
name|seg_info
argument_list|(
name|l
operator|->
name|seg
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|fixS
modifier|*
name|f
decl_stmt|;
name|fixS
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|f
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|fx_next
control|)
block|{
comment|/* Check whether this is a `low' fixup which matches l->fixp.  */
if|if
condition|(
name|FX_OPINFO_R_TYPE
argument_list|(
name|f
argument_list|)
operator|==
name|BFD_RELOC_LO16
operator|&&
name|f
operator|->
name|fx_addsy
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
operator|&&
name|f
operator|->
name|fx_offset
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_offset
operator|&&
operator|(
name|pass
operator|==
literal|1
operator|||
name|prev
operator|==
name|NULL
operator|||
operator|(
name|FX_OPINFO_R_TYPE
argument_list|(
name|prev
argument_list|)
operator|!=
name|BFD_RELOC_HI16
operator|)
operator|||
name|prev
operator|->
name|fx_addsy
operator|!=
name|f
operator|->
name|fx_addsy
operator|||
name|prev
operator|->
name|fx_offset
operator|!=
name|f
operator|->
name|fx_offset
operator|)
condition|)
block|{
name|fixS
modifier|*
modifier|*
name|pf
decl_stmt|;
comment|/* Move l->fixp before f.  */
for|for
control|(
name|pf
operator|=
operator|&
name|seginfo
operator|->
name|fix_root
init|;
operator|*
name|pf
operator|!=
name|l
operator|->
name|fixp
condition|;
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|fx_next
control|)
name|assert
argument_list|(
operator|*
name|pf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|pf
operator|=
name|l
operator|->
name|fixp
operator|->
name|fx_next
expr_stmt|;
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|seginfo
operator|->
name|fix_root
operator|=
name|l
operator|->
name|fixp
expr_stmt|;
else|else
name|prev
operator|->
name|fx_next
operator|=
name|l
operator|->
name|fixp
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|f
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|as_warn_where
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_file
argument_list|,
name|l
operator|->
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Unmatched high relocation"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* See whether we need to force a relocation into the output file. */
end_comment

begin_function
name|int
name|mep_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|1
return|;
comment|/* Allow branches to global symbols to be resolved at assembly time.      This is consistent with way relaxable branches are handled, since      branches to both global and local symbols are relaxed.  It also      corresponds to the assumptions made in md_pcrel_from_section.  */
return|return
name|S_FORCE_RELOC
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|,
operator|!
name|fixp
operator|->
name|fx_pcrel
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a value out to the object file, using the appropriate endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type type, and store the appropriate bytes in *litP.  The number    of LITTLENUMS emitted is stored in *sizeP .  An error message is    returned, or NULL on OK. */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|mep_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
name|NULL
decl_stmt|;
name|int
name|opindex
init|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
init|=
name|cgen_operand_lookup_by_num
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|opindex
argument_list|)
decl_stmt|;
name|reloc_type
operator|=
name|md_cgen_lookup_reloc
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
block|}
else|else
name|reloc_type
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Prevent all adjustments to global symbols. */
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We need the symbol name for the VTABLE entries */
if|if
condition|(
name|reloc_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|mep_elf_section_letter
parameter_list|(
name|int
name|letter
parameter_list|,
name|char
modifier|*
modifier|*
name|ptrmsg
parameter_list|)
block|{
if|if
condition|(
name|letter
operator|==
literal|'v'
condition|)
return|return
name|SHF_MEP_VLIW
return|;
operator|*
name|ptrmsg
operator|=
name|_
argument_list|(
literal|"Bad .section directive: want a,v,w,x,M,S in string"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|flagword
name|mep_elf_section_flags
parameter_list|(
name|flagword
name|flags
parameter_list|,
name|int
name|attr
parameter_list|,
name|int
name|type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|attr
operator|&
name|SHF_MEP_VLIW
condition|)
name|flags
operator||=
name|SEC_MEP_VLIW
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* In vliw mode, the default section is .vtext.  We have to be able    to switch into .vtext using only the .vtext directive.  */
end_comment

begin_function
specifier|static
name|segT
name|mep_vtext_section
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|segT
name|vtext_section
decl_stmt|;
if|if
condition|(
operator|!
name|vtext_section
condition|)
block|{
name|flagword
name|applicable
init|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
decl_stmt|;
name|vtext_section
operator|=
name|subseg_new
argument_list|(
name|VTEXT_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|vtext_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator||
name|SEC_MEP_VLIW
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|vtext_section
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mep_s_vtext
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
comment|/* Record previous_section and previous_subsection.  */
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|mep_vtext_section
argument_list|()
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mep_switch_to_core_mode
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|mep_process_saved_insns
argument_list|()
expr_stmt|;
name|pluspresent
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|CORE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mep_switch_to_vliw_mode
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|MEP_VLIW
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".vliw unavailable when VLIW is disabled."
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|VLIW
expr_stmt|;
comment|/* Switch into .vtext here too. */
comment|/* mep_s_vtext(); */
block|}
end_function

begin_comment
comment|/* This is an undocumented pseudo-op used to disable gas's    "disabled_registers" check.  Used for code which checks for those    registers at runtime.  */
end_comment

begin_function
specifier|static
name|void
name|mep_noregerr
parameter_list|(
name|int
name|i
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|allow_disabled_registers
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mep_unrecognized_line: This is called when a line that can't be parsed    is encountered.  We use it to check for a leading '+' sign which indicates    that the current instruction is a coprocessor instruction that is to be    parallelized with a previous core insn.  This function accepts the '+' and    rejects all other characters that might indicate garbage at the beginning    of the line.  The '+' character gets lost as the calling loop continues,    so we need to indicate that we saw it.  */
end_comment

begin_function
name|int
name|mep_unrecognized_line
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
name|pluspresent
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
comment|/* '+' indicates an instruction to be parallelized. */
default|default:
return|return
literal|0
return|;
comment|/* If it's not a '+', the line can't be parsed. */
block|}
block|}
end_function

begin_function
name|void
name|mep_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Take care of any insns left to be parallelized when the file ends.      This is mainly here to handle the case where the file ends with an      insn preceeded by a + or the file ends unexpectedly.  */
if|if
condition|(
name|mode
operator|==
name|VLIW
condition|)
name|mep_process_saved_insns
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mep_flush_pending_output
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|VLIW
condition|)
block|{
name|mep_process_saved_insns
argument_list|()
expr_stmt|;
name|pluspresent
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

