begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-cr16.c -- Assembler code for the CR16 CPU core.    Copyright 2007 Free Software Foundation, Inc.     Contributed by M R Swami Reddy<MR.Swami.Reddy@nsc.com>     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the    Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cr16.h"
end_include

begin_include
include|#
directive|include
file|"elf/cr16.h"
end_include

begin_comment
comment|/* Word is considered here as a 16-bit unsigned short int.  */
end_comment

begin_define
define|#
directive|define
name|WORD_SHIFT
value|16
end_define

begin_comment
comment|/* Register is 2-byte size.  */
end_comment

begin_define
define|#
directive|define
name|REG_SIZE
value|2
end_define

begin_comment
comment|/* Maximum size of a single instruction (in words).  */
end_comment

begin_define
define|#
directive|define
name|INSN_MAX_SIZE
value|3
end_define

begin_comment
comment|/* Maximum bits which may be set in a `mask16' operand.  */
end_comment

begin_define
define|#
directive|define
name|MAX_REGS_IN_MASK16
value|8
end_define

begin_comment
comment|/* Assign a number NUM, shifted by SHIFT bytes, into a location    pointed by index BYTE of array 'output_opcode'.  */
end_comment

begin_define
define|#
directive|define
name|CR16_PRINT
parameter_list|(
name|BYTE
parameter_list|,
name|NUM
parameter_list|,
name|SHIFT
parameter_list|)
value|output_opcode[BYTE] |= (NUM<< SHIFT)
end_define

begin_comment
comment|/* Operand errors.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OP_LEGAL
init|=
literal|0
block|,
comment|/* Legal operand.  */
name|OP_OUT_OF_RANGE
block|,
comment|/* Operand not within permitted range.  */
name|OP_NOT_EVEN
comment|/* Operand is Odd number, should be even.  */
block|}
name|op_err
typedef|;
end_typedef

begin_comment
comment|/* Opcode mnemonics hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|cr16_inst_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CR16 registers hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CR16 register pair hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|regp_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CR16 processor registers hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|preg_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CR16 processor registers 32 bit hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|pregp_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current instruction we're assembling.  */
end_comment

begin_decl_stmt
specifier|const
name|inst
modifier|*
name|instruction
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|code_label
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variables.  */
end_comment

begin_comment
comment|/* Array to hold an instruction encoding.  */
end_comment

begin_decl_stmt
name|long
name|output_opcode
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means a relocatable symbol.  */
end_comment

begin_decl_stmt
name|int
name|relocatable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A copy of the original instruction (used in error messages).  */
end_comment

begin_decl_stmt
name|char
name|ins_parse
index|[
name|MAX_INST_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current processed argument number.  */
end_comment

begin_decl_stmt
name|int
name|cur_arg_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic assembler global variables which must be defined by all targets.  */
end_comment

begin_comment
comment|/* Characters which always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds machine specific line separator characters.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant as in 0f12.456  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"f'"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target-specific multicharacter options, not const-declared at usage.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|l_cons
parameter_list|(
name|int
name|nbytes
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|TC_ADDRESS_BYTES
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|nbytes
operator|=
name|TC_ADDRESS_BYTES
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|unsigned
name|int
name|bits_available
init|=
name|BITS_PER_CHAR
operator|*
name|nbytes
decl_stmt|;
name|char
modifier|*
name|hold
init|=
name|input_line_pointer
decl_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|':'
condition|)
block|{
comment|/* Bitfields.  */
name|long
name|value
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|long
name|width
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|':'
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using a bit field width of zero"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"field width \"%s\" too complex for a bitfield"
argument_list|)
argument_list|,
name|hold
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|':'
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|width
operator|=
name|exp
operator|.
name|X_add_number
operator|)
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|BITS_PER_CHAR
operator|*
name|nbytes
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"field width %lu too big to fit in %d bytes: truncated to %d bits"
argument_list|)
argument_list|,
name|width
argument_list|,
name|nbytes
argument_list|,
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
argument_list|)
expr_stmt|;
name|width
operator|=
name|BITS_PER_CHAR
operator|*
name|nbytes
expr_stmt|;
block|}
comment|/* Too big.  */
if|if
condition|(
name|width
operator|>
name|bits_available
condition|)
block|{
comment|/* FIXME-SOMEDAY: backing up and reparsing is wasteful.  */
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|value
expr_stmt|;
break|break;
block|}
comment|/* Skip ':'.  */
name|hold
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|char
name|cache
init|=
operator|*
name|input_line_pointer
decl_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"field value \"%s\" too complex for a bitfield"
argument_list|)
argument_list|,
name|hold
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|cache
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|value
operator||=
operator|(
operator|(
operator|~
operator|(
operator|-
literal|1
operator|<<
name|width
operator|)
operator|&
name|exp
operator|.
name|X_add_number
operator|)
operator|<<
operator|(
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
operator|-
name|bits_available
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bits_available
operator|-=
name|width
operator|)
operator|==
literal|0
operator|||
name|is_it_end_of_statement
argument_list|()
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
name|hold
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
name|exp
operator|.
name|X_add_number
operator|=
name|value
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_unsigned
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
operator|(
name|input_line_pointer
operator|)
operator|==
literal|'@'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|input_line_pointer
operator|+
literal|1
operator|)
operator|==
literal|'c'
operator|)
condition|)
name|code_label
operator|=
literal|1
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|input_line_pointer
operator|)
operator|==
literal|'@'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|input_line_pointer
operator|+
literal|1
operator|)
operator|==
literal|'c'
operator|)
condition|)
block|{
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
operator|)
condition|)
do|;
comment|/* Put terminator back into stream.  */
name|input_line_pointer
operator|--
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This table describes all the machine specific pseudo-ops    the assembler has to support.  The fields are:    *** Pseudo-op name without dot.    *** Function to call to execute this pseudo-op.    *** Integer arg to pass to the function.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* In CR16 machine, align is in bytes (not a ptwo boundary).  */
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
block|{
literal|"long"
block|,
name|l_cons
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CR16 relaxation table.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* bCC  */
block|{
literal|0xfa
block|,
operator|-
literal|0x100
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/*  8 */
block|{
literal|0xfffe
block|,
operator|-
literal|0x10000
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* 16 */
block|{
literal|0xfffffe
block|,
operator|-
literal|0x1000000
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* 24 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the bit size for a given operand.  */
end_comment

begin_function
specifier|static
name|int
name|get_opbits
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|cr16_optab
index|[
name|op
index|]
operator|.
name|bit_size
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the argument type of a given operand.  */
end_comment

begin_function
specifier|static
name|argtype
name|get_optype
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|cr16_optab
index|[
name|op
index|]
operator|.
name|arg_type
return|;
else|else
return|return
name|nullargs
return|;
block|}
end_function

begin_comment
comment|/* Return the flags of a given operand.  */
end_comment

begin_function
specifier|static
name|int
name|get_opflags
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|cr16_optab
index|[
name|op
index|]
operator|.
name|flags
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the cc code.  */
end_comment

begin_function
specifier|static
name|int
name|get_cc
parameter_list|(
name|char
modifier|*
name|cc_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cr16_num_cc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cc_name
argument_list|,
name|cr16_b_cond_tab
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get the core processor register 'reg_name'.  */
end_comment

begin_function
specifier|static
name|reg
name|get_register
parameter_list|(
name|char
modifier|*
name|reg_name
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
return|return
name|reg
operator|->
name|value
operator|.
name|reg_val
return|;
return|return
name|nullregister
return|;
block|}
end_function

begin_comment
comment|/* Get the core processor register-pair 'reg_name'.  */
end_comment

begin_function
specifier|static
name|reg
name|get_register_pair
parameter_list|(
name|char
modifier|*
name|reg_name
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|char
name|tmp_rp
index|[
literal|16
index|]
init|=
literal|"\0"
decl_stmt|;
comment|/* Add '(' and ')' to the reg pair, if its not present.  */
if|if
condition|(
name|reg_name
index|[
literal|0
index|]
operator|!=
literal|'('
condition|)
block|{
name|tmp_rp
index|[
literal|0
index|]
operator|=
literal|'('
expr_stmt|;
name|strcat
argument_list|(
name|tmp_rp
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_rp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|regp_hash
argument_list|,
name|tmp_rp
argument_list|)
expr_stmt|;
block|}
else|else
name|reg
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|regp_hash
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
return|return
name|reg
operator|->
name|value
operator|.
name|reg_val
return|;
return|return
name|nullregister
return|;
block|}
end_function

begin_comment
comment|/* Get the index register 'reg_name'.  */
end_comment

begin_function
specifier|static
name|reg
name|get_index_register
parameter_list|(
name|char
modifier|*
name|reg_name
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|reg
operator|->
name|value
operator|.
name|reg_val
operator|==
literal|12
operator|)
operator|||
operator|(
name|reg
operator|->
name|value
operator|.
name|reg_val
operator|==
literal|13
operator|)
operator|)
condition|)
return|return
name|reg
operator|->
name|value
operator|.
name|reg_val
return|;
return|return
name|nullregister
return|;
block|}
end_function

begin_comment
comment|/* Get the core processor index register-pair 'reg_name'.  */
end_comment

begin_function
specifier|static
name|reg
name|get_index_register_pair
parameter_list|(
name|char
modifier|*
name|reg_name
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|regp_hash
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|reg
operator|->
name|value
operator|.
name|reg_val
operator|!=
literal|1
operator|)
operator|||
operator|(
name|reg
operator|->
name|value
operator|.
name|reg_val
operator|!=
literal|7
operator|)
operator|||
operator|(
name|reg
operator|->
name|value
operator|.
name|reg_val
operator|!=
literal|9
operator|)
operator|||
operator|(
name|reg
operator|->
name|value
operator|.
name|reg_val
operator|>
literal|10
operator|)
condition|)
return|return
name|reg
operator|->
name|value
operator|.
name|reg_val
return|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown register pair - index relative mode: `%d'"
argument_list|)
argument_list|,
name|reg
operator|->
name|value
operator|.
name|reg_val
argument_list|)
expr_stmt|;
block|}
return|return
name|nullregister
return|;
block|}
end_function

begin_comment
comment|/* Get the processor register 'preg_name'.  */
end_comment

begin_function
specifier|static
name|preg
name|get_pregister
parameter_list|(
name|char
modifier|*
name|preg_name
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|preg
decl_stmt|;
name|preg
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|preg_hash
argument_list|,
name|preg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|preg
operator|!=
name|NULL
condition|)
return|return
name|preg
operator|->
name|value
operator|.
name|preg_val
return|;
return|return
name|nullpregister
return|;
block|}
end_function

begin_comment
comment|/* Get the processor register 'preg_name 32 bit'.  */
end_comment

begin_function
specifier|static
name|preg
name|get_pregisterp
parameter_list|(
name|char
modifier|*
name|preg_name
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|preg
decl_stmt|;
name|preg
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|pregp_hash
argument_list|,
name|preg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|preg
operator|!=
name|NULL
condition|)
return|return
name|preg
operator|->
name|value
operator|.
name|preg_val
return|;
return|return
name|nullpregister
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|seg
parameter_list|,
name|valueT
name|val
parameter_list|)
block|{
comment|/* Round .text section to a multiple of 2.  */
if|if
condition|(
name|seg
operator|==
name|text_section
condition|)
return|return
operator|(
name|val
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
return|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific (remove '*').  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|char
name|c
init|=
operator|*
name|input_line_pointer
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Reset global variables before parsing a new instruction.  */
end_comment

begin_function
specifier|static
name|void
name|reset_vars
parameter_list|(
name|char
modifier|*
name|op
parameter_list|)
block|{
name|cur_arg_num
operator|=
name|relocatable
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|output_opcode
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|output_opcode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save a copy of the original OP (used in error messages).  */
name|strncpy
argument_list|(
name|ins_parse
argument_list|,
name|op
argument_list|,
sizeof|sizeof
name|ins_parse
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ins_parse
index|[
sizeof|sizeof
name|ins_parse
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This macro decides whether a particular reloc is an entry in a    switch table.  It is used when relaxing, because the linker needs    to know about all such entries so that it can adjust them if    necessary.  */
end_comment

begin_define
define|#
directive|define
name|SWITCH_TABLE
parameter_list|(
name|fix
parameter_list|)
define|\
value|(   (fix)->fx_addsy != NULL                              \&& (fix)->fx_subsy != NULL                              \&& S_GET_SEGMENT ((fix)->fx_addsy) ==                   \       S_GET_SEGMENT ((fix)->fx_subsy)                      \&& S_GET_SEGMENT (fix->fx_addsy) != undefined_section   \&& (   (fix)->fx_r_type == BFD_RELOC_CR16_NUM8          \        || (fix)->fx_r_type == BFD_RELOC_CR16_NUM16         \        || (fix)->fx_r_type == BFD_RELOC_CR16_NUM32         \        || (fix)->fx_r_type == BFD_RELOC_CR16_NUM32a))
end_define

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|cr16_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|)
block|{
comment|/* REVISIT: Check if the "SWITCH_TABLE (fix)" should be added      if (generic_force_reloc (fix) || SWITCH_TABLE (fix))  */
if|if
condition|(
name|generic_force_reloc
argument_list|(
name|fix
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record a fixup for a cons expression.  */
end_comment

begin_function
name|void
name|cr16_cons_fix_new
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|rtype
decl_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
default|default:
name|rtype
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rtype
operator|=
name|BFD_RELOC_CR16_NUM8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rtype
operator|=
name|BFD_RELOC_CR16_NUM16
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|code_label
condition|)
block|{
name|rtype
operator|=
name|BFD_RELOC_CR16_NUM32a
expr_stmt|;
name|code_label
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|rtype
operator|=
name|BFD_RELOC_CR16_NUM32
expr_stmt|;
break|break;
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a relocation entry for a fixup.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SWITCH_TABLE
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
comment|/* Keep the current difference in the addend.  */
name|reloc
operator|->
name|addend
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|+
name|fixP
operator|->
name|fx_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_CR16_NUM8
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_CR16_NUM8
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CR16_NUM16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_CR16_NUM16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CR16_NUM32
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_CR16_NUM32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CR16_NUM32a
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_CR16_NUM32a
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* We only resolve difference expressions in the same section.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can't resolve `%s' {%s section} - `%s' {%s section}"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_addsy
condition|?
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
literal|"0"
argument_list|,
name|segment_name
argument_list|(
name|fixP
operator|->
name|fx_addsy
condition|?
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|absolute_section
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>
literal|0
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal error: reloc %d (`%s') not supported by object file format"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|==
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Prepare machine-dependent frags for relaxation.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|seg
parameter_list|)
block|{
comment|/* If symbol is undefined or located in a different section,      select the largest supported relocation.  */
name|relax_substateT
name|subtype
decl_stmt|;
name|relax_substateT
name|rlx_state
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|}
decl_stmt|;
for|for
control|(
name|subtype
operator|=
literal|0
init|;
name|subtype
operator|<
name|ARRAY_SIZE
argument_list|(
name|rlx_state
argument_list|)
condition|;
name|subtype
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
name|rlx_state
index|[
name|subtype
index|]
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|||
name|seg
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator|=
name|rlx_state
index|[
name|subtype
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|>=
name|ARRAY_SIZE
argument_list|(
name|md_relax_table
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|md_relax_table
index|[
name|fragp
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
comment|/* 'opcode' points to the start of the instruction, whether      we need to change the instruction's fixed encoding.  */
name|bfd_reloc_code_real_type
name|reloc
init|=
name|BFD_RELOC_NONE
decl_stmt|;
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
name|bfd_get_reloc_size
argument_list|(
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process machine-dependent command line options.  Called once for    each option on the command line that the machine-independent part of    GAS does not understand.  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Machine-dependent usage-output.  */
end_comment

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixS (fixup of an instruction or data that we didn't have    enough info to complete immediately) to the data in a frag.    Since linkrelax is nonzero and TC_LINKRELAX_FIXUP is defined to disable    relaxation of debug sections, this function is called only when    fixuping relocations of debug sections.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|valueT
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_CR16_NUM8
case|:
name|bfd_put_8
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CR16_NUM16
case|:
name|bfd_put_16
argument_list|(
name|stdoutput
argument_list|,
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CR16_NUM32
case|:
name|bfd_put_32
argument_list|(
name|stdoutput
argument_list|,
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CR16_NUM32a
case|:
name|bfd_put_32
argument_list|(
name|stdoutput
argument_list|,
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* We shouldn't ever get here because linkrelax is nonzero.  */
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|1
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|seg
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialise_reg_hash_table
parameter_list|(
name|struct
name|hash_control
modifier|*
modifier|*
name|hash_table
parameter_list|,
specifier|const
name|reg_entry
modifier|*
name|register_table
parameter_list|,
specifier|const
name|unsigned
name|int
name|num_entries
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
specifier|const
name|char
modifier|*
name|hashret
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|hash_table
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|register_table
init|;
name|reg
operator|<
operator|(
name|register_table
operator|+
name|num_entries
operator|)
condition|;
name|reg
operator|++
control|)
block|{
name|hashret
operator|=
name|hash_insert
argument_list|(
operator|*
name|hash_table
argument_list|,
name|reg
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashret
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
name|reg
operator|->
name|name
argument_list|,
name|hashret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  This should    set up all the tables, etc that the MD part of the assembler needs.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Set up a hash table for the instructions.  */
if|if
condition|(
operator|(
name|cr16_inst_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cr16_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|hashret
decl_stmt|;
specifier|const
name|char
modifier|*
name|mnemonic
init|=
name|cr16_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
decl_stmt|;
name|hashret
operator|=
name|hash_insert
argument_list|(
name|cr16_inst_hash
argument_list|,
name|mnemonic
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|cr16_instruction
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashret
operator|!=
name|NULL
operator|&&
operator|*
name|hashret
operator|!=
literal|'\0'
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't hash `%s': %s\n"
argument_list|)
argument_list|,
name|cr16_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
argument_list|,
operator|*
name|hashret
operator|==
literal|0
condition|?
name|_
argument_list|(
literal|"(unknown reason)"
argument_list|)
else|:
name|hashret
argument_list|)
expr_stmt|;
comment|/* Insert unique names into hash table.  The CR16 instruction set          has many identical opcode names that have different opcodes based          on the operands.  This hash table then provides a quick index to          the first opcode with a particular name in the opcode table.  */
do|do
block|{
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|cr16_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
operator|!=
name|NULL
operator|&&
name|streq
argument_list|(
name|cr16_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
argument_list|,
name|mnemonic
argument_list|)
condition|)
do|;
block|}
comment|/* Initialize reg_hash hash table.  */
name|initialise_reg_hash_table
argument_list|(
operator|&
name|reg_hash
argument_list|,
name|cr16_regtab
argument_list|,
name|NUMREGS
argument_list|)
expr_stmt|;
comment|/* Initialize regp_hash hash table.  */
name|initialise_reg_hash_table
argument_list|(
operator|&
name|regp_hash
argument_list|,
name|cr16_regptab
argument_list|,
name|NUMREGPS
argument_list|)
expr_stmt|;
comment|/* Initialize preg_hash hash table.  */
name|initialise_reg_hash_table
argument_list|(
operator|&
name|preg_hash
argument_list|,
name|cr16_pregtab
argument_list|,
name|NUMPREGS
argument_list|)
expr_stmt|;
comment|/* Initialize pregp_hash hash table.  */
name|initialise_reg_hash_table
argument_list|(
operator|&
name|pregp_hash
argument_list|,
name|cr16_pregptab
argument_list|,
name|NUMPREGPS
argument_list|)
expr_stmt|;
comment|/*  Set linkrelax here to avoid fixups in most sections.  */
name|linkrelax
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process constants (immediate/absolute)    and labels (jump targets/Memory locations).  */
end_comment

begin_function
specifier|static
name|void
name|process_label_constant
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|ins
modifier|*
name|cr16_ins
parameter_list|)
block|{
name|char
modifier|*
name|saved_input_line_pointer
decl_stmt|;
name|int
name|symbol_with_at
init|=
literal|0
decl_stmt|;
name|int
name|symbol_with_s
init|=
literal|0
decl_stmt|;
name|int
name|symbol_with_m
init|=
literal|0
decl_stmt|;
name|int
name|symbol_with_l
init|=
literal|0
decl_stmt|;
name|argument
modifier|*
name|cur_arg
init|=
name|cr16_ins
operator|->
name|arg
operator|+
name|cur_arg_num
decl_stmt|;
comment|/* Current argument.  */
name|saved_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|cr16_ins
operator|->
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cr16_ins
operator|->
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_big
case|:
case|case
name|O_absent
case|:
comment|/* Missing or bad expr becomes absolute 0.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing or invalid displacement expression `%s' taken as 0"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|cr16_ins
operator|->
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|cr16_ins
operator|->
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|cr16_ins
operator|->
name|exp
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|cr16_ins
operator|->
name|exp
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_constant
case|:
name|cur_arg
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|cur_arg
operator|->
name|constant
operator|=
name|cr16_ins
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
case|case
name|O_subtract
case|:
case|case
name|O_add
case|:
name|cur_arg
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|relocatable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strneq
argument_list|(
name|input_line_pointer
argument_list|,
literal|"@c"
argument_list|,
literal|2
argument_list|)
condition|)
name|symbol_with_at
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strneq
argument_list|(
name|input_line_pointer
argument_list|,
literal|"@l"
argument_list|,
literal|2
argument_list|)
operator|||
name|strneq
argument_list|(
name|input_line_pointer
argument_list|,
literal|":l"
argument_list|,
literal|2
argument_list|)
condition|)
name|symbol_with_l
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strneq
argument_list|(
name|input_line_pointer
argument_list|,
literal|"@m"
argument_list|,
literal|2
argument_list|)
operator|||
name|strneq
argument_list|(
name|input_line_pointer
argument_list|,
literal|":m"
argument_list|,
literal|2
argument_list|)
condition|)
name|symbol_with_m
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strneq
argument_list|(
name|input_line_pointer
argument_list|,
literal|"@s"
argument_list|,
literal|2
argument_list|)
operator|||
name|strneq
argument_list|(
name|input_line_pointer
argument_list|,
literal|":s"
argument_list|,
literal|2
argument_list|)
condition|)
name|symbol_with_s
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|cur_arg
operator|->
name|type
condition|)
block|{
case|case
name|arg_cr
case|:
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur_arg
operator|->
name|size
operator|==
literal|20
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL20
expr_stmt|;
else|else
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL20a
expr_stmt|;
block|}
break|break;
case|case
name|arg_crp
case|:
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
condition|)
switch|switch
condition|(
name|instruction
operator|->
name|size
condition|)
block|{
case|case
literal|1
case|:
switch|switch
condition|(
name|cur_arg
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL0
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"loadb"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"storb"
argument_list|)
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL4
expr_stmt|;
else|else
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL4a
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|2
case|:
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL16
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|cur_arg
operator|->
name|size
operator|==
literal|20
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL20
expr_stmt|;
else|else
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL20a
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|arg_idxr
case|:
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL20
expr_stmt|;
break|break;
case|case
name|arg_idxrp
case|:
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
condition|)
switch|switch
condition|(
name|instruction
operator|->
name|size
condition|)
block|{
case|case
literal|1
case|:
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL14
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_REGREL20
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|arg_c
case|:
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"bal"
argument_list|)
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_DISP24
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_INS
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol_with_s
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_DISP8
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol_with_m
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_DISP16
expr_stmt|;
else|else
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_DISP24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|STOR_IMM_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol_with_s
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand %d: illegal use expression: `%s`"
argument_list|)
argument_list|,
name|cur_arg_num
operator|+
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_with_m
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_ABS20
expr_stmt|;
else|else
comment|/* Default to (symbol_with_l) */
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_ABS24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_NEQ_INS
argument_list|)
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_DISP4
expr_stmt|;
break|break;
case|case
name|arg_ic
case|:
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|ARITH_INS
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol_with_s
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_IMM4
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol_with_m
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_IMM20
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol_with_at
condition|)
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_IMM32a
expr_stmt|;
else|else
comment|/* Default to (symbol_with_l) */
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_IMM32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|ARITH_BYTE_INS
argument_list|)
condition|)
block|{
name|cr16_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_IMM16
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
name|cur_arg
operator|->
name|X_op
operator|=
name|cr16_ins
operator|->
name|exp
operator|.
name|X_op
expr_stmt|;
break|break;
block|}
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Retrieve the opcode image of a given register.    If the register is illegal for the current instruction,    issue an error.  */
end_comment

begin_function
specifier|static
name|int
name|getreg_image
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|char
modifier|*
name|reg_name
decl_stmt|;
name|int
name|is_procreg
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means argument should be processor reg.  */
comment|/* Check whether the register is in registers table.  */
if|if
condition|(
name|r
operator|<
name|MAX_REG
condition|)
name|reg
operator|=
name|cr16_regtab
operator|+
name|r
expr_stmt|;
else|else
comment|/* Register not found.  */
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown register: `%d'"
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|reg_name
operator|=
name|reg
operator|->
name|name
expr_stmt|;
comment|/* Issue a error message when register is illegal.  */
define|#
directive|define
name|IMAGE_ERR
define|\
value|as_bad (_("Illegal register (`%s') in Instruction: `%s'"), \             reg_name, ins_parse);                            \   break;
switch|switch
condition|(
name|reg
operator|->
name|type
condition|)
block|{
case|case
name|CR16_R_REGTYPE
case|:
if|if
condition|(
operator|!
name|is_procreg
condition|)
return|return
name|reg
operator|->
name|image
return|;
else|else
name|IMAGE_ERR
expr_stmt|;
case|case
name|CR16_P_REGTYPE
case|:
return|return
name|reg
operator|->
name|image
return|;
break|break;
default|default:
name|IMAGE_ERR
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parsing different types of operands    -> constants             Immediate/Absolute/Relative numbers    -> Labels                Relocatable symbols    -> (reg pair base)       Register pair base    -> (rbase)               Register base    -> disp(rbase)           Register relative    -> [rinx]disp(reg pair)  Register index with reg pair mode    -> disp(rbase,ridx,scl)  Register index mode.  */
end_comment

begin_function
specifier|static
name|void
name|set_operand
parameter_list|(
name|char
modifier|*
name|operand
parameter_list|,
name|ins
modifier|*
name|cr16_ins
parameter_list|)
block|{
name|char
modifier|*
name|operandS
decl_stmt|;
comment|/* Pointer to start of sub-opearand.  */
name|char
modifier|*
name|operandE
decl_stmt|;
comment|/* Pointer to end of sub-opearand.  */
name|argument
modifier|*
name|cur_arg
init|=
operator|&
name|cr16_ins
operator|->
name|arg
index|[
name|cur_arg_num
index|]
decl_stmt|;
comment|/* Current argument.  */
comment|/* Initialize pointers.  */
name|operandS
operator|=
name|operandE
operator|=
name|operand
expr_stmt|;
switch|switch
condition|(
name|cur_arg
operator|->
name|type
condition|)
block|{
case|case
name|arg_ic
case|:
comment|/* Case $0x18.  */
name|operandS
operator|++
expr_stmt|;
case|case
name|arg_c
case|:
comment|/* Case 0x18.  */
comment|/* Set constant.  */
name|process_label_constant
argument_list|(
name|operandS
argument_list|,
name|cr16_ins
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_arg
operator|->
name|type
operator|!=
name|arg_ic
condition|)
name|cur_arg
operator|->
name|type
operator|=
name|arg_c
expr_stmt|;
break|break;
case|case
name|arg_icr
case|:
comment|/* Case $0x18(r1).  */
name|operandS
operator|++
expr_stmt|;
case|case
name|arg_cr
case|:
comment|/* Case 0x18(r1).   */
comment|/* Set displacement constant.  */
while|while
condition|(
operator|*
name|operandE
operator|!=
literal|'('
condition|)
name|operandE
operator|++
expr_stmt|;
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
name|process_label_constant
argument_list|(
name|operandS
argument_list|,
name|cr16_ins
argument_list|)
expr_stmt|;
name|operandS
operator|=
name|operandE
expr_stmt|;
case|case
name|arg_rbase
case|:
comment|/* Case (r1) or (r1,r0).  */
name|operandS
operator|++
expr_stmt|;
comment|/* Set register base.  */
while|while
condition|(
operator|*
name|operandE
operator|!=
literal|')'
condition|)
name|operandE
operator|++
expr_stmt|;
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cur_arg
operator|->
name|r
operator|=
name|get_register
argument_list|(
name|operandS
argument_list|)
operator|)
operator|==
name|nullregister
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal register `%s' in Instruction `%s'"
argument_list|)
argument_list|,
name|operandS
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
comment|/* set the arg->rp, if reg is "r12" or "r13" or "14" or "15" */
if|if
condition|(
operator|(
name|cur_arg
operator|->
name|type
operator|!=
name|arg_rbase
operator|)
operator|&&
operator|(
operator|(
name|getreg_image
argument_list|(
name|cur_arg
operator|->
name|r
argument_list|)
operator|==
literal|12
operator|)
operator|||
operator|(
name|getreg_image
argument_list|(
name|cur_arg
operator|->
name|r
argument_list|)
operator|==
literal|13
operator|)
operator|||
operator|(
name|getreg_image
argument_list|(
name|cur_arg
operator|->
name|r
argument_list|)
operator|==
literal|14
operator|)
operator|||
operator|(
name|getreg_image
argument_list|(
name|cur_arg
operator|->
name|r
argument_list|)
operator|==
literal|15
operator|)
operator|)
condition|)
block|{
name|cur_arg
operator|->
name|type
operator|=
name|arg_crp
expr_stmt|;
name|cur_arg
operator|->
name|rp
operator|=
name|cur_arg
operator|->
name|r
expr_stmt|;
block|}
break|break;
case|case
name|arg_crp
case|:
comment|/* Case 0x18(r1,r0).   */
comment|/* Set displacement constant.  */
while|while
condition|(
operator|*
name|operandE
operator|!=
literal|'('
condition|)
name|operandE
operator|++
expr_stmt|;
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
name|process_label_constant
argument_list|(
name|operandS
argument_list|,
name|cr16_ins
argument_list|)
expr_stmt|;
name|operandS
operator|=
name|operandE
expr_stmt|;
name|operandS
operator|++
expr_stmt|;
comment|/* Set register pair base.  */
while|while
condition|(
operator|*
name|operandE
operator|!=
literal|')'
condition|)
name|operandE
operator|++
expr_stmt|;
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cur_arg
operator|->
name|rp
operator|=
name|get_register_pair
argument_list|(
name|operandS
argument_list|)
operator|)
operator|==
name|nullregister
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal register pair `%s' in Instruction `%s'"
argument_list|)
argument_list|,
name|operandS
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_idxr
case|:
comment|/* Set register pair base.  */
if|if
condition|(
operator|(
name|strchr
argument_list|(
name|operandS
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|operandE
operator|!=
literal|'('
operator|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|operandE
argument_list|)
operator|)
condition|)
name|operandE
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cur_arg
operator|->
name|rp
operator|=
name|get_index_register_pair
argument_list|(
name|operandE
argument_list|)
operator|)
operator|==
name|nullregister
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal register pair `%s' in Instruction `%s'"
argument_list|)
argument_list|,
name|operandS
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
operator|*
name|operandE
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|cur_arg
operator|->
name|type
operator|=
name|arg_idxrp
expr_stmt|;
block|}
else|else
name|cur_arg
operator|->
name|rp
operator|=
operator|-
literal|1
expr_stmt|;
name|operandE
operator|=
name|operandS
expr_stmt|;
comment|/* Set displacement constant.  */
while|while
condition|(
operator|*
name|operandE
operator|!=
literal|']'
condition|)
name|operandE
operator|++
expr_stmt|;
name|process_label_constant
argument_list|(
operator|++
name|operandE
argument_list|,
name|cr16_ins
argument_list|)
expr_stmt|;
operator|*
name|operandE
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|operandE
operator|=
name|operandS
expr_stmt|;
comment|/* Set index register .  */
name|operandS
operator|=
name|strchr
argument_list|(
name|operandE
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|operandS
operator|!=
name|NULL
condition|)
block|{
comment|/* Eliminate '[', detach from rest of operand.  */
operator|*
name|operandS
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|operandE
operator|=
name|strchr
argument_list|(
name|operandS
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|operandE
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unmatched '['"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Eliminate ']' and make sure it was the last thing                  in the string.  */
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|operandE
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"garbage after index spec ignored"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|cur_arg
operator|->
name|i_r
operator|=
name|get_index_register
argument_list|(
name|operandS
argument_list|)
operator|)
operator|==
name|nullregister
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal register `%s' in Instruction `%s'"
argument_list|)
argument_list|,
name|operandS
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|operandS
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Parse a single operand.    operand - Current operand to parse.    cr16_ins - Current assembled instruction.  */
end_comment

begin_function
specifier|static
name|void
name|parse_operand
parameter_list|(
name|char
modifier|*
name|operand
parameter_list|,
name|ins
modifier|*
name|cr16_ins
parameter_list|)
block|{
name|int
name|ret_val
decl_stmt|;
name|argument
modifier|*
name|cur_arg
init|=
name|cr16_ins
operator|->
name|arg
operator|+
name|cur_arg_num
decl_stmt|;
comment|/* Current argument.  */
comment|/* Initialize the type to NULL before parsing.  */
name|cur_arg
operator|->
name|type
operator|=
name|nullargs
expr_stmt|;
comment|/* Check whether this is a condition code .  */
if|if
condition|(
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"b"
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|ret_val
operator|=
name|get_cc
argument_list|(
name|operand
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|cur_arg
operator|->
name|type
operator|=
name|arg_cc
expr_stmt|;
name|cur_arg
operator|->
name|cc
operator|=
name|ret_val
expr_stmt|;
name|cur_arg
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
return|return;
block|}
comment|/* Check whether this is a general processor register.  */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|get_register
argument_list|(
name|operand
argument_list|)
operator|)
operator|!=
name|nullregister
condition|)
block|{
name|cur_arg
operator|->
name|type
operator|=
name|arg_r
expr_stmt|;
name|cur_arg
operator|->
name|r
operator|=
name|ret_val
expr_stmt|;
name|cur_arg
operator|->
name|X_op
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Check whether this is a general processor register pair.  */
if|if
condition|(
operator|(
name|operand
index|[
literal|0
index|]
operator|==
literal|'('
operator|)
operator|&&
operator|(
operator|(
name|ret_val
operator|=
name|get_register_pair
argument_list|(
name|operand
argument_list|)
operator|)
operator|!=
name|nullregister
operator|)
condition|)
block|{
name|cur_arg
operator|->
name|type
operator|=
name|arg_rp
expr_stmt|;
name|cur_arg
operator|->
name|rp
operator|=
name|ret_val
expr_stmt|;
name|cur_arg
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
return|return;
block|}
comment|/* Check whether the operand is a processor register.      For "lprd" and "sprd" instruction, only 32 bit      processor registers used.  */
if|if
condition|(
operator|!
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"lprd"
argument_list|)
operator|||
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"sprd"
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ret_val
operator|=
name|get_pregister
argument_list|(
name|operand
argument_list|)
operator|)
operator|!=
name|nullpregister
operator|)
condition|)
block|{
name|cur_arg
operator|->
name|type
operator|=
name|arg_pr
expr_stmt|;
name|cur_arg
operator|->
name|pr
operator|=
name|ret_val
expr_stmt|;
name|cur_arg
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
return|return;
block|}
comment|/* Check whether this is a processor register - 32 bit.  */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|get_pregisterp
argument_list|(
name|operand
argument_list|)
operator|)
operator|!=
name|nullpregister
condition|)
block|{
name|cur_arg
operator|->
name|type
operator|=
name|arg_prp
expr_stmt|;
name|cur_arg
operator|->
name|prp
operator|=
name|ret_val
expr_stmt|;
name|cur_arg
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
return|return;
block|}
comment|/* Deal with special characters.  */
switch|switch
condition|(
name|operand
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'$'
case|:
if|if
condition|(
name|strchr
argument_list|(
name|operand
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
condition|)
name|cur_arg
operator|->
name|type
operator|=
name|arg_icr
expr_stmt|;
else|else
name|cur_arg
operator|->
name|type
operator|=
name|arg_ic
expr_stmt|;
goto|goto
name|set_params
goto|;
break|break;
case|case
literal|'('
case|:
name|cur_arg
operator|->
name|type
operator|=
name|arg_rbase
expr_stmt|;
goto|goto
name|set_params
goto|;
break|break;
case|case
literal|'['
case|:
name|cur_arg
operator|->
name|type
operator|=
name|arg_idxr
expr_stmt|;
goto|goto
name|set_params
goto|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|operand
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|operand
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|strchr
argument_list|(
name|operand
argument_list|,
literal|','
argument_list|)
operator|>
name|strchr
argument_list|(
name|operand
argument_list|,
literal|'('
argument_list|)
operator|)
condition|)
name|cur_arg
operator|->
name|type
operator|=
name|arg_crp
expr_stmt|;
else|else
name|cur_arg
operator|->
name|type
operator|=
name|arg_cr
expr_stmt|;
block|}
else|else
name|cur_arg
operator|->
name|type
operator|=
name|arg_c
expr_stmt|;
comment|/* Parse an operand according to its type.  */
name|set_params
label|:
name|cur_arg
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
name|set_operand
argument_list|(
name|operand
argument_list|,
name|cr16_ins
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the various operands. Each operand is then analyzed to fillup    the fields in the cr16_ins data structure.  */
end_comment

begin_function
specifier|static
name|void
name|parse_operands
parameter_list|(
name|ins
modifier|*
name|cr16_ins
parameter_list|,
name|char
modifier|*
name|operands
parameter_list|)
block|{
name|char
modifier|*
name|operandS
decl_stmt|;
comment|/* Operands string.  */
name|char
modifier|*
name|operandH
decl_stmt|,
modifier|*
name|operandT
decl_stmt|;
comment|/* Single operand head/tail pointers.  */
name|int
name|allocated
init|=
literal|0
decl_stmt|;
comment|/* Indicates a new operands string was allocated.*/
name|char
modifier|*
name|operand
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Separating the operands.  */
name|int
name|op_num
init|=
literal|0
decl_stmt|;
comment|/* Current operand number we are parsing.  */
name|int
name|bracket_flag
init|=
literal|0
decl_stmt|;
comment|/* Indicates a bracket '(' was found.  */
name|int
name|sq_bracket_flag
init|=
literal|0
decl_stmt|;
comment|/* Indicates a square bracket '[' was found.  */
comment|/* Preprocess the list of registers, if necessary.  */
name|operandS
operator|=
name|operandH
operator|=
name|operandT
operator|=
name|operands
expr_stmt|;
while|while
condition|(
operator|*
name|operandT
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|operandT
operator|==
literal|','
operator|&&
name|bracket_flag
operator|!=
literal|1
operator|&&
name|sq_bracket_flag
operator|!=
literal|1
condition|)
block|{
operator|*
name|operandT
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|operand
index|[
name|op_num
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|operandH
argument_list|)
expr_stmt|;
name|operandH
operator|=
name|operandT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|operandT
operator|==
literal|' '
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands (whitespace): `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|operandT
operator|==
literal|'('
condition|)
name|bracket_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|operandT
operator|==
literal|'['
condition|)
name|sq_bracket_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|operandT
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|bracket_flag
condition|)
name|bracket_flag
operator|=
literal|0
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Missing matching brackets : `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|operandT
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|sq_bracket_flag
condition|)
name|sq_bracket_flag
operator|=
literal|0
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Missing matching brackets : `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bracket_flag
operator|==
literal|1
operator|&&
operator|*
name|operandT
operator|==
literal|')'
condition|)
name|bracket_flag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sq_bracket_flag
operator|==
literal|1
operator|&&
operator|*
name|operandT
operator|==
literal|']'
condition|)
name|sq_bracket_flag
operator|=
literal|0
expr_stmt|;
name|operandT
operator|++
expr_stmt|;
block|}
comment|/* Adding the last operand.  */
name|operand
index|[
name|op_num
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|operandH
argument_list|)
expr_stmt|;
name|cr16_ins
operator|->
name|nargs
operator|=
name|op_num
expr_stmt|;
comment|/* Verifying correct syntax of operands (all brackets should be closed).  */
if|if
condition|(
name|bracket_flag
operator|||
name|sq_bracket_flag
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Missing matching brackets : `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
comment|/* Now we parse each operand separately.  */
for|for
control|(
name|op_num
operator|=
literal|0
init|;
name|op_num
operator|<
name|cr16_ins
operator|->
name|nargs
condition|;
name|op_num
operator|++
control|)
block|{
name|cur_arg_num
operator|=
name|op_num
expr_stmt|;
name|parse_operand
argument_list|(
name|operand
index|[
name|op_num
index|]
argument_list|,
name|cr16_ins
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|operand
index|[
name|op_num
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allocated
condition|)
name|free
argument_list|(
name|operandS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the trap index in dispatch table, given its name.    This routine is used by assembling the 'excp' instruction.  */
end_comment

begin_function
specifier|static
name|int
name|gettrap
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|trap_entry
modifier|*
name|trap
decl_stmt|;
for|for
control|(
name|trap
operator|=
name|cr16_traps
init|;
name|trap
operator|<
operator|(
name|cr16_traps
operator|+
name|NUMTRAPS
operator|)
condition|;
name|trap
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|trap
operator|->
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
name|trap
operator|->
name|entry
return|;
comment|/* To make compatable with CR16 4.1 tools, the below 3-lines of    * code added. Refer: Development Tracker item #123 */
for|for
control|(
name|trap
operator|=
name|cr16_traps
init|;
name|trap
operator|<
operator|(
name|cr16_traps
operator|+
name|NUMTRAPS
operator|)
condition|;
name|trap
operator|++
control|)
if|if
condition|(
name|trap
operator|->
name|entry
operator|==
operator|(
name|unsigned
name|int
operator|)
name|atoi
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|trap
operator|->
name|entry
return|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown exception: `%s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Top level module where instruction parsing starts.    cr16_ins - data structure holds some information.    operands - holds the operands part of the whole instruction.  */
end_comment

begin_function
specifier|static
name|void
name|parse_insn
parameter_list|(
name|ins
modifier|*
name|insn
parameter_list|,
name|char
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Handle instructions with no operands.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cr16_no_op_insn
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|cr16_no_op_insn
index|[
name|i
index|]
argument_list|,
name|instruction
operator|->
name|mnemonic
argument_list|)
condition|)
block|{
name|insn
operator|->
name|nargs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Handle 'excp' instructions.  */
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"excp"
argument_list|)
condition|)
block|{
name|insn
operator|->
name|nargs
operator|=
literal|1
expr_stmt|;
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|arg_ic
expr_stmt|;
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|constant
operator|=
name|gettrap
argument_list|(
name|operands
argument_list|)
expr_stmt|;
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|operands
operator|!=
name|NULL
condition|)
name|parse_operands
argument_list|(
name|insn
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* bCC instruction requires special handling.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_b_cc
parameter_list|(
name|char
modifier|*
name|op
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|char
name|op1
index|[
literal|5
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|strlen
argument_list|(
name|op
argument_list|)
condition|;
name|i
operator|++
control|)
name|op1
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|op
index|[
name|i
index|]
expr_stmt|;
name|op1
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cr16_num_cc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|op1
argument_list|,
name|cr16_b_cond_tab
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|cr16_b_cond_tab
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* bCC instruction requires special handling.  */
end_comment

begin_function
specifier|static
name|int
name|is_bcc_insn
parameter_list|(
name|char
modifier|*
name|op
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|streq
argument_list|(
name|op
argument_list|,
literal|"bal"
argument_list|)
operator|||
name|streq
argument_list|(
name|op
argument_list|,
literal|"beq0b"
argument_list|)
operator|||
name|streq
argument_list|(
name|op
argument_list|,
literal|"bnq0b"
argument_list|)
operator|||
name|streq
argument_list|(
name|op
argument_list|,
literal|"beq0w"
argument_list|)
operator|||
name|streq
argument_list|(
name|op
argument_list|,
literal|"bnq0w"
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|(
name|op
index|[
literal|0
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|get_b_cc
argument_list|(
name|op
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Cinv instruction requires special handling.  */
end_comment

begin_function
specifier|static
name|int
name|check_cinv_options
parameter_list|(
name|char
modifier|*
name|operand
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|operand
decl_stmt|;
name|int
name|i_used
init|=
literal|0
decl_stmt|,
name|u_used
init|=
literal|0
decl_stmt|,
name|d_used
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|' '
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'i'
condition|)
name|i_used
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'u'
condition|)
name|u_used
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'d'
condition|)
name|d_used
operator|=
literal|1
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal `cinv' parameter: `%c'"
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the opcode image of a given register pair.    If the register is illegal for the current instruction,    issue an error.  */
end_comment

begin_function
specifier|static
name|int
name|getregp_image
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|char
modifier|*
name|reg_name
decl_stmt|;
comment|/* Check whether the register is in registers table.  */
if|if
condition|(
name|r
operator|<
name|MAX_REG
condition|)
name|reg
operator|=
name|cr16_regptab
operator|+
name|r
expr_stmt|;
comment|/* Register not found.  */
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown register pair: `%d'"
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|reg_name
operator|=
name|reg
operator|->
name|name
expr_stmt|;
comment|/* Issue a error message when register  pair is illegal.  */
define|#
directive|define
name|RPAIR_IMAGE_ERR
define|\
value|as_bad (_("Illegal register pair (`%s') in Instruction: `%s'"), \             reg_name, ins_parse);                                 \   break;
switch|switch
condition|(
name|reg
operator|->
name|type
condition|)
block|{
case|case
name|CR16_RP_REGTYPE
case|:
return|return
name|reg
operator|->
name|image
return|;
default|default:
name|RPAIR_IMAGE_ERR
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the opcode image of a given index register pair.    If the register is illegal for the current instruction,    issue an error.  */
end_comment

begin_function
specifier|static
name|int
name|getidxregp_image
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|char
modifier|*
name|reg_name
decl_stmt|;
comment|/* Check whether the register is in registers table.  */
if|if
condition|(
name|r
operator|<
name|MAX_REG
condition|)
name|reg
operator|=
name|cr16_regptab
operator|+
name|r
expr_stmt|;
comment|/* Register not found.  */
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown register pair: `%d'"
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|reg_name
operator|=
name|reg
operator|->
name|name
expr_stmt|;
comment|/* Issue a error message when register  pair is illegal.  */
define|#
directive|define
name|IDX_RPAIR_IMAGE_ERR
define|\
value|as_bad (_("Illegal index register pair (`%s') in Instruction: `%s'"), \             reg_name, ins_parse);                                       \    if (reg->type == CR16_RP_REGTYPE)
block|{
switch|switch
condition|(
name|reg
operator|->
name|image
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
break|break;
case|case
literal|2
case|:
return|return
literal|1
return|;
break|break;
case|case
literal|4
case|:
return|return
literal|2
return|;
break|break;
case|case
literal|6
case|:
return|return
literal|3
return|;
break|break;
case|case
literal|8
case|:
return|return
literal|4
return|;
break|break;
case|case
literal|10
case|:
return|return
literal|5
return|;
break|break;
case|case
literal|3
case|:
return|return
literal|6
return|;
break|break;
case|case
literal|5
case|:
return|return
literal|7
return|;
break|break;
default|default:
break|break;
block|}
block|}
name|IDX_RPAIR_IMAGE_ERR
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the opcode image of a given processort register.    If the register is illegal for the current instruction,    issue an error.  */
end_comment

begin_function
specifier|static
name|int
name|getprocreg_image
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|char
modifier|*
name|reg_name
decl_stmt|;
comment|/* Check whether the register is in registers table.  */
if|if
condition|(
name|r
operator|<
name|MAX_PREG
condition|)
name|reg
operator|=
operator|&
name|cr16_pregtab
index|[
name|r
operator|-
name|MAX_REG
index|]
expr_stmt|;
comment|/* Register not found.  */
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown processor register : `%d'"
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|reg_name
operator|=
name|reg
operator|->
name|name
expr_stmt|;
comment|/* Issue a error message when register  pair is illegal.  */
define|#
directive|define
name|PROCREG_IMAGE_ERR
define|\
value|as_bad (_("Illegal processor register (`%s') in Instruction: `%s'"), \             reg_name, ins_parse);                                      \   break;
switch|switch
condition|(
name|reg
operator|->
name|type
condition|)
block|{
case|case
name|CR16_P_REGTYPE
case|:
return|return
name|reg
operator|->
name|image
return|;
default|default:
name|PROCREG_IMAGE_ERR
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the opcode image of a given processort register.    If the register is illegal for the current instruction,    issue an error.  */
end_comment

begin_function
specifier|static
name|int
name|getprocregp_image
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|char
modifier|*
name|reg_name
decl_stmt|;
name|int
name|pregptab_disp
init|=
literal|0
decl_stmt|;
comment|/* Check whether the register is in registers table.  */
if|if
condition|(
name|r
operator|<
name|MAX_PREG
condition|)
block|{
name|r
operator|=
name|r
operator|-
name|MAX_REG
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|4
case|:
name|pregptab_disp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|pregptab_disp
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
name|pregptab_disp
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|pregptab_disp
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|pregptab_disp
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|reg
operator|=
operator|&
name|cr16_pregptab
index|[
name|r
operator|-
name|pregptab_disp
index|]
expr_stmt|;
block|}
comment|/* Register not found.  */
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown processor register (32 bit) : `%d'"
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|reg_name
operator|=
name|reg
operator|->
name|name
expr_stmt|;
comment|/* Issue a error message when register  pair is illegal.  */
define|#
directive|define
name|PROCREGP_IMAGE_ERR
define|\
value|as_bad (_("Illegal 32 bit - processor register (`%s') in Instruction: `%s'"),\             reg_name, ins_parse);                                              \   break;
switch|switch
condition|(
name|reg
operator|->
name|type
condition|)
block|{
case|case
name|CR16_P_REGTYPE
case|:
return|return
name|reg
operator|->
name|image
return|;
default|default:
name|PROCREGP_IMAGE_ERR
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Routine used to represent integer X using NBITS bits.  */
end_comment

begin_function
specifier|static
name|long
name|getconstant
parameter_list|(
name|long
name|x
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
comment|/* The following expression avoids overflow if      'nbits' is the number of bits in 'bfd_vma'.  */
return|return
operator|(
name|x
operator|&
operator|(
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print a constant value to 'output_opcode':    ARG holds the operand's type and value.    SHIFT represents the location of the operand to be print into.    NBITS determines the size (in bits) of the constant.  */
end_comment

begin_function
specifier|static
name|void
name|print_constant
parameter_list|(
name|int
name|nbits
parameter_list|,
name|int
name|shift
parameter_list|,
name|argument
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|long
name|mask
init|=
literal|0
decl_stmt|;
name|long
name|constant
init|=
name|getconstant
argument_list|(
name|arg
operator|->
name|constant
argument_list|,
name|nbits
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nbits
condition|)
block|{
case|case
literal|32
case|:
case|case
literal|28
case|:
comment|/* mask the upper part of the constant, that is, the bits 	 going to the lowest byte of output_opcode[0]. 	 The upper part of output_opcode[1] is always filled, 	 therefore it is always masked with 0xFFFF.  */
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|nbits
operator|-
literal|16
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Divide the constant between two consecutive words : 	 0        1         2         3 	 +---------+---------+---------+---------+ 	 |         | X X X X | x X x X |         | 	 +---------+---------+---------+---------+ 	 output_opcode[0]    output_opcode[1]     */
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
name|constant
operator|>>
name|WORD_SHIFT
operator|)
operator|&
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CR16_PRINT
argument_list|(
literal|1
argument_list|,
operator|(
name|constant
operator|&
literal|0xFFFF
operator|)
argument_list|,
name|WORD_SHIFT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|21
case|:
if|if
condition|(
operator|(
name|nbits
operator|==
literal|21
operator|)
operator|&&
operator|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|)
condition|)
name|nbits
operator|=
literal|20
expr_stmt|;
case|case
literal|24
case|:
case|case
literal|22
case|:
case|case
literal|20
case|:
comment|/* mask the upper part of the constant, that is, the bits 	 going to the lowest byte of output_opcode[0]. 	 The upper part of output_opcode[1] is always filled, 	 therefore it is always masked with 0xFFFF.  */
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|nbits
operator|-
literal|16
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Divide the constant between two consecutive words : 	 0        1         2          3 	 +---------+---------+---------+---------+ 	 |         | X X X X | - X - X |         | 	 +---------+---------+---------+---------+ 	 output_opcode[0]    output_opcode[1]     */
if|if
condition|(
operator|(
name|instruction
operator|->
name|size
operator|>
literal|2
operator|)
operator|&&
operator|(
name|shift
operator|==
name|WORD_SHIFT
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|type
operator|==
name|arg_idxrp
condition|)
block|{
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|constant
operator|>>
name|WORD_SHIFT
operator|)
operator|&
name|mask
operator|)
operator|<<
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CR16_PRINT
argument_list|(
literal|1
argument_list|,
operator|(
name|constant
operator|&
literal|0xFFFF
operator|)
argument_list|,
name|WORD_SHIFT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
operator|(
operator|(
operator|(
name|constant
operator|>>
name|WORD_SHIFT
operator|)
operator|&
name|mask
operator|)
operator|<<
literal|8
operator|)
operator|&
literal|0x0f00
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|constant
operator|>>
name|WORD_SHIFT
operator|)
operator|&
name|mask
operator|)
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CR16_PRINT
argument_list|(
literal|1
argument_list|,
operator|(
name|constant
operator|&
literal|0xFFFF
operator|)
argument_list|,
name|WORD_SHIFT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|constant
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
if|if
condition|(
name|arg
operator|->
name|type
operator|==
name|arg_idxrp
condition|)
block|{
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|2
condition|)
block|{
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|constant
operator|)
operator|&
literal|0xf
operator|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
comment|// 0-3 bits
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|constant
operator|>>
literal|4
operator|)
operator|&
literal|0x3
operator|)
argument_list|,
operator|(
name|shift
operator|+
literal|20
operator|)
argument_list|)
expr_stmt|;
comment|// 4-5 bits
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|constant
operator|>>
literal|6
operator|)
operator|&
literal|0x3
operator|)
argument_list|,
operator|(
name|shift
operator|+
literal|14
operator|)
argument_list|)
expr_stmt|;
comment|// 6-7 bits
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|constant
operator|>>
literal|8
operator|)
operator|&
literal|0x3f
operator|)
argument_list|,
operator|(
name|shift
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|// 8-13 bits
block|}
else|else
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|constant
argument_list|,
name|shift
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
case|case
literal|12
case|:
comment|/* When instruction size is 3 and 'shift' is 16, a 16-bit constant is 	 always filling the upper part of output_opcode[1]. If we mistakenly 	 write it to output_opcode[0], the constant prefix (that is, 'match') 	 will be overriden. 	 0        1         2         3 	 +---------+---------+---------+---------+ 	 | 'match' |         | X X X X |         | 	 +---------+---------+---------+---------+ 	 output_opcode[0]    output_opcode[1]     */
if|if
condition|(
operator|(
name|instruction
operator|->
name|size
operator|>
literal|2
operator|)
operator|&&
operator|(
name|shift
operator|==
name|WORD_SHIFT
operator|)
condition|)
name|CR16_PRINT
argument_list|(
literal|1
argument_list|,
name|constant
argument_list|,
name|WORD_SHIFT
argument_list|)
expr_stmt|;
else|else
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|constant
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|constant
operator|/
literal|2
operator|)
operator|&
literal|0xf
operator|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|constant
operator|/
literal|2
operator|)
operator|>>
literal|4
operator|)
argument_list|,
operator|(
name|shift
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|constant
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print an operand to 'output_opcode', which later on will be    printed to the object file:    ARG holds the operand's type, size and value.    SHIFT represents the printing location of operand.    NBITS determines the size (in bits) of a constant operand.  */
end_comment

begin_function
specifier|static
name|void
name|print_operand
parameter_list|(
name|int
name|nbits
parameter_list|,
name|int
name|shift
parameter_list|,
name|argument
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|arg
operator|->
name|type
condition|)
block|{
case|case
name|arg_cc
case|:
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|arg
operator|->
name|cc
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_r
case|:
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|r
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_rp
case|:
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getregp_image
argument_list|(
name|arg
operator|->
name|rp
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_pr
case|:
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getprocreg_image
argument_list|(
name|arg
operator|->
name|pr
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_prp
case|:
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getprocregp_image
argument_list|(
name|arg
operator|->
name|prp
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_idxrp
case|:
comment|/*    16      12      8    6      0             +-----------------------------+             | r_index | disp  | rp_base   |             +-----------------------------+          */
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|3
condition|)
block|{
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getidxregp_image
argument_list|(
name|arg
operator|->
name|rp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|getreg_image
argument_list|(
name|arg
operator|->
name|i_r
argument_list|)
operator|==
literal|12
condition|)
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getidxregp_image
argument_list|(
name|arg
operator|->
name|rp
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|getreg_image
argument_list|(
name|arg
operator|->
name|i_r
argument_list|)
operator|==
literal|12
condition|)
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|19
argument_list|)
expr_stmt|;
else|else
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|19
argument_list|)
expr_stmt|;
block|}
name|print_constant
argument_list|(
name|nbits
argument_list|,
name|shift
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_idxr
case|:
if|if
condition|(
name|getreg_image
argument_list|(
name|arg
operator|->
name|i_r
argument_list|)
operator|==
literal|12
condition|)
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"cbitb"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"sbitb"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"tbitb"
argument_list|)
condition|)
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|)
expr_stmt|;
else|else
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|24
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"cbitb"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"sbitb"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"tbitb"
argument_list|)
condition|)
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|23
argument_list|)
expr_stmt|;
else|else
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|print_constant
argument_list|(
name|nbits
argument_list|,
name|shift
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_ic
case|:
case|case
name|arg_c
case|:
name|print_constant
argument_list|(
name|nbits
argument_list|,
name|shift
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_rbase
case|:
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|r
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_cr
case|:
name|print_constant
argument_list|(
name|nbits
argument_list|,
name|shift
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Add the register argument to the output_opcode.  */
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|r
argument_list|)
argument_list|,
operator|(
name|shift
operator|+
literal|16
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_crp
case|:
name|print_constant
argument_list|(
name|nbits
argument_list|,
name|shift
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|instruction
operator|->
name|size
operator|>
literal|1
condition|)
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getregp_image
argument_list|(
name|arg
operator|->
name|rp
argument_list|)
argument_list|,
operator|(
name|shift
operator|+
literal|16
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|||
operator|(
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|2
condition|)
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getregp_image
argument_list|(
name|arg
operator|->
name|rp
argument_list|)
argument_list|,
operator|(
name|shift
operator|-
literal|8
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|1
condition|)
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getregp_image
argument_list|(
name|arg
operator|->
name|rp
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
name|CR16_PRINT
argument_list|(
literal|0
argument_list|,
name|getregp_image
argument_list|(
name|arg
operator|->
name|rp
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Retrieve the number of operands for the current assembled instruction.  */
end_comment

begin_function
specifier|static
name|int
name|get_number_of_operands
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
operator|&&
name|i
operator|<
name|MAX_OPERANDS
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Verify that the number NUM can be represented in BITS bits (that is,    within its permitted range), based on the instruction's FLAGS.    If UPDATE is nonzero, update the value of NUM if necessary.    Return OP_LEGAL upon success, actual error type upon failure.  */
end_comment

begin_function
specifier|static
name|op_err
name|check_range
parameter_list|(
name|long
modifier|*
name|num
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|unsigned
name|flags
parameter_list|,
name|int
name|update
parameter_list|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|int
name|retval
init|=
name|OP_LEGAL
decl_stmt|;
name|long
name|value
init|=
operator|*
name|num
decl_stmt|;
if|if
condition|(
name|bits
operator|==
literal|0
operator|&&
name|value
operator|>
literal|0
condition|)
return|return
name|OP_OUT_OF_RANGE
return|;
comment|/* For hosts witah longs bigger than 32-bits make sure that the top      bits of a 32-bit negative value read in by the parser are set,      so that the correct comparisons are made.  */
if|if
condition|(
name|value
operator|&
literal|0x80000000
condition|)
name|value
operator||=
operator|(
operator|-
literal|1L
operator|<<
literal|31
operator|)
expr_stmt|;
comment|/* Verify operand value is even.  */
if|if
condition|(
name|flags
operator|&
name|OP_EVEN
condition|)
block|{
if|if
condition|(
name|value
operator|%
literal|2
condition|)
return|return
name|OP_NOT_EVEN
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|OP_DEC
condition|)
block|{
name|value
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|update
condition|)
operator|*
name|num
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|OP_SHIFT
condition|)
block|{
name|value
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|update
condition|)
operator|*
name|num
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OP_SHIFT_DEC
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|update
condition|)
operator|*
name|num
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|OP_ABS20
condition|)
block|{
if|if
condition|(
name|value
operator|>
literal|0xEFFFF
condition|)
return|return
name|OP_OUT_OF_RANGE
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|OP_ESC
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|0xB
operator|||
name|value
operator|==
literal|0x9
condition|)
return|return
name|OP_OUT_OF_RANGE
return|;
elseif|else
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|update
condition|)
operator|*
name|num
operator|=
literal|9
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|OP_ESC1
condition|)
block|{
if|if
condition|(
name|value
operator|>
literal|13
condition|)
return|return
name|OP_OUT_OF_RANGE
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|OP_SIGNED
condition|)
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|>
name|max
operator|)
operator|||
operator|(
name|value
operator|<
name|min
operator|)
condition|)
name|retval
operator|=
name|OP_OUT_OF_RANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OP_UNSIGNED
condition|)
block|{
name|max
operator|=
operator|(
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
operator|)
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max
operator|)
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|<
operator|(
name|unsigned
name|long
operator|)
name|min
operator|)
condition|)
name|retval
operator|=
name|OP_OUT_OF_RANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OP_NEG
condition|)
block|{
name|max
operator|=
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|>
name|max
operator|)
operator|||
operator|(
name|value
operator|<
name|min
operator|)
condition|)
name|retval
operator|=
name|OP_OUT_OF_RANGE
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Bunch of error checkings.    The checks are made after a matching instruction was found.  */
end_comment

begin_function
specifier|static
name|void
name|warn_if_needed
parameter_list|(
name|ins
modifier|*
name|insn
parameter_list|)
block|{
comment|/* If the post-increment address mode is used and the load/store      source register is the same as rbase, the result of the      instruction is undefined.  */
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS_INC
argument_list|)
condition|)
block|{
comment|/* Enough to verify that one of the arguments is a simple reg.  */
if|if
condition|(
operator|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|arg_r
operator|)
operator|||
operator|(
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|arg_r
operator|)
condition|)
if|if
condition|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
operator|==
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|r
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Same src/dest register is used (`r%d'), result is undefined"
argument_list|)
argument_list|,
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"pop"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"push"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"popret"
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|count
init|=
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|constant
decl_stmt|,
name|reg_val
decl_stmt|;
comment|/* Check if count operand caused to save/retrive the RA twice 	 to generate warning message.  */
if|if
condition|(
name|insn
operator|->
name|nargs
operator|>
literal|2
condition|)
block|{
name|reg_val
operator|=
name|getreg_image
argument_list|(
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reg_val
operator|==
literal|9
operator|)
operator|&&
operator|(
name|count
operator|>
literal|7
operator|)
operator|)
operator|||
operator|(
operator|(
name|reg_val
operator|==
literal|10
operator|)
operator|&&
operator|(
name|count
operator|>
literal|6
operator|)
operator|)
operator|||
operator|(
operator|(
name|reg_val
operator|==
literal|11
operator|)
operator|&&
operator|(
name|count
operator|>
literal|5
operator|)
operator|)
operator|||
operator|(
operator|(
name|reg_val
operator|==
literal|12
operator|)
operator|&&
operator|(
name|count
operator|>
literal|4
operator|)
operator|)
operator|||
operator|(
operator|(
name|reg_val
operator|==
literal|13
operator|)
operator|&&
operator|(
name|count
operator|>
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
name|reg_val
operator|==
literal|14
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"RA register is saved twice."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if the third operand is "RA" or "ra" */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|insn
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|r
operator|)
operator|==
name|ra
operator|)
operator|||
operator|(
operator|(
name|insn
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|r
operator|)
operator|==
name|RA
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' Illegal use of registers."
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|->
name|nargs
operator|>
literal|1
condition|)
block|{
name|reg_val
operator|=
name|getreg_image
argument_list|(
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|r
argument_list|)
expr_stmt|;
comment|/* If register is a register pair ie r12/r13/r14 in operand1, then             the count constant should be validated.  */
if|if
condition|(
operator|(
operator|(
name|reg_val
operator|==
literal|11
operator|)
operator|&&
operator|(
name|count
operator|>
literal|7
operator|)
operator|)
operator|||
operator|(
operator|(
name|reg_val
operator|==
literal|12
operator|)
operator|&&
operator|(
name|count
operator|>
literal|6
operator|)
operator|)
operator|||
operator|(
operator|(
name|reg_val
operator|==
literal|13
operator|)
operator|&&
operator|(
name|count
operator|>
literal|4
operator|)
operator|)
operator|||
operator|(
operator|(
name|reg_val
operator|==
literal|14
operator|)
operator|&&
operator|(
name|count
operator|>
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
name|reg_val
operator|==
literal|15
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' Illegal count-register combination."
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if the operand is "RA" or "ra" */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
operator|)
operator|==
name|ra
operator|)
operator|||
operator|(
operator|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
operator|)
operator|==
name|RA
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' Illegal use of register."
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Some instruction assume the stack pointer as rptr operand.      Issue an error when the register to be loaded is also SP.  */
if|if
condition|(
name|instruction
operator|->
name|flags
operator|&
name|NO_SP
condition|)
block|{
if|if
condition|(
name|getreg_image
argument_list|(
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|r
argument_list|)
operator|==
name|getreg_image
argument_list|(
name|sp
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' has undefined result"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
block|}
comment|/* If the rptr register is specified as one of the registers to be loaded,      the final contents of rptr are undefined. Thus, we issue an error.  */
if|if
condition|(
name|instruction
operator|->
name|flags
operator|&
name|NO_RPTR
condition|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|getreg_image
argument_list|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
argument_list|)
operator|)
operator|&
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Same src/dest register is used (`r%d'),result is undefined"
argument_list|)
argument_list|,
name|getreg_image
argument_list|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* In some cases, we need to adjust the instruction pointer although a    match was already found. Here, we gather all these cases.    Returns 1 if instruction pointer was adjusted, otherwise 0.  */
end_comment

begin_function
specifier|static
name|int
name|adjust_if_needed
parameter_list|(
name|ins
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|ret_value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
operator|)
operator|||
operator|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|instruction
operator|->
name|operands
index|[
literal|0
index|]
operator|.
name|op_type
operator|==
name|abs24
operator|)
operator|&&
operator|(
operator|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|constant
operator|)
operator|>
literal|0xF00000
operator|)
condition|)
block|{
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|constant
operator|&=
literal|0xFFFFF
expr_stmt|;
name|instruction
operator|--
expr_stmt|;
name|ret_value
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|ret_value
return|;
block|}
end_function

begin_comment
comment|/* Assemble a single instruction:    INSN is already parsed (that is, all operand values and types are set).    For instruction to be assembled, we need to find an appropriate template in    the instruction table, meeting the following conditions:     1: Has the same number of operands.     2: Has the same operand types.     3: Each operand size is sufficient to represent the instruction's values.    Returns 1 upon success, 0 upon failure.  */
end_comment

begin_function
specifier|static
name|int
name|assemble_insn
parameter_list|(
name|char
modifier|*
name|mnemonic
parameter_list|,
name|ins
modifier|*
name|insn
parameter_list|)
block|{
comment|/* Type of each operand in the current template.  */
name|argtype
name|cur_type
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Size (in bits) of each operand in the current template.  */
name|unsigned
name|int
name|cur_size
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Flags of each operand in the current template.  */
name|unsigned
name|int
name|cur_flags
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Instruction type to match.  */
name|unsigned
name|int
name|ins_type
decl_stmt|;
comment|/* Boolean flag to mark whether a match was found.  */
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Nonzero if an instruction with same number of operands was found.  */
name|int
name|found_same_number_of_operands
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if an instruction with same argument types was found.  */
name|int
name|found_same_argument_types
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if a constant was found within the required range.  */
name|int
name|found_const_within_range
init|=
literal|0
decl_stmt|;
comment|/* Argument number of an operand with invalid type.  */
name|int
name|invalid_optype
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Argument number of an operand with invalid constant value.  */
name|int
name|invalid_const
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Operand error (used for issuing various constant error messages).  */
name|op_err
name|op_error
decl_stmt|,
name|const_err
init|=
name|OP_LEGAL
decl_stmt|;
comment|/* Retrieve data (based on FUNC) for each operand of a given instruction.  */
define|#
directive|define
name|GET_CURRENT_DATA
parameter_list|(
name|FUNC
parameter_list|,
name|ARRAY
parameter_list|)
define|\
value|for (i = 0; i< insn->nargs; i++)                             \     ARRAY[i] = FUNC (instruction->operands[i].op_type)
define|#
directive|define
name|GET_CURRENT_TYPE
value|GET_CURRENT_DATA (get_optype, cur_type)
define|#
directive|define
name|GET_CURRENT_SIZE
value|GET_CURRENT_DATA (get_opbits, cur_size)
define|#
directive|define
name|GET_CURRENT_FLAGS
value|GET_CURRENT_DATA (get_opflags, cur_flags)
comment|/* Instruction has no operands -> only copy the constant opcode.   */
if|if
condition|(
name|insn
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|output_opcode
index|[
literal|0
index|]
operator|=
name|BIN
argument_list|(
name|instruction
operator|->
name|match
argument_list|,
name|instruction
operator|->
name|match_bits
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* In some case, same mnemonic can appear with different instruction types.      For example, 'storb' is supported with 3 different types :      LD_STOR_INS, LD_STOR_INS_INC, STOR_IMM_INS.      We assume that when reaching this point, the instruction type was      pre-determined. We need to make sure that the type stays the same      during a search for matching instruction.  */
name|ins_type
operator|=
name|CR16_INS_TYPE
argument_list|(
name|instruction
operator|->
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
comment|/* Check that match is still not found.  */
name|match
operator|!=
literal|1
comment|/* Check we didn't get to end of table.  */
operator|&&
name|instruction
operator|->
name|mnemonic
operator|!=
name|NULL
comment|/* Check that the actual mnemonic is still available.  */
operator|&&
name|IS_INSN_MNEMONIC
argument_list|(
name|mnemonic
argument_list|)
comment|/* Check that the instruction type wasn't changed.  */
operator|&&
name|IS_INSN_TYPE
argument_list|(
name|ins_type
argument_list|)
condition|)
block|{
comment|/* Check whether number of arguments is legal.  */
if|if
condition|(
name|get_number_of_operands
argument_list|()
operator|!=
name|insn
operator|->
name|nargs
condition|)
goto|goto
name|next_insn
goto|;
name|found_same_number_of_operands
operator|=
literal|1
expr_stmt|;
comment|/* Initialize arrays with data of each operand in current template.  */
name|GET_CURRENT_TYPE
expr_stmt|;
name|GET_CURRENT_SIZE
expr_stmt|;
name|GET_CURRENT_FLAGS
expr_stmt|;
comment|/* Check for type compatibility.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cur_type
index|[
name|i
index|]
operator|!=
name|insn
operator|->
name|arg
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|invalid_optype
operator|==
operator|-
literal|1
condition|)
name|invalid_optype
operator|=
name|i
operator|+
literal|1
expr_stmt|;
goto|goto
name|next_insn
goto|;
block|}
block|}
name|found_same_argument_types
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
comment|/* If 'bal' instruction size is '2' and reg operand is not 'ra'              then goto next instruction.  */
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"bal"
argument_list|)
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
name|instruction
operator|->
name|size
operator|==
literal|2
operator|)
operator|&&
operator|(
name|insn
operator|->
name|arg
index|[
name|i
index|]
operator|.
name|rp
operator|!=
literal|14
operator|)
condition|)
goto|goto
name|next_insn
goto|;
comment|/* If 'storb' instruction with 'sp' reg and 16-bit disp of            * reg-pair, leads to undifined trap, so this should use            * 20-bit disp of reg-pair.  */
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"storb"
argument_list|)
operator|&&
operator|(
name|instruction
operator|->
name|size
operator|==
literal|2
operator|)
operator|&&
operator|(
name|insn
operator|->
name|arg
index|[
name|i
index|]
operator|.
name|r
operator|==
literal|15
operator|)
operator|&&
operator|(
name|insn
operator|->
name|arg
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|type
operator|==
name|arg_crp
operator|)
condition|)
goto|goto
name|next_insn
goto|;
comment|/* Only check range - don't update the constant's value, since the              current instruction may not be the last we try to match.              The constant's value will be updated later, right before printing              it to the object file.  */
if|if
condition|(
operator|(
name|insn
operator|->
name|arg
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
operator|(
name|op_error
operator|=
name|check_range
argument_list|(
operator|&
name|insn
operator|->
name|arg
index|[
name|i
index|]
operator|.
name|constant
argument_list|,
name|cur_size
index|[
name|i
index|]
argument_list|,
name|cur_flags
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|invalid_const
operator|==
operator|-
literal|1
condition|)
block|{
name|invalid_const
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|const_err
operator|=
name|op_error
expr_stmt|;
block|}
goto|goto
name|next_insn
goto|;
block|}
comment|/* For symbols, we make sure the relocation size (which was already              determined) is sufficient.  */
elseif|else
if|if
condition|(
operator|(
name|insn
operator|->
name|arg
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_symbol
operator|)
operator|&&
operator|(
operator|(
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|insn
operator|->
name|rtype
argument_list|)
operator|)
operator|->
name|bitsize
operator|>
name|cur_size
index|[
name|i
index|]
operator|)
condition|)
goto|goto
name|next_insn
goto|;
block|}
name|found_const_within_range
operator|=
literal|1
expr_stmt|;
comment|/* If we got till here -> Full match is found.  */
name|match
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Try again with next instruction.  */
name|next_insn
label|:
name|instruction
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
comment|/* We haven't found a match - instruction can't be assembled.  */
if|if
condition|(
operator|!
name|found_same_number_of_operands
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect number of operands"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|found_same_argument_types
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal type of operand (arg %d)"
argument_list|)
argument_list|,
name|invalid_optype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|found_const_within_range
condition|)
block|{
switch|switch
condition|(
name|const_err
condition|)
block|{
case|case
name|OP_OUT_OF_RANGE
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand out of range (arg %d)"
argument_list|)
argument_list|,
name|invalid_const
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NOT_EVEN
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand has odd displacement (arg %d)"
argument_list|)
argument_list|,
name|invalid_const
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operand (arg %d)"
argument_list|)
argument_list|,
name|invalid_const
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
else|else
comment|/* Full match - print the encoding to output file.  */
block|{
comment|/* Make further checkings (such that couldn't be made earlier).          Warn the user if necessary.  */
name|warn_if_needed
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Check whether we need to adjust the instruction pointer.  */
if|if
condition|(
name|adjust_if_needed
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* If instruction pointer was adjusted, we need to update            the size of the current template operands.  */
name|GET_CURRENT_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|instruction
operator|->
name|flags
operator|&
name|REVERSE_MATCH
condition|?
name|i
operator|==
literal|0
condition|?
literal|1
else|:
name|i
operator|==
literal|1
condition|?
literal|0
else|:
name|i
else|:
name|i
decl_stmt|;
comment|/* This time, update constant value before printing it.  */
if|if
condition|(
operator|(
name|insn
operator|->
name|arg
index|[
name|j
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
operator|(
name|check_range
argument_list|(
operator|&
name|insn
operator|->
name|arg
index|[
name|j
index|]
operator|.
name|constant
argument_list|,
name|cur_size
index|[
name|j
index|]
argument_list|,
name|cur_flags
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
operator|!=
name|OP_LEGAL
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Illegal operand (arg %d)"
argument_list|)
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* First, copy the instruction's opcode.  */
name|output_opcode
index|[
literal|0
index|]
operator|=
name|BIN
argument_list|(
name|instruction
operator|->
name|match
argument_list|,
name|instruction
operator|->
name|match_bits
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
comment|/* For BAL (ra),disp17 instuction only. And also set the             DISP24a relocation type.  */
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"bal"
argument_list|)
operator|&&
operator|(
name|instruction
operator|->
name|size
operator|==
literal|2
operator|)
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|insn
operator|->
name|rtype
operator|=
name|BFD_RELOC_CR16_DISP24a
expr_stmt|;
continue|continue;
block|}
name|cur_arg_num
operator|=
name|i
expr_stmt|;
name|print_operand
argument_list|(
name|cur_size
index|[
name|i
index|]
argument_list|,
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|shift
argument_list|,
operator|&
name|insn
operator|->
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print the instruction.    Handle also cases where the instruction is relaxable/relocatable.  */
end_comment

begin_function
specifier|static
name|void
name|print_insn
parameter_list|(
name|ins
modifier|*
name|insn
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|insn_size
decl_stmt|;
name|char
modifier|*
name|this_frag
decl_stmt|;
name|unsigned
name|short
name|words
index|[
literal|4
index|]
decl_stmt|;
name|int
name|addr_mod
decl_stmt|;
comment|/* Arrange the insn encodings in a WORD size array.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|words
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|output_opcode
index|[
name|i
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
name|words
index|[
name|j
operator|++
index|]
operator|=
name|output_opcode
index|[
name|i
index|]
operator|&
literal|0xFFFF
expr_stmt|;
block|}
name|insn_size
operator|=
name|instruction
operator|->
name|size
expr_stmt|;
name|this_frag
operator|=
name|frag_more
argument_list|(
name|insn_size
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* Handle relocation.  */
if|if
condition|(
operator|(
name|relocatable
operator|)
operator|&&
operator|(
name|insn
operator|->
name|rtype
operator|!=
name|BFD_RELOC_NONE
operator|)
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
decl_stmt|;
name|int
name|size
decl_stmt|;
name|reloc_howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|insn
operator|->
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_howto
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|this_frag
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
operator|&
name|insn
operator|->
name|exp
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|insn
operator|->
name|rtype
argument_list|)
expr_stmt|;
block|}
comment|/* Verify a 2-byte code alignment.  */
name|addr_mod
operator|=
name|frag_now_fix
argument_list|()
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|frag_now
operator|->
name|has_code
operator|&&
name|frag_now
operator|->
name|insn_addr
operator|!=
name|addr_mod
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction address is not a multiple of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|insn_addr
operator|=
name|addr_mod
expr_stmt|;
name|frag_now
operator|->
name|has_code
operator|=
literal|1
expr_stmt|;
comment|/* Write the instruction encoding to frag.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_size
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|this_frag
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|this_frag
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  OP points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|op
parameter_list|)
block|{
name|ins
name|cr16_ins
decl_stmt|;
name|char
modifier|*
name|param
decl_stmt|,
name|param1
index|[
literal|32
index|]
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Reset global variables for a new instruction.  */
name|reset_vars
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Strip the mnemonic.  */
for|for
control|(
name|param
operator|=
name|op
init|;
operator|*
name|param
operator|!=
literal|0
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|param
argument_list|)
condition|;
name|param
operator|++
control|)
empty_stmt|;
name|c
operator|=
operator|*
name|param
expr_stmt|;
operator|*
name|param
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* bCC instuctions and adjust the mnemonic by adding extra white spaces.  */
if|if
condition|(
name|is_bcc_insn
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|param1
argument_list|,
name|get_b_cc
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
literal|"b"
expr_stmt|;
name|strcat
argument_list|(
name|param1
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|param1
argument_list|,
name|param
argument_list|)
expr_stmt|;
name|param
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|param1
expr_stmt|;
block|}
comment|/* Checking the cinv options and adjust the mnemonic by removing the      extra white spaces.  */
if|if
condition|(
name|streq
argument_list|(
literal|"cinv"
argument_list|,
name|op
argument_list|)
condition|)
block|{
comment|/* Validate the cinv options.  */
name|check_cinv_options
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|op
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
comment|/* MAPPING - SHIFT INSN, if imm4/imm16 positive values      lsh[b/w] imm4/imm6, reg ==> ashu[b/w] imm4/imm16, reg      as CR16 core doesn't support lsh[b/w] right shift operaions.  */
if|if
condition|(
operator|(
name|streq
argument_list|(
literal|"lshb"
argument_list|,
name|op
argument_list|)
operator|||
name|streq
argument_list|(
literal|"lshw"
argument_list|,
name|op
argument_list|)
operator|||
name|streq
argument_list|(
literal|"lshd"
argument_list|,
name|op
argument_list|)
operator|)
operator|&&
operator|(
name|param
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|param1
argument_list|,
name|param
argument_list|)
expr_stmt|;
comment|/* Find the instruction.  */
name|instruction
operator|=
operator|(
specifier|const
name|inst
operator|*
operator|)
name|hash_find
argument_list|(
name|cr16_inst_hash
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|parse_operands
argument_list|(
operator|&
name|cr16_ins
argument_list|,
name|param1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|&
name|cr16_ins
operator|)
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|arg_ic
operator|)
operator|&&
operator|(
operator|(
operator|&
name|cr16_ins
operator|)
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|constant
operator|>=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
literal|"lshb"
argument_list|,
name|op
argument_list|)
condition|)
name|op
operator|=
literal|"ashub"
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
literal|"lshd"
argument_list|,
name|op
argument_list|)
condition|)
name|op
operator|=
literal|"ashud"
expr_stmt|;
else|else
name|op
operator|=
literal|"ashuw"
expr_stmt|;
block|}
block|}
comment|/* Find the instruction.  */
name|instruction
operator|=
operator|(
specifier|const
name|inst
operator|*
operator|)
name|hash_find
argument_list|(
name|cr16_inst_hash
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|instruction
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Tie dwarf2 debug info to the address at the start of the insn.  */
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Parse the instruction's operands.  */
name|parse_insn
argument_list|(
operator|&
name|cr16_ins
argument_list|,
name|param
argument_list|)
expr_stmt|;
comment|/* Assemble the instruction - return upon failure.  */
if|if
condition|(
name|assemble_insn
argument_list|(
name|op
argument_list|,
operator|&
name|cr16_ins
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Print the instruction.  */
name|print_insn
argument_list|(
operator|&
name|cr16_ins
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

